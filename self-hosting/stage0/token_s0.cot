// =============================================================================
// token_s0.cot - Token definitions for Stage 0 self-hosting compiler
// =============================================================================
//
// LANGUAGE FEATURES REQUIRED:
// ---------------------------
// This file requires the following language features to compile:
//
// [x] WORKING  - Basic types: u8, i64, bool
// [x] WORKING  - String type
// [x] WORKING  - Functions
// [x] WORKING  - Structs
// [ ] MISSING  - Enum with backing type: enum TokenKind: u8 { ... }
// [ ] MISSING  - Enum value comparison: if kind == TokenKind.plus { ... }
// [ ] MISSING  - Integer from enum: @intFromEnum(TokenKind.plus) -> u8
//
// BLOCKING: This file cannot compile until enums are implemented.
//
// ARCHITECTURE:
// -------------
// Based on bootstrap-0.2/src/frontend/token.zig
// Simplified for minimal self-hosting (fewer token types).
//
// =============================================================================

// =============================================================================
// TokenKind Enum
// =============================================================================
//
// LANGUAGE FEATURE: enum with backing type
// SYNTAX: enum Name: BackingType { variant1, variant2, ... }
// EXPECTED: enum values are integers, can be compared with ==
//
// Example in other languages:
//   Zig:  pub const Token = enum(u8) { add, sub, ... };
//   Rust: #[repr(u8)] enum Token { Add, Sub, ... }
//   Go:   type Token int; const ( TokenAdd Token = iota; ... )

enum TokenKind: u8 {
    // ===================
    // Special
    // ===================
    invalid,        // 0 - Invalid/error token
    eof,            // 1 - End of file

    // ===================
    // Literals
    // ===================
    int_lit,        // 2 - Integer literal: 42, 0xFF
    string_lit,     // 3 - String literal: "hello"
    char_lit,       // 4 - Character literal: 'a'
    ident,          // 5 - Identifier: foo, bar

    // ===================
    // Keywords (minimal set for stage0)
    // ===================
    kw_fn,          // 6  - fn
    kw_var,         // 7  - var
    kw_const,       // 8  - const
    kw_struct,      // 9  - struct
    kw_enum,        // 10 - enum
    kw_if,          // 11 - if
    kw_else,        // 12 - else
    kw_while,       // 13 - while
    kw_return,      // 14 - return
    kw_true,        // 15 - true
    kw_false,       // 16 - false
    kw_and,         // 17 - and
    kw_or,          // 18 - or
    kw_not,         // 19 - not

    // ===================
    // Arithmetic Operators
    // ===================
    plus,           // 20 - +
    minus,          // 21 - -
    star,           // 22 - *
    slash,          // 23 - /
    percent,        // 24 - %

    // ===================
    // Bitwise Operators
    // ===================
    amp,            // 25 - &
    pipe,           // 26 - |
    caret,          // 27 - ^
    tilde,          // 28 - ~
    lshift,         // 29 - <<
    rshift,         // 30 - >>

    // ===================
    // Comparison Operators
    // ===================
    eq_eq,          // 31 - ==
    bang_eq,        // 32 - !=
    lt,             // 33 - <
    lt_eq,          // 34 - <=
    gt,             // 35 - >
    gt_eq,          // 36 - >=

    // ===================
    // Assignment
    // ===================
    eq,             // 37 - =

    // ===================
    // Punctuation
    // ===================
    lparen,         // 38 - (
    rparen,         // 39 - )
    lbrace,         // 40 - {
    rbrace,         // 41 - }
    lbracket,       // 42 - [
    rbracket,       // 43 - ]
    comma,          // 44 - ,
    semicolon,      // 45 - ;
    colon,          // 46 - :
    dot,            // 47 - .
    arrow,          // 48 - ->
    at,             // 49 - @

    // ===================
    // Other
    // ===================
    bang,           // 50 - !
}

// =============================================================================
// Token Struct
// =============================================================================
//
// LANGUAGE FEATURE: struct
// STATUS: Working in bootstrap-0.2
//
// Represents a single token from the source code.

struct Token {
    kind: TokenKind,    // What type of token
    start: i64,         // Start position in source (byte offset)
    length: i64,        // Length in bytes
    line: i64,          // Line number (1-based)
}

// =============================================================================
// Token Constructor
// =============================================================================
//
// LANGUAGE FEATURE: function returning struct
// STATUS: Working in bootstrap-0.2

fn tokenNew(kind: TokenKind, start: i64, length: i64, line: i64) Token {
    return Token{
        .kind = kind,
        .start = start,
        .length = length,
        .line = line,
    }
}

// =============================================================================
// Keyword Lookup
// =============================================================================
//
// LANGUAGE FEATURE: string comparison with ==
// STATUS: Should be working in bootstrap-0.2 (needs verification)
//
// Maps identifier text to keyword token kind.
// Returns TokenKind.ident if not a keyword.

fn lookupKeyword(text: string) TokenKind {
    // Keywords in alphabetical order for clarity
    if text == "and" { return TokenKind.kw_and }
    if text == "const" { return TokenKind.kw_const }
    if text == "else" { return TokenKind.kw_else }
    if text == "enum" { return TokenKind.kw_enum }
    if text == "false" { return TokenKind.kw_false }
    if text == "fn" { return TokenKind.kw_fn }
    if text == "if" { return TokenKind.kw_if }
    if text == "not" { return TokenKind.kw_not }
    if text == "or" { return TokenKind.kw_or }
    if text == "return" { return TokenKind.kw_return }
    if text == "struct" { return TokenKind.kw_struct }
    if text == "true" { return TokenKind.kw_true }
    if text == "var" { return TokenKind.kw_var }
    if text == "while" { return TokenKind.kw_while }

    return TokenKind.ident
}

// =============================================================================
// Precedence
// =============================================================================
//
// LANGUAGE FEATURE: function with enum parameter
// STATUS: Requires enums
//
// Returns operator precedence (higher = tighter binding).
// Returns 0 for non-operators.

fn tokenPrecedence(kind: TokenKind) i64 {
    // Precedence levels (highest to lowest):
    // 6: * / %
    // 5: + - | ^
    // 4: == != < <= > >=
    // 3: and
    // 2: or
    // 1: (reserved for future operators)
    // 0: non-operator

    if kind == TokenKind.star { return 6 }
    if kind == TokenKind.slash { return 6 }
    if kind == TokenKind.percent { return 6 }

    if kind == TokenKind.plus { return 5 }
    if kind == TokenKind.minus { return 5 }
    if kind == TokenKind.pipe { return 5 }
    if kind == TokenKind.caret { return 5 }

    if kind == TokenKind.eq_eq { return 4 }
    if kind == TokenKind.bang_eq { return 4 }
    if kind == TokenKind.lt { return 4 }
    if kind == TokenKind.lt_eq { return 4 }
    if kind == TokenKind.gt { return 4 }
    if kind == TokenKind.gt_eq { return 4 }

    if kind == TokenKind.kw_and { return 3 }
    if kind == TokenKind.kw_or { return 2 }

    return 0
}

// =============================================================================
// Token Kind Predicates
// =============================================================================
//
// LANGUAGE FEATURE: enum comparison
// STATUS: Requires enums

fn isLiteralKind(kind: TokenKind) bool {
    if kind == TokenKind.int_lit { return true }
    if kind == TokenKind.string_lit { return true }
    if kind == TokenKind.char_lit { return true }
    if kind == TokenKind.ident { return true }
    return false
}

fn isKeywordKind(kind: TokenKind) bool {
    // Check if kind is in keyword range (6-19)
    // LANGUAGE FEATURE NEEDED: @intFromEnum(kind) to get numeric value
    // WORKAROUND: Check each keyword individually

    if kind == TokenKind.kw_fn { return true }
    if kind == TokenKind.kw_var { return true }
    if kind == TokenKind.kw_const { return true }
    if kind == TokenKind.kw_struct { return true }
    if kind == TokenKind.kw_enum { return true }
    if kind == TokenKind.kw_if { return true }
    if kind == TokenKind.kw_else { return true }
    if kind == TokenKind.kw_while { return true }
    if kind == TokenKind.kw_return { return true }
    if kind == TokenKind.kw_true { return true }
    if kind == TokenKind.kw_false { return true }
    if kind == TokenKind.kw_and { return true }
    if kind == TokenKind.kw_or { return true }
    if kind == TokenKind.kw_not { return true }
    return false
}

// =============================================================================
// Test Function
// =============================================================================
//
// Used to verify token_s0.cot compiles and works correctly.
// Returns 42 on success.

fn test_token() i64 {
    // Test token creation
    var tok: Token = tokenNew(TokenKind.plus, 0, 1, 1)
    if tok.kind != TokenKind.plus {
        return 1
    }
    if tok.start != 0 {
        return 2
    }

    // Test keyword lookup
    var fn_kind: TokenKind = lookupKeyword("fn")
    if fn_kind != TokenKind.kw_fn {
        return 3
    }

    var not_kw: TokenKind = lookupKeyword("foo")
    if not_kw != TokenKind.ident {
        return 4
    }

    // Test precedence
    if tokenPrecedence(TokenKind.star) != 6 {
        return 5
    }
    if tokenPrecedence(TokenKind.plus) != 5 {
        return 6
    }
    if tokenPrecedence(TokenKind.eq_eq) != 4 {
        return 7
    }
    if tokenPrecedence(TokenKind.lparen) != 0 {
        return 8
    }

    // Test predicates
    if not isLiteralKind(TokenKind.int_lit) {
        return 9
    }
    if isLiteralKind(TokenKind.plus) {
        return 10
    }
    if not isKeywordKind(TokenKind.kw_fn) {
        return 11
    }
    if isKeywordKind(TokenKind.plus) {
        return 12
    }

    return 42
}

// =============================================================================
// SUMMARY OF LANGUAGE FEATURES NEEDED
// =============================================================================
//
// CRITICAL (blocking this file):
// 1. enum with backing type: enum Name: u8 { ... }
// 2. Enum value comparison: kind == TokenKind.plus
// 3. Enum value in struct field: struct { kind: TokenKind, ... }
//
// NICE TO HAVE (could work around):
// 4. @intFromEnum() - convert enum to integer
//
// =============================================================================

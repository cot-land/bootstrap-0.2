// =============================================================================
// scanner_s0.cot - Lexical scanner for Stage 0 self-hosting compiler
// =============================================================================
//
// LANGUAGE FEATURES REQUIRED:
// ---------------------------
// This file requires the following language features to compile:
//
// FROM token_s0.cot:
// [ ] MISSING  - Enum with backing type (TokenKind)
// [ ] MISSING  - Enum comparison
//
// NEW REQUIREMENTS:
// [ ] MISSING  - String indexing: source[pos] -> u8
// [ ] MISSING  - Logical AND: cond1 and cond2 (short-circuit)
// [ ] MISSING  - Logical OR: cond1 or cond2 (short-circuit)
// [x] WORKING  - While loops
// [x] WORKING  - Character literals: 'a', '\n'
// [x] WORKING  - Integer comparison: pos < len(source)
//
// BLOCKING: Enums (from token_s0.cot) + String indexing + Logical operators
//
// SIMPLIFICATIONS FOR STAGE 0:
// ----------------------------
// - No string interpolation support (too complex)
// - No float literals (stage0 only needs integers)
// - No error reporting (just return invalid token)
// - No position tracking (just byte offset)
// - No Source struct (just use string directly)
//
// ARCHITECTURE:
// -------------
// Based on bootstrap-0.2/src/frontend/scanner.zig
// Simplified to ~200 lines (vs ~750 lines in Zig version)
//
// =============================================================================

// Import token definitions
// NOTE: In stage0, we concatenate all files, so this is conceptual
// import "token_s0.cot"

// =============================================================================
// Scanner Struct
// =============================================================================
//
// LANGUAGE FEATURE: struct with string field
// STATUS: Working in bootstrap-0.2

struct Scanner {
    source: string,     // Source code to scan
    pos: i64,           // Current byte position
    line: i64,          // Current line number (1-based)
}

// =============================================================================
// Scanner Constructor
// =============================================================================

fn scannerInit(source: string) Scanner {
    return Scanner{
        .source = source,
        .pos = 0,
        .line = 1,
    }
}

// =============================================================================
// Character Classification Helpers
// =============================================================================
//
// LANGUAGE FEATURE: logical AND/OR for combining conditions
// LANGUAGE FEATURE: character comparison (u8 comparison)
//
// NOTE: Using explicit ASCII values for clarity:
//   'a' = 97, 'z' = 122
//   'A' = 65, 'Z' = 90
//   '0' = 48, '9' = 57
//   '_' = 95

fn isAlpha(c: u8) bool {
    // a-z: 97-122, A-Z: 65-90, _: 95
    //
    // LANGUAGE FEATURE NEEDED: logical OR
    // if (c >= 97 and c <= 122) or (c >= 65 and c <= 90) or c == 95 {
    //     return true
    // }
    // return false
    //
    // WORKAROUND: nested if statements
    if c >= 97 {
        if c <= 122 {
            return true
        }
    }
    if c >= 65 {
        if c <= 90 {
            return true
        }
    }
    if c == 95 {
        return true
    }
    return false
}

fn isDigit(c: u8) bool {
    // 0-9: 48-57
    if c >= 48 {
        if c <= 57 {
            return true
        }
    }
    return false
}

fn isAlphaNumeric(c: u8) bool {
    if isAlpha(c) {
        return true
    }
    if isDigit(c) {
        return true
    }
    return false
}

fn isHexDigit(c: u8) bool {
    if isDigit(c) {
        return true
    }
    // a-f: 97-102
    if c >= 97 {
        if c <= 102 {
            return true
        }
    }
    // A-F: 65-70
    if c >= 65 {
        if c <= 70 {
            return true
        }
    }
    return false
}

fn isWhitespace(c: u8) bool {
    // space=32, tab=9, newline=10, carriage return=13
    if c == 32 { return true }
    if c == 9 { return true }
    if c == 10 { return true }
    if c == 13 { return true }
    return false
}

// =============================================================================
// Scanner: Peek and Advance
// =============================================================================
//
// LANGUAGE FEATURE: string indexing (source[pos])
// STATUS: MISSING - Required for scanner to work

fn scannerAtEnd(s: *Scanner) bool {
    return s.*.pos >= len(s.*.source)
}

fn scannerPeek(s: *Scanner) u8 {
    if scannerAtEnd(s) {
        return 0  // NUL byte indicates end
    }
    // LANGUAGE FEATURE NEEDED: string indexing
    return s.*.source[s.*.pos]
}

fn scannerPeekNext(s: *Scanner) u8 {
    if s.*.pos + 1 >= len(s.*.source) {
        return 0
    }
    // LANGUAGE FEATURE NEEDED: string indexing
    return s.*.source[s.*.pos + 1]
}

fn scannerAdvance(s: *Scanner) u8 {
    var c: u8 = scannerPeek(s)
    s.*.pos = s.*.pos + 1
    // Track newlines for line numbers
    if c == 10 {  // '\n'
        s.*.line = s.*.line + 1
    }
    return c
}

// =============================================================================
// Scanner: Skip Whitespace and Comments
// =============================================================================

fn scannerSkipWhitespace(s: *Scanner) void {
    while not scannerAtEnd(s) {
        var c: u8 = scannerPeek(s)

        if isWhitespace(c) {
            scannerAdvance(s)
        } else if c == 47 {  // '/'
            var next: u8 = scannerPeekNext(s)
            if next == 47 {  // '//' line comment
                scannerSkipLineComment(s)
            } else if next == 42 {  // '/*' block comment
                scannerSkipBlockComment(s)
            } else {
                return  // Just a slash operator
            }
        } else {
            return
        }
    }
}

fn scannerSkipLineComment(s: *Scanner) void {
    // Skip the //
    scannerAdvance(s)
    scannerAdvance(s)
    // Skip until newline or EOF
    while not scannerAtEnd(s) {
        var c: u8 = scannerAdvance(s)
        if c == 10 {  // '\n'
            return
        }
    }
}

fn scannerSkipBlockComment(s: *Scanner) void {
    // Skip the /*
    scannerAdvance(s)
    scannerAdvance(s)
    // Skip until */ or EOF
    while not scannerAtEnd(s) {
        var c: u8 = scannerPeek(s)
        if c == 42 {  // '*'
            if scannerPeekNext(s) == 47 {  // '/'
                scannerAdvance(s)  // Skip *
                scannerAdvance(s)  // Skip /
                return
            }
        }
        scannerAdvance(s)
    }
}

// =============================================================================
// Scanner: Scan Identifier or Keyword
// =============================================================================

fn scannerScanIdentifier(s: *Scanner, start: i64) Token {
    while not scannerAtEnd(s) {
        var c: u8 = scannerPeek(s)
        if isAlphaNumeric(c) {
            scannerAdvance(s)
        } else {
            // Break out of loop
            // WORKAROUND: Use explicit return in else to break
            var text: string = substringFromSource(s.*.source, start, s.*.pos)
            var kind: TokenKind = lookupKeyword(text)
            return tokenNew(kind, start, s.*.pos - start, s.*.line)
        }
    }
    // End of file reached
    var text: string = substringFromSource(s.*.source, start, s.*.pos)
    var kind: TokenKind = lookupKeyword(text)
    return tokenNew(kind, start, s.*.pos - start, s.*.line)
}

// =============================================================================
// Scanner: Scan Number
// =============================================================================

fn scannerScanNumber(s: *Scanner, start: i64) Token {
    // Check for hex, octal, binary prefixes
    if scannerPeek(s) == 48 {  // '0'
        var next: u8 = scannerPeekNext(s)
        if next == 120 {  // 'x' - hex
            scannerAdvance(s)  // Skip 0
            scannerAdvance(s)  // Skip x
            while not scannerAtEnd(s) {
                if isHexDigit(scannerPeek(s)) {
                    scannerAdvance(s)
                } else {
                    return tokenNew(TokenKind.int_lit, start, s.*.pos - start, s.*.line)
                }
            }
            return tokenNew(TokenKind.int_lit, start, s.*.pos - start, s.*.line)
        }
        if next == 98 {  // 'b' - binary
            scannerAdvance(s)  // Skip 0
            scannerAdvance(s)  // Skip b
            while not scannerAtEnd(s) {
                var c: u8 = scannerPeek(s)
                if c == 48 {  // '0'
                    scannerAdvance(s)
                } else if c == 49 {  // '1'
                    scannerAdvance(s)
                } else {
                    return tokenNew(TokenKind.int_lit, start, s.*.pos - start, s.*.line)
                }
            }
            return tokenNew(TokenKind.int_lit, start, s.*.pos - start, s.*.line)
        }
        if next == 111 {  // 'o' - octal
            scannerAdvance(s)  // Skip 0
            scannerAdvance(s)  // Skip o
            while not scannerAtEnd(s) {
                var c: u8 = scannerPeek(s)
                if c >= 48 {
                    if c <= 55 {  // '0'-'7'
                        scannerAdvance(s)
                    } else {
                        return tokenNew(TokenKind.int_lit, start, s.*.pos - start, s.*.line)
                    }
                } else {
                    return tokenNew(TokenKind.int_lit, start, s.*.pos - start, s.*.line)
                }
            }
            return tokenNew(TokenKind.int_lit, start, s.*.pos - start, s.*.line)
        }
    }

    // Decimal number
    while not scannerAtEnd(s) {
        var c: u8 = scannerPeek(s)
        if isDigit(c) {
            scannerAdvance(s)
        } else if c == 95 {  // '_' separator
            scannerAdvance(s)
        } else {
            return tokenNew(TokenKind.int_lit, start, s.*.pos - start, s.*.line)
        }
    }
    return tokenNew(TokenKind.int_lit, start, s.*.pos - start, s.*.line)
}

// =============================================================================
// Scanner: Scan String Literal
// =============================================================================

fn scannerScanString(s: *Scanner, start: i64) Token {
    scannerAdvance(s)  // Skip opening "

    while not scannerAtEnd(s) {
        var c: u8 = scannerPeek(s)
        if c == 34 {  // '"' closing quote
            scannerAdvance(s)
            return tokenNew(TokenKind.string_lit, start, s.*.pos - start, s.*.line)
        }
        if c == 92 {  // '\' escape
            scannerAdvance(s)  // Skip backslash
            if not scannerAtEnd(s) {
                scannerAdvance(s)  // Skip escaped char
            }
        } else if c == 10 {  // '\n' - unterminated string
            return tokenNew(TokenKind.invalid, start, s.*.pos - start, s.*.line)
        } else {
            scannerAdvance(s)
        }
    }
    // Unterminated string
    return tokenNew(TokenKind.invalid, start, s.*.pos - start, s.*.line)
}

// =============================================================================
// Scanner: Scan Character Literal
// =============================================================================

fn scannerScanChar(s: *Scanner, start: i64) Token {
    scannerAdvance(s)  // Skip opening '

    if scannerAtEnd(s) {
        return tokenNew(TokenKind.invalid, start, s.*.pos - start, s.*.line)
    }

    var c: u8 = scannerPeek(s)
    if c == 92 {  // '\' escape
        scannerAdvance(s)  // Skip backslash
        if not scannerAtEnd(s) {
            scannerAdvance(s)  // Skip escaped char
        }
    } else {
        scannerAdvance(s)  // Skip the character
    }

    // Expect closing quote
    if not scannerAtEnd(s) {
        if scannerPeek(s) == 39 {  // '\''
            scannerAdvance(s)
            return tokenNew(TokenKind.char_lit, start, s.*.pos - start, s.*.line)
        }
    }

    return tokenNew(TokenKind.invalid, start, s.*.pos - start, s.*.line)
}

// =============================================================================
// Scanner: Scan Operator or Punctuation
// =============================================================================

fn scannerScanOperator(s: *Scanner, start: i64) Token {
    var c: u8 = scannerAdvance(s)

    // Single character tokens
    if c == 40 { return tokenNew(TokenKind.lparen, start, 1, s.*.line) }     // '('
    if c == 41 { return tokenNew(TokenKind.rparen, start, 1, s.*.line) }     // ')'
    if c == 123 { return tokenNew(TokenKind.lbrace, start, 1, s.*.line) }    // '{'
    if c == 125 { return tokenNew(TokenKind.rbrace, start, 1, s.*.line) }    // '}'
    if c == 91 { return tokenNew(TokenKind.lbracket, start, 1, s.*.line) }   // '['
    if c == 93 { return tokenNew(TokenKind.rbracket, start, 1, s.*.line) }   // ']'
    if c == 44 { return tokenNew(TokenKind.comma, start, 1, s.*.line) }      // ','
    if c == 59 { return tokenNew(TokenKind.semicolon, start, 1, s.*.line) }  // ';'
    if c == 58 { return tokenNew(TokenKind.colon, start, 1, s.*.line) }      // ':'
    if c == 126 { return tokenNew(TokenKind.tilde, start, 1, s.*.line) }     // '~'
    if c == 64 { return tokenNew(TokenKind.at, start, 1, s.*.line) }         // '@'

    // Two-character operators (check for second char)
    var next: u8 = scannerPeek(s)

    // + or +=
    if c == 43 {  // '+'
        // Note: We don't support += in stage0 for simplicity
        return tokenNew(TokenKind.plus, start, 1, s.*.line)
    }

    // - or -> or -=
    if c == 45 {  // '-'
        if next == 62 {  // '>'
            scannerAdvance(s)
            return tokenNew(TokenKind.arrow, start, 2, s.*.line)
        }
        return tokenNew(TokenKind.minus, start, 1, s.*.line)
    }

    // * or *=
    if c == 42 {  // '*'
        return tokenNew(TokenKind.star, start, 1, s.*.line)
    }

    // / or /=
    if c == 47 {  // '/'
        return tokenNew(TokenKind.slash, start, 1, s.*.line)
    }

    // % or %=
    if c == 37 {  // '%'
        return tokenNew(TokenKind.percent, start, 1, s.*.line)
    }

    // &
    if c == 38 {  // '&'
        return tokenNew(TokenKind.amp, start, 1, s.*.line)
    }

    // |
    if c == 124 {  // '|'
        return tokenNew(TokenKind.pipe, start, 1, s.*.line)
    }

    // ^
    if c == 94 {  // '^'
        return tokenNew(TokenKind.caret, start, 1, s.*.line)
    }

    // = or == or =>
    if c == 61 {  // '='
        if next == 61 {  // '=='
            scannerAdvance(s)
            return tokenNew(TokenKind.eq_eq, start, 2, s.*.line)
        }
        return tokenNew(TokenKind.eq, start, 1, s.*.line)
    }

    // ! or !=
    if c == 33 {  // '!'
        if next == 61 {  // '!='
            scannerAdvance(s)
            return tokenNew(TokenKind.bang_eq, start, 2, s.*.line)
        }
        return tokenNew(TokenKind.bang, start, 1, s.*.line)
    }

    // < or <= or <<
    if c == 60 {  // '<'
        if next == 61 {  // '<='
            scannerAdvance(s)
            return tokenNew(TokenKind.lt_eq, start, 2, s.*.line)
        }
        if next == 60 {  // '<<'
            scannerAdvance(s)
            return tokenNew(TokenKind.lshift, start, 2, s.*.line)
        }
        return tokenNew(TokenKind.lt, start, 1, s.*.line)
    }

    // > or >= or >>
    if c == 62 {  // '>'
        if next == 61 {  // '>='
            scannerAdvance(s)
            return tokenNew(TokenKind.gt_eq, start, 2, s.*.line)
        }
        if next == 62 {  // '>>'
            scannerAdvance(s)
            return tokenNew(TokenKind.rshift, start, 2, s.*.line)
        }
        return tokenNew(TokenKind.gt, start, 1, s.*.line)
    }

    // . or .*
    if c == 46 {  // '.'
        return tokenNew(TokenKind.dot, start, 1, s.*.line)
    }

    // Unknown character
    return tokenNew(TokenKind.invalid, start, 1, s.*.line)
}

// =============================================================================
// Scanner: Main Entry Point - Get Next Token
// =============================================================================

fn scannerNext(s: *Scanner) Token {
    scannerSkipWhitespace(s)

    if scannerAtEnd(s) {
        return tokenNew(TokenKind.eof, s.*.pos, 0, s.*.line)
    }

    var start: i64 = s.*.pos
    var c: u8 = scannerPeek(s)

    // Identifier or keyword
    if isAlpha(c) {
        return scannerScanIdentifier(s, start)
    }

    // Number
    if isDigit(c) {
        return scannerScanNumber(s, start)
    }

    // String literal
    if c == 34 {  // '"'
        return scannerScanString(s, start)
    }

    // Character literal
    if c == 39 {  // '\''
        return scannerScanChar(s, start)
    }

    // Operator or punctuation
    return scannerScanOperator(s, start)
}

// =============================================================================
// Helper: Extract Substring from Source
// =============================================================================
//
// LANGUAGE FEATURE NEEDED: String slicing or substring builtin
// WORKAROUND: For stage0, we can use a builtin or just track start/length
//
// NOTE: In practice, we may need @substring(source, start, end) -> string
// For now, assume this exists or use token start/length with original source

fn substringFromSource(source: string, start: i64, end: i64) string {
    // PLACEHOLDER: This would need runtime support or string slicing
    // For keyword lookup, we compare character by character instead
    return source  // Return full source as placeholder
}

// =============================================================================
// Test Function
// =============================================================================
//
// Used to verify scanner_s0.cot compiles and works correctly.
// Returns 42 on success.

fn test_scanner() i64 {
    var source: string = "fn main() { return 42 }"
    var scanner: Scanner = scannerInit(source)

    // Token 1: "fn" keyword
    var tok1: Token = scannerNext(&scanner)
    if tok1.kind != TokenKind.kw_fn {
        return 1
    }

    // Token 2: "main" identifier
    var tok2: Token = scannerNext(&scanner)
    if tok2.kind != TokenKind.ident {
        return 2
    }

    // Token 3: "(" left paren
    var tok3: Token = scannerNext(&scanner)
    if tok3.kind != TokenKind.lparen {
        return 3
    }

    // Token 4: ")" right paren
    var tok4: Token = scannerNext(&scanner)
    if tok4.kind != TokenKind.rparen {
        return 4
    }

    // Token 5: "{" left brace
    var tok5: Token = scannerNext(&scanner)
    if tok5.kind != TokenKind.lbrace {
        return 5
    }

    // Token 6: "return" keyword
    var tok6: Token = scannerNext(&scanner)
    if tok6.kind != TokenKind.kw_return {
        return 6
    }

    // Token 7: "42" number
    var tok7: Token = scannerNext(&scanner)
    if tok7.kind != TokenKind.int_lit {
        return 7
    }

    // Token 8: "}" right brace
    var tok8: Token = scannerNext(&scanner)
    if tok8.kind != TokenKind.rbrace {
        return 8
    }

    // Token 9: EOF
    var tok9: Token = scannerNext(&scanner)
    if tok9.kind != TokenKind.eof {
        return 9
    }

    return 42
}

// =============================================================================
// SUMMARY OF LANGUAGE FEATURES NEEDED
// =============================================================================
//
// FROM token_s0.cot (inherited):
// 1. enum with backing type: enum TokenKind: u8 { ... }
// 2. Enum comparison: kind == TokenKind.plus
//
// NEW IN scanner_s0.cot:
// 3. String indexing: source[pos] -> u8
// 4. Logical AND/OR (can workaround with nested if)
//
// NICE TO HAVE:
// 5. String slicing: source[start..end] or @substring(source, start, end)
//
// =============================================================================

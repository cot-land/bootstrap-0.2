// cot1 Feature Test Suite
// ========================
//
// This file tests cot1-specific language features (beyond cot0/e2e tests).
// Each feature must have 3-5 tests that pass before the feature is complete.
//
// Run with cot1 compiler (NOT the Zig bootstrap):
//   ./zig-out/bin/cot cot1/main.cot -o /tmp/cot1-stage1
//   /tmp/cot1-stage1 test/cot1/cot1_features.cot -o /tmp/cot1_features && /tmp/cot1_features
//
// Also run the base tests to prove cot1 parity:
//   /tmp/cot1-stage1 test/cot1/all_tests.cot -o /tmp/cot1_base && /tmp/cot1_base
//
// Expected output: "All N tests passed!" where N grows as features are added.

// ============================================================================
// Test Infrastructure (same as e2e/all_tests.cot)
// ============================================================================

extern fn write(fd: i64, buf: *u8, count: i64) i64;

fn print(s: string) {
    let _ = write(1, s.ptr, s.len);
}

fn print_int(n: i64) {
    if n < 0 {
        print("-");
        print_int(0 - n);
        return;
    }
    if n >= 10 {
        print_int(n / 10);
    }
    var buf: [1]u8 = undefined;
    buf[0] = @intCast(u8, 48 + (n % 10));
    let _ = write(1, &buf[0], 1);
}

var g_tests_run: i64 = 0;
var g_tests_passed: i64 = 0;

fn run_test(name: string, result: i64, expected: i64) {
    g_tests_run = g_tests_run + 1;
    if result == expected {
        g_tests_passed = g_tests_passed + 1;
    } else {
        print("FAIL: ");
        print(name);
        print(" - got ");
        print_int(result);
        print(", expected ");
        print_int(expected);
        print("\n");
    }
}

// ============================================================================
// Feature: Error Unions - IMPLEMENTED (syntax only, no real error handling yet)
// ============================================================================

fn get_error_value(fail: bool) !i64 {
    if fail {
        return 0;  // Would be error in real impl
    }
    return 42;
}

fn test_error_union_return_type() i64 {
    // Function can declare !T return type
    let result: !i64 = get_error_value(false);
    if result == 42 { return 1; }
    return 0;
}

fn test_error_union_variable() i64 {
    // Variables can have !T type
    var value: !i64 = 100;
    if value == 100 { return 1; }
    return 0;
}

fn test_error_union_as_param() i64 {
    // For now, !T is treated as T
    let x: !i64 = 99;
    if x == 99 { return 1; }
    return 0;
}

// ============================================================================
// Feature: Optional Types - IMPLEMENTED
// ============================================================================

struct OptTestItem {
    key: i64,
    value: i64,
}

fn test_optional_ptr_null() i64 {
    let ptr: ?*OptTestItem = null;
    if ptr == null { return 1; }
    return 0;
}

fn test_optional_ptr_some() i64 {
    var item: OptTestItem = undefined;
    item.key = 42;
    let ptr: ?*OptTestItem = &item;
    if ptr != null { return 1; }
    return 0;
}

fn test_optional_reassign() i64 {
    var item: OptTestItem = undefined;
    var ptr: ?*OptTestItem = null;
    if ptr != null { return 0; }
    ptr = &item;
    if ptr == null { return 0; }
    return 1;
}

// ============================================================================
// Feature: Type Aliases - IMPLEMENTED
// ============================================================================

// Type aliases now work!
type TestIndex = i64
type TestOffset = i64

fn get_test_index(idx: TestIndex) TestIndex {
    return idx + 1;
}

fn test_type_alias_basic() i64 {
    let idx: TestIndex = 5;
    let result: TestIndex = get_test_index(idx);
    if result == 6 { return 1; }
    return 0;
}

fn test_type_alias_assignment() i64 {
    let a: TestIndex = 10;
    let b: TestOffset = 20;
    let sum: i64 = a + b;
    if sum == 30 { return 1; }
    return 0;
}

fn test_type_alias_function_return() i64 {
    let result: TestIndex = get_test_index(99);
    if result == 100 { return 1; }
    return 0;
}

// ============================================================================
// Feature: Labeled Break/Continue
// ============================================================================

fn test_labeled_break_placeholder() i64 {
    // Placeholder until labeled control flow is added
    return 1;
}

// ============================================================================
// Feature: Struct Init Shorthand
// ============================================================================

fn test_struct_shorthand_placeholder() i64 {
    // Placeholder until .field shorthand is added
    return 1;
}

// ============================================================================
// Main Test Runner
// ============================================================================

fn main() i64 {
    print("cot1 Feature Test Suite\n");
    print("=======================\n\n");

    // Error Union Tests (Feature 1) - IMPLEMENTED
    print("Testing: Error Unions\n");
    run_test("error_union_return_type", test_error_union_return_type(), 1);
    run_test("error_union_variable", test_error_union_variable(), 1);
    run_test("error_union_as_param", test_error_union_as_param(), 1);

    // Optional Type Tests (Feature 2) - IMPLEMENTED
    print("Testing: Optional Types\n");
    run_test("optional_ptr_null", test_optional_ptr_null(), 1);
    run_test("optional_ptr_some", test_optional_ptr_some(), 1);
    run_test("optional_reassign", test_optional_reassign(), 1);

    // Type Alias Tests (Feature 3) - IMPLEMENTED
    print("Testing: Type Aliases\n");
    run_test("type_alias_basic", test_type_alias_basic(), 1);
    run_test("type_alias_assignment", test_type_alias_assignment(), 1);
    run_test("type_alias_function_return", test_type_alias_function_return(), 1);

    // Labeled Break/Continue Tests (Feature 5)
    print("Testing: Labeled Break/Continue\n");
    run_test("labeled_break_placeholder", test_labeled_break_placeholder(), 1);

    // Struct Init Shorthand Tests (Feature 7)
    print("Testing: Struct Init Shorthand\n");
    run_test("struct_shorthand_placeholder", test_struct_shorthand_placeholder(), 1);

    // Summary
    print("\n");
    print_int(g_tests_passed);
    print("/");
    print_int(g_tests_run);
    print(" tests passed\n");

    if g_tests_passed == g_tests_run {
        print("All ");
        print_int(g_tests_run);
        print(" tests passed!\n");
        return 0;
    } else {
        print("FAILURES: ");
        print_int(g_tests_run - g_tests_passed);
        print(" tests failed\n");
        return 1;
    }
}

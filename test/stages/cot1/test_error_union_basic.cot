// Test: Error Union Type Basic Syntax
// Feature: !T type for error-or-value
//
// This test verifies:
// 1. Error union type declaration parsing (!T)
// 2. Functions with error union return types
// 3. Basic error union variable handling
//
// Note: Full error handling (try/catch/error sets) will be in cot2.
// cot1 focuses on the basic !T type syntax.

struct Item {
    key: i64,
    value: i64,
}

// Test 1: Function returning error union can return success value
fn get_value_or_error(succeed: bool) !i64 {
    if succeed {
        return 42;
    }
    // For now, return success - error propagation comes later
    return 0;
}

// Test 2: Function returning error union pointer
fn get_item_or_error(item: *Item, succeed: bool) !*Item {
    if succeed {
        return item;
    }
    // Return pointer for now
    return item;
}

// Test 3: Nested types with error union
fn get_optional_or_error(succeed: bool) !?i64 {
    if succeed {
        return 100;
    }
    return null;
}

fn test_error_union_return_success() i64 {
    // Test that we can call a function returning !i64 and get the success value
    let result: i64 = get_value_or_error(true);
    if result == 42 {
        return 1;
    }
    return 0;
}

fn test_error_union_ptr_return() i64 {
    var item: Item = undefined;
    item.key = 99;
    item.value = 200;

    let result: *Item = get_item_or_error(&item, true);
    if result.key == 99 {
        return 1;
    }
    return 0;
}

fn test_error_union_nested_optional() i64 {
    // This tests !?i64 - error union of optional
    let result: ?i64 = get_optional_or_error(true);
    if result == 100 {
        return 1;
    }
    return 0;
}

fn main() i64 {
    var passed: i64 = 0;

    if test_error_union_return_success() == 1 { passed = passed + 1; }
    if test_error_union_ptr_return() == 1 { passed = passed + 1; }
    if test_error_union_nested_optional() == 1 { passed = passed + 1; }

    // Return 0 if all 3 tests pass
    if passed == 3 {
        return 0;
    }
    return 1;
}

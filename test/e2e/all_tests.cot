// ============================================================================
// COT END-TO-END TEST SUITE
// ============================================================================
//
// Progress: 145 / 145 tests passing
//
// ============================================================================
// STATUS TRACKER
// ============================================================================
//
// PASSING:
//   [x] test_return       - return literal
//   [x] test_mul          - multiplication
//   [x] test_div          - division
//   [x] test_sub          - subtraction
//   [x] test_neg          - unary negation
//   [x] test_call         - simple function call
//   [x] test_nested_call  - nested function calls
//   [x] test_call_spill   - call result preserved across subsequent calls
//   [x] test_fn_call      - call helper function
//   [x] test_var_assign   - local variable assignment
//   [x] test_const        - const declaration
//   [x] test_if           - if with true condition
//   [x] test_if_false     - if with false condition (else branch)
//   [x] test_nested_if    - nested if statements
//   [x] test_while_simple - while with false condition (skip loop)
//   [x] test_while        - while loop with variable mutation
//   [x] test_ne           - not equal comparison
//   [x] test_lt           - less than comparison
//   [x] test_gt           - greater than comparison
//   [x] test_fibonacci    - fibonacci (comprehensive phi test)
//   [x] test_neg_compare   - comparison with negative numbers
//   [x] test_chain         - chained arithmetic
//   [x] test_countdown     - countdown while loop
//   [x] test_multi_var     - multiple variables
//   [x] test_early_return  - early return in if
//   [x] test_le            - less or equal comparison
//   [x] test_ge            - greater or equal comparison
//   [x] test_mod           - modulo operator
//   [x] test_recursion     - recursive function call
//   [x] test_bool          - boolean type
//   [x] test_8args         - 8 arguments (register passing)
//   [x] test_9args         - 9 arguments (stack passing)
//   [x] test_nested_while  - nested while loops
//   [x] test_break         - break statement
//   [x] test_continue      - continue statement
//   [x] test_precedence    - operator precedence
//   [x] test_parens        - parentheses in expressions
//   [x] test_void          - void function calls
//   [x] test_large         - large numbers
//   [x] test_struct_simple  - simple struct field access
//   [x] test_struct_reassign - struct field reassignment
//   [x] test_nested_struct  - nested struct field access
//   [x] test_large_struct   - large struct (64 bytes)
//   [x] test_char_simple    - character literal
//   [x] test_char_escape    - character escape sequences
//   [x] test_char_compare   - character comparison
//   [x] test_string_simple  - string literal (address loading)
//   [x] test_len_string     - len() builtin with string literals
//   [x] test_len_escape     - len() with escape sequences
//   [x] test_len_string_var - len() with string variables (runtime)
//   [x] test_array_index    - array indexing with constants
//   [x] test_array_assign   - array element assignment
//   [x] test_array_var_index - array indexing with variables
//   [x] test_array_param    - array as function parameter
//   [x] test_ptr_read       - pointer read (dereference)
//   [x] test_ptr_write      - pointer write (dereference assignment)
//   [x] test_ptr_modify     - pointer modifying original variable
//   [x] test_ptr_param      - pointer as function parameter
//   [x] test_ptr_expr       - multiple dereferences in expression
//   [x] test_bitwise_and    - bitwise AND operator
//   [x] test_bitwise_or     - bitwise OR operator
//   [x] test_bitwise_xor    - bitwise XOR operator
//   [x] test_shl            - left shift operator
//   [x] test_shr            - right shift operator
//   [x] test_bitwise_combo  - combined bitwise operations
//   [x] test_shift_var      - shift with variable amount
//   [x] test_mask_extract   - bit masking pattern
//   [x] test_logical_and_true - logical AND both true
//   [x] test_logical_and_false_first - logical AND short-circuit
//   [x] test_logical_and_false_second - logical AND second false
//   [x] test_logical_or_false - logical OR both false
//   [x] test_logical_or_true_first - logical OR short-circuit
//   [x] test_logical_or_true_second - logical OR second true
//   [x] test_logical_and_chain - chained AND
//   [x] test_logical_or_chain - chained OR
//   [x] test_enum_first - enum first variant
//   [x] test_enum_second - enum second variant
//   [x] test_enum_third - enum third variant
//   [x] test_enum_ne - enum not equal comparison
//   [x] test_enum_param - enum as function parameter
//   [x] test_defer_simple - defer with function call
//   [x] test_defer_early_return - defer in early return path
//   [x] test_defer_multiple - multiple defers (LIFO)
//   [x] test_defer_block - defer in block scope
//
// BLOCKED - Need more struct features (16):
//   [ ] test_struct_init, test_struct_param, test_struct_return, ...
//
// BLOCKED - Need advanced features (32):
//   [ ] enums, unions, slices, for loops, ...
//
// ============================================================================
// IMPLEMENTATION ORDER
// ============================================================================
//
// 1. Function calls   -> DONE!
// 2. Local variables  -> DONE!
// 3. Comparisons      -> DONE! (==, !=, <, <=, >, >=)
// 4. If/else          -> DONE!
// 5. Simple while     -> DONE! (loops without variable mutation)
// 6. While with vars  -> DONE! (phi nodes implemented!)
// 7. Structs          -> DONE! (basic field access, nested, large structs)
// 8. Continue until 113/113
//
// ============================================================================

// ============================================================================
// GLOBAL VARIABLES (for TIER 24 tests)
// ============================================================================

var g_counter: i64 = 0;

// ============================================================================
// TIER 1: Basic Return + Arithmetic
// ============================================================================

fn test_return() i64 {
    return 42;
}

fn test_mul() i64 {
    return 6 * 7;
}

fn test_div() i64 {
    return 84 / 2;
}

fn test_sub() i64 {
    return 50 - 8;
}

fn test_neg() i64 {
    let x: i64 = -5;
    return x + 47;
}

// ============================================================================
// TIER 2: Function Calls
// ============================================================================

fn add_one(x: i64) i64 {
    return x + 1;
}

fn test_call() i64 {
    return add_one(41);
}

fn add(a: i64, b: i64) i64 {
    return a + b;
}

fn mul(a: i64, b: i64) i64 {
    return a * b;
}

fn test_nested_call() i64 {
    return add(mul(2, 3), mul(6, 6));
}

// Test that first call result is preserved across subsequent calls
// This was a bug: regalloc assigned register to original value instead of load_reg
fn test_call_spill() i64 {
    var x: i64 = mul(2, 3);
    var y: i64 = mul(6, 6);
    return x;
}

fn helper() i64 {
    return 42;
}

fn test_fn_call() i64 {
    return helper();
}

// ============================================================================
// TIER 3: Local Variables
// ============================================================================

fn test_var_assign() i64 {
    let x: i64 = 42;
    let y: i64 = x;
    return y;
}

fn test_const() i64 {
    const x: i64 = 42;
    return x;
}

// ============================================================================
// TIER 4: Comparisons
// ============================================================================

fn test_ne() i64 {
    if 1 != 2 {
        return 42;
    }
    return 0;
}

fn test_lt() i64 {
    if 10 < 20 {
        return 42;
    }
    return 0;
}

fn test_gt() i64 {
    if 20 > 10 {
        return 42;
    }
    return 0;
}

// ============================================================================
// TIER 5: If/Else
// ============================================================================

fn test_if() i64 {
    if 1 == 1 {
        return 42;
    } else {
        return 0;
    }
}

fn test_if_false() i64 {
    if 1 == 2 {
        return 0;
    } else {
        return 42;
    }
}

fn test_nested_if() i64 {
    if 1 == 1 {
        if 2 == 2 {
            return 42;
        }
    }
    return 0;
}

// ============================================================================
// TIER 6: While Loops
// ============================================================================

fn test_while_simple() i64 {
    while 1 == 2 {
        return 1;
    }
    return 42;
}

fn test_while() i64 {
    var x: i64 = 0;
    while x < 42 {
        x = x + 1;
    }
    return x;
}

fn test_fibonacci() i64 {
    var a: i64 = 0;
    var b: i64 = 1;
    var i: i64 = 0;
    while i < 10 {
        let temp: i64 = a + b;
        a = b;
        b = temp;
        i = i + 1;
    }
    return a;
}

// ============================================================================
// TIER 6.5: Edge Cases
// ============================================================================

// Test comparison with negative numbers
fn test_neg_compare() i64 {
    let x: i64 = -5;
    if x < 0 {
        return 42;
    }
    return 0;
}

// Test chained arithmetic
fn test_chain() i64 {
    return 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 6;
}

// Test countdown while loop
fn test_countdown() i64 {
    var x: i64 = 10;
    while x > 0 {
        x = x - 1;
    }
    return 42 + x;
}

// Test multiple variables
fn test_multi_var() i64 {
    let a: i64 = 10;
    let b: i64 = 20;
    let c: i64 = 12;
    return a + b + c;
}

// Test early return in if
fn test_early_return() i64 {
    if 1 == 1 {
        return 42;
    }
    return 0;
}

// Test le comparison
fn test_le() i64 {
    if 5 <= 5 {
        return 42;
    }
    return 0;
}

// Test ge comparison
fn test_ge() i64 {
    if 5 >= 5 {
        return 42;
    }
    return 0;
}

// Test modulo operator
fn test_mod() i64 {
    return 17 % 5 + 40;
}

// Test recursive factorial
fn factorial(n: i64) i64 {
    if n <= 1 {
        return 1;
    }
    return n * factorial(n - 1);
}

fn test_recursion() i64 {
    if factorial(5) == 120 {
        return 42;
    }
    return 0;
}

// Test boolean type
fn test_bool() i64 {
    let b: bool = true;
    if b {
        return 42;
    }
    return 0;
}

// Test 8 arguments (max register args)
fn sum8(a: i64, b: i64, c: i64, d: i64, e: i64, f: i64, g: i64, h: i64) i64 {
    return a + b + c + d + e + f + g + h;
}

fn test_8args() i64 {
    if sum8(1, 2, 3, 4, 5, 6, 7, 8) == 36 {
        return 42;
    }
    return 0;
}

// Test 9 arguments (stack argument passing)
fn sum9(a: i64, b: i64, c: i64, d: i64, e: i64, f: i64, g: i64, h: i64, i: i64) i64 {
    return a + b + c + d + e + f + g + h + i;
}

fn test_9args() i64 {
    if sum9(1, 2, 3, 4, 5, 6, 7, 8, 9) == 45 {
        return 42;
    }
    return 0;
}

// Test nested while loops
fn test_nested_while() i64 {
    var sum: i64 = 0;
    var i: i64 = 0;
    while i < 3 {
        var j: i64 = 0;
        while j < 3 {
            sum = sum + 1;
            j = j + 1;
        }
        i = i + 1;
    }
    if sum == 9 {
        return 42;
    }
    return 0;
}

// Test break statement
fn test_break() i64 {
    var i: i64 = 0;
    while i < 100 {
        if i == 10 {
            break;
        }
        i = i + 1;
    }
    if i == 10 {
        return 42;
    }
    return 0;
}

// Test continue statement
fn test_continue() i64 {
    var sum: i64 = 0;
    var i: i64 = 0;
    while i < 10 {
        i = i + 1;
        if i % 2 == 1 {
            continue;
        }
        sum = sum + 1;
    }
    if sum == 5 {
        return 42;
    }
    return 0;
}

// Test operator precedence
fn test_precedence() i64 {
    // 2 + (3*4) + (2*3*4) + 4 = 2 + 12 + 24 + 4 = 42
    return 2 + 3 * 4 + 2 * 3 * 4 + 4;
}

// Test parentheses
fn test_parens() i64 {
    // (1+2) * (3+4) * 2 = 3 * 7 * 2 = 42
    return (1 + 2) * (3 + 4) * 2;
}

// Test void function
fn void_helper() void {
    return;
}

fn test_void() i64 {
    void_helper();
    return 42;
}

// Test large numbers
fn test_large() i64 {
    let big: i64 = 1000000000;
    if big / 1000000000 == 1 {
        return 42;
    }
    return 0;
}

// ============================================================================
// TIER 7: Structs
// ============================================================================

struct Point {
    x: i64,
    y: i64,
}

struct Inner {
    a: i64,
    b: i64,
}

struct Outer {
    inner: Inner,
    c: i64,
}

// Test simple struct field access
fn test_struct_simple() i64 {
    var p: Point;
    p.x = 20;
    p.y = 22;
    return p.x + p.y;
}

// Test struct field reassignment
fn test_struct_reassign() i64 {
    var p: Point;
    p.x = 10;
    p.y = 10;
    p.x = p.x + 12;
    p.y = p.y + 10;
    return p.x + p.y;
}

// Test nested struct field access
fn test_nested_struct() i64 {
    var o: Outer;
    o.inner.a = 10;
    o.inner.b = 20;
    o.c = 12;
    return o.inner.a + o.inner.b + o.c;
}

struct LargeStruct {
    a: i64,
    b: i64,
    c: i64,
    d: i64,
    e: i64,
    f: i64,
    g: i64,
    h: i64,
}

// Test large struct (64 bytes = 8 fields * 8 bytes)
// This exercises stack frame layout for structs > 16 bytes
fn test_large_struct() i64 {
    var s: LargeStruct;
    s.a = 1;
    s.b = 2;
    s.c = 3;
    s.d = 4;
    s.e = 5;
    s.f = 6;
    s.g = 7;
    s.h = 14;
    return s.a + s.b + s.c + s.d + s.e + s.f + s.g + s.h;
}

// ============================================================================
// TIER 8: Characters and Strings
// ============================================================================

// Test simple character literal
fn test_char_simple() i64 {
    let c: u8 = 'A';
    if c == 65 {
        return 42;
    }
    return 0;
}

// Test character escape sequences
fn test_char_escape() i64 {
    let newline: u8 = '\n';
    let tab: u8 = '\t';
    let backslash: u8 = '\\';
    if newline == 10 {
        if tab == 9 {
            if backslash == 92 {
                return 42;
            }
        }
    }
    return 0;
}

// Test character comparison
fn test_char_compare() i64 {
    let a: u8 = 'a';
    let b: u8 = 'b';
    if a < b {
        return 42;
    }
    return 0;
}

// Test simple string literal - just verify codegen works
fn test_string_simple() i64 {
    let s: string = "hello";
    // For now, just test that the code compiles and runs
    // We're not yet using the string value
    return 42;
}

// Test len() builtin with string literal
fn test_len_string() i64 {
    if len("hello") == 5 {
        if len("") == 0 {
            if len("a") == 1 {
                return 42;
            }
        }
    }
    return 0;
}

// Test len() with escape sequences (escapes count as 1 byte each)
fn test_len_escape() i64 {
    if len("\n") == 1 {
        if len("a\nb") == 3 {
            if len("\\") == 1 {
                return 42;
            }
        }
    }
    return 0;
}

// Test len() with string variables (runtime)
fn test_len_string_var() i64 {
    let s: string = "hello";
    if len(s) == 5 {
        let empty: string = "";
        if len(empty) == 0 {
            let escaped: string = "a\nb";
            if len(escaped) == 3 {
                return 42;
            }
        }
    }
    return 0;
}

// ============================================================================
// TIER 9: Arrays
// ============================================================================

// Test array declaration and indexing
fn test_array_index() i64 {
    var arr: [3]i64 = [10, 20, 30];
    if arr[0] == 10 {
        if arr[1] == 20 {
            if arr[2] == 30 {
                return 42;
            }
        }
    }
    return 0;
}

// Test array element assignment
fn test_array_assign() i64 {
    var arr: [3]i64 = [0, 0, 0];
    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 12;
    return arr[0] + arr[1] + arr[2];
}

// Test array with variable index
fn test_array_var_index() i64 {
    var arr: [5]i64 = [1, 2, 3, 4, 5];
    var sum: i64 = 0;
    var i: i64 = 0;
    while i < 5 {
        sum = sum + arr[i];
        i = i + 1;
    }
    if sum == 15 {
        return 42;
    }
    return 0;
}

// Test array sum helper for array test
fn array_sum(arr: [4]i64) i64 {
    return arr[0] + arr[1] + arr[2] + arr[3];
}

// Test array as function parameter
fn test_array_param() i64 {
    var arr: [4]i64 = [10, 11, 12, 9];
    if array_sum(arr) == 42 {
        return 42;
    }
    return 0;
}

// ============================================================================
// TIER 10: Pointers
// ============================================================================

// Test pointer read (dereference)
fn test_ptr_read() i64 {
    var x: i64 = 42;
    let ptr: *i64 = &x;
    return ptr.*;
}

// Test pointer write (dereference assignment)
fn test_ptr_write() i64 {
    var x: i64 = 10;
    let ptr: *i64 = &x;
    ptr.* = 42;
    return x;
}

// Test pointer modifying original variable
fn test_ptr_modify() i64 {
    var a: i64 = 10;
    var b: i64 = 20;
    let ptr_a: *i64 = &a;
    let ptr_b: *i64 = &b;
    ptr_a.* = ptr_a.* + ptr_b.*;
    return a + b;
}

// Test pointer as function parameter
fn add_via_ptr(ptr: *i64, val: i64) void {
    ptr.* = ptr.* + val;
    return;
}

fn test_ptr_param() i64 {
    var x: i64 = 10;
    add_via_ptr(&x, 32);
    return x;
}

// Test multiple dereferences in expression
fn test_ptr_expr() i64 {
    var a: i64 = 20;
    var b: i64 = 22;
    let pa: *i64 = &a;
    let pb: *i64 = &b;
    return pa.* + pb.*;
}

// Test pointer field store: ptr.field = value
fn set_point_x(p: *Point, val: i64) void {
    p.x = val;  // Store through pointer to struct field
}

fn test_ptr_field_store() i64 {
    var pt: Point;
    pt.x = 0;
    pt.y = 0;
    set_point_x(&pt, 42);
    return pt.x;  // Should be 42
}

// Test function type declaration and assignment
fn helper_add(a: i64, b: i64) i64 {
    return a + b;
}

fn test_fn_type() i64 {
    // Declare a variable of function type
    var f: fn(i64, i64) -> i64;
    f = helper_add;  // Assign function to variable
    // Note: Indirect calls through function pointers not yet supported
    // Just verify the type checking and assignment work
    return helper_add(20, 22);  // Should be 42
}

// ============================================================================
// TIER 11: Bitwise Operators
// ============================================================================

// Test bitwise AND
fn test_bitwise_and() i64 {
    // 0b1111 & 0b1010 = 0b1010 = 10
    return 15 & 10;
}

// Test bitwise OR
fn test_bitwise_or() i64 {
    // 0b0101 | 0b1010 = 0b1111 = 15
    return 5 | 10;
}

// Test bitwise XOR
fn test_bitwise_xor() i64 {
    // 0b1111 ^ 0b1010 = 0b0101 = 5
    return 15 ^ 10;
}

// Test left shift
fn test_shl() i64 {
    // 1 << 5 = 32
    return 1 << 5;
}

// Test right shift
fn test_shr() i64 {
    // 64 >> 4 = 4
    return 64 >> 4;
}

// Test combined bitwise: (10 | 5) & 12 = 15 & 12 = 12
fn test_bitwise_combo() i64 {
    let a: i64 = 10;
    let b: i64 = 5;
    let c: i64 = 12;
    return (a | b) & c;
}

// Test shift with variable: 1 << n where n = 6 -> 64
fn test_shift_var() i64 {
    let n: i64 = 6;
    return 1 << n;
}

// Test masking: extract bits 4-7 of 0xFF -> 15
fn test_mask_extract() i64 {
    let val: i64 = 255;
    return (val >> 4) & 15;
}

// ============================================================================
// TIER 12: Logical Operators (Short-Circuit)
// ============================================================================

// Test logical AND - both true
fn test_logical_and_true() i64 {
    if 1 == 1 and 2 == 2 {
        return 42;
    }
    return 0;
}

// Test logical AND - first false (short-circuit)
fn test_logical_and_false_first() i64 {
    if 1 == 2 and 2 == 2 {
        return 0;
    }
    return 42;
}

// Test logical AND - second false
fn test_logical_and_false_second() i64 {
    if 1 == 1 and 2 == 3 {
        return 0;
    }
    return 42;
}

// Test logical OR - both false
fn test_logical_or_false() i64 {
    if 1 == 2 or 3 == 4 {
        return 0;
    }
    return 42;
}

// Test logical OR - first true (short-circuit)
fn test_logical_or_true_first() i64 {
    if 1 == 1 or 2 == 3 {
        return 42;
    }
    return 0;
}

// Test logical OR - second true
fn test_logical_or_true_second() i64 {
    if 1 == 2 or 2 == 2 {
        return 42;
    }
    return 0;
}

// Test chained AND
fn test_logical_and_chain() i64 {
    if 1 == 1 and 2 == 2 and 3 == 3 {
        return 42;
    }
    return 0;
}

// Test chained OR
fn test_logical_or_chain() i64 {
    if 1 == 2 or 2 == 3 or 3 == 3 {
        return 42;
    }
    return 0;
}

// ============================================================================
// TIER 13: Enums
// ============================================================================

enum Status {
    Pending,
    Active,
    Done,
}

// Test enum value (first variant = 0)
fn test_enum_first() i64 {
    let s: Status = Status.Pending;
    if s == Status.Pending {
        return 42;
    }
    return 0;
}

// Test enum value (second variant = 1)
fn test_enum_second() i64 {
    let s: Status = Status.Active;
    if s == Status.Active {
        return 42;
    }
    return 0;
}

// Test enum value (third variant = 2)
fn test_enum_third() i64 {
    let s: Status = Status.Done;
    if s == Status.Done {
        return 42;
    }
    return 0;
}

// Test enum comparison not equal
fn test_enum_ne() i64 {
    let s: Status = Status.Active;
    if s != Status.Pending {
        return 42;
    }
    return 0;
}

// Test enum as function parameter
fn check_status(s: Status) i64 {
    if s == Status.Done {
        return 42;
    }
    return 0;
}

fn test_enum_param() i64 {
    return check_status(Status.Done);
}

// ============================================================================
// TIER 14: Null and Pointers
// ============================================================================

// Test null pointer assignment and comparison (== null)
fn test_null_eq() i64 {
    let p: *i64 = null;
    if p == null {
        return 42;
    }
    return 0;
}

// Test null pointer comparison (!= null)
fn test_null_ne() i64 {
    let p: *i64 = null;
    if p != null {
        return 0;
    }
    return 42;
}

// Test null on right side of comparison
fn test_null_eq_right() i64 {
    let p: *i64 = null;
    if null == p {
        return 42;
    }
    return 0;
}

// Test non-null pointer
fn test_ptr_not_null() i64 {
    var x: i64 = 42;
    let p: *i64 = &x;
    if p != null {
        return p.*;
    }
    return 0;
}

// ============================================================================
// TIER 15: Slices
// ============================================================================

// Test basic slice creation from array
fn test_slice_create() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50];
    let s: []i64 = arr[0:3];
    // For MVP: just verify the code compiles and runs
    return 42;
}

// Test slice with explicit start index
fn test_slice_start() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50];
    let s: []i64 = arr[2:5];
    return 42;
}

// Test slice indexing - read first element
fn test_slice_index_first() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50];
    let s: []i64 = arr[0:3];
    return s[0];  // Should return 10
}

// Test slice indexing - read middle element
fn test_slice_index_middle() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50];
    let s: []i64 = arr[1:4];
    return s[1];  // arr[2] = 30
}

// Test slice indexing with offset start
fn test_slice_index_offset() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50];
    let s: []i64 = arr[2:5];
    return s[0];  // arr[2] = 30
}

// Test len() on slice
fn test_slice_len() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50];
    let s: []i64 = arr[1:4];
    return len(s);  // Should return 3
}

// Test len() on full array slice
fn test_slice_len_full() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50];
    let s: []i64 = arr[0:5];
    return len(s);  // Should return 5
}

// Test slice shares memory with array (write through slice)
fn test_slice_write() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50];
    let s: []i64 = arr[0:3];
    s[0] = 42;
    return arr[0];  // Should return 42 (shared memory)
}

// Test implicit end: arr[start:] slices to end
fn test_slice_implicit_end() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50];
    let s: []i64 = arr[2:];  // Same as arr[2:5]
    return s[0];  // Should return 30 (arr[2])
}

// Test implicit start and end: arr[:] slices full array
fn test_slice_full() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50];
    let s: []i64 = arr[:];  // Same as arr[0:5]
    return len(s);  // Should return 5
}

// Test implicit start: arr[:end]
fn test_slice_implicit_start() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50];
    let s: []i64 = arr[:3];  // Same as arr[0:3]
    return s[2];  // Should return 30 (arr[2])
}

// ============================================================================
// TIER 15.4: Computed Base Index Assignment
// ============================================================================

// Helper that returns a slice from a pointer parameter
fn get_slice_from_ptr(arr: *[3]i64) []i64 {
    return arr.*[:];
}

// Test computed base assignment: func()[i] = x
fn test_computed_base_assign() i64 {
    var backing: [3]i64 = [0, 0, 0];
    get_slice_from_ptr(&backing)[0] = 42;  // Assign through computed slice
    return backing[0];  // Should be 42
}

// ============================================================================
// TIER 15.5: Array Copy Semantics
// ============================================================================

// Test array copy - modifying copy doesn't affect original
fn test_array_copy() i64 {
    var a: [3]i64 = [10, 20, 30];
    var b: [3]i64 = a;  // Copy a to b
    b[0] = 99;          // Modify b
    return a[0];        // a[0] should still be 10
}

// Test array copy - verify copy has correct values
fn test_array_copy_values() i64 {
    var a: [3]i64 = [10, 20, 30];
    var b: [3]i64 = a;  // Copy a to b
    return b[0] + b[1] + b[2];  // Should be 60 (10+20+30)
}

// ============================================================================
// TIER 15.6: String Variable Assignment
// ============================================================================

// Test string variable copy - verify len works on copy
fn test_string_var_copy() i64 {
    let s1: string = "hello";
    let s2: string = s1;  // Copy string variable
    return len(s2);       // Should return 5
}

// Test string variable copy - different string
fn test_string_var_copy2() i64 {
    let a: string = "abc";
    let b: string = a;
    let c: string = "defgh";
    let d: string = c;
    return len(b) + len(d);  // Should return 8 (3+5)
}

// ============================================================================
// TIER 15.7: String Indexing and Slicing
// ============================================================================

// Test string indexing - first character
fn test_string_index_first() i64 {
    let s: string = "hello";
    let c: u8 = s[0];
    if c == 104 { return 42; }  // 'h' = 104
    return 0;
}

// Test string indexing - middle character
fn test_string_index_middle() i64 {
    let s: string = "hello";
    let c: u8 = s[2];
    if c == 108 { return 42; }  // 'l' = 108
    return 0;
}

// Test string slicing - get substring
fn test_string_slice() i64 {
    let s: string = "hello";
    let sub: string = s[0:3];  // "hel"
    return len(sub);  // Should return 3
}

// Test string slicing - verify content
fn test_string_slice_content() i64 {
    let s: string = "hello";
    let sub: string = s[1:4];  // "ell"
    let c0: u8 = sub[0];
    let c1: u8 = sub[1];
    let c2: u8 = sub[2];
    // 'e' = 101, 'l' = 108
    if c0 == 101 {
        if c1 == 108 {
            if c2 == 108 {
                return 42;  // success
            }
        }
    }
    return 0;
}

// ============================================================================
// TIER 15.8: String Concatenation
// ============================================================================

// Note: String concatenation requires the runtime library (cot_runtime.c)
// which provides __cot_str_concat(ptr1, len1, ptr2, len2) -> (ptr, len)

// Test basic string concatenation
fn test_str_concat_basic() i64 {
    let a: string = "hello";
    let b: string = " world";
    let c: string = a + b;
    if len(c) == 11 { return 42; }
    return 0;
}

// Test empty string concatenation
fn test_str_concat_empty() i64 {
    let a: string = "foo";
    let b: string = "";
    let c: string = a + b;
    if len(c) == 3 { return 42; }
    return 0;
}

// Test multiple concatenations
fn test_str_concat_multi() i64 {
    let a: string = "a";
    let b: string = "b";
    let c: string = "c";
    let d: string = a + b;
    let e: string = d + c;
    if len(e) == 3 { return 42; }
    return 0;
}

// ============================================================================
// TIER 15.9: @string Builtin
// ============================================================================

// Test @string creates substring with correct length
fn test_string_builtin_len() i64 {
    let s: string = "hello world";
    let sub: string = @string(s.ptr + 6, 5);
    if len(sub) == 5 { return 42; }
    return 0;
}

// Test @string creates substring with correct content
fn test_string_builtin_content() i64 {
    let s: string = "hello world";
    let sub: string = @string(s.ptr + 6, 5);
    // First char should be 'w' (119)
    if sub[0] == 119 { return 42; }
    return 0;
}

// Test @string with zero length
fn test_string_builtin_empty() i64 {
    let s: string = "hello";
    let empty: string = @string(s.ptr, 0);
    if len(empty) == 0 { return 42; }
    return 0;
}

// ============================================================================
// TIER 16: For-In Loops
// ============================================================================

// Test basic for-in loop over array - sum elements
fn test_for_array() i64 {
    var arr: [5]i64 = [1, 2, 3, 4, 5];
    var sum: i64 = 0;
    for x in arr {
        sum = sum + x;
    }
    return sum;  // 1+2+3+4+5 = 15
}

// Test for-in with break
fn test_for_break() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50];
    var sum: i64 = 0;
    for x in arr {
        if x == 30 {
            break;
        }
        sum = sum + x;
    }
    return sum;  // 10+20 = 30
}

// Test for-in with continue
fn test_for_continue() i64 {
    var arr: [5]i64 = [1, 2, 3, 4, 5];
    var sum: i64 = 0;
    for x in arr {
        if x == 3 {
            continue;
        }
        sum = sum + x;
    }
    return sum;  // 1+2+4+5 = 12
}

// Test for-in with slice
fn test_for_slice() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50];
    let s: []i64 = arr[1:4];
    var sum: i64 = 0;
    for x in s {
        sum = sum + x;
    }
    return sum;  // 20+30+40 = 90
}

// ============================================================================
// TIER 17: Switch Statement
// ============================================================================

// Test switch - basic integer matching
fn test_switch_int() i64 {
    let x: i64 = 2;
    return switch x {
        1 => 10,
        2 => 42,
        3 => 30,
        else => 99,
    };
}

// Test switch - else (default) case
fn test_switch_default() i64 {
    let x: i64 = 5;
    return switch x {
        1 => 10,
        2 => 20,
        else => 42,
    };
}

// Test switch - multiple patterns per case
fn test_switch_multi() i64 {
    let x: i64 = 3;
    return switch x {
        1, 2 => 12,
        3, 4 => 42,
        else => 99,
    };
}

// Test switch - first case match
fn test_switch_first() i64 {
    let x: i64 = 1;
    return switch x {
        1 => 42,
        2 => 20,
        3 => 30,
        else => 99,
    };
}

// ============================================================================
// TIER 18: Indirect Function Calls (Function Pointers)
// ============================================================================

// Helper function for indirect call tests
fn add_fn(a: i64, b: i64) i64 {
    return a + b;
}

fn mul_fn(a: i64, b: i64) i64 {
    return a * b;
}

// Test indirect call through function pointer variable
fn test_fn_ptr_call() i64 {
    var f: fn(i64, i64) -> i64 = add_fn;
    return f(20, 22);  // Should return 42
}

// Test reassigning function pointer
fn test_fn_ptr_reassign() i64 {
    var f: fn(i64, i64) -> i64 = add_fn;
    let r1: i64 = f(10, 5);   // 15
    f = mul_fn;
    let r2: i64 = f(6, 7);    // 42
    return r2;
}

// Test function pointer with zero args
fn get_forty_two() i64 {
    return 42;
}

fn test_fn_ptr_no_args() i64 {
    var f: fn() -> i64 = get_forty_two;
    return f();
}

// ============================================================================
// TIER 19: Pointer Arithmetic (Go: OpAddPtr pattern)
// Need: ptr + int, ptr - int
// ============================================================================

extern fn malloc(size: i64) *i64;
extern fn free(ptr: *i64);

// Test pointer + integer arithmetic
fn test_ptr_add() i64 {
    let buf: *i64 = malloc(24);  // 3 x 8 bytes
    buf.* = 10;
    let p1: *i64 = buf + 8;      // offset by 8 bytes
    p1.* = 20;
    let p2: *i64 = buf + 16;     // offset by 16 bytes
    p2.* = 12;
    let sum: i64 = buf.* + (buf + 8).* + (buf + 16).*;  // 10 + 20 + 12 = 42
    free(buf);
    return sum;
}

// Test pointer subtraction
fn test_ptr_sub() i64 {
    let buf: *i64 = malloc(16);
    buf.* = 50;
    let end: *i64 = buf + 8;
    end.* = 100;
    // Go back: end - 8 should point to buf
    let start: *i64 = end - 8;
    let val: i64 = start.*;  // Should be 50
    free(buf);
    if val == 50 { return 42; }
    return 0;
}

// ============================================================================
// TIER 20: Bitwise NOT
// ============================================================================

fn test_bitwise_not_zero() i64 {
    let x: i64 = 0;
    if ~x == -1 { return 42; }
    return 0;
}

fn test_bitwise_not_neg() i64 {
    let x: i64 = -1;
    if ~x == 0 { return 42; }
    return 0;
}

fn test_bitwise_not_double() i64 {
    let x: i64 = 42;
    if ~~x == 42 { return 42; }
    return 0;
}

// ============================================================================
// TIER 21: Compound Assignments
// ============================================================================

fn test_add_assign() i64 {
    let x: i64 = 10;
    x += 5;
    if x == 15 { return 42; }
    return 0;
}

fn test_sub_assign() i64 {
    let x: i64 = 20;
    x -= 8;
    if x == 12 { return 42; }
    return 0;
}

fn test_mul_assign() i64 {
    let x: i64 = 6;
    x *= 7;
    if x == 42 { return 42; }
    return 0;
}

fn test_div_assign() i64 {
    let x: i64 = 84;
    x /= 2;
    if x == 42 { return 42; }
    return 0;
}

fn test_bitwise_and_assign() i64 {
    let x: i64 = 15;  // 1111
    x &= 6;           // 0110
    if x == 6 { return 42; }
    return 0;
}

fn test_bitwise_or_assign() i64 {
    let x: i64 = 8;   // 1000
    x |= 4;           // 0100
    if x == 12 { return 42; }  // 1100
    return 0;
}

// ============================================================================
// TIER 22: @intCast
// ============================================================================

fn test_intcast_widen() i64 {
    let a: u8 = 200;
    let b: i64 = @intCast(i64, a);
    if b == 200 { return 42; }
    return 0;
}

fn test_intcast_truncate() i64 {
    let a: i64 = 300;  // 0x12C -> truncate to 0x2C = 44
    let b: u8 = @intCast(u8, a);
    if b == 44 { return 42; }
    return 0;
}

fn test_intcast_roundtrip() i64 {
    let a: i64 = 12345;
    let b: i32 = @intCast(i32, a);
    let c: i64 = @intCast(i64, b);
    if c == 12345 { return 42; }
    return 0;
}

// ============================================================================
// TIER 23+: BLOCKED - Advanced Features
// Need: more features...
// ============================================================================

// (many more tests to add as we implement features)

// ============================================================================
// TIER 23: Defer Statement
// ============================================================================

// Helper for defer tests
fn defer_identity(x: i64) i64 {
    return x;
}

// Simple defer with function call
fn test_defer_simple() i64 {
    defer defer_identity(42);  // Runs at scope exit, result discarded
    return 42;
}

// Defer in early return path
fn test_defer_early_return() i64 {
    let x: i64 = -5;
    defer defer_identity(99);
    if x < 0 {
        return 42;  // Defer runs before early return
    }
    return 0;
}

// Multiple defers execute
fn test_defer_multiple() i64 {
    defer defer_identity(1);
    defer defer_identity(2);
    defer defer_identity(3);
    return 42;  // All three defers run in LIFO order
}

// Defer in block scope
fn test_defer_block() i64 {
    {
        defer defer_identity(10);  // Runs when block exits
    }
    return 42;  // After block, execution continues
}

// ============================================================================
// TIER 24: Global Variables
// ============================================================================

// Helper function to increment global counter
fn g_increment() {
    g_counter = g_counter + 1;
}

// Helper function to get current counter value
fn g_get() i64 {
    return g_counter;
}

// Helper function to reset counter
fn g_reset() {
    g_counter = 0;
}

// Basic global variable access
fn test_global_basic() i64 {
    g_counter = 42;
    return g_counter;
}

// Global variable modified from helper function
fn test_global_increment() i64 {
    g_reset();          // Start at 0
    g_increment();      // 1
    g_increment();      // 2
    g_increment();      // 3
    return g_get() + 39;  // 3 + 39 = 42
}

// Global variable arithmetic
fn test_global_arithmetic() i64 {
    g_counter = 10;
    g_counter = g_counter * 4;  // 40
    g_counter = g_counter + 2;  // 42
    return g_counter;
}

// Global variable accessed from multiple functions
fn test_global_multi_access() i64 {
    g_counter = 0;
    g_increment();  // 1
    g_increment();  // 2
    let x: i64 = g_get();  // x = 2
    g_increment();  // 3
    g_increment();  // 4
    return g_get() * 10 + x;  // 4 * 10 + 2 = 42
}

// ============================================================================
// MAIN - Test Runner
// ============================================================================

fn main() i64 {
    var failed: i64 = 0;

    // TIER 1: Basic arithmetic
    if test_return() != 42 { println("FAIL: test_return"); failed += 1; }
    if test_mul() != 42 { println("FAIL: test_mul"); failed += 1; }
    if test_div() != 42 { println("FAIL: test_div"); failed += 1; }
    if test_sub() != 42 { println("FAIL: test_sub"); failed += 1; }
    if test_neg() != 42 { println("FAIL: test_neg"); failed += 1; }

    // TIER 2: Function calls
    if test_call() != 42 { println("FAIL: test_call"); failed += 1; }
    if test_nested_call() != 42 { println("FAIL: test_nested_call"); failed += 1; }
    if test_call_spill() != 6 { println("FAIL: test_call_spill"); failed += 1; }
    if test_fn_call() != 42 { println("FAIL: test_fn_call"); failed += 1; }

    // TIER 3: Local variables
    if test_var_assign() != 42 { println("FAIL: test_var_assign"); failed += 1; }
    if test_const() != 42 { println("FAIL: test_const"); failed += 1; }

    // TIER 4: Comparisons
    if test_ne() != 42 { println("FAIL: test_ne"); failed += 1; }
    if test_lt() != 42 { println("FAIL: test_lt"); failed += 1; }
    if test_gt() != 42 { println("FAIL: test_gt"); failed += 1; }

    // TIER 5: If/else
    if test_if() != 42 { println("FAIL: test_if"); failed += 1; }
    if test_if_false() != 42 { println("FAIL: test_if_false"); failed += 1; }
    if test_nested_if() != 42 { println("FAIL: test_nested_if"); failed += 1; }

    // TIER 6: While loops
    if test_while_simple() != 42 { println("FAIL: test_while_simple"); failed += 1; }
    if test_while() != 42 { println("FAIL: test_while"); failed += 1; }
    if test_fibonacci() != 55 { println("FAIL: test_fibonacci"); failed += 1; }

    // TIER 6.5: Edge cases
    if test_neg_compare() != 42 { println("FAIL: test_neg_compare"); failed += 1; }
    if test_chain() != 42 { println("FAIL: test_chain"); failed += 1; }
    if test_countdown() != 42 { println("FAIL: test_countdown"); failed += 1; }
    if test_multi_var() != 42 { println("FAIL: test_multi_var"); failed += 1; }
    if test_early_return() != 42 { println("FAIL: test_early_return"); failed += 1; }
    if test_le() != 42 { println("FAIL: test_le"); failed += 1; }
    if test_ge() != 42 { println("FAIL: test_ge"); failed += 1; }
    if test_mod() != 42 { println("FAIL: test_mod"); failed += 1; }
    if test_recursion() != 42 { println("FAIL: test_recursion"); failed += 1; }
    if test_bool() != 42 { println("FAIL: test_bool"); failed += 1; }
    if test_8args() != 42 { println("FAIL: test_8args"); failed += 1; }
    if test_9args() != 42 { println("FAIL: test_9args"); failed += 1; }
    if test_nested_while() != 42 { println("FAIL: test_nested_while"); failed += 1; }
    if test_break() != 42 { println("FAIL: test_break"); failed += 1; }
    if test_continue() != 42 { println("FAIL: test_continue"); failed += 1; }
    if test_precedence() != 42 { println("FAIL: test_precedence"); failed += 1; }
    if test_parens() != 42 { println("FAIL: test_parens"); failed += 1; }
    if test_void() != 42 { println("FAIL: test_void"); failed += 1; }
    if test_large() != 42 { println("FAIL: test_large"); failed += 1; }

    // TIER 7: Structs
    if test_struct_simple() != 42 { println("FAIL: test_struct_simple"); failed += 1; }
    if test_struct_reassign() != 42 { println("FAIL: test_struct_reassign"); failed += 1; }
    if test_nested_struct() != 42 { println("FAIL: test_nested_struct"); failed += 1; }
    if test_large_struct() != 42 { println("FAIL: test_large_struct"); failed += 1; }

    // TIER 8: Characters
    if test_char_simple() != 42 { println("FAIL: test_char_simple"); failed += 1; }
    if test_char_escape() != 42 { println("FAIL: test_char_escape"); failed += 1; }
    if test_char_compare() != 42 { println("FAIL: test_char_compare"); failed += 1; }

    // TIER 8: Strings
    if test_string_simple() != 42 { println("FAIL: test_string_simple"); failed += 1; }
    if test_len_string() != 42 { println("FAIL: test_len_string"); failed += 1; }
    if test_len_escape() != 42 { println("FAIL: test_len_escape"); failed += 1; }
    if test_len_string_var() != 42 { println("FAIL: test_len_string_var"); failed += 1; }

    // TIER 9: Arrays
    if test_array_index() != 42 { println("FAIL: test_array_index"); failed += 1; }
    if test_array_assign() != 42 { println("FAIL: test_array_assign"); failed += 1; }
    if test_array_var_index() != 42 { println("FAIL: test_array_var_index"); failed += 1; }
    if test_array_param() != 42 { println("FAIL: test_array_param"); failed += 1; }

    // TIER 10: Pointers
    if test_ptr_read() != 42 { println("FAIL: test_ptr_read"); failed += 1; }
    if test_ptr_write() != 42 { println("FAIL: test_ptr_write"); failed += 1; }
    if test_ptr_modify() != 50 { println("FAIL: test_ptr_modify"); failed += 1; }
    if test_ptr_param() != 42 { println("FAIL: test_ptr_param"); failed += 1; }
    if test_ptr_expr() != 42 { println("FAIL: test_ptr_expr"); failed += 1; }
    if test_ptr_field_store() != 42 { println("FAIL: test_ptr_field_store"); failed += 1; }
    if test_fn_type() != 42 { println("FAIL: test_fn_type"); failed += 1; }

    // TIER 11: Bitwise operators
    if test_bitwise_and() != 10 { println("FAIL: test_bitwise_and"); failed += 1; }
    if test_bitwise_or() != 15 { println("FAIL: test_bitwise_or"); failed += 1; }
    if test_bitwise_xor() != 5 { println("FAIL: test_bitwise_xor"); failed += 1; }
    if test_shl() != 32 { println("FAIL: test_shl"); failed += 1; }
    if test_shr() != 4 { println("FAIL: test_shr"); failed += 1; }
    if test_bitwise_combo() != 12 { println("FAIL: test_bitwise_combo"); failed += 1; }
    if test_shift_var() != 64 { println("FAIL: test_shift_var"); failed += 1; }
    if test_mask_extract() != 15 { println("FAIL: test_mask_extract"); failed += 1; }

    // TIER 12: Logical operators (short-circuit)
    if test_logical_and_true() != 42 { println("FAIL: test_logical_and_true"); failed += 1; }
    if test_logical_and_false_first() != 42 { println("FAIL: test_logical_and_false_first"); failed += 1; }
    if test_logical_and_false_second() != 42 { println("FAIL: test_logical_and_false_second"); failed += 1; }
    if test_logical_or_false() != 42 { println("FAIL: test_logical_or_false"); failed += 1; }
    if test_logical_or_true_first() != 42 { println("FAIL: test_logical_or_true_first"); failed += 1; }
    if test_logical_or_true_second() != 42 { println("FAIL: test_logical_or_true_second"); failed += 1; }
    if test_logical_and_chain() != 42 { println("FAIL: test_logical_and_chain"); failed += 1; }
    if test_logical_or_chain() != 42 { println("FAIL: test_logical_or_chain"); failed += 1; }

    // TIER 13: Enums
    if test_enum_first() != 42 { println("FAIL: test_enum_first"); failed += 1; }
    if test_enum_second() != 42 { println("FAIL: test_enum_second"); failed += 1; }
    if test_enum_third() != 42 { println("FAIL: test_enum_third"); failed += 1; }
    if test_enum_ne() != 42 { println("FAIL: test_enum_ne"); failed += 1; }
    if test_enum_param() != 42 { println("FAIL: test_enum_param"); failed += 1; }

    // TIER 14: Null and Pointers
    if test_null_eq() != 42 { println("FAIL: test_null_eq"); failed += 1; }
    if test_null_ne() != 42 { println("FAIL: test_null_ne"); failed += 1; }
    if test_null_eq_right() != 42 { println("FAIL: test_null_eq_right"); failed += 1; }
    if test_ptr_not_null() != 42 { println("FAIL: test_ptr_not_null"); failed += 1; }

    // TIER 15: Slices
    if test_slice_create() != 42 { println("FAIL: test_slice_create"); failed += 1; }
    if test_slice_start() != 42 { println("FAIL: test_slice_start"); failed += 1; }
    if test_slice_index_first() != 10 { println("FAIL: test_slice_index_first"); failed += 1; }
    if test_slice_index_middle() != 30 { println("FAIL: test_slice_index_middle"); failed += 1; }
    if test_slice_index_offset() != 30 { println("FAIL: test_slice_index_offset"); failed += 1; }
    if test_slice_len() != 3 { println("FAIL: test_slice_len"); failed += 1; }
    if test_slice_len_full() != 5 { println("FAIL: test_slice_len_full"); failed += 1; }
    if test_slice_write() != 42 { println("FAIL: test_slice_write"); failed += 1; }
    if test_slice_implicit_end() != 30 { println("FAIL: test_slice_implicit_end"); failed += 1; }
    if test_slice_full() != 5 { println("FAIL: test_slice_full"); failed += 1; }
    if test_slice_implicit_start() != 30 { println("FAIL: test_slice_implicit_start"); failed += 1; }

    // TIER 15.4: Computed Base Index Assignment
    if test_computed_base_assign() != 42 { println("FAIL: test_computed_base_assign"); failed += 1; }

    // TIER 15.5: Array Copy
    if test_array_copy() != 10 { println("FAIL: test_array_copy"); failed += 1; }
    if test_array_copy_values() != 60 { println("FAIL: test_array_copy_values"); failed += 1; }

    // TIER 15.6: String Variable Assignment
    if test_string_var_copy() != 5 { println("FAIL: test_string_var_copy"); failed += 1; }
    if test_string_var_copy2() != 8 { println("FAIL: test_string_var_copy2"); failed += 1; }

    // TIER 15.7: String Indexing and Slicing
    if test_string_index_first() != 42 { println("FAIL: test_string_index_first"); failed += 1; }
    if test_string_index_middle() != 42 { println("FAIL: test_string_index_middle"); failed += 1; }
    if test_string_slice() != 3 { println("FAIL: test_string_slice"); failed += 1; }
    if test_string_slice_content() != 42 { println("FAIL: test_string_slice_content"); failed += 1; }

    // TIER 15.8: String Concatenation
    if test_str_concat_basic() != 42 { println("FAIL: test_str_concat_basic"); failed += 1; }
    if test_str_concat_empty() != 42 { println("FAIL: test_str_concat_empty"); failed += 1; }
    if test_str_concat_multi() != 42 { println("FAIL: test_str_concat_multi"); failed += 1; }

    // TIER 15.9: @string Builtin
    if test_string_builtin_len() != 42 { println("FAIL: test_string_builtin_len"); failed += 1; }
    if test_string_builtin_content() != 42 { println("FAIL: test_string_builtin_content"); failed += 1; }
    if test_string_builtin_empty() != 42 { println("FAIL: test_string_builtin_empty"); failed += 1; }

    // TIER 16: For-In Loops
    if test_for_array() != 15 { println("FAIL: test_for_array"); failed += 1; }
    if test_for_break() != 30 { println("FAIL: test_for_break"); failed += 1; }
    if test_for_continue() != 12 { println("FAIL: test_for_continue"); failed += 1; }
    if test_for_slice() != 90 { println("FAIL: test_for_slice"); failed += 1; }

    // TIER 17: Switch Statement
    if test_switch_int() != 42 { println("FAIL: test_switch_int"); failed += 1; }
    if test_switch_default() != 42 { println("FAIL: test_switch_default"); failed += 1; }
    if test_switch_multi() != 42 { println("FAIL: test_switch_multi"); failed += 1; }
    if test_switch_first() != 42 { println("FAIL: test_switch_first"); failed += 1; }

    // TIER 18: Indirect Function Calls
    if test_fn_ptr_call() != 42 { println("FAIL: test_fn_ptr_call"); failed += 1; }
    if test_fn_ptr_reassign() != 42 { println("FAIL: test_fn_ptr_reassign"); failed += 1; }
    if test_fn_ptr_no_args() != 42 { println("FAIL: test_fn_ptr_no_args"); failed += 1; }

    // TIER 19: Pointer Arithmetic
    if test_ptr_add() != 42 { println("FAIL: test_ptr_add"); failed += 1; }
    if test_ptr_sub() != 42 { println("FAIL: test_ptr_sub"); failed += 1; }

    // TIER 20: Bitwise NOT
    if test_bitwise_not_zero() != 42 { println("FAIL: test_bitwise_not_zero"); failed += 1; }
    if test_bitwise_not_neg() != 42 { println("FAIL: test_bitwise_not_neg"); failed += 1; }
    if test_bitwise_not_double() != 42 { println("FAIL: test_bitwise_not_double"); failed += 1; }

    // TIER 21: Compound Assignments
    if test_add_assign() != 42 { println("FAIL: test_add_assign"); failed += 1; }
    if test_sub_assign() != 42 { println("FAIL: test_sub_assign"); failed += 1; }
    if test_mul_assign() != 42 { println("FAIL: test_mul_assign"); failed += 1; }
    if test_div_assign() != 42 { println("FAIL: test_div_assign"); failed += 1; }
    if test_bitwise_and_assign() != 42 { println("FAIL: test_bitwise_and_assign"); failed += 1; }
    if test_bitwise_or_assign() != 42 { println("FAIL: test_bitwise_or_assign"); failed += 1; }

    // TIER 22: @intCast
    if test_intcast_widen() != 42 { println("FAIL: test_intcast_widen"); failed += 1; }
    if test_intcast_truncate() != 42 { println("FAIL: test_intcast_truncate"); failed += 1; }
    if test_intcast_roundtrip() != 42 { println("FAIL: test_intcast_roundtrip"); failed += 1; }

    // TIER 23: Defer Statement
    if test_defer_simple() != 42 { println("FAIL: test_defer_simple"); failed += 1; }
    if test_defer_early_return() != 42 { println("FAIL: test_defer_early_return"); failed += 1; }
    if test_defer_multiple() != 42 { println("FAIL: test_defer_multiple"); failed += 1; }
    if test_defer_block() != 42 { println("FAIL: test_defer_block"); failed += 1; }

    // TIER 24: Global Variables
    if test_global_basic() != 42 { println("FAIL: test_global_basic"); failed += 1; }
    if test_global_increment() != 42 { println("FAIL: test_global_increment"); failed += 1; }
    if test_global_arithmetic() != 42 { println("FAIL: test_global_arithmetic"); failed += 1; }
    if test_global_multi_access() != 42 { println("FAIL: test_global_multi_access"); failed += 1; }

    // Summary
    if failed == 0 {
        println("All 145 tests passed!");
    }

    return failed;
}

// ============================================================================
// COT END-TO-END TEST SUITE
// ============================================================================
//
// Progress: 49 / 113 tests passing (targeting 49 with len() builtin)
//
// ============================================================================
// STATUS TRACKER
// ============================================================================
//
// PASSING:
//   [x] test_return       - return literal
//   [x] test_mul          - multiplication
//   [x] test_div          - division
//   [x] test_sub          - subtraction
//   [x] test_neg          - unary negation
//   [x] test_call         - simple function call
//   [x] test_nested_call  - nested function calls
//   [x] test_call_spill   - call result preserved across subsequent calls
//   [x] test_fn_call      - call helper function
//   [x] test_var_assign   - local variable assignment
//   [x] test_const        - const declaration
//   [x] test_if           - if with true condition
//   [x] test_if_false     - if with false condition (else branch)
//   [x] test_nested_if    - nested if statements
//   [x] test_while_simple - while with false condition (skip loop)
//   [x] test_while        - while loop with variable mutation
//   [x] test_ne           - not equal comparison
//   [x] test_lt           - less than comparison
//   [x] test_gt           - greater than comparison
//   [x] test_fibonacci    - fibonacci (comprehensive phi test)
//   [x] test_neg_compare   - comparison with negative numbers
//   [x] test_chain         - chained arithmetic
//   [x] test_countdown     - countdown while loop
//   [x] test_multi_var     - multiple variables
//   [x] test_early_return  - early return in if
//   [x] test_le            - less or equal comparison
//   [x] test_ge            - greater or equal comparison
//   [x] test_mod           - modulo operator
//   [x] test_recursion     - recursive function call
//   [x] test_bool          - boolean type
//   [x] test_8args         - 8 arguments (register passing)
//   [x] test_9args         - 9 arguments (stack passing)
//   [x] test_nested_while  - nested while loops
//   [x] test_break         - break statement
//   [x] test_continue      - continue statement
//   [x] test_precedence    - operator precedence
//   [x] test_parens        - parentheses in expressions
//   [x] test_void          - void function calls
//   [x] test_large         - large numbers
//   [x] test_struct_simple  - simple struct field access
//   [x] test_struct_reassign - struct field reassignment
//   [x] test_nested_struct  - nested struct field access
//   [x] test_large_struct   - large struct (64 bytes)
//   [x] test_char_simple    - character literal
//   [x] test_char_escape    - character escape sequences
//   [x] test_char_compare   - character comparison
//   [x] test_string_simple  - string literal (address loading)
//   [x] test_len_string     - len() builtin with string literals
//   [x] test_len_escape     - len() with escape sequences
//
// BLOCKED - Need more struct features (16):
//   [ ] test_struct_init, test_struct_param, test_struct_return, ...
//
// BLOCKED - Need advanced features (41):
//   [ ] enums, unions, arrays, slices, strings, pointers, for loops, ...
//
// ============================================================================
// IMPLEMENTATION ORDER
// ============================================================================
//
// 1. Function calls   -> DONE!
// 2. Local variables  -> DONE!
// 3. Comparisons      -> DONE! (==, !=, <, <=, >, >=)
// 4. If/else          -> DONE!
// 5. Simple while     -> DONE! (loops without variable mutation)
// 6. While with vars  -> DONE! (phi nodes implemented!)
// 7. Structs          -> DONE! (basic field access, nested, large structs)
// 8. Continue until 113/113
//
// ============================================================================

// ============================================================================
// TIER 1: Basic Return + Arithmetic
// ============================================================================

fn test_return() i64 {
    return 42;
}

fn test_mul() i64 {
    return 6 * 7;
}

fn test_div() i64 {
    return 84 / 2;
}

fn test_sub() i64 {
    return 50 - 8;
}

fn test_neg() i64 {
    let x: i64 = -5;
    return x + 47;
}

// ============================================================================
// TIER 2: Function Calls
// ============================================================================

fn add_one(x: i64) i64 {
    return x + 1;
}

fn test_call() i64 {
    return add_one(41);
}

fn add(a: i64, b: i64) i64 {
    return a + b;
}

fn mul(a: i64, b: i64) i64 {
    return a * b;
}

fn test_nested_call() i64 {
    return add(mul(2, 3), mul(6, 6));
}

// Test that first call result is preserved across subsequent calls
// This was a bug: regalloc assigned register to original value instead of load_reg
fn test_call_spill() i64 {
    var x: i64 = mul(2, 3);
    var y: i64 = mul(6, 6);
    return x;
}

fn helper() i64 {
    return 42;
}

fn test_fn_call() i64 {
    return helper();
}

// ============================================================================
// TIER 3: Local Variables
// ============================================================================

fn test_var_assign() i64 {
    let x: i64 = 42;
    let y: i64 = x;
    return y;
}

fn test_const() i64 {
    const x: i64 = 42;
    return x;
}

// ============================================================================
// TIER 4: Comparisons
// ============================================================================

fn test_ne() i64 {
    if 1 != 2 {
        return 42;
    }
    return 0;
}

fn test_lt() i64 {
    if 10 < 20 {
        return 42;
    }
    return 0;
}

fn test_gt() i64 {
    if 20 > 10 {
        return 42;
    }
    return 0;
}

// ============================================================================
// TIER 5: If/Else
// ============================================================================

fn test_if() i64 {
    if 1 == 1 {
        return 42;
    } else {
        return 0;
    }
}

fn test_if_false() i64 {
    if 1 == 2 {
        return 0;
    } else {
        return 42;
    }
}

fn test_nested_if() i64 {
    if 1 == 1 {
        if 2 == 2 {
            return 42;
        }
    }
    return 0;
}

// ============================================================================
// TIER 6: While Loops
// ============================================================================

fn test_while_simple() i64 {
    while 1 == 2 {
        return 1;
    }
    return 42;
}

fn test_while() i64 {
    var x: i64 = 0;
    while x < 42 {
        x = x + 1;
    }
    return x;
}

fn test_fibonacci() i64 {
    var a: i64 = 0;
    var b: i64 = 1;
    var i: i64 = 0;
    while i < 10 {
        let temp: i64 = a + b;
        a = b;
        b = temp;
        i = i + 1;
    }
    return a;
}

// ============================================================================
// TIER 6.5: Edge Cases
// ============================================================================

// Test comparison with negative numbers
fn test_neg_compare() i64 {
    let x: i64 = -5;
    if x < 0 {
        return 42;
    }
    return 0;
}

// Test chained arithmetic
fn test_chain() i64 {
    return 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 6;
}

// Test countdown while loop
fn test_countdown() i64 {
    var x: i64 = 10;
    while x > 0 {
        x = x - 1;
    }
    return 42 + x;
}

// Test multiple variables
fn test_multi_var() i64 {
    let a: i64 = 10;
    let b: i64 = 20;
    let c: i64 = 12;
    return a + b + c;
}

// Test early return in if
fn test_early_return() i64 {
    if 1 == 1 {
        return 42;
    }
    return 0;
}

// Test le comparison
fn test_le() i64 {
    if 5 <= 5 {
        return 42;
    }
    return 0;
}

// Test ge comparison
fn test_ge() i64 {
    if 5 >= 5 {
        return 42;
    }
    return 0;
}

// Test modulo operator
fn test_mod() i64 {
    return 17 % 5 + 40;
}

// Test recursive factorial
fn factorial(n: i64) i64 {
    if n <= 1 {
        return 1;
    }
    return n * factorial(n - 1);
}

fn test_recursion() i64 {
    if factorial(5) == 120 {
        return 42;
    }
    return 0;
}

// Test boolean type
fn test_bool() i64 {
    let b: bool = true;
    if b {
        return 42;
    }
    return 0;
}

// Test 8 arguments (max register args)
fn sum8(a: i64, b: i64, c: i64, d: i64, e: i64, f: i64, g: i64, h: i64) i64 {
    return a + b + c + d + e + f + g + h;
}

fn test_8args() i64 {
    if sum8(1, 2, 3, 4, 5, 6, 7, 8) == 36 {
        return 42;
    }
    return 0;
}

// Test 9 arguments (stack argument passing)
fn sum9(a: i64, b: i64, c: i64, d: i64, e: i64, f: i64, g: i64, h: i64, i: i64) i64 {
    return a + b + c + d + e + f + g + h + i;
}

fn test_9args() i64 {
    if sum9(1, 2, 3, 4, 5, 6, 7, 8, 9) == 45 {
        return 42;
    }
    return 0;
}

// Test nested while loops
fn test_nested_while() i64 {
    var sum: i64 = 0;
    var i: i64 = 0;
    while i < 3 {
        var j: i64 = 0;
        while j < 3 {
            sum = sum + 1;
            j = j + 1;
        }
        i = i + 1;
    }
    if sum == 9 {
        return 42;
    }
    return 0;
}

// Test break statement
fn test_break() i64 {
    var i: i64 = 0;
    while i < 100 {
        if i == 10 {
            break;
        }
        i = i + 1;
    }
    if i == 10 {
        return 42;
    }
    return 0;
}

// Test continue statement
fn test_continue() i64 {
    var sum: i64 = 0;
    var i: i64 = 0;
    while i < 10 {
        i = i + 1;
        if i % 2 == 1 {
            continue;
        }
        sum = sum + 1;
    }
    if sum == 5 {
        return 42;
    }
    return 0;
}

// Test operator precedence
fn test_precedence() i64 {
    // 2 + (3*4) + (2*3*4) + 4 = 2 + 12 + 24 + 4 = 42
    return 2 + 3 * 4 + 2 * 3 * 4 + 4;
}

// Test parentheses
fn test_parens() i64 {
    // (1+2) * (3+4) * 2 = 3 * 7 * 2 = 42
    return (1 + 2) * (3 + 4) * 2;
}

// Test void function
fn void_helper() void {
    return;
}

fn test_void() i64 {
    void_helper();
    return 42;
}

// Test large numbers
fn test_large() i64 {
    let big: i64 = 1000000000;
    if big / 1000000000 == 1 {
        return 42;
    }
    return 0;
}

// ============================================================================
// TIER 7: Structs
// ============================================================================

struct Point {
    x: i64,
    y: i64,
}

struct Inner {
    a: i64,
    b: i64,
}

struct Outer {
    inner: Inner,
    c: i64,
}

// Test simple struct field access
fn test_struct_simple() i64 {
    var p: Point;
    p.x = 20;
    p.y = 22;
    return p.x + p.y;
}

// Test struct field reassignment
fn test_struct_reassign() i64 {
    var p: Point;
    p.x = 10;
    p.y = 10;
    p.x = p.x + 12;
    p.y = p.y + 10;
    return p.x + p.y;
}

// Test nested struct field access
fn test_nested_struct() i64 {
    var o: Outer;
    o.inner.a = 10;
    o.inner.b = 20;
    o.c = 12;
    return o.inner.a + o.inner.b + o.c;
}

struct LargeStruct {
    a: i64,
    b: i64,
    c: i64,
    d: i64,
    e: i64,
    f: i64,
    g: i64,
    h: i64,
}

// Test large struct (64 bytes = 8 fields * 8 bytes)
// This exercises stack frame layout for structs > 16 bytes
fn test_large_struct() i64 {
    var s: LargeStruct;
    s.a = 1;
    s.b = 2;
    s.c = 3;
    s.d = 4;
    s.e = 5;
    s.f = 6;
    s.g = 7;
    s.h = 14;
    return s.a + s.b + s.c + s.d + s.e + s.f + s.g + s.h;
}

// ============================================================================
// TIER 8: Characters and Strings
// ============================================================================

// Test simple character literal
fn test_char_simple() i64 {
    let c: u8 = 'A';
    if c == 65 {
        return 42;
    }
    return 0;
}

// Test character escape sequences
fn test_char_escape() i64 {
    let newline: u8 = '\n';
    let tab: u8 = '\t';
    let backslash: u8 = '\\';
    if newline == 10 {
        if tab == 9 {
            if backslash == 92 {
                return 42;
            }
        }
    }
    return 0;
}

// Test character comparison
fn test_char_compare() i64 {
    let a: u8 = 'a';
    let b: u8 = 'b';
    if a < b {
        return 42;
    }
    return 0;
}

// Test simple string literal - just verify codegen works
fn test_string_simple() i64 {
    let s: string = "hello";
    // For now, just test that the code compiles and runs
    // We're not yet using the string value
    return 42;
}

// Test len() builtin with string literal
fn test_len_string() i64 {
    if len("hello") == 5 {
        if len("") == 0 {
            if len("a") == 1 {
                return 42;
            }
        }
    }
    return 0;
}

// Test len() with escape sequences (escapes count as 1 byte each)
fn test_len_escape() i64 {
    if len("\n") == 1 {
        if len("a\nb") == 3 {
            if len("\\") == 1 {
                return 42;
            }
        }
    }
    return 0;
}

// ============================================================================
// TIER 8+: BLOCKED - Advanced Features
// Need: enums, unions, arrays, slices, strings, pointers, etc.
// ============================================================================

// (many more tests to add as we implement features)

// ============================================================================
// MAIN - Test Runner
// ============================================================================

fn main() i64 {
    var passed: i64 = 0;

    // TIER 1: Basic arithmetic
    if test_return() == 42 { passed = passed + 1; }
    if test_mul() == 42 { passed = passed + 1; }
    if test_div() == 42 { passed = passed + 1; }
    if test_sub() == 42 { passed = passed + 1; }
    if test_neg() == 42 { passed = passed + 1; }

    // TIER 2: Function calls
    if test_call() == 42 { passed = passed + 1; }
    if test_nested_call() == 42 { passed = passed + 1; }
    if test_call_spill() == 6 { passed = passed + 1; }
    if test_fn_call() == 42 { passed = passed + 1; }

    // TIER 3: Local variables
    if test_var_assign() == 42 { passed = passed + 1; }
    if test_const() == 42 { passed = passed + 1; }

    // TIER 4: Comparisons
    if test_ne() == 42 { passed = passed + 1; }
    if test_lt() == 42 { passed = passed + 1; }
    if test_gt() == 42 { passed = passed + 1; }

    // TIER 5: If/else
    if test_if() == 42 { passed = passed + 1; }
    if test_if_false() == 42 { passed = passed + 1; }
    if test_nested_if() == 42 { passed = passed + 1; }

    // TIER 6: While loops
    if test_while_simple() == 42 { passed = passed + 1; }
    if test_while() == 42 { passed = passed + 1; }
    if test_fibonacci() == 55 { passed = passed + 1; }

    // TIER 6.5: Edge cases
    if test_neg_compare() == 42 { passed = passed + 1; }
    if test_chain() == 42 { passed = passed + 1; }
    if test_countdown() == 42 { passed = passed + 1; }
    if test_multi_var() == 42 { passed = passed + 1; }
    if test_early_return() == 42 { passed = passed + 1; }
    if test_le() == 42 { passed = passed + 1; }
    if test_ge() == 42 { passed = passed + 1; }
    if test_mod() == 42 { passed = passed + 1; }
    if test_recursion() == 42 { passed = passed + 1; }
    if test_bool() == 42 { passed = passed + 1; }
    if test_8args() == 42 { passed = passed + 1; }
    if test_9args() == 42 { passed = passed + 1; }
    if test_nested_while() == 42 { passed = passed + 1; }
    if test_break() == 42 { passed = passed + 1; }
    if test_continue() == 42 { passed = passed + 1; }
    if test_precedence() == 42 { passed = passed + 1; }
    if test_parens() == 42 { passed = passed + 1; }
    if test_void() == 42 { passed = passed + 1; }
    if test_large() == 42 { passed = passed + 1; }

    // TIER 7: Structs
    if test_struct_simple() == 42 { passed = passed + 1; }
    if test_struct_reassign() == 42 { passed = passed + 1; }
    if test_nested_struct() == 42 { passed = passed + 1; }
    if test_large_struct() == 42 { passed = passed + 1; }

    // TIER 8: Characters
    if test_char_simple() == 42 { passed = passed + 1; }
    if test_char_escape() == 42 { passed = passed + 1; }
    if test_char_compare() == 42 { passed = passed + 1; }

    // TIER 8: Strings
    if test_string_simple() == 42 { passed = passed + 1; }
    if test_len_string() == 42 { passed = passed + 1; }
    if test_len_escape() == 42 { passed = passed + 1; }

    return passed;
}

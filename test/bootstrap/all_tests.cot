// ============================================================================
// COT END-TO-END TEST SUITE
// ============================================================================
//
// Progress: 715 / 715 tests passing
//
// ============================================================================
// STATUS TRACKER
// ============================================================================
//
// PASSING:
//   [x] test_return       - return literal
//   [x] test_mul          - multiplication
//   [x] test_div          - division
//   [x] test_sub          - subtraction
//   [x] test_neg          - unary negation
//   [x] test_call         - simple function call
//   [x] test_nested_call  - nested function calls
//   [x] test_call_spill   - call result preserved across subsequent calls
//   [x] test_fn_call      - call helper function
//   [x] test_var_assign   - local variable assignment
//   [x] test_const        - const declaration
//   [x] test_if           - if with true condition
//   [x] test_if_false     - if with false condition (else branch)
//   [x] test_nested_if    - nested if statements
//   [x] test_while_simple - while with false condition (skip loop)
//   [x] test_while        - while loop with variable mutation
//   [x] test_ne           - not equal comparison
//   [x] test_lt           - less than comparison
//   [x] test_gt           - greater than comparison
//   [x] test_fibonacci    - fibonacci (comprehensive phi test)
//   [x] test_neg_compare   - comparison with negative numbers
//   [x] test_chain         - chained arithmetic
//   [x] test_countdown     - countdown while loop
//   [x] test_multi_var     - multiple variables
//   [x] test_early_return  - early return in if
//   [x] test_le            - less or equal comparison
//   [x] test_ge            - greater or equal comparison
//   [x] test_mod           - modulo operator
//   [x] test_recursion     - recursive function call
//   [x] test_bool          - boolean type
//   [x] test_8args         - 8 arguments (register passing)
//   [x] test_9args         - 9 arguments (stack passing)
//   [x] test_nested_while  - nested while loops
//   [x] test_break         - break statement
//   [x] test_continue      - continue statement
//   [x] test_precedence    - operator precedence
//   [x] test_parens        - parentheses in expressions
//   [x] test_void          - void function calls
//   [x] test_large         - large numbers
//   [x] test_struct_simple  - simple struct field access
//   [x] test_struct_reassign - struct field reassignment
//   [x] test_nested_struct  - nested struct field access
//   [x] test_large_struct   - large struct (64 bytes)
//   [x] test_char_simple    - character literal
//   [x] test_char_escape    - character escape sequences
//   [x] test_char_compare   - character comparison
//   [x] test_string_simple  - string literal (address loading)
//   [x] test_len_string     - len() builtin with string literals
//   [x] test_len_escape     - len() with escape sequences
//   [x] test_len_string_var - len() with string variables (runtime)
//   [x] test_array_index    - array indexing with constants
//   [x] test_array_assign   - array element assignment
//   [x] test_array_var_index - array indexing with variables
//   [x] test_array_param    - array as function parameter
//   [x] test_ptr_read       - pointer read (dereference)
//   [x] test_ptr_write      - pointer write (dereference assignment)
//   [x] test_ptr_modify     - pointer modifying original variable
//   [x] test_ptr_param      - pointer as function parameter
//   [x] test_ptr_expr       - multiple dereferences in expression
//   [x] test_bitwise_and    - bitwise AND operator
//   [x] test_bitwise_or     - bitwise OR operator
//   [x] test_bitwise_xor    - bitwise XOR operator
//   [x] test_shl            - left shift operator
//   [x] test_shr            - right shift operator
//   [x] test_bitwise_combo  - combined bitwise operations
//   [x] test_shift_var      - shift with variable amount
//   [x] test_mask_extract   - bit masking pattern
//   [x] test_logical_and_true - logical AND both true
//   [x] test_logical_and_false_first - logical AND short-circuit
//   [x] test_logical_and_false_second - logical AND second false
//   [x] test_logical_or_false - logical OR both false
//   [x] test_logical_or_true_first - logical OR short-circuit
//   [x] test_logical_or_true_second - logical OR second true
//   [x] test_logical_and_chain - chained AND
//   [x] test_logical_or_chain - chained OR (one true)
//   [x] test_logical_or_chain_all_false - chained OR 3 conditions all false (BUG-015)
//   [x] test_logical_or_chain_4_false - chained OR 4 conditions all false
//   [x] test_enum_first - enum first variant
//   [x] test_enum_second - enum second variant
//   [x] test_enum_third - enum third variant
//   [x] test_enum_ne - enum not equal comparison
//   [x] test_enum_param - enum as function parameter
//   [x] test_defer_simple - defer with function call
//   [x] test_defer_early_return - defer in early return path
//   [x] test_defer_multiple - multiple defers (LIFO)
//   [x] test_defer_block - defer in block scope
//
// BLOCKED - Need more struct features (16):
//   [ ] test_struct_init, test_struct_param, test_struct_return, ...
//
// BLOCKED - Need advanced features (32):
//   [ ] enums, unions, slices, for loops, ...
//
// ============================================================================
// IMPLEMENTATION ORDER
// ============================================================================
//
// 1. Function calls   -> DONE!
// 2. Local variables  -> DONE!
// 3. Comparisons      -> DONE! (==, !=, <, <=, >, >=)
// 4. If/else          -> DONE!
// 5. Simple while     -> DONE! (loops without variable mutation)
// 6. While with vars  -> DONE! (phi nodes implemented!)
// 7. Structs          -> DONE! (basic field access, nested, large structs)
// 8. Continue until 113/113
//
// ============================================================================

// ============================================================================
// GLOBAL VARIABLES (for TIER 24 tests)
// ============================================================================

var g_counter: i64 = 0

// ============================================================================
// TIER 1: Basic Return + Arithmetic
// ============================================================================

fn test_return() i64 {
    return 42
}

fn test_mul() i64 {
    return 6 * 7
}

fn test_div() i64 {
    return 84 / 2
}

fn test_sub() i64 {
    return 50 - 8
}

fn test_neg() i64 {
    let x: i64 = -5
    return x + 47
}

// ============================================================================
// TIER 2: Function Calls
// ============================================================================

fn add_one(x: i64) i64 {
    return x + 1
}

fn test_call() i64 {
    return add_one(41)
}

fn add(a: i64, b: i64) i64 {
    return a + b
}

fn mul(a: i64, b: i64) i64 {
    return a * b
}

fn test_nested_call() i64 {
    return add(mul(2, 3), mul(6, 6))
}

// Test that first call result is preserved across subsequent calls
// This was a bug: regalloc assigned register to original value instead of load_reg
fn test_call_spill() i64 {
    var x: i64 = mul(2, 3)
    var y: i64 = mul(6, 6)
    return x
}

fn helper() i64 {
    return 42
}

fn test_fn_call() i64 {
    return helper()
}

// ============================================================================
// TIER 3: Local Variables
// ============================================================================

fn test_var_assign() i64 {
    let x: i64 = 42
    let y: i64 = x
    return y
}

fn test_const() i64 {
    const x: i64 = 42
    return x
}

// ============================================================================
// TIER 4: Comparisons
// ============================================================================

fn test_ne() i64 {
    if 1 != 2 {
        return 42
    }
    return 0
}

fn test_lt() i64 {
    if 10 < 20 {
        return 42
    }
    return 0
}

fn test_gt() i64 {
    if 20 > 10 {
        return 42
    }
    return 0
}

// ============================================================================
// TIER 5: If/Else
// ============================================================================

fn test_if() i64 {
    if 1 == 1 {
        return 42
    } else {
        return 0
    }
}

fn test_if_false() i64 {
    if 1 == 2 {
        return 0
    } else {
        return 42
    }
}

fn test_nested_if() i64 {
    if 1 == 1 {
        if 2 == 2 {
            return 42
        }
    }
    return 0
}

// ============================================================================
// TIER 6: While Loops
// ============================================================================

fn test_while_simple() i64 {
    while 1 == 2 {
        return 1
    }
    return 42
}

fn test_while() i64 {
    var x: i64 = 0
    while x < 42 {
        x = x + 1
    }
    return x
}

fn test_fibonacci() i64 {
    var a: i64 = 0
    var b: i64 = 1
    var i: i64 = 0
    while i < 10 {
        let temp: i64 = a + b
        a = b
        b = temp
        i = i + 1
    }
    return a
}

// ============================================================================
// TIER 6.5: Edge Cases
// ============================================================================

// Test comparison with negative numbers
fn test_neg_compare() i64 {
    let x: i64 = -5
    if x < 0 {
        return 42
    }
    return 0
}

// Test chained arithmetic
fn test_chain() i64 {
    return 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 6
}

// Test countdown while loop
fn test_countdown() i64 {
    var x: i64 = 10
    while x > 0 {
        x = x - 1
    }
    return 42 + x
}

// Test multiple variables
fn test_multi_var() i64 {
    let a: i64 = 10
    let b: i64 = 20
    let c: i64 = 12
    return a + b + c
}

// Test early return in if
fn test_early_return() i64 {
    if 1 == 1 {
        return 42
    }
    return 0
}

// Test le comparison
fn test_le() i64 {
    if 5 <= 5 {
        return 42
    }
    return 0
}

// Test ge comparison
fn test_ge() i64 {
    if 5 >= 5 {
        return 42
    }
    return 0
}

// Test modulo operator
fn test_mod() i64 {
    return 17 % 5 + 40
}

// Test recursive factorial
fn factorial(n: i64) i64 {
    if n <= 1 {
        return 1
    }
    return n * factorial(n - 1)
}

fn test_recursion() i64 {
    if factorial(5) == 120 {
        return 42
    }
    return 0
}

// Test boolean type
fn test_bool() i64 {
    let b: bool = true
    if b {
        return 42
    }
    return 0
}

// Test 8 arguments (max register args)
fn sum8(a: i64, b: i64, c: i64, d: i64, e: i64, f: i64, g: i64, h: i64) i64 {
    return a + b + c + d + e + f + g + h
}

fn test_8args() i64 {
    if sum8(1, 2, 3, 4, 5, 6, 7, 8) == 36 {
        return 42
    }
    return 0
}

// Test 9 arguments (stack argument passing)
fn sum9(a: i64, b: i64, c: i64, d: i64, e: i64, f: i64, g: i64, h: i64, i: i64) i64 {
    return a + b + c + d + e + f + g + h + i
}

fn test_9args() i64 {
    if sum9(1, 2, 3, 4, 5, 6, 7, 8, 9) == 45 {
        return 42
    }
    return 0
}

// Test nested while loops
fn test_nested_while() i64 {
    var sum: i64 = 0
    var i: i64 = 0
    while i < 3 {
        var j: i64 = 0
        while j < 3 {
            sum = sum + 1
            j = j + 1
        }
        i = i + 1
    }
    if sum == 9 {
        return 42
    }
    return 0
}

// Test break statement
fn test_break() i64 {
    var i: i64 = 0
    while i < 100 {
        if i == 10 {
            break
        }
        i = i + 1
    }
    if i == 10 {
        return 42
    }
    return 0
}

// Test continue statement
fn test_continue() i64 {
    var sum: i64 = 0
    var i: i64 = 0
    while i < 10 {
        i = i + 1
        if i % 2 == 1 {
            continue
        }
        sum = sum + 1
    }
    if sum == 5 {
        return 42
    }
    return 0
}

// Test operator precedence
fn test_precedence() i64 {
    // 2 + (3*4) + (2*3*4) + 4 = 2 + 12 + 24 + 4 = 42
    return 2 + 3 * 4 + 2 * 3 * 4 + 4
}

// Test parentheses
fn test_parens() i64 {
    // (1+2) * (3+4) * 2 = 3 * 7 * 2 = 42
    return (1 + 2) * (3 + 4) * 2
}

// Test void function
fn void_helper() void {
    return
}

fn test_void() i64 {
    void_helper()
    return 42
}

// Test large numbers
fn test_large() i64 {
    let big: i64 = 1000000000
    if big / 1000000000 == 1 {
        return 42
    }
    return 0
}

// ============================================================================
// TIER 7: Structs
// ============================================================================

struct Point {
    x: i64,
    y: i64,
}

struct Inner {
    a: i64,
    b: i64,
}

struct Outer {
    inner: Inner,
    c: i64,
}

// Test simple struct field access
fn test_struct_simple() i64 {
    var p: Point
    p.x = 20
    p.y = 22
    return p.x + p.y
}

// Test struct field reassignment
fn test_struct_reassign() i64 {
    var p: Point
    p.x = 10
    p.y = 10
    p.x = p.x + 12
    p.y = p.y + 10
    return p.x + p.y
}

// Test nested struct field access
fn test_nested_struct() i64 {
    var o: Outer
    o.inner.a = 10
    o.inner.b = 20
    o.c = 12
    return o.inner.a + o.inner.b + o.c
}

struct LargeStruct {
    a: i64,
    b: i64,
    c: i64,
    d: i64,
    e: i64,
    f: i64,
    g: i64,
    h: i64,
}

// Test large struct (64 bytes = 8 fields * 8 bytes)
// This exercises stack frame layout for structs > 16 bytes
fn test_large_struct() i64 {
    var s: LargeStruct
    s.a = 1
    s.b = 2
    s.c = 3
    s.d = 4
    s.e = 5
    s.f = 6
    s.g = 7
    s.h = 14
    return s.a + s.b + s.c + s.d + s.e + s.f + s.g + s.h
}

// ============================================================================
// TIER 8: Characters and Strings
// ============================================================================

// Test simple character literal
fn test_char_simple() i64 {
    let c: u8 = 'A'
    if c == 65 {
        return 42
    }
    return 0
}

// Test character escape sequences
fn test_char_escape() i64 {
    let newline: u8 = '\n'
    let tab: u8 = '\t'
    let backslash: u8 = '\\'
    if newline == 10 {
        if tab == 9 {
            if backslash == 92 {
                return 42
            }
        }
    }
    return 0
}

// Test character comparison
fn test_char_compare() i64 {
    let a: u8 = 'a'
    let b: u8 = 'b'
    if a < b {
        return 42
    }
    return 0
}

// Test simple string literal - just verify codegen works
fn test_string_simple() i64 {
    let s: string = "hello"
    // For now, just test that the code compiles and runs
    // We're not yet using the string value
    return 42
}

// Test len() builtin with string literal
fn test_len_string() i64 {
    if len("hello") == 5 {
        if len("") == 0 {
            if len("a") == 1 {
                return 42
            }
        }
    }
    return 0
}

// Test len() with escape sequences (escapes count as 1 byte each)
fn test_len_escape() i64 {
    if len("\n") == 1 {
        if len("a\nb") == 3 {
            if len("\\") == 1 {
                return 42
            }
        }
    }
    return 0
}

// Test len() with string variables (runtime)
fn test_len_string_var() i64 {
    let s: string = "hello"
    if len(s) == 5 {
        let empty: string = ""
        if len(empty) == 0 {
            let escaped: string = "a\nb"
            if len(escaped) == 3 {
                return 42
            }
        }
    }
    return 0
}

// ============================================================================
// TIER 9: Arrays
// ============================================================================

// Test array declaration and indexing
fn test_array_index() i64 {
    var arr: [3]i64 = [10, 20, 30]
    if arr[0] == 10 {
        if arr[1] == 20 {
            if arr[2] == 30 {
                return 42
            }
        }
    }
    return 0
}

// Test array element assignment
fn test_array_assign() i64 {
    var arr: [3]i64 = [0, 0, 0]
    arr[0] = 10
    arr[1] = 20
    arr[2] = 12
    return arr[0] + arr[1] + arr[2]
}

// Test array with variable index
fn test_array_var_index() i64 {
    var arr: [5]i64 = [1, 2, 3, 4, 5]
    var sum: i64 = 0
    var i: i64 = 0
    while i < 5 {
        sum = sum + arr[i]
        i = i + 1
    }
    if sum == 15 {
        return 42
    }
    return 0
}

// Test array sum helper for array test
fn array_sum(arr: [4]i64) i64 {
    return arr[0] + arr[1] + arr[2] + arr[3]
}

// Test array as function parameter
fn test_array_param() i64 {
    var arr: [4]i64 = [10, 11, 12, 9]
    if array_sum(arr) == 42 {
        return 42
    }
    return 0
}

// ============================================================================
// TIER 10: Pointers
// ============================================================================

// Test pointer read (dereference)
fn test_ptr_read() i64 {
    var x: i64 = 42
    let ptr: *i64 = &x
    return ptr.*
}

// Test pointer write (dereference assignment)
fn test_ptr_write() i64 {
    var x: i64 = 10
    let ptr: *i64 = &x
    ptr.* = 42
    return x
}

// Test pointer modifying original variable
fn test_ptr_modify() i64 {
    var a: i64 = 10
    var b: i64 = 20
    let ptr_a: *i64 = &a
    let ptr_b: *i64 = &b
    ptr_a.* = ptr_a.* + ptr_b.*
    return a + b
}

// Test pointer as function parameter
fn add_via_ptr(ptr: *i64, val: i64) void {
    ptr.* = ptr.* + val
    return
}

fn test_ptr_param() i64 {
    var x: i64 = 10
    add_via_ptr(&x, 32)
    return x
}

// Test multiple dereferences in expression
fn test_ptr_expr() i64 {
    var a: i64 = 20
    var b: i64 = 22
    let pa: *i64 = &a
    let pb: *i64 = &b
    return pa.* + pb.*
}

// Test pointer field store: ptr.field = value
fn set_point_x(p: *Point, val: i64) void {
    p.x = val  // Store through pointer to struct field
}

fn test_ptr_field_store() i64 {
    var pt: Point
    pt.x = 0
    pt.y = 0
    set_point_x(&pt, 42)
    return pt.x  // Should be 42
}

// Test function type declaration and assignment
fn helper_add(a: i64, b: i64) i64 {
    return a + b
}

fn test_fn_type() i64 {
    // Declare a variable of function type
    var f: fn(i64, i64) -> i64
    f = helper_add  // Assign function to variable
    // Note: Indirect calls through function pointers not yet supported
    // Just verify the type checking and assignment work
    return helper_add(20, 22)  // Should be 42
}

// ============================================================================
// TIER 11: Bitwise Operators
// ============================================================================

// Test bitwise AND
fn test_bitwise_and() i64 {
    // 0b1111 & 0b1010 = 0b1010 = 10
    return 15 & 10
}

// Test bitwise OR
fn test_bitwise_or() i64 {
    // 0b0101 | 0b1010 = 0b1111 = 15
    return 5 | 10
}

// Test bitwise XOR
fn test_bitwise_xor() i64 {
    // 0b1111 ^ 0b1010 = 0b0101 = 5
    return 15 ^ 10
}

// Test left shift
fn test_shl() i64 {
    // 1 << 5 = 32
    return 1 << 5
}

// Test right shift
fn test_shr() i64 {
    // 64 >> 4 = 4
    return 64 >> 4
}

// Test combined bitwise: (10 | 5) & 12 = 15 & 12 = 12
fn test_bitwise_combo() i64 {
    let a: i64 = 10
    let b: i64 = 5
    let c: i64 = 12
    return (a | b) & c
}

// Test shift with variable: 1 << n where n = 6 -> 64
fn test_shift_var() i64 {
    let n: i64 = 6
    return 1 << n
}

// Test masking: extract bits 4-7 of 0xFF -> 15
fn test_mask_extract() i64 {
    let val: i64 = 255
    return (val >> 4) & 15
}

// ============================================================================
// TIER 12: Logical Operators (Short-Circuit)
// ============================================================================

// Test logical AND - both true
fn test_logical_and_true() i64 {
    if 1 == 1 and 2 == 2 {
        return 42
    }
    return 0
}

// Test logical AND - first false (short-circuit)
fn test_logical_and_false_first() i64 {
    if 1 == 2 and 2 == 2 {
        return 0
    }
    return 42
}

// Test logical AND - second false
fn test_logical_and_false_second() i64 {
    if 1 == 1 and 2 == 3 {
        return 0
    }
    return 42
}

// Test logical OR - both false
fn test_logical_or_false() i64 {
    if 1 == 2 or 3 == 4 {
        return 0
    }
    return 42
}

// Test logical OR - first true (short-circuit)
fn test_logical_or_true_first() i64 {
    if 1 == 1 or 2 == 3 {
        return 42
    }
    return 0
}

// Test logical OR - second true
fn test_logical_or_true_second() i64 {
    if 1 == 2 or 2 == 2 {
        return 42
    }
    return 0
}

// Test chained AND
fn test_logical_and_chain() i64 {
    if 1 == 1 and 2 == 2 and 3 == 3 {
        return 42
    }
    return 0
}

// Test chained OR (one true)
fn test_logical_or_chain() i64 {
    if 1 == 2 or 2 == 3 or 3 == 3 {
        return 42
    }
    return 0
}

// Test chained OR with 3 conditions ALL false (BUG-015 regression test)
fn test_logical_or_chain_all_false() i64 {
    let x: i64 = 100
    // All conditions are false, should NOT enter the if block
    if x == 1 or x == 2 or x == 3 {
        return 0  // Wrong!
    }
    return 42
}

// Test chained OR with 4 conditions ALL false
fn test_logical_or_chain_4_false() i64 {
    let c: i64 = 65  // 'A'
    // Simulates scanner's skip_whitespace: c == 32 or c == 9 or c == 10 or c == 13
    if c == 32 or c == 9 or c == 10 or c == 13 {
        return 0  // Wrong! 'A' is not whitespace
    }
    return 42
}

// ============================================================================
// TIER 13: Enums
// ============================================================================

enum Status {
    Pending,
    Active,
    Done,
}

// Test enum value (first variant = 0)
fn test_enum_first() i64 {
    let s: Status = Status.Pending
    if s == Status.Pending {
        return 42
    }
    return 0
}

// Test enum value (second variant = 1)
fn test_enum_second() i64 {
    let s: Status = Status.Active
    if s == Status.Active {
        return 42
    }
    return 0
}

// Test enum value (third variant = 2)
fn test_enum_third() i64 {
    let s: Status = Status.Done
    if s == Status.Done {
        return 42
    }
    return 0
}

// Test enum comparison not equal
fn test_enum_ne() i64 {
    let s: Status = Status.Active
    if s != Status.Pending {
        return 42
    }
    return 0
}

// Test enum as function parameter
fn check_status(s: Status) i64 {
    if s == Status.Done {
        return 42
    }
    return 0
}

fn test_enum_param() i64 {
    return check_status(Status.Done)
}

// ============================================================================
// TIER 14: Null and Pointers
// ============================================================================

// Test null pointer assignment and comparison (== null)
fn test_null_eq() i64 {
    let p: *i64 = null
    if p == null {
        return 42
    }
    return 0
}

// Test null pointer comparison (!= null)
fn test_null_ne() i64 {
    let p: *i64 = null
    if p != null {
        return 0
    }
    return 42
}

// Test null on right side of comparison
fn test_null_eq_right() i64 {
    let p: *i64 = null
    if null == p {
        return 42
    }
    return 0
}

// Test non-null pointer
fn test_ptr_not_null() i64 {
    var x: i64 = 42
    let p: *i64 = &x
    if p != null {
        return p.*
    }
    return 0
}

// ============================================================================
// TIER 15: Slices
// ============================================================================

// Test basic slice creation from array
fn test_slice_create() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50]
    let s: []i64 = arr[0:3]
    // For MVP: just verify the code compiles and runs
    return 42
}

// Test slice with explicit start index
fn test_slice_start() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50]
    let s: []i64 = arr[2:5]
    return 42
}

// Test slice indexing - read first element
fn test_slice_index_first() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50]
    let s: []i64 = arr[0:3]
    return s[0]  // Should return 10
}

// Test slice indexing - read middle element
fn test_slice_index_middle() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50]
    let s: []i64 = arr[1:4]
    return s[1]  // arr[2] = 30
}

// Test slice indexing with offset start
fn test_slice_index_offset() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50]
    let s: []i64 = arr[2:5]
    return s[0]  // arr[2] = 30
}

// Test len() on slice
fn test_slice_len() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50]
    let s: []i64 = arr[1:4]
    return len(s)  // Should return 3
}

// Test len() on full array slice
fn test_slice_len_full() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50]
    let s: []i64 = arr[0:5]
    return len(s)  // Should return 5
}

// Test slice shares memory with array (write through slice)
fn test_slice_write() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50]
    let s: []i64 = arr[0:3]
    s[0] = 42
    return arr[0]  // Should return 42 (shared memory)
}

// Test implicit end: arr[start:] slices to end
fn test_slice_implicit_end() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50]
    let s: []i64 = arr[2:]  // Same as arr[2:5]
    return s[0]  // Should return 30 (arr[2])
}

// Test implicit start and end: arr[:] slices full array
fn test_slice_full() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50]
    let s: []i64 = arr[:]  // Same as arr[0:5]
    return len(s)  // Should return 5
}

// Test implicit start: arr[:end]
fn test_slice_implicit_start() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50]
    let s: []i64 = arr[:3]  // Same as arr[0:3]
    return s[2]  // Should return 30 (arr[2])
}

// ============================================================================
// TIER 15.4: Computed Base Index Assignment
// ============================================================================

// Helper that returns a slice from a pointer parameter
fn get_slice_from_ptr(arr: *[3]i64) []i64 {
    return arr.*[:]
}

// Test computed base assignment: func()[i] = x
fn test_computed_base_assign() i64 {
    var backing: [3]i64 = [0, 0, 0]
    get_slice_from_ptr(&backing)[0] = 42  // Assign through computed slice
    return backing[0]  // Should be 42
}

// ============================================================================
// TIER 15.5: Array Copy Semantics
// ============================================================================

// Test array copy - modifying copy doesn't affect original
fn test_array_copy() i64 {
    var a: [3]i64 = [10, 20, 30]
    var b: [3]i64 = a  // Copy a to b
    b[0] = 99          // Modify b
    return a[0]        // a[0] should still be 10
}

// Test array copy - verify copy has correct values
fn test_array_copy_values() i64 {
    var a: [3]i64 = [10, 20, 30]
    var b: [3]i64 = a  // Copy a to b
    return b[0] + b[1] + b[2]  // Should be 60 (10+20+30)
}

// ============================================================================
// TIER 15.6: String Variable Assignment
// ============================================================================

// Test string variable copy - verify len works on copy
fn test_string_var_copy() i64 {
    let s1: string = "hello"
    let s2: string = s1  // Copy string variable
    return len(s2)       // Should return 5
}

// Test string variable copy - different string
fn test_string_var_copy2() i64 {
    let a: string = "abc"
    let b: string = a
    let c: string = "defgh"
    let d: string = c
    return len(b) + len(d)  // Should return 8 (3+5)
}

// ============================================================================
// TIER 15.7: String Indexing and Slicing
// ============================================================================

// Test string indexing - first character
fn test_string_index_first() i64 {
    let s: string = "hello"
    let c: u8 = s[0]
    if c == 104 { return 42 }  // 'h' = 104
    return 0
}

// Test string indexing - middle character
fn test_string_index_middle() i64 {
    let s: string = "hello"
    let c: u8 = s[2]
    if c == 108 { return 42 }  // 'l' = 108
    return 0
}

// Test string slicing - get substring
fn test_string_slice() i64 {
    let s: string = "hello"
    let sub: string = s[0:3]  // "hel"
    return len(sub)  // Should return 3
}

// Test string slicing - verify content
fn test_string_slice_content() i64 {
    let s: string = "hello"
    let sub: string = s[1:4]  // "ell"
    let c0: u8 = sub[0]
    let c1: u8 = sub[1]
    let c2: u8 = sub[2]
    // 'e' = 101, 'l' = 108
    if c0 == 101 {
        if c1 == 108 {
            if c2 == 108 {
                return 42  // success
            }
        }
    }
    return 0
}

// ============================================================================
// TIER 15.8: String Concatenation
// ============================================================================

// Note: String concatenation requires the runtime library (cot_runtime.c)
// which provides __cot_str_concat(ptr1, len1, ptr2, len2) -> (ptr, len)

// Test basic string concatenation
fn test_str_concat_basic() i64 {
    let a: string = "hello"
    let b: string = " world"
    let c: string = a + b
    if len(c) == 11 { return 42 }
    return 0
}

// Test empty string concatenation
fn test_str_concat_empty() i64 {
    let a: string = "foo"
    let b: string = ""
    let c: string = a + b
    if len(c) == 3 { return 42 }
    return 0
}

// Test multiple concatenations
fn test_str_concat_multi() i64 {
    let a: string = "a"
    let b: string = "b"
    let c: string = "c"
    let d: string = a + b
    let e: string = d + c
    if len(e) == 3 { return 42 }
    return 0
}

// ============================================================================
// TIER 15.9: @string Builtin
// ============================================================================

// Test @string creates substring with correct length
fn test_string_builtin_len() i64 {
    let s: string = "hello world"
    let sub: string = @string(s.ptr + 6, 5)
    if len(sub) == 5 { return 42 }
    return 0
}

// Test @string creates substring with correct content
fn test_string_builtin_content() i64 {
    let s: string = "hello world"
    let sub: string = @string(s.ptr + 6, 5)
    // First char should be 'w' (119)
    if sub[0] == 119 { return 42 }
    return 0
}

// Test @string with zero length
fn test_string_builtin_empty() i64 {
    let s: string = "hello"
    let empty: string = @string(s.ptr, 0)
    if len(empty) == 0 { return 42 }
    return 0
}

// ============================================================================
// TIER 16: For-In Loops
// ============================================================================

// Test basic for-in loop over array - sum elements
fn test_for_array() i64 {
    var arr: [5]i64 = [1, 2, 3, 4, 5]
    var sum: i64 = 0
    for x in arr {
        sum = sum + x
    }
    return sum  // 1+2+3+4+5 = 15
}

// Test for-in with break
fn test_for_break() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50]
    var sum: i64 = 0
    for x in arr {
        if x == 30 {
            break
        }
        sum = sum + x
    }
    return sum  // 10+20 = 30
}

// Test for-in with continue
fn test_for_continue() i64 {
    var arr: [5]i64 = [1, 2, 3, 4, 5]
    var sum: i64 = 0
    for x in arr {
        if x == 3 {
            continue
        }
        sum = sum + x
    }
    return sum  // 1+2+4+5 = 12
}

// Test for-in with slice
fn test_for_slice() i64 {
    var arr: [5]i64 = [10, 20, 30, 40, 50]
    let s: []i64 = arr[1:4]
    var sum: i64 = 0
    for x in s {
        sum = sum + x
    }
    return sum  // 20+30+40 = 90
}

// ============================================================================
// TIER 17: Switch Statement
// ============================================================================

// Test switch - basic integer matching
fn test_switch_int() i64 {
    let x: i64 = 2
    return switch x {
        1 => 10,
        2 => 42,
        3 => 30,
        else => 99,
    }
}

// Test switch - else (default) case
fn test_switch_default() i64 {
    let x: i64 = 5
    return switch x {
        1 => 10,
        2 => 20,
        else => 42,
    }
}

// Test switch - multiple patterns per case
fn test_switch_multi() i64 {
    let x: i64 = 3
    return switch x {
        1, 2 => 12,
        3, 4 => 42,
        else => 99,
    }
}

// Test switch - first case match
fn test_switch_first() i64 {
    let x: i64 = 1
    return switch x {
        1 => 42,
        2 => 20,
        3 => 30,
        else => 99,
    }
}

// ============================================================================
// TIER 18: Indirect Function Calls (Function Pointers)
// ============================================================================

// Helper function for indirect call tests
fn add_fn(a: i64, b: i64) i64 {
    return a + b
}

fn mul_fn(a: i64, b: i64) i64 {
    return a * b
}

// Test indirect call through function pointer variable
fn test_fn_ptr_call() i64 {
    var f: fn(i64, i64) -> i64 = add_fn
    return f(20, 22)  // Should return 42
}

// Test reassigning function pointer
fn test_fn_ptr_reassign() i64 {
    var f: fn(i64, i64) -> i64 = add_fn
    let r1: i64 = f(10, 5)   // 15
    f = mul_fn
    let r2: i64 = f(6, 7)    // 42
    return r2
}

// Test function pointer with zero args
fn get_forty_two() i64 {
    return 42
}

fn test_fn_ptr_no_args() i64 {
    var f: fn() -> i64 = get_forty_two
    return f()
}

// ============================================================================
// TIER 19: Pointer Arithmetic (Go: OpAddPtr pattern)
// Need: ptr + int, ptr - int
// ============================================================================

extern fn malloc(size: i64) *i64;
extern fn malloc_u8(size: i64) *u8;
extern fn free(ptr: *i64);

// Test pointer + integer arithmetic
fn test_ptr_add() i64 {
    let buf: *i64 = malloc(24)  // 3 x 8 bytes
    buf.* = 10
    let p1: *i64 = buf + 8      // offset by 8 bytes
    p1.* = 20
    let p2: *i64 = buf + 16     // offset by 16 bytes
    p2.* = 12
    let sum: i64 = buf.* + (buf + 8).* + (buf + 16).*  // 10 + 20 + 12 = 42
    free(buf)
    return sum
}

// Test pointer subtraction
fn test_ptr_sub() i64 {
    let buf: *i64 = malloc(16)
    buf.* = 50
    let end: *i64 = buf + 8
    end.* = 100
    // Go back: end - 8 should point to buf
    let start: *i64 = end - 8
    let val: i64 = start.*  // Should be 50
    free(buf)
    if val == 50 { return 42 }
    return 0
}

// ============================================================================
// TIER 20: Bitwise NOT
// ============================================================================

fn test_bitwise_not_zero() i64 {
    let x: i64 = 0
    if ~x == -1 { return 42 }
    return 0
}

fn test_bitwise_not_neg() i64 {
    let x: i64 = -1
    if ~x == 0 { return 42 }
    return 0
}

fn test_bitwise_not_double() i64 {
    let x: i64 = 42
    if ~~x == 42 { return 42 }
    return 0
}

// ============================================================================
// TIER 21: Compound Assignments
// ============================================================================

fn test_add_assign() i64 {
    let x: i64 = 10
    x += 5
    if x == 15 { return 42 }
    return 0
}

fn test_sub_assign() i64 {
    let x: i64 = 20
    x -= 8
    if x == 12 { return 42 }
    return 0
}

fn test_mul_assign() i64 {
    let x: i64 = 6
    x *= 7
    if x == 42 { return 42 }
    return 0
}

fn test_div_assign() i64 {
    let x: i64 = 84
    x /= 2
    if x == 42 { return 42 }
    return 0
}

fn test_bitwise_and_assign() i64 {
    let x: i64 = 15  // 1111
    x &= 6           // 0110
    if x == 6 { return 42 }
    return 0
}

fn test_bitwise_or_assign() i64 {
    let x: i64 = 8   // 1000
    x |= 4           // 0100
    if x == 12 { return 42 }  // 1100
    return 0
}

// ============================================================================
// TIER 22: @intCast
// ============================================================================

fn test_intcast_widen() i64 {
    let a: u8 = 200
    let b: i64 = @intCast(i64, a)
    if b == 200 { return 42 }
    return 0
}

fn test_intcast_truncate() i64 {
    let a: i64 = 300  // 0x12C -> truncate to 0x2C = 44
    let b: u8 = @intCast(u8, a)
    if b == 44 { return 42 }
    return 0
}

fn test_intcast_roundtrip() i64 {
    let a: i64 = 12345
    let b: i32 = @intCast(i32, a)
    let c: i64 = @intCast(i64, b)
    if c == 12345 { return 42 }
    return 0
}

// ============================================================================
// TIER 23+: BLOCKED - Advanced Features
// Need: more features...
// ============================================================================

// (many more tests to add as we implement features)

// ============================================================================
// TIER 23: Defer Statement
// ============================================================================

// Helper for defer tests
fn defer_identity(x: i64) i64 {
    return x
}

// Simple defer with function call
fn test_defer_simple() i64 {
    defer defer_identity(42)  // Runs at scope exit, result discarded
    return 42
}

// Defer in early return path
fn test_defer_early_return() i64 {
    let x: i64 = -5
    defer defer_identity(99)
    if x < 0 {
        return 42  // Defer runs before early return
    }
    return 0
}

// Multiple defers execute
fn test_defer_multiple() i64 {
    defer defer_identity(1)
    defer defer_identity(2)
    defer defer_identity(3)
    return 42  // All three defers run in LIFO order
}

// Defer in block scope
fn test_defer_block() i64 {
    {
        defer defer_identity(10)  // Runs when block exits
    }
    return 42  // After block, execution continues
}

// ============================================================================
// TIER 24: Global Variables
// ============================================================================

// Helper function to increment global counter
fn g_increment() {
    g_counter = g_counter + 1
}

// Helper function to get current counter value
fn g_get() i64 {
    return g_counter
}

// Helper function to reset counter
fn g_reset() {
    g_counter = 0
}

// Basic global variable access
fn test_global_basic() i64 {
    g_counter = 42
    return g_counter
}

// Global variable modified from helper function
fn test_global_increment() i64 {
    g_reset()          // Start at 0
    g_increment()      // 1
    g_increment()      // 2
    g_increment()      // 3
    return g_get() + 39  // 3 + 39 = 42
}

// Global variable arithmetic
fn test_global_arithmetic() i64 {
    g_counter = 10
    g_counter = g_counter * 4  // 40
    g_counter = g_counter + 2  // 42
    return g_counter
}

// Global variable accessed from multiple functions
fn test_global_multi_access() i64 {
    g_counter = 0
    g_increment()  // 1
    g_increment()  // 2
    let x: i64 = g_get()  // x = 2
    g_increment()  // 3
    g_increment()  // 4
    return g_get() * 10 + x  // 4 * 10 + 2 = 42
}

// ============================================================================
// TIER 25: STRESS TESTS - Register Pressure, Phi Nodes, Deep Nesting
// ============================================================================
// These tests expose bugs that simple tests miss

// --- Register Pressure Tests ---
// Force many values to be live simultaneously, stressing the register allocator

// 15 live values - exceeds caller-saved registers (x0-x15)
fn test_regpressure_15() i64 {
    let a: i64 = 1
    let b: i64 = 2
    let c: i64 = 3
    let d: i64 = 4
    let e: i64 = 5
    let f: i64 = 6
    let g: i64 = 7
    let h: i64 = 8
    let i: i64 = 9
    let j: i64 = 10
    let k: i64 = 11
    let l: i64 = 12
    let m: i64 = 13
    let n: i64 = 14
    let o: i64 = 15
    // All 15 values must be live here - forces spilling
    return a + b + c + d + e + f + g + h + i + j + k + l + m + n + o // = 120
}

// 20 live values - well beyond register capacity
fn test_regpressure_20() i64 {
    let a: i64 = 1; let b: i64 = 2; let c: i64 = 3; let d: i64 = 4
    let e: i64 = 5; let f: i64 = 6; let g: i64 = 7; let h: i64 = 8
    let i: i64 = 9; let j: i64 = 10; let k: i64 = 11; let l: i64 = 12
    let m: i64 = 13; let n: i64 = 14; let o: i64 = 15; let p: i64 = 16
    let q: i64 = 17; let r: i64 = 18; let s: i64 = 19; let t: i64 = 20
    return a+b+c+d+e+f+g+h+i+j+k+l+m+n+o+p+q+r+s+t // = 210
}

// Register pressure with function calls interspersed
fn pressure_helper(x: i64) i64 { return x * 2 }

fn test_regpressure_with_calls() i64 {
    let a: i64 = 1; let b: i64 = 2; let c: i64 = 3; let d: i64 = 4
    let e: i64 = 5; let f: i64 = 6; let g: i64 = 7; let h: i64 = 8
    // Call that might clobber registers
    let x: i64 = pressure_helper(a)  // x = 2
    // More live values after call
    let i: i64 = 9; let j: i64 = 10; let k: i64 = 11; let l: i64 = 12
    // Another call
    let y: i64 = pressure_helper(b)  // y = 4
    // All values must survive
    return a+b+c+d+e+f+g+h+i+j+k+l+x+y // 1+2+3+4+5+6+7+8+9+10+11+12+2+4 = 84
}

// --- Multi-Way Control Flow Tests ---
// Test if-else chains and nested control flow that stress phi handling

fn test_phi_3way(x: i64) i64 {
    // 3-way if-else chain - each path sets result differently
    var result: i64 = 0
    if x == 1 {
        result = 10
    } else if x == 2 {
        result = 20
    } else {
        result = 30
    }
    // After merge, result has been assigned on all paths
    return result
}

fn test_phi_4way(x: i64) i64 {
    // 4-way if-else chain
    var result: i64 = 0
    if x == 1 {
        result = 100
    } else if x == 2 {
        result = 200
    } else if x == 3 {
        result = 300
    } else {
        result = 400
    }
    return result
}

fn test_phi_3way_driver() i64 {
    // Test all 3 paths
    let r1: i64 = test_phi_3way(1)  // 10
    let r2: i64 = test_phi_3way(2)  // 20
    let r3: i64 = test_phi_3way(99) // 30
    if r1 + r2 + r3 == 60 { return 42 }
    return 0
}

fn test_phi_4way_driver() i64 {
    let r1: i64 = test_phi_4way(1)  // 100
    let r2: i64 = test_phi_4way(2)  // 200
    let r3: i64 = test_phi_4way(3)  // 300
    let r4: i64 = test_phi_4way(99) // 400
    if r1 + r2 + r3 + r4 == 1000 { return 42 }
    return 0
}

// --- Many Arguments Tests ---
// Test stack-based parameter passing at scale

fn args16(a1: i64, a2: i64, a3: i64, a4: i64, a5: i64, a6: i64, a7: i64, a8: i64,
          a9: i64, a10: i64, a11: i64, a12: i64, a13: i64, a14: i64, a15: i64, a16: i64) i64 {
    return a1+a2+a3+a4+a5+a6+a7+a8+a9+a10+a11+a12+a13+a14+a15+a16
}

fn test_16args() i64 {
    let result: i64 = args16(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
    if result == 136 { return 42 }  // sum 1..16 = 136
    return 0
}

// --- String Across Branches Tests ---
// Strings flowing through control flow merges stress phi handling for 16-byte values

fn test_string_branch() i64 {
    let x: i64 = 10
    var s: string = "short"
    if x > 5 {
        s = "longer_string"
    }
    // phi for string - 16 bytes flowing through merge
    return len(s)  // 13 if condition was true
}

fn test_string_loop() i64 {
    var s: string = ""
    var i: i64 = 0
    while i < 3 {
        s = s + "x"  // phi for string in loop
        i = i + 1
    }
    return len(s)  // 3
}

// --- Deep Nesting Tests ---
// 3+ levels of control flow to catch nesting bugs

fn test_nest3() i64 {
    var result: i64 = 0
    var i: i64 = 0
    while i < 3 {                  // Level 1
        var j: i64 = 0
        while j < 3 {              // Level 2
            if (i + j) % 2 == 0 {  // Level 3
                result = result + 1
            }
            j = j + 1
        }
        i = i + 1
    }
    // (0,0)=0 even, (0,2)=2 even, (1,1)=2 even, (2,0)=2 even, (2,2)=4 even = 5
    return result  // 5
}

fn test_nest4() i64 {
    var total: i64 = 0
    var a: i64 = 0
    while a < 2 {                     // Level 1
        var b: i64 = 0
        while b < 2 {                 // Level 2
            var c: i64 = 0
            while c < 2 {             // Level 3
                if a + b + c == 2 {   // Level 4
                    total = total + 1
                }
                c = c + 1
            }
            b = b + 1
        }
        a = a + 1
    }
    // (0,1,1), (1,0,1), (1,1,0) = 3 combinations
    return total  // 3
}

// --- Complex Expression Tests ---
// Long expression chains that stress temporary allocation

fn test_long_expr() i64 {
    let a: i64 = 1; let b: i64 = 2; let c: i64 = 3
    // Complex expression with many intermediates
    return ((a + b) * (c + a) + (b * c)) * ((a + c) - b) + (a * b * c)
    // = (3 * 4 + 6) * (4 - 2) + 6 = 18 * 2 + 6 = 42
}

fn test_nested_arith() i64 {
    let x: i64 = 2
    let y: i64 = 3
    let z: i64 = 4
    // Deeply nested arithmetic
    return (((x + y) * z) + ((y * z) - x)) * (x + y - 1)
    // = ((5 * 4) + (12 - 2)) * 4 = (20 + 10) * 4 = 30 * 4 = 120
}

// Combined: control flow + register pressure
fn test_pressure_in_loop() i64 {
    var sum: i64 = 0
    var i: i64 = 0
    while i < 5 {
        // Many live values inside loop
        let a: i64 = i * 2
        let b: i64 = i * 3
        let c: i64 = i * 4
        let d: i64 = i * 5
        let e: i64 = a + b
        let f: i64 = c + d
        sum = sum + e + f
        i = i + 1
    }
    // i=0: e=0, f=0, sum=0
    // i=1: e=5, f=9, sum=14
    // i=2: e=10, f=18, sum=42
    // i=3: e=15, f=27, sum=84
    // i=4: e=20, f=36, sum=140
    return sum  // 140
}

// ============================================================================
// TIER 26: BUG REGRESSION TESTS
// ============================================================================
// Each test here exercises a specific bug that was found and fixed.
// These ensure we don't regress on fixed bugs.

// --- BUG-003: Struct with enum field layout ---
// Enums are 4 bytes but were incorrectly sized, causing field offset corruption

enum TokenKind {
    Number,
    Ident,
    Plus,
}

struct TokenWithEnum {
    kind: TokenKind,
    x: i64,
    y: i64,
}

fn test_bug003_struct_enum_field() i64 {
    var t: TokenWithEnum
    t.kind = TokenKind.Ident
    t.x = 10
    t.y = 20
    // If enum size is wrong, x and y will have corrupted values
    return t.x + t.y  // Should be 30
}

// --- BUG-004: Large struct return (>16B) ---
// ARM64 ABI: >16B structs must be returned via hidden pointer (x8)

struct BigReturn {
    a: i64,
    b: i64,
    c: i64,
}  // 24 bytes - must use hidden return pointer

fn make_big_return(x: i64, y: i64, z: i64) BigReturn {
    var s: BigReturn
    s.a = x
    s.b = y
    s.c = z
    return s
}

fn test_bug004_large_struct_return() i64 {
    let s: BigReturn = make_big_return(10, 20, 12)
    return s.a + s.b + s.c  // Should be 42
}

// --- BUG-012: ptr.*.field access ---
// Was loading entire struct instead of computing ptr + offset

struct NodeForPtrDeref {
    kind: i64,
    value: i64,
}

fn get_value_via_ptr(p: *NodeForPtrDeref) i64 {
    return p.*.value  // Access field through pointer dereference
}

fn test_bug012_ptr_deref_field() i64 {
    var node: NodeForPtrDeref
    node.kind = 5
    node.value = 42
    return get_value_via_ptr(&node)  // Should be 42
}

// --- BUG-016: Const on right side of comparison ---
// Parser assumed uppercase + { was struct literal

const BUG016_CONST: i64 = 42

fn test_bug016_const_right_side() i64 {
    let a: i64 = 42
    if a == BUG016_CONST {  // Const on RIGHT side
        return 42
    }
    return 0
}

// --- BUG-019: Large struct (>16B) passed by value ---
// ARM64: >16B structs must be passed by reference (pointer in register)

struct BigArg {
    a: i64,
    b: i64,
    c: i64,
    d: i64,
    e: i64,
    f: i64,
}  // 48 bytes - 6 x i64

fn sum_big_arg(s: BigArg) i64 {
    return s.a + s.b + s.c + s.d + s.e + s.f
}

fn test_bug019_large_struct_arg() i64 {
    var s: BigArg
    s.a = 1
    s.b = 2
    s.c = 3
    s.d = 4
    s.e = 5
    s.f = 27  // Sum = 42
    return sum_big_arg(s)  // Should be 42
}

// --- BUG-019b: Large struct arg with struct literal ---

fn test_bug019b_large_struct_literal_arg() i64 {
    let s: BigArg = BigArg{ .a = 7, .b = 7, .c = 7, .d = 7, .e = 7, .f = 7 }
    return sum_big_arg(s)  // 7*6 = 42
}

// ============================================================================
// MAIN - Test Runner
// ============================================================================

// ============================================================================
// PARITY TESTS (merged from test/parity/)
// ============================================================================

// Parity test: arrays/arr_011_bubble_sort
fn bubble_sort_parity_bubble_sort(arr: *i64, len: i64) void {
    var i: i64 = 0;
    while i < len - 1 {
        var j: i64 = 0;
        while j < len - 1 - i {
            if (arr + j).* > (arr + j + 1).* {
                var tmp: i64 = (arr + j).*;
                (arr + j).* = (arr + j + 1).*;
                (arr + j + 1).* = tmp;
            }
            j = j + 1;
        }
        i = i + 1;
    }
}
fn test_parity_bubble_sort() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 5;
    (arr + 1).* = 2;
    (arr + 2).* = 4;
    (arr + 3).* = 1;
    (arr + 4).* = 3;
    bubble_sort_parity_bubble_sort(arr, 5);
    if (arr + 0).* == 1 and (arr + 4).* == 5 { return 42; }
    return 1;
}


// Parity test: arrays/arr_016_insertion_sort
fn insertion_sort_parity_insertion_sort(arr: *i64, n: i64) void {
    var i: i64 = 1;
    while i < n {
        var key: i64 = (arr + i).*;
        var j: i64 = i - 1;
        while j >= 0 and (arr + j).* > key {
            (arr + j + 1).* = (arr + j).*;
            j = j - 1;
        }
        (arr + j + 1).* = key;
        i = i + 1;
    }
}
fn test_parity_insertion_sort() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 5;
    (arr + 1).* = 3;
    (arr + 2).* = 4;
    (arr + 3).* = 1;
    (arr + 4).* = 2;
    insertion_sort_parity_insertion_sort(arr, 5);
    if (arr + 0).* == 1 and (arr + 4).* == 5 { return 42; }
    return 1;
}


// Parity test: arrays/arr_017_selection_sort
fn selection_sort_parity_selection_sort(arr: *i64, n: i64) void {
    var i: i64 = 0;
    while i < n - 1 {
        var min_idx: i64 = i;
        var j: i64 = i + 1;
        while j < n {
            if (arr + j).* < (arr + min_idx).* {
                min_idx = j;
            }
            j = j + 1;
        }
        var tmp: i64 = (arr + i).*;
        (arr + i).* = (arr + min_idx).*;
        (arr + min_idx).* = tmp;
        i = i + 1;
    }
}
fn test_parity_selection_sort() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 4;
    (arr + 1).* = 2;
    (arr + 2).* = 5;
    (arr + 3).* = 1;
    (arr + 4).* = 3;
    selection_sort_parity_selection_sort(arr, 5);
    if (arr + 0).* == 1 and (arr + 4).* == 5 { return 42; }
    return 1;
}


// Parity test: arrays/arr_018_binary_search
fn binary_search_parity_binary_search(arr: *i64, n: i64, target: i64) i64 {
    var low: i64 = 0;
    var high: i64 = n - 1;
    while low <= high {
        var mid: i64 = (low + high) / 2;
        var val: i64 = (arr + mid).*;
        if val == target { return mid; }
        if val < target { low = mid + 1; }
        if val > target { high = mid - 1; }
    }
    return 0 - 1;
}
fn test_parity_binary_search() i64 {
    var arr: *i64 = malloc(56);
    (arr + 0).* = 10;
    (arr + 1).* = 20;
    (arr + 2).* = 30;
    (arr + 3).* = 40;
    (arr + 4).* = 50;
    (arr + 5).* = 60;
    (arr + 6).* = 70;
    if binary_search_parity_binary_search(arr, 7, 40) == 3 { return 42; }
    return 1;
}


// Parity test: functions/fn_061_collatz
fn collatz_steps_parity_collatz(n: i64) i64 {
    var steps: i64 = 0;
    var x: i64 = n;
    while x > 1 {
        if x % 2 == 0 {
            x = x / 2;
        } else {
            x = 3 * x + 1;
        }
        steps = steps + 1;
    }
    return steps;
}
fn test_parity_collatz() i64 {
    if collatz_steps_parity_collatz(27) == 111 { return 42; }
    return 1;
}


// Parity test: functions/fn_060_is_prime
fn is_prime_parity_is_prime(n: i64) i64 {
    if n <= 1 { return 0; }
    if n <= 3 { return 1; }
    if n % 2 == 0 { return 0; }
    var i: i64 = 3;
    while i * i <= n {
        if n % i == 0 { return 0; }
        i = i + 2;
    }
    return 1;
}
fn test_parity_is_prime() i64 {
    var p1: i64 = is_prime_parity_is_prime(2);
    var p2: i64 = is_prime_parity_is_prime(17);
    var p3: i64 = is_prime_parity_is_prime(18);
    var p4: i64 = is_prime_parity_is_prime(97);
    if p1 == 1 and p2 == 1 and p3 == 0 and p4 == 1 { return 42; }
    return 1;
}


// Parity test: functions/fn_059_power
fn power_parity_power(base: i64, exp: i64) i64 {
    var result: i64 = 1;
    var i: i64 = 0;
    while i < exp {
        result = result * base;
        i = i + 1;
    }
    return result;
}
fn test_parity_power() i64 {
    if power_parity_power(2, 10) == 1024 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_085_triple_loop
fn test_parity_triple_loop() i64 {
    var sum: i64 = 0;
    var i: i64 = 0;
    while i < 2 {
        var j: i64 = 0;
        while j < 3 {
            var k: i64 = 0;
            while k < 4 {
                sum = sum + 1;
                k = k + 1;
            }
            j = j + 1;
        }
        i = i + 1;
    }
    if sum == 24 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_094_nested_loop_sum
fn test_parity_nested_loop() i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    while i <= 5 {
        var j: i64 = 1;
        while j <= i {
            sum = sum + j;
            j = j + 1;
        }
        i = i + 1;
    }
    if sum == 35 { return 42; }
    return 1;
}


// Parity test: expressions/expr_100_count_bits
fn count_bits_parity_count_bits(n: i64) i64 {
    var count: i64 = 0;
    var x: i64 = n;
    while x > 0 {
        count = count + (x & 1);
        x = x >> 1;
    }
    return count;
}
fn test_parity_count_bits() i64 {
    if count_bits_parity_count_bits(0b11101010) == 5 { return 42; }
    return 1;
}



// Parity test: arrays/arr_031_reverse_in_place
fn reverse_parity_reverse(arr: *i64, n: i64) void {
    var i: i64 = 0;
    var j: i64 = n - 1;
    while i < j {
        var t: i64 = (arr + i).*;
        (arr + i).* = (arr + j).*;
        (arr + j).* = t;
        i = i + 1;
        j = j - 1;
    }
}
fn test_parity_reverse() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 3;
    (arr + 3).* = 4;
    (arr + 4).* = 5;
    reverse_parity_reverse(arr, 5);
    if (arr + 0).* == 5 and (arr + 4).* == 1 and (arr + 2).* == 3 { return 42; }
    return 1;
}


// Parity test: arrays/arr_007_find_max
fn find_max_parity_find_max(arr: *i64, len: i64) i64 {
    var max: i64 = (arr + 0).*;
    var i: i64 = 1;
    while i < len {
        if (arr + i).* > max {
            max = (arr + i).*;
        }
        i = i + 1;
    }
    return max;
}
fn test_parity_find_max() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 30;
    (arr + 1).* = 10;
    (arr + 2).* = 50;
    (arr + 3).* = 20;
    (arr + 4).* = 40;
    if find_max_parity_find_max(arr, 5) == 50 { return 42; }
    return 1;
}


// Parity test: arrays/arr_008_find_min
fn find_min_parity_find_min(arr: *i64, len: i64) i64 {
    var min: i64 = (arr + 0).*;
    var i: i64 = 1;
    while i < len {
        if (arr + i).* < min {
            min = (arr + i).*;
        }
        i = i + 1;
    }
    return min;
}
fn test_parity_find_min() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 30;
    (arr + 1).* = 10;
    (arr + 2).* = 50;
    (arr + 3).* = 5;
    (arr + 4).* = 40;
    if find_min_parity_find_min(arr, 5) == 5 { return 42; }
    return 1;
}


// Parity test: arrays/arr_013_count
fn count_val_parity_array_count(arr: *i64, len: i64, val: i64) i64 {
    var count: i64 = 0;
    var i: i64 = 0;
    while i < len {
        if (arr + i).* == val {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}
fn test_parity_array_count() i64 {
    var arr: *i64 = malloc(56);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 1;
    (arr + 3).* = 3;
    (arr + 4).* = 1;
    (arr + 5).* = 2;
    (arr + 6).* = 1;
    if count_val_parity_array_count(arr, 7, 1) == 4 { return 42; }
    return 1;
}


// Parity test: arrays/arr_021_partial_sum
fn partial_sums_parity_partial_sum(arr: *i64, out: *i64, n: i64) void {
    var sum: i64 = 0;
    var i: i64 = 0;
    while i < n {
        sum = sum + (arr + i).*;
        (out + i).* = sum;
        i = i + 1;
    }
}
fn test_parity_partial_sum() i64 {
    var arr: *i64 = malloc(40);
    var out: *i64 = malloc(40);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 3;
    (arr + 3).* = 4;
    (arr + 4).* = 5;
    partial_sums_parity_partial_sum(arr, out, 5);
    if (out + 0).* == 1 and (out + 4).* == 15 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_070_count_primes
fn is_prime_parity_count_primes(n: i64) i64 {
    if n <= 1 { return 0; }
    if n <= 3 { return 1; }
    if n % 2 == 0 { return 0; }
    var i: i64 = 3;
    while i * i <= n {
        if n % i == 0 { return 0; }
        i = i + 2;
    }
    return 1;
}
fn test_parity_count_primes() i64 {
    var count: i64 = 0;
    var n: i64 = 2;
    while n <= 100 {
        count = count + is_prime_parity_count_primes(n);
        n = n + 1;
    }
    if count == 25 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_080_sum_divisible
fn sum_divisible_parity_sum_divisible(n: i64, d: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    while i <= n {
        if i % d == 0 {
            sum = sum + i;
        }
        i = i + 1;
    }
    return sum;
}
fn test_parity_sum_divisible() i64 {
    if sum_divisible_parity_sum_divisible(10, 2) == 30 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_097_fizzbuzz_logic
fn fizzbuzz_parity_fizzbuzz(n: i64) i64 {
    if n % 15 == 0 { return 3; }
    if n % 5 == 0 { return 2; }
    if n % 3 == 0 { return 1; }
    return 0;
}
fn test_parity_fizzbuzz() i64 {
    if fizzbuzz_parity_fizzbuzz(15) == 3 {
        if fizzbuzz_parity_fizzbuzz(9) == 1 {
            if fizzbuzz_parity_fizzbuzz(10) == 2 {
                if fizzbuzz_parity_fizzbuzz(7) == 0 { return 42; }
            }
        }
    }
    return 1;
}


// Parity test: expressions/expr_113_align_up
fn align_up_parity_align_up(n: i64, align: i64) i64 {
    return (n + align - 1) & (0 - align);
}
fn test_parity_align_up() i64 {
    if align_up_parity_align_up(13, 8) == 16 { return 42; }
    return 1;
}


// Parity test: expressions/expr_115_bit_extract
fn extract_byte_parity_bit_extract(x: i64, pos: i64) i64 {
    return (x >> (pos * 8)) & 0xFF;
}
fn test_parity_bit_extract() i64 {
    var x: i64 = 0x12345678;
    if extract_byte_parity_bit_extract(x, 0) == 0x78 { return 42; }
    return 1;
}


// Parity test: functions/fn_057_fibonacci_iter
fn fib_iter_parity_fib_iter(n: i64) i64 {
    if n <= 1 { return n; }
    var a: i64 = 0;
    var b: i64 = 1;
    var i: i64 = 2;
    while i <= n {
        var tmp: i64 = a + b;
        a = b;
        b = tmp;
        i = i + 1;
    }
    return b;
}
fn test_parity_fib_iter() i64 {
    if fib_iter_parity_fib_iter(10) == 55 { return 42; }
    return 1;
}


// Parity test: functions/fn_058_factorial_iter
fn fact_iter_parity_factorial(n: i64) i64 {
    var result: i64 = 1;
    var i: i64 = 2;
    while i <= n {
        result = result * i;
        i = i + 1;
    }
    return result;
}
fn test_parity_factorial() i64 {
    if fact_iter_parity_factorial(6) == 720 { return 42; }
    return 1;
}


// Parity test: functions/fn_073_nth_prime
fn is_prime_parity_nth_prime(n: i64) i64 {
    if n <= 1 { return 0; }
    if n <= 3 { return 1; }
    if n % 2 == 0 { return 0; }
    var i: i64 = 3;
    while i * i <= n {
        if n % i == 0 { return 0; }
        i = i + 2;
    }
    return 1;
}
fn nth_prime_parity_nth_prime(n: i64) i64 {
    var count: i64 = 0;
    var num: i64 = 2;
    while count < n {
        if is_prime_parity_nth_prime(num) == 1 {
            count = count + 1;
            if count == n { return num; }
        }
        num = num + 1;
    }
    return num;
}
fn test_parity_nth_prime() i64 {
    if nth_prime_parity_nth_prime(10) == 29 { return 42; }
    return 1;
}


// Parity test: memory/mem_050_fibonacci_array
fn init_fib_parity_fib_array(arr: *i64, n: i64) void {
    if n >= 1 { (arr + 0).* = 0; }
    if n >= 2 { (arr + 1).* = 1; }
    var i: i64 = 2;
    while i < n {
        (arr + i).* = (arr + i - 1).* + (arr + i - 2).*;
        i = i + 1;
    }
}
fn test_parity_fib_array() i64 {
    var arr: *i64 = malloc(80);
    init_fib_parity_fib_array(arr, 10);
    if (arr + 9).* == 34 { return 42; }
    return 1;
}



// ============================================================================
// PARITY TESTS (from test/parity/)
// ============================================================================

// Parity test: arrays/arr_001_basic_i64
fn test_parity_arr_001_basic_i64() i64 {
    var arr: *i64 = malloc(32);
    (arr + 0).* = 10;
    (arr + 1).* = 20;
    (arr + 2).* = 30;
    (arr + 3).* = 40;
    var sum: i64 = (arr + 0).* + (arr + 1).* + (arr + 2).* + (arr + 3).*;
    if sum == 100 { return 42; }
    return 1;
}


// Parity test: arrays/arr_002_index_calc
fn test_parity_arr_002_index_calc() i64 {
    var arr: *i64 = malloc(40);
    var i: i64 = 0;
    while i < 5 {
        (arr + i).* = i * 10;
        i = i + 1;
    }
    if (arr + 0).* == 0 and (arr + 4).* == 40 { return 42; }
    return 1;
}


// Parity test: arrays/arr_003_sum_loop
fn test_parity_arr_003_sum_loop() i64 {
    var arr: *i64 = malloc(80);
    var i: i64 = 0;
    while i < 10 {
        (arr + i).* = i + 1;
        i = i + 1;
    }
    var sum: i64 = 0;
    i = 0;
    while i < 10 {
        sum = sum + (arr + i).*;
        i = i + 1;
    }
    if sum == 55 { return 42; }
    return 1;
}


// Parity test: arrays/arr_004_pass_to_fn
fn sum_array_parity_arr_004_pass_to_fn(arr: *i64, len: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 0;
    while i < len {
        sum = sum + (arr + i).*;
        i = i + 1;
    }
    return sum;
}
fn test_parity_arr_004_pass_to_fn() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 3;
    (arr + 3).* = 4;
    (arr + 4).* = 5;
    if sum_array_parity_arr_004_pass_to_fn(arr, 5) == 15 { return 42; }
    return 1;
}


// Parity test: arrays/arr_005_modify_in_fn
fn double_array_parity_arr_005_modify_in_fn(arr: *i64, len: i64) void {
    var i: i64 = 0;
    while i < len {
        (arr + i).* = (arr + i).* * 2;
        i = i + 1;
    }
}
fn test_parity_arr_005_modify_in_fn() i64 {
    var arr: *i64 = malloc(24);
    (arr + 0).* = 5;
    (arr + 1).* = 10;
    (arr + 2).* = 15;
    double_array_parity_arr_005_modify_in_fn(arr, 3);
    if (arr + 0).* == 10 and (arr + 1).* == 20 and (arr + 2).* == 30 { return 42; }
    return 1;
}


// Parity test: arrays/arr_006_copy_array
fn copy_array_parity_arr_006_copy_array(src: *i64, dst: *i64, len: i64) void {
    var i: i64 = 0;
    while i < len {
        (dst + i).* = (src + i).*;
        i = i + 1;
    }
}
fn test_parity_arr_006_copy_array() i64 {
    var src: *i64 = malloc(24);
    var dst: *i64 = malloc(24);
    (src + 0).* = 100;
    (src + 1).* = 200;
    (src + 2).* = 300;
    copy_array_parity_arr_006_copy_array(src, dst, 3);
    if (dst + 0).* == 100 and (dst + 1).* == 200 and (dst + 2).* == 300 { return 42; }
    return 1;
}


// Parity test: arrays/arr_007_find_max
fn find_max_parity_arr_007_find_max(arr: *i64, len: i64) i64 {
    var max: i64 = (arr + 0).*;
    var i: i64 = 1;
    while i < len {
        if (arr + i).* > max {
            max = (arr + i).*;
        }
        i = i + 1;
    }
    return max;
}
fn test_parity_arr_007_find_max() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 30;
    (arr + 1).* = 10;
    (arr + 2).* = 50;
    (arr + 3).* = 20;
    (arr + 4).* = 40;
    if find_max_parity_arr_007_find_max(arr, 5) == 50 { return 42; }
    return 1;
}


// Parity test: arrays/arr_008_find_min
fn find_min_parity_arr_008_find_min(arr: *i64, len: i64) i64 {
    var min: i64 = (arr + 0).*;
    var i: i64 = 1;
    while i < len {
        if (arr + i).* < min {
            min = (arr + i).*;
        }
        i = i + 1;
    }
    return min;
}
fn test_parity_arr_008_find_min() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 30;
    (arr + 1).* = 10;
    (arr + 2).* = 50;
    (arr + 3).* = 5;
    (arr + 4).* = 40;
    if find_min_parity_arr_008_find_min(arr, 5) == 5 { return 42; }
    return 1;
}


// Parity test: arrays/arr_009_reverse
fn reverse_parity_arr_009_reverse(arr: *i64, len: i64) void {
    var i: i64 = 0;
    var j: i64 = len - 1;
    while i < j {
        var tmp: i64 = (arr + i).*;
        (arr + i).* = (arr + j).*;
        (arr + j).* = tmp;
        i = i + 1;
        j = j - 1;
    }
}
fn test_parity_arr_009_reverse() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 3;
    (arr + 3).* = 4;
    (arr + 4).* = 5;
    reverse_parity_arr_009_reverse(arr, 5);
    if (arr + 0).* == 5 and (arr + 4).* == 1 { return 42; }
    return 1;
}


// Parity test: arrays/arr_010_swap
fn swap_parity_arr_010_swap(arr: *i64, i: i64, j: i64) void {
    var tmp: i64 = (arr + i).*;
    (arr + i).* = (arr + j).*;
    (arr + j).* = tmp;
}
fn test_parity_arr_010_swap() i64 {
    var arr: *i64 = malloc(24);
    (arr + 0).* = 10;
    (arr + 1).* = 20;
    (arr + 2).* = 30;
    swap_parity_arr_010_swap(arr, 0, 2);
    if (arr + 0).* == 30 and (arr + 2).* == 10 { return 42; }
    return 1;
}


// Parity test: arrays/arr_011_bubble_sort
fn bubble_sort_parity_arr_011_bubble_sort(arr: *i64, len: i64) void {
    var i: i64 = 0;
    while i < len - 1 {
        var j: i64 = 0;
        while j < len - 1 - i {
            if (arr + j).* > (arr + j + 1).* {
                var tmp: i64 = (arr + j).*;
                (arr + j).* = (arr + j + 1).*;
                (arr + j + 1).* = tmp;
            }
            j = j + 1;
        }
        i = i + 1;
    }
}
fn test_parity_arr_011_bubble_sort() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 5;
    (arr + 1).* = 2;
    (arr + 2).* = 4;
    (arr + 3).* = 1;
    (arr + 4).* = 3;
    bubble_sort_parity_arr_011_bubble_sort(arr, 5);
    if (arr + 0).* == 1 and (arr + 4).* == 5 { return 42; }
    return 1;
}


// Parity test: arrays/arr_012_linear_search
fn linear_search_parity_arr_012_linear_search(arr: *i64, len: i64, target: i64) i64 {
    var i: i64 = 0;
    while i < len {
        if (arr + i).* == target {
            return i;
        }
        i = i + 1;
    }
    return 0 - 1;
}
fn test_parity_arr_012_linear_search() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 10;
    (arr + 1).* = 20;
    (arr + 2).* = 30;
    (arr + 3).* = 40;
    (arr + 4).* = 50;
    if linear_search_parity_arr_012_linear_search(arr, 5, 30) == 2 { return 42; }
    return 1;
}


// Parity test: arrays/arr_013_count
fn count_val_parity_arr_013_count(arr: *i64, len: i64, val: i64) i64 {
    var count: i64 = 0;
    var i: i64 = 0;
    while i < len {
        if (arr + i).* == val {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}
fn test_parity_arr_013_count() i64 {
    var arr: *i64 = malloc(56);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 1;
    (arr + 3).* = 3;
    (arr + 4).* = 1;
    (arr + 5).* = 2;
    (arr + 6).* = 1;
    if count_val_parity_arr_013_count(arr, 7, 1) == 4 { return 42; }
    return 1;
}


// Parity test: arrays/arr_014_product
fn product_parity_arr_014_product(arr: *i64, len: i64) i64 {
    var prod: i64 = 1;
    var i: i64 = 0;
    while i < len {
        prod = prod * (arr + i).*;
        i = i + 1;
    }
    return prod;
}
fn test_parity_arr_014_product() i64 {
    var arr: *i64 = malloc(32);
    (arr + 0).* = 2;
    (arr + 1).* = 3;
    (arr + 2).* = 4;
    (arr + 3).* = 5;
    if product_parity_arr_014_product(arr, 4) == 120 { return 42; }
    return 1;
}


// Parity test: arrays/arr_015_all_positive
fn all_positive_parity_arr_015_all_positive(arr: *i64, len: i64) i64 {
    var i: i64 = 0;
    while i < len {
        if (arr + i).* <= 0 {
            return 0;
        }
        i = i + 1;
    }
    return 1;
}
fn test_parity_arr_015_all_positive() i64 {
    var arr: *i64 = malloc(32);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 3;
    (arr + 3).* = 4;
    if all_positive_parity_arr_015_all_positive(arr, 4) == 1 { return 42; }
    return 1;
}


// Parity test: arrays/arr_016_insertion_sort
fn insertion_sort_parity_arr_016_insertion_sort(arr: *i64, n: i64) void {
    var i: i64 = 1;
    while i < n {
        var key: i64 = (arr + i).*;
        var j: i64 = i - 1;
        while j >= 0 and (arr + j).* > key {
            (arr + j + 1).* = (arr + j).*;
            j = j - 1;
        }
        (arr + j + 1).* = key;
        i = i + 1;
    }
}
fn test_parity_arr_016_insertion_sort() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 5;
    (arr + 1).* = 3;
    (arr + 2).* = 4;
    (arr + 3).* = 1;
    (arr + 4).* = 2;
    insertion_sort_parity_arr_016_insertion_sort(arr, 5);
    if (arr + 0).* == 1 and (arr + 4).* == 5 { return 42; }
    return 1;
}


// Parity test: arrays/arr_017_selection_sort
fn selection_sort_parity_arr_017_selection_sort(arr: *i64, n: i64) void {
    var i: i64 = 0;
    while i < n - 1 {
        var min_idx: i64 = i;
        var j: i64 = i + 1;
        while j < n {
            if (arr + j).* < (arr + min_idx).* {
                min_idx = j;
            }
            j = j + 1;
        }
        var tmp: i64 = (arr + i).*;
        (arr + i).* = (arr + min_idx).*;
        (arr + min_idx).* = tmp;
        i = i + 1;
    }
}
fn test_parity_arr_017_selection_sort() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 4;
    (arr + 1).* = 2;
    (arr + 2).* = 5;
    (arr + 3).* = 1;
    (arr + 4).* = 3;
    selection_sort_parity_arr_017_selection_sort(arr, 5);
    if (arr + 0).* == 1 and (arr + 4).* == 5 { return 42; }
    return 1;
}


// Parity test: arrays/arr_018_binary_search
fn binary_search_parity_arr_018_binary_search(arr: *i64, n: i64, target: i64) i64 {
    var low: i64 = 0;
    var high: i64 = n - 1;
    while low <= high {
        var mid: i64 = (low + high) / 2;
        var val: i64 = (arr + mid).*;
        if val == target { return mid; }
        if val < target { low = mid + 1; }
        if val > target { high = mid - 1; }
    }
    return 0 - 1;
}
fn test_parity_arr_018_binary_search() i64 {
    var arr: *i64 = malloc(56);
    (arr + 0).* = 10;
    (arr + 1).* = 20;
    (arr + 2).* = 30;
    (arr + 3).* = 40;
    (arr + 4).* = 50;
    (arr + 5).* = 60;
    (arr + 6).* = 70;
    if binary_search_parity_arr_018_binary_search(arr, 7, 40) == 3 { return 42; }
    return 1;
}


// Parity test: arrays/arr_019_merge_arrays
fn merge_parity_arr_019_merge_arrays(a: *i64, na: i64, b: *i64, nb: i64, out: *i64) void {
    var i: i64 = 0;
    var j: i64 = 0;
    var k: i64 = 0;
    while i < na and j < nb {
        if (a + i).* <= (b + j).* {
            (out + k).* = (a + i).*;
            i = i + 1;
        } else {
            (out + k).* = (b + j).*;
            j = j + 1;
        }
        k = k + 1;
    }
    while i < na {
        (out + k).* = (a + i).*;
        i = i + 1;
        k = k + 1;
    }
    while j < nb {
        (out + k).* = (b + j).*;
        j = j + 1;
        k = k + 1;
    }
}
fn test_parity_arr_019_merge_arrays() i64 {
    var a: *i64 = malloc(24);
    var b: *i64 = malloc(24);
    var out: *i64 = malloc(48);
    (a + 0).* = 1; (a + 1).* = 3; (a + 2).* = 5;
    (b + 0).* = 2; (b + 1).* = 4; (b + 2).* = 6;
    merge_parity_arr_019_merge_arrays(a, 3, b, 3, out);
    if (out + 0).* == 1 and (out + 5).* == 6 { return 42; }
    return 1;
}


// Parity test: arrays/arr_020_fill_pattern
fn test_parity_arr_020_fill_pattern() i64 {
    var arr: *i64 = malloc(80);
    var i: i64 = 0;
    while i < 10 {
        (arr + i).* = (i + 1) * (i + 1);
        i = i + 1;
    }
    var sum: i64 = 0;
    i = 0;
    while i < 10 {
        sum = sum + (arr + i).*;
        i = i + 1;
    }
    if sum == 385 { return 42; }
    return 1;
}


// Parity test: arrays/arr_021_partial_sum
fn partial_sums_parity_arr_021_partial_sum(arr: *i64, out: *i64, n: i64) void {
    var sum: i64 = 0;
    var i: i64 = 0;
    while i < n {
        sum = sum + (arr + i).*;
        (out + i).* = sum;
        i = i + 1;
    }
}
fn test_parity_arr_021_partial_sum() i64 {
    var arr: *i64 = malloc(40);
    var out: *i64 = malloc(40);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 3;
    (arr + 3).* = 4;
    (arr + 4).* = 5;
    partial_sums_parity_arr_021_partial_sum(arr, out, 5);
    if (out + 0).* == 1 and (out + 4).* == 15 { return 42; }
    return 1;
}


// Parity test: arrays/arr_022_rotate
fn rotate_left_parity_arr_022_rotate(arr: *i64, n: i64) void {
    var first: i64 = (arr + 0).*;
    var i: i64 = 0;
    while i < n - 1 {
        (arr + i).* = (arr + i + 1).*;
        i = i + 1;
    }
    (arr + n - 1).* = first;
}
fn test_parity_arr_022_rotate() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 3;
    (arr + 3).* = 4;
    (arr + 4).* = 5;
    rotate_left_parity_arr_022_rotate(arr, 5);
    if (arr + 0).* == 2 and (arr + 4).* == 1 { return 42; }
    return 1;
}


// Parity test: arrays/arr_023_filter
fn count_even_parity_arr_023_filter(arr: *i64, n: i64) i64 {
    var count: i64 = 0;
    var i: i64 = 0;
    while i < n {
        if (arr + i).* % 2 == 0 {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}
fn test_parity_arr_023_filter() i64 {
    var arr: *i64 = malloc(80);
    var i: i64 = 0;
    while i < 10 {
        (arr + i).* = i;
        i = i + 1;
    }
    if count_even_parity_arr_023_filter(arr, 10) == 5 { return 42; }
    return 1;
}


// Parity test: arrays/arr_024_average
fn average_parity_arr_024_average(arr: *i64, n: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 0;
    while i < n {
        sum = sum + (arr + i).*;
        i = i + 1;
    }
    return sum / n;
}
fn test_parity_arr_024_average() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 10;
    (arr + 1).* = 20;
    (arr + 2).* = 30;
    (arr + 3).* = 40;
    (arr + 4).* = 50;
    if average_parity_arr_024_average(arr, 5) == 30 { return 42; }
    return 1;
}


// Parity test: arrays/arr_025_map
fn map_double_parity_arr_025_map(arr: *i64, n: i64) void {
    var i: i64 = 0;
    while i < n {
        (arr + i).* = (arr + i).* * 2;
        i = i + 1;
    }
}
fn test_parity_arr_025_map() i64 {
    var arr: *i64 = malloc(32);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 3;
    (arr + 3).* = 4;
    map_double_parity_arr_025_map(arr, 4);
    if (arr + 0).* == 2 and (arr + 3).* == 8 { return 42; }
    return 1;
}


// Parity test: arrays/arr_026_dot_product
fn dot_product_parity_arr_026_dot_product(a: *i64, b: *i64, n: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 0;
    while i < n {
        sum = sum + (a + i).* * (b + i).*;
        i = i + 1;
    }
    return sum;
}
fn test_parity_arr_026_dot_product() i64 {
    var a: *i64 = malloc(24);
    var b: *i64 = malloc(24);
    (a + 0).* = 1; (a + 1).* = 2; (a + 2).* = 3;
    (b + 0).* = 4; (b + 1).* = 5; (b + 2).* = 6;
    if dot_product_parity_arr_026_dot_product(a, b, 3) == 32 { return 42; }
    return 1;
}


// Parity test: arrays/arr_027_norm_squared
fn norm_squared_parity_arr_027_norm_squared(arr: *i64, n: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 0;
    while i < n {
        var v: i64 = (arr + i).*;
        sum = sum + v * v;
        i = i + 1;
    }
    return sum;
}
fn test_parity_arr_027_norm_squared() i64 {
    var arr: *i64 = malloc(24);
    (arr + 0).* = 3;
    (arr + 1).* = 4;
    (arr + 2).* = 0;
    if norm_squared_parity_arr_027_norm_squared(arr, 3) == 25 { return 42; }
    return 1;
}


// Parity test: arrays/arr_028_diff_array
fn diff_parity_arr_028_diff_array(arr: *i64, out: *i64, n: i64) void {
    var i: i64 = 0;
    while i < n - 1 {
        (out + i).* = (arr + i + 1).* - (arr + i).*;
        i = i + 1;
    }
}
fn test_parity_arr_028_diff_array() i64 {
    var arr: *i64 = malloc(40);
    var out: *i64 = malloc(32);
    (arr + 0).* = 1;
    (arr + 1).* = 3;
    (arr + 2).* = 6;
    (arr + 3).* = 10;
    (arr + 4).* = 15;
    diff_parity_arr_028_diff_array(arr, out, 5);
    if (out + 0).* == 2 and (out + 3).* == 5 { return 42; }
    return 1;
}


// Parity test: arrays/arr_029_scale
fn scale_parity_arr_029_scale(arr: *i64, n: i64, factor: i64) void {
    var i: i64 = 0;
    while i < n {
        (arr + i).* = (arr + i).* * factor;
        i = i + 1;
    }
}
fn test_parity_arr_029_scale() i64 {
    var arr: *i64 = malloc(32);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 3;
    (arr + 3).* = 4;
    scale_parity_arr_029_scale(arr, 4, 10);
    if (arr + 0).* == 10 and (arr + 3).* == 40 { return 42; }
    return 1;
}


// Parity test: arrays/arr_030_add_arrays
fn add_arrays_parity_arr_030_add_arrays(a: *i64, b: *i64, out: *i64, n: i64) void {
    var i: i64 = 0;
    while i < n {
        (out + i).* = (a + i).* + (b + i).*;
        i = i + 1;
    }
}
fn test_parity_arr_030_add_arrays() i64 {
    var a: *i64 = malloc(24);
    var b: *i64 = malloc(24);
    var out: *i64 = malloc(24);
    (a + 0).* = 10; (a + 1).* = 20; (a + 2).* = 30;
    (b + 0).* = 1; (b + 1).* = 2; (b + 2).* = 3;
    add_arrays_parity_arr_030_add_arrays(a, b, out, 3);
    if (out + 0).* == 11 and (out + 2).* == 33 { return 42; }
    return 1;
}


// Parity test: arrays/arr_031_reverse_in_place
fn reverse_parity_arr_031_reverse_in_place(arr: *i64, n: i64) void {
    var i: i64 = 0;
    var j: i64 = n - 1;
    while i < j {
        var t: i64 = (arr + i).*;
        (arr + i).* = (arr + j).*;
        (arr + j).* = t;
        i = i + 1;
        j = j - 1;
    }
}
fn test_parity_arr_031_reverse_in_place() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 3;
    (arr + 3).* = 4;
    (arr + 4).* = 5;
    reverse_parity_arr_031_reverse_in_place(arr, 5);
    if (arr + 0).* == 5 and (arr + 4).* == 1 and (arr + 2).* == 3 { return 42; }
    return 1;
}


// Parity test: arrays/arr_032_partition
fn count_less_parity_arr_032_partition(arr: *i64, n: i64, pivot: i64) i64 {
    var count: i64 = 0;
    var i: i64 = 0;
    while i < n {
        if (arr + i).* < pivot {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}
fn test_parity_arr_032_partition() i64 {
    var arr: *i64 = malloc(56);
    (arr + 0).* = 3;
    (arr + 1).* = 1;
    (arr + 2).* = 4;
    (arr + 3).* = 1;
    (arr + 4).* = 5;
    (arr + 5).* = 9;
    (arr + 6).* = 2;
    if count_less_parity_arr_032_partition(arr, 7, 4) == 4 { return 42; }
    return 1;
}


// Parity test: arrays/arr_033_find_index
fn find_index_parity_arr_033_find_index(arr: *i64, n: i64, val: i64) i64 {
    var i: i64 = 0;
    while i < n {
        if (arr + i).* == val {
            return i;
        }
        i = i + 1;
    }
    return 0 - 1;
}
fn test_parity_arr_033_find_index() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 10;
    (arr + 1).* = 20;
    (arr + 2).* = 30;
    (arr + 3).* = 40;
    (arr + 4).* = 50;
    if find_index_parity_arr_033_find_index(arr, 5, 30) == 2 { return 42; }
    return 1;
}


// Parity test: arrays/arr_034_contains
fn contains_parity_arr_034_contains(arr: *i64, n: i64, val: i64) i64 {
    var i: i64 = 0;
    while i < n {
        if (arr + i).* == val {
            return 1;
        }
        i = i + 1;
    }
    return 0;
}
fn test_parity_arr_034_contains() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 10;
    (arr + 1).* = 20;
    (arr + 2).* = 30;
    (arr + 3).* = 40;
    (arr + 4).* = 50;
    var r1: i64 = contains_parity_arr_034_contains(arr, 5, 30);
    var r2: i64 = contains_parity_arr_034_contains(arr, 5, 35);
    if r1 == 1 and r2 == 0 { return 42; }
    return 1;
}


// Parity test: arrays/arr_035_unique_count
fn count_unique_parity_arr_035_unique_count(arr: *i64, n: i64) i64 {
    var count: i64 = 0;
    var i: i64 = 0;
    while i < n {
        var unique: i64 = 1;
        var j: i64 = 0;
        while j < i {
            if (arr + j).* == (arr + i).* {
                unique = 0;
            }
            j = j + 1;
        }
        count = count + unique;
        i = i + 1;
    }
    return count;
}
fn test_parity_arr_035_unique_count() i64 {
    var arr: *i64 = malloc(56);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 1;
    (arr + 3).* = 3;
    (arr + 4).* = 2;
    (arr + 5).* = 1;
    (arr + 6).* = 4;
    if count_unique_parity_arr_035_unique_count(arr, 7) == 4 { return 42; }
    return 1;
}


// Parity test: arrays/arr_036_copy_array
fn copy_array_parity_arr_036_copy_array(src: *i64, dst: *i64, n: i64) void {
    var i: i64 = 0;
    while i < n {
        (dst + i).* = (src + i).*;
        i = i + 1;
    }
}
fn test_parity_arr_036_copy_array() i64 {
    var src: *i64 = malloc(40);
    var dst: *i64 = malloc(40);
    (src + 0).* = 10;
    (src + 1).* = 20;
    (src + 2).* = 30;
    (src + 3).* = 40;
    (src + 4).* = 50;
    copy_array_parity_arr_036_copy_array(src, dst, 5);
    if (dst + 2).* == 30 and (dst + 4).* == 50 { return 42; }
    return 1;
}


// Parity test: arrays/arr_037_fill_array
fn fill_parity_arr_037_fill_array(arr: *i64, n: i64, val: i64) void {
    var i: i64 = 0;
    while i < n {
        (arr + i).* = val;
        i = i + 1;
    }
}
fn test_parity_arr_037_fill_array() i64 {
    var arr: *i64 = malloc(40);
    fill_parity_arr_037_fill_array(arr, 5, 42);
    if (arr + 0).* == 42 and (arr + 2).* == 42 and (arr + 4).* == 42 { return 42; }
    return 1;
}


// Parity test: arrays/arr_038_swap_elements
fn swap_parity_arr_038_swap_elements(arr: *i64, i: i64, j: i64) void {
    var t: i64 = (arr + i).*;
    (arr + i).* = (arr + j).*;
    (arr + j).* = t;
}
fn test_parity_arr_038_swap_elements() i64 {
    var arr: *i64 = malloc(24);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 3;
    swap_parity_arr_038_swap_elements(arr, 0, 2);
    if (arr + 0).* == 3 and (arr + 2).* == 1 { return 42; }
    return 1;
}


// Parity test: arrays/arr_039_rotate_left
fn rotate_left_parity_arr_039_rotate_left(arr: *i64, n: i64) void {
    if n < 2 { return; }
    var first: i64 = (arr + 0).*;
    var i: i64 = 0;
    while i < n - 1 {
        (arr + i).* = (arr + i + 1).*;
        i = i + 1;
    }
    (arr + n - 1).* = first;
}
fn test_parity_arr_039_rotate_left() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 3;
    (arr + 3).* = 4;
    (arr + 4).* = 5;
    rotate_left_parity_arr_039_rotate_left(arr, 5);
    if (arr + 0).* == 2 and (arr + 4).* == 1 { return 42; }
    return 1;
}


// Parity test: arrays/arr_040_rotate_right
fn rotate_right_parity_arr_040_rotate_right(arr: *i64, n: i64) void {
    if n < 2 { return; }
    var last: i64 = (arr + n - 1).*;
    var i: i64 = n - 1;
    while i > 0 {
        (arr + i).* = (arr + i - 1).*;
        i = i - 1;
    }
    (arr + 0).* = last;
}
fn test_parity_arr_040_rotate_right() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 3;
    (arr + 3).* = 4;
    (arr + 4).* = 5;
    rotate_right_parity_arr_040_rotate_right(arr, 5);
    if (arr + 0).* == 5 and (arr + 4).* == 4 { return 42; }
    return 1;
}


// Parity test: arrays/arr_041_is_sorted
fn is_sorted_parity_arr_041_is_sorted(arr: *i64, n: i64) i64 {
    var i: i64 = 1;
    while i < n {
        if (arr + i - 1).* > (arr + i).* {
            return 0;
        }
        i = i + 1;
    }
    return 1;
}
fn test_parity_arr_041_is_sorted() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 3;
    (arr + 3).* = 4;
    (arr + 4).* = 5;
    var r1: i64 = is_sorted_parity_arr_041_is_sorted(arr, 5);
    (arr + 2).* = 10;
    var r2: i64 = is_sorted_parity_arr_041_is_sorted(arr, 5);
    if r1 == 1 and r2 == 0 { return 42; }
    return 1;
}


// Parity test: arrays/arr_042_count_if
fn count_greater_parity_arr_042_count_if(arr: *i64, n: i64, threshold: i64) i64 {
    var count: i64 = 0;
    var i: i64 = 0;
    while i < n {
        if (arr + i).* > threshold {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}
fn test_parity_arr_042_count_if() i64 {
    var arr: *i64 = malloc(56);
    (arr + 0).* = 3;
    (arr + 1).* = 1;
    (arr + 2).* = 4;
    (arr + 3).* = 1;
    (arr + 4).* = 5;
    (arr + 5).* = 9;
    (arr + 6).* = 2;
    if count_greater_parity_arr_042_count_if(arr, 7, 3) == 3 { return 42; }
    return 1;
}


// Parity test: arrays/arr_043_all_positive
fn all_positive_parity_arr_043_all_positive(arr: *i64, n: i64) i64 {
    var i: i64 = 0;
    while i < n {
        if (arr + i).* <= 0 {
            return 0;
        }
        i = i + 1;
    }
    return 1;
}
fn test_parity_arr_043_all_positive() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 3;
    (arr + 3).* = 4;
    (arr + 4).* = 5;
    var r1: i64 = all_positive_parity_arr_043_all_positive(arr, 5);
    (arr + 2).* = 0 - 1;
    var r2: i64 = all_positive_parity_arr_043_all_positive(arr, 5);
    if r1 == 1 and r2 == 0 { return 42; }
    return 1;
}


// Parity test: arrays/arr_044_any_zero
fn any_zero_parity_arr_044_any_zero(arr: *i64, n: i64) i64 {
    var i: i64 = 0;
    while i < n {
        if (arr + i).* == 0 {
            return 1;
        }
        i = i + 1;
    }
    return 0;
}
fn test_parity_arr_044_any_zero() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 3;
    (arr + 3).* = 4;
    (arr + 4).* = 5;
    var r1: i64 = any_zero_parity_arr_044_any_zero(arr, 5);
    (arr + 2).* = 0;
    var r2: i64 = any_zero_parity_arr_044_any_zero(arr, 5);
    if r1 == 0 and r2 == 1 { return 42; }
    return 1;
}


// Parity test: arrays/arr_045_second_largest
fn second_largest_parity_arr_045_second_largest(arr: *i64, n: i64) i64 {
    if n < 2 { return 0; }
    var first: i64 = (arr + 0).*;
    var second: i64 = (arr + 0).*;
    if (arr + 1).* > first {
        second = first;
        first = (arr + 1).*;
    } else {
        second = (arr + 1).*;
    }
    var i: i64 = 2;
    while i < n {
        var val: i64 = (arr + i).*;
        if val > first {
            second = first;
            first = val;
        } else if val > second {
            second = val;
        }
        i = i + 1;
    }
    return second;
}
fn test_parity_arr_045_second_largest() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 10;
    (arr + 1).* = 50;
    (arr + 2).* = 30;
    (arr + 3).* = 40;
    (arr + 4).* = 20;
    if second_largest_parity_arr_045_second_largest(arr, 5) == 40 { return 42; }
    return 1;
}


// Parity test: arrays/arr_046_selection_sort
fn selection_sort_parity_arr_046_selection_sort(arr: *i64, n: i64) void {
    var i: i64 = 0;
    while i < n - 1 {
        var min_idx: i64 = i;
        var j: i64 = i + 1;
        while j < n {
            if (arr + j).* < (arr + min_idx).* {
                min_idx = j;
            }
            j = j + 1;
        }
        if min_idx != i {
            var t: i64 = (arr + i).*;
            (arr + i).* = (arr + min_idx).*;
            (arr + min_idx).* = t;
        }
        i = i + 1;
    }
}
fn test_parity_arr_046_selection_sort() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 5;
    (arr + 1).* = 3;
    (arr + 2).* = 1;
    (arr + 3).* = 4;
    (arr + 4).* = 2;
    selection_sort_parity_arr_046_selection_sort(arr, 5);
    if (arr + 0).* == 1 { return 42; }
    return 1;
}


// Parity test: arrays/arr_047_find_max_index
fn find_max_idx_parity_arr_047_find_max_index(arr: *i64, n: i64) i64 {
    var max_idx: i64 = 0;
    var i: i64 = 1;
    while i < n {
        if (arr + i).* > (arr + max_idx).* {
            max_idx = i;
        }
        i = i + 1;
    }
    return max_idx;
}
fn test_parity_arr_047_find_max_index() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 10;
    (arr + 1).* = 50;
    (arr + 2).* = 30;
    (arr + 3).* = 40;
    (arr + 4).* = 20;
    if find_max_idx_parity_arr_047_find_max_index(arr, 5) == 1 { return 42; }
    return 1;
}


// Parity test: arrays/arr_048_find_min_index
fn find_min_idx_parity_arr_048_find_min_index(arr: *i64, n: i64) i64 {
    var min_idx: i64 = 0;
    var i: i64 = 1;
    while i < n {
        if (arr + i).* < (arr + min_idx).* {
            min_idx = i;
        }
        i = i + 1;
    }
    return min_idx;
}
fn test_parity_arr_048_find_min_index() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 30;
    (arr + 1).* = 50;
    (arr + 2).* = 10;
    (arr + 3).* = 40;
    (arr + 4).* = 20;
    if find_min_idx_parity_arr_048_find_min_index(arr, 5) == 2 { return 42; }
    return 1;
}


// Parity test: arrays/arr_049_prefix_sum
fn prefix_sum_parity_arr_049_prefix_sum(arr: *i64, n: i64) void {
    var i: i64 = 1;
    while i < n {
        (arr + i).* = (arr + i).* + (arr + i - 1).*;
        i = i + 1;
    }
}
fn test_parity_arr_049_prefix_sum() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 3;
    (arr + 3).* = 4;
    (arr + 4).* = 5;
    prefix_sum_parity_arr_049_prefix_sum(arr, 5);
    if (arr + 4).* == 15 { return 42; }
    return 1;
}


// Parity test: arrays/arr_050_difference
fn differences_parity_arr_050_difference(arr: *i64, diff: *i64, n: i64) void {
    var i: i64 = 0;
    while i < n - 1 {
        (diff + i).* = (arr + i + 1).* - (arr + i).*;
        i = i + 1;
    }
}
fn test_parity_arr_050_difference() i64 {
    var arr: *i64 = malloc(40);
    var diff: *i64 = malloc(32);
    (arr + 0).* = 1;
    (arr + 1).* = 3;
    (arr + 2).* = 6;
    (arr + 3).* = 10;
    (arr + 4).* = 15;
    differences_parity_arr_050_difference(arr, diff, 5);
    if (diff + 0).* == 2 { return 42; }
    return 1;
}


// Parity test: arrays/arr_051_dot_product
fn dot_product_parity_arr_051_dot_product(a: *i64, b: *i64, n: i64) i64 {
    var result: i64 = 0;
    var i: i64 = 0;
    while i < n {
        result = result + (a + i).* * (b + i).*;
        i = i + 1;
    }
    return result;
}
fn test_parity_arr_051_dot_product() i64 {
    var a: *i64 = malloc(24);
    var b: *i64 = malloc(24);
    (a + 0).* = 1; (b + 0).* = 4;
    (a + 1).* = 2; (b + 1).* = 5;
    (a + 2).* = 3; (b + 2).* = 6;
    if dot_product_parity_arr_051_dot_product(a, b, 3) == 32 { return 42; }
    return 1;
}


// Parity test: arrays/arr_052_element_wise_add
fn add_arrays_parity_arr_052_element_wise_add(a: *i64, b: *i64, c: *i64, n: i64) void {
    var i: i64 = 0;
    while i < n {
        (c + i).* = (a + i).* + (b + i).*;
        i = i + 1;
    }
}
fn test_parity_arr_052_element_wise_add() i64 {
    var a: *i64 = malloc(24);
    var b: *i64 = malloc(24);
    var c: *i64 = malloc(24);
    (a + 0).* = 1; (b + 0).* = 10;
    (a + 1).* = 2; (b + 1).* = 20;
    (a + 2).* = 3; (b + 2).* = 30;
    add_arrays_parity_arr_052_element_wise_add(a, b, c, 3);
    if (c + 1).* == 22 { return 42; }
    return 1;
}


// Parity test: arrays/arr_053_scale_array
fn scale_parity_arr_053_scale_array(arr: *i64, n: i64, factor: i64) void {
    var i: i64 = 0;
    while i < n {
        (arr + i).* = (arr + i).* * factor;
        i = i + 1;
    }
}
fn test_parity_arr_053_scale_array() i64 {
    var arr: *i64 = malloc(32);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 3;
    (arr + 3).* = 4;
    scale_parity_arr_053_scale_array(arr, 4, 10);
    if (arr + 2).* == 30 { return 42; }
    return 1;
}


// Parity test: arrays/arr_054_find_last
fn find_last_parity_arr_054_find_last(arr: *i64, n: i64, val: i64) i64 {
    var last_idx: i64 = 0 - 1;
    var i: i64 = 0;
    while i < n {
        if (arr + i).* == val {
            last_idx = i;
        }
        i = i + 1;
    }
    return last_idx;
}
fn test_parity_arr_054_find_last() i64 {
    var arr: *i64 = malloc(48);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 3;
    (arr + 3).* = 2;
    (arr + 4).* = 1;
    (arr + 5).* = 2;
    if find_last_parity_arr_054_find_last(arr, 6, 2) == 5 { return 42; }
    return 1;
}


// Parity test: arrays/arr_055_count_value
fn count_value_parity_arr_055_count_value(arr: *i64, n: i64, val: i64) i64 {
    var count: i64 = 0;
    var i: i64 = 0;
    while i < n {
        if (arr + i).* == val {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}
fn test_parity_arr_055_count_value() i64 {
    var arr: *i64 = malloc(56);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 3;
    (arr + 3).* = 2;
    (arr + 4).* = 1;
    (arr + 5).* = 2;
    (arr + 6).* = 1;
    if count_value_parity_arr_055_count_value(arr, 7, 2) == 3 { return 42; }
    return 1;
}


// Parity test: arrays/arr_056_binary_search
fn binary_search_parity_arr_056_binary_search(arr: *i64, n: i64, target: i64) i64 {
    var lo: i64 = 0;
    var hi: i64 = n;
    while lo < hi {
        var mid: i64 = (lo + hi) / 2;
        if (arr + mid).* < target {
            lo = mid + 1;
        } else {
            hi = mid;
        }
    }
    if lo < n {
        if (arr + lo).* == target { return lo; }
    }
    return 0 - 1;
}
fn test_parity_arr_056_binary_search() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 10;
    (arr + 1).* = 20;
    (arr + 2).* = 30;
    (arr + 3).* = 40;
    (arr + 4).* = 50;
    if binary_search_parity_arr_056_binary_search(arr, 5, 30) == 2 { return 42; }
    return 1;
}


// Parity test: arrays/arr_057_lower_bound
fn lower_bound_parity_arr_057_lower_bound(arr: *i64, n: i64, target: i64) i64 {
    var lo: i64 = 0;
    var hi: i64 = n;
    while lo < hi {
        var mid: i64 = (lo + hi) / 2;
        if (arr + mid).* < target {
            lo = mid + 1;
        } else {
            hi = mid;
        }
    }
    return lo;
}
fn test_parity_arr_057_lower_bound() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 10;
    (arr + 1).* = 20;
    (arr + 2).* = 30;
    (arr + 3).* = 40;
    (arr + 4).* = 50;
    if lower_bound_parity_arr_057_lower_bound(arr, 5, 25) == 2 { return 42; }
    return 1;
}


// Parity test: arrays/arr_058_upper_bound
fn upper_bound_parity_arr_058_upper_bound(arr: *i64, n: i64, target: i64) i64 {
    var lo: i64 = 0;
    var hi: i64 = n;
    while lo < hi {
        var mid: i64 = (lo + hi) / 2;
        if (arr + mid).* <= target {
            lo = mid + 1;
        } else {
            hi = mid;
        }
    }
    return lo;
}
fn test_parity_arr_058_upper_bound() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 10;
    (arr + 1).* = 20;
    (arr + 2).* = 30;
    (arr + 3).* = 40;
    (arr + 4).* = 50;
    if upper_bound_parity_arr_058_upper_bound(arr, 5, 30) == 3 { return 42; }
    return 1;
}


// Parity test: arrays/arr_059_merge
fn merge_parity_arr_059_merge(a: *i64, na: i64, b: *i64, nb: i64, out: *i64) void {
    var i: i64 = 0;
    var j: i64 = 0;
    var k: i64 = 0;
    while i < na {
        if j < nb {
            if (a + i).* <= (b + j).* {
                (out + k).* = (a + i).*;
                i = i + 1;
            } else {
                (out + k).* = (b + j).*;
                j = j + 1;
            }
        } else {
            (out + k).* = (a + i).*;
            i = i + 1;
        }
        k = k + 1;
    }
    while j < nb {
        (out + k).* = (b + j).*;
        j = j + 1;
        k = k + 1;
    }
}
fn test_parity_arr_059_merge() i64 {
    var a: *i64 = malloc(24);
    var b: *i64 = malloc(24);
    var out: *i64 = malloc(48);
    (a + 0).* = 1; (a + 1).* = 3; (a + 2).* = 5;
    (b + 0).* = 2; (b + 1).* = 4; (b + 2).* = 6;
    merge_parity_arr_059_merge(a, 3, b, 3, out);
    if (out + 2).* == 3 { return 42; }
    return 1;
}


// Parity test: arrays/arr_060_remove_element
fn remove_elem_parity_arr_060_remove_element(arr: *i64, n: i64, val: i64) i64 {
    var write: i64 = 0;
    var read: i64 = 0;
    while read < n {
        if (arr + read).* != val {
            (arr + write).* = (arr + read).*;
            write = write + 1;
        }
        read = read + 1;
    }
    return write;
}
fn test_parity_arr_060_remove_element() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 3;
    (arr + 3).* = 2;
    (arr + 4).* = 4;
    var new_len: i64 = remove_elem_parity_arr_060_remove_element(arr, 5, 2);
    if new_len == 3 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_001_if
fn check_parity_cf_001_if(x: i64) i64 { if x > 0 { return 1; } return 0; }
fn test_parity_cf_001_if() i64 { if check_parity_cf_001_if(5) == 1 { return 42; } return 1; }


// Parity test: control_flow/cf_002_while
fn sum_parity_cf_002_while(n: i64) i64 { var s: i64 = 0; var i: i64 = 0; while i < n { s = s + i; i = i + 1; } return s; }
fn test_parity_cf_002_while() i64 { if sum_parity_cf_002_while(5) == 10 { return 42; } return 1; }


// Parity test: control_flow/cf_003_nested_if
fn classify_parity_cf_003_nested_if(x: i64) i64 {
    if x > 0 {
        if x > 10 { return 2; }
        return 1;
    }
    return 0;
}
fn test_parity_cf_003_nested_if() i64 { if classify_parity_cf_003_nested_if(5) == 1 { return 42; } return 1; }


// Parity test: control_flow/cf_004_else
fn test_else_parity_cf_004_else(x: i64) i64 {
    if x > 0 { return 1; }
    else { return 0; }
}
fn test_parity_cf_004_else() i64 { if test_else_parity_cf_004_else(5) == 1 { return 42; } return 1; }


// Parity test: control_flow/cf_005_else_if
fn classify_parity_cf_005_else_if(x: i64) i64 {
    if x < 0 { return 0; }
    else if x == 0 { return 1; }
    else { return 2; }
}
fn test_parity_cf_005_else_if() i64 { if classify_parity_cf_005_else_if(0) == 1 { return 42; } return 1; }


// Parity test: control_flow/cf_006_while_break
fn find_first_gt_parity_cf_006_while_break(limit: i64) i64 {
    var i: i64 = 0;
    while i < 100 {
        if i > limit { break; }
        i = i + 1;
    }
    return i;
}
fn test_parity_cf_006_while_break() i64 { if find_first_gt_parity_cf_006_while_break(10) == 11 { return 42; } return 1; }


// Parity test: control_flow/cf_007_while_continue
fn sum_odd_parity_cf_007_while_continue(n: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 0;
    while i < n {
        i = i + 1;
        if (i % 2) == 0 { continue; }
        sum = sum + i;
    }
    return sum;
}
fn test_parity_cf_007_while_continue() i64 { if sum_odd_parity_cf_007_while_continue(10) == 25 { return 42; } return 1; }


// Parity test: control_flow/cf_008_nested_while
fn mul_table_sum_parity_cf_008_nested_while(n: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    while i <= n {
        var j: i64 = 1;
        while j <= n {
            sum = sum + (i * j);
            j = j + 1;
        }
        i = i + 1;
    }
    return sum;
}
fn test_parity_cf_008_nested_while() i64 { if mul_table_sum_parity_cf_008_nested_while(3) == 36 { return 42; } return 1; }


// Parity test: control_flow/cf_009_early_return
fn find_zero_parity_cf_009_early_return(a: i64, b: i64, c: i64) i64 {
    if a == 0 { return 1; }
    if b == 0 { return 2; }
    if c == 0 { return 3; }
    return 0;
}
fn test_parity_cf_009_early_return() i64 { if find_zero_parity_cf_009_early_return(1, 0, 1) == 2 { return 42; } return 1; }


// Parity test: control_flow/cf_010_multi_cond
fn check_parity_cf_010_multi_cond(a: i64, b: i64, c: i64) i64 {
    if a > 0 {
        if b > 0 {
            if c > 0 { return 1; }
        }
    }
    return 0;
}
fn test_parity_cf_010_multi_cond() i64 { if check_parity_cf_010_multi_cond(1, 2, 3) == 1 { return 42; } return 1; }


// Parity test: control_flow/cf_011_deep_nest
fn deep_nest_parity_cf_011_deep_nest(x: i64) i64 {
    if x > 0 {
        if x > 5 {
            if x > 10 {
                if x > 15 { return 4; }
                return 3;
            }
            return 2;
        }
        return 1;
    }
    return 0;
}
fn test_parity_cf_011_deep_nest() i64 { if deep_nest_parity_cf_011_deep_nest(12) == 3 { return 42; } return 1; }


// Parity test: control_flow/cf_012_if_in_while
fn sum_even_parity_cf_012_if_in_while(n: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 0;
    while i <= n {
        if (i % 2) == 0 { sum = sum + i; }
        i = i + 1;
    }
    return sum;
}
fn test_parity_cf_012_if_in_while() i64 { if sum_even_parity_cf_012_if_in_while(10) == 30 { return 42; } return 1; }


// Parity test: control_flow/cf_013_while_in_if
fn conditional_sum_parity_cf_013_while_in_if(do_sum: i64, n: i64) i64 {
    if do_sum != 0 {
        var sum: i64 = 0;
        var i: i64 = 1;
        while i <= n {
            sum = sum + i;
            i = i + 1;
        }
        return sum;
    }
    return 0;
}
fn test_parity_cf_013_while_in_if() i64 { if conditional_sum_parity_cf_013_while_in_if(1, 5) == 15 { return 42; } return 1; }


// Parity test: control_flow/cf_014_break_nested
fn find_product_parity_cf_014_break_nested(limit: i64) i64 {
    var result: i64 = 0;
    var i: i64 = 1;
    while i < 10 {
        var j: i64 = 1;
        while j < 10 {
            if i * j > limit {
                result = i * j;
                break;
            }
            j = j + 1;
        }
        if result > 0 { break; }
        i = i + 1;
    }
    return result;
}
fn test_parity_cf_014_break_nested() i64 { if find_product_parity_cf_014_break_nested(20) == 21 { return 42; } return 1; }


// Parity test: control_flow/cf_015_multi_return
fn multi_return_parity_cf_015_multi_return(x: i64) i64 {
    if x < 0 { return -1; }
    if x == 0 { return 0; }
    if x < 10 { return 1; }
    if x < 100 { return 2; }
    return 3;
}
fn test_parity_cf_015_multi_return() i64 { if multi_return_parity_cf_015_multi_return(50) == 2 { return 42; } return 1; }


// Parity test: control_flow/cf_016_count_down
fn count_down_parity_cf_016_count_down(n: i64) i64 {
    var count: i64 = 0;
    var i: i64 = n;
    while i > 0 {
        count = count + 1;
        i = i - 1;
    }
    return count;
}
fn test_parity_cf_016_count_down() i64 { if count_down_parity_cf_016_count_down(10) == 10 { return 42; } return 1; }


// Parity test: control_flow/cf_017_gcd
// NOTE: Zig treats function params as const, so use local vars
fn gcd_parity_cf_017_gcd(a_in: i64, b_in: i64) i64 {
    var a: i64 = a_in;
    var b: i64 = b_in;
    while b != 0 {
        var t: i64 = b;
        b = a % b;
        a = t;
    }
    return a;
}
fn test_parity_cf_017_gcd() i64 { if gcd_parity_cf_017_gcd(48, 18) == 6 { return 42; } return 1; }


// Parity test: control_flow/cf_018_fizzbuzz_count
fn count_fizzbuzz_parity_cf_018_fizzbuzz_count(n: i64) i64 {
    var count: i64 = 0;
    var i: i64 = 1;
    while i <= n {
        if (i % 3) == 0 {
            if (i % 5) == 0 { count = count + 1; }
        }
        i = i + 1;
    }
    return count;
}
fn test_parity_cf_018_fizzbuzz_count() i64 { if count_fizzbuzz_parity_cf_018_fizzbuzz_count(30) == 2 { return 42; } return 1; }


// Parity test: control_flow/cf_019_find_first
fn find_first_divisible_parity_cf_019_find_first(n: i64, divisor: i64) i64 {
    var i: i64 = 1;
    while i <= n {
        if (i % divisor) == 0 { return i; }
        i = i + 1;
    }
    return 0;
}
fn test_parity_cf_019_find_first() i64 { if find_first_divisible_parity_cf_019_find_first(10, 3) == 3 { return 42; } return 1; }


// Parity test: control_flow/cf_020_sum_digits
fn sum_digits_parity_cf_020_sum_digits(n: i64) i64 {
    var sum: i64 = 0;
    var x: i64 = n;
    while x > 0 {
        sum = sum + (x % 10);
        x = x / 10;
    }
    return sum;
}
fn test_parity_cf_020_sum_digits() i64 { if sum_digits_parity_cf_020_sum_digits(12345) == 15 { return 42; } return 1; }


// Parity test: control_flow/cf_021_binary_search
fn binary_search_parity_cf_021_binary_search(arr: *i64, len: i64, target: i64) i64 {
    var lo: i64 = 0;
    var hi: i64 = len - 1;
    while lo <= hi {
        var mid: i64 = (lo + hi) / 2;
        var val: i64 = (arr + mid).*;
        if val == target { return mid; }
        if val < target { lo = mid + 1; }
        else { hi = mid - 1; }
    }
    return -1;
}
fn test_parity_cf_021_binary_search() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 1; (arr + 1).* = 3; (arr + 2).* = 5;
    (arr + 3).* = 7; (arr + 4).* = 9;
    if binary_search_parity_cf_021_binary_search(arr, 5, 5) == 2 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_022_linear_search
fn linear_search_parity_cf_022_linear_search(arr: *i64, len: i64, target: i64) i64 {
    var i: i64 = 0;
    while i < len {
        if (arr + i).* == target { return i; }
        i = i + 1;
    }
    return -1;
}
fn test_parity_cf_022_linear_search() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 3; (arr + 1).* = 1; (arr + 2).* = 4;
    (arr + 3).* = 1; (arr + 4).* = 5;
    if linear_search_parity_cf_022_linear_search(arr, 5, 4) == 2 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_023_bubble_sort
fn bubble_sort_parity_cf_023_bubble_sort(arr: *i64, len: i64) void {
    var i: i64 = 0;
    while i < len - 1 {
        var j: i64 = 0;
        while j < len - 1 - i {
            var a: i64 = (arr + j).*;
            var b: i64 = (arr + j + 1).*;
            if a > b {
                (arr + j).* = b;
                (arr + j + 1).* = a;
            }
            j = j + 1;
        }
        i = i + 1;
    }
}
fn test_parity_cf_023_bubble_sort() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 5; (arr + 1).* = 2; (arr + 2).* = 4;
    (arr + 3).* = 1; (arr + 4).* = 3;
    bubble_sort_parity_cf_023_bubble_sort(arr, 5);
    if (arr + 0).* == 1 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_024_array_max
fn array_max_parity_cf_024_array_max(arr: *i64, len: i64) i64 {
    var max: i64 = (arr + 0).*;
    var i: i64 = 1;
    while i < len {
        var val: i64 = (arr + i).*;
        if val > max { max = val; }
        i = i + 1;
    }
    return max;
}
fn test_parity_cf_024_array_max() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 3; (arr + 1).* = 7; (arr + 2).* = 2;
    (arr + 3).* = 9; (arr + 4).* = 5;
    if array_max_parity_cf_024_array_max(arr, 5) == 9 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_025_array_min
fn array_min_parity_cf_025_array_min(arr: *i64, len: i64) i64 {
    var min: i64 = (arr + 0).*;
    var i: i64 = 1;
    while i < len {
        var val: i64 = (arr + i).*;
        if val < min { min = val; }
        i = i + 1;
    }
    return min;
}
fn test_parity_cf_025_array_min() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 3; (arr + 1).* = 7; (arr + 2).* = 2;
    (arr + 3).* = 9; (arr + 4).* = 5;
    if array_min_parity_cf_025_array_min(arr, 5) == 2 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_026_empty_while
fn count_to_parity_cf_026_empty_while(n: i64) i64 {
    var i: i64 = 0;
    while i < n { i = i + 1; }
    return i;
}
fn test_parity_cf_026_empty_while() i64 { if count_to_parity_cf_026_empty_while(100) == 100 { return 42; } return 1; }


// Parity test: control_flow/cf_027_false_cond
fn false_cond_parity_cf_027_false_cond() i64 {
    if 0 != 0 { return 1; }
    return 0;
}
fn test_parity_cf_027_false_cond() i64 { if false_cond_parity_cf_027_false_cond() == 0 { return 42; } return 1; }


// Parity test: control_flow/cf_028_true_cond
fn true_cond_parity_cf_028_true_cond() i64 {
    if 1 == 1 { return 42; }
    return 0;
}
fn test_parity_cf_028_true_cond() i64 { if true_cond_parity_cf_028_true_cond() == 42 { return 42; } return 1; }


// Parity test: control_flow/cf_029_nested_break
fn find_sum_gt_parity_cf_029_nested_break(limit: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    while i < 100 {
        sum = sum + i;
        if sum > limit { break; }
        i = i + 1;
    }
    return sum;
}
fn test_parity_cf_029_nested_break() i64 { if find_sum_gt_parity_cf_029_nested_break(50) == 55 { return 42; } return 1; }


// Parity test: control_flow/cf_030_multiple_breaks
fn first_divisible_parity_cf_030_multiple_breaks(n: i64, d1: i64, d2: i64) i64 {
    var i: i64 = 1;
    while i <= n {
        if (i % d1) == 0 { break; }
        if (i % d2) == 0 { break; }
        i = i + 1;
    }
    return i;
}
fn test_parity_cf_030_multiple_breaks() i64 { if first_divisible_parity_cf_030_multiple_breaks(20, 7, 11) == 7 { return 42; } return 1; }


// Parity test: control_flow/cf_031_long_chain
fn classify_parity_cf_031_long_chain(x: i64) i64 {
    if x < 10 { return 0; }
    else if x < 20 { return 1; }
    else if x < 30 { return 2; }
    else if x < 40 { return 3; }
    else if x < 50 { return 4; }
    else { return 5; }
}
fn test_parity_cf_031_long_chain() i64 { if classify_parity_cf_031_long_chain(35) == 3 { return 42; } return 1; }


// Parity test: control_flow/cf_032_while_zero
fn while_zero_parity_cf_032_while_zero() i64 {
    var count: i64 = 0;
    while 0 != 0 { count = count + 1; }
    return count;
}
fn test_parity_cf_032_while_zero() i64 { if while_zero_parity_cf_032_while_zero() == 0 { return 42; } return 1; }


// Parity test: control_flow/cf_033_nested_else
fn nested_else_parity_cf_033_nested_else(a: i64, b: i64) i64 {
    if a > 0 {
        if b > 0 { return 1; }
        else { return 2; }
    } else {
        if b > 0 { return 3; }
        else { return 4; }
    }
}
fn test_parity_cf_033_nested_else() i64 { if nested_else_parity_cf_033_nested_else(-1, 5) == 3 { return 42; } return 1; }


// Parity test: control_flow/cf_034_count_matches
fn count_matches_parity_cf_034_count_matches(limit: i64, mod_val: i64) i64 {
    var count: i64 = 0;
    var i: i64 = 1;
    while i <= limit {
        if (i % mod_val) == 0 { count = count + 1; }
        i = i + 1;
    }
    return count;
}
fn test_parity_cf_034_count_matches() i64 { if count_matches_parity_cf_034_count_matches(20, 4) == 5 { return 42; } return 1; }


// Parity test: control_flow/cf_035_alternating
fn sum_alternating_parity_cf_035_alternating(n: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    var sign: i64 = 1;
    while i <= n {
        sum = sum + sign * i;
        sign = -sign;
        i = i + 1;
    }
    return sum;
}
fn test_parity_cf_035_alternating() i64 { if sum_alternating_parity_cf_035_alternating(10) == -5 { return 42; } return 1; }


// Parity test: control_flow/cf_036_nested_continue
fn count_odd_in_range_parity_cf_036_nested_continue(lo: i64, hi: i64) i64 {
    var count: i64 = 0;
    var i: i64 = lo;
    while i <= hi {
        if (i % 2) == 0 { i = i + 1; continue; }
        count = count + 1;
        i = i + 1;
    }
    return count;
}
fn test_parity_cf_036_nested_continue() i64 { if count_odd_in_range_parity_cf_036_nested_continue(1, 10) == 5 { return 42; } return 1; }


// Parity test: control_flow/cf_037_double_loop
fn sum_matrix_parity_cf_037_double_loop(n: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    while i <= n {
        var j: i64 = 1;
        while j <= n {
            sum = sum + i * j;
            j = j + 1;
        }
        i = i + 1;
    }
    return sum;
}
fn test_parity_cf_037_double_loop() i64 { if sum_matrix_parity_cf_037_double_loop(4) == 100 { return 42; } return 1; }


// Parity test: control_flow/cf_038_nested_while
fn test_parity_cf_038_nested_while() i64 {
    var sum: i64 = 0;
    var i: i64 = 0;
    while i < 5 {
        var j: i64 = 0;
        while j < 5 {
            sum = sum + 1;
            j = j + 1;
        }
        i = i + 1;
    }
    if sum == 25 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_039_triple_nested
fn test_parity_cf_039_triple_nested() i64 {
    var sum: i64 = 0;
    var i: i64 = 0;
    while i < 3 {
        var j: i64 = 0;
        while j < 3 {
            var k: i64 = 0;
            while k < 3 {
                sum = sum + 1;
                k = k + 1;
            }
            j = j + 1;
        }
        i = i + 1;
    }
    if sum == 27 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_040_if_in_while
fn test_parity_cf_040_if_in_while() i64 {
    var count: i64 = 0;
    var i: i64 = 0;
    while i < 10 {
        if i % 2 == 0 {
            count = count + 1;
        }
        i = i + 1;
    }
    if count == 5 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_041_while_in_if
fn test_parity_cf_041_while_in_if() i64 {
    var x: i64 = 5;
    var sum: i64 = 0;
    if x > 0 {
        var i: i64 = 0;
        while i < x {
            sum = sum + i;
            i = i + 1;
        }
    }
    if sum == 10 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_042_multi_cond
fn test_parity_cf_042_multi_cond() i64 {
    var a: i64 = 5;
    var b: i64 = 10;
    var c: i64 = 15;
    if a < b and b < c {
        if a + b == c {
            return 42;
        }
    }
    return 1;
}


// Parity test: control_flow/cf_043_or_cond
fn test_parity_cf_043_or_cond() i64 {
    var x: i64 = 5;
    if x == 3 or x == 5 or x == 7 {
        return 42;
    }
    return 1;
}


// Parity test: control_flow/cf_044_complex_bool
fn test_parity_cf_044_complex_bool() i64 {
    var a: i64 = 1;
    var b: i64 = 2;
    var c: i64 = 3;
    if (a < b and b < c) or (a == 1 and c == 3) {
        return 42;
    }
    return 1;
}


// Parity test: control_flow/cf_045_early_return
fn check_parity_cf_045_early_return(x: i64) i64 {
    if x < 0 { return 0 - 1; }
    if x == 0 { return 0; }
    if x == 1 { return 1; }
    return x * 2;
}
fn test_parity_cf_045_early_return() i64 {
    if check_parity_cf_045_early_return(0 - 5) == 0 - 1 and check_parity_cf_045_early_return(0) == 0 and check_parity_cf_045_early_return(1) == 1 and check_parity_cf_045_early_return(5) == 10 {
        return 42;
    }
    return 1;
}


// Parity test: control_flow/cf_046_cascade_if
fn grade_parity_cf_046_cascade_if(score: i64) i64 {
    if score >= 90 { return 4; }
    if score >= 80 { return 3; }
    if score >= 70 { return 2; }
    if score >= 60 { return 1; }
    return 0;
}
fn test_parity_cf_046_cascade_if() i64 {
    if grade_parity_cf_046_cascade_if(95) == 4 and grade_parity_cf_046_cascade_if(85) == 3 and grade_parity_cf_046_cascade_if(75) == 2 and grade_parity_cf_046_cascade_if(65) == 1 and grade_parity_cf_046_cascade_if(55) == 0 {
        return 42;
    }
    return 1;
}


// Parity test: control_flow/cf_047_while_flag
fn test_parity_cf_047_while_flag() i64 {
    var found: i64 = 0;
    var i: i64 = 0;
    while i < 100 and found == 0 {
        if i * i == 49 {
            found = 1;
        }
        i = i + 1;
    }
    if found == 1 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_048_deeply_nested
fn test_parity_cf_048_deeply_nested() i64 {
    var x: i64 = 100;
    if x > 0 {
        if x > 10 {
            if x > 50 {
                if x > 75 {
                    if x > 90 {
                        return 42;
                    }
                }
            }
        }
    }
    return 1;
}


// Parity test: control_flow/cf_049_if_else_chain
fn classify_parity_cf_049_if_else_chain(n: i64) i64 {
    if n < 0 { return 0 - 1; }
    if n == 0 { return 0; }
    if n < 10 { return 1; }
    if n < 100 { return 2; }
    return 3;
}
fn test_parity_cf_049_if_else_chain() i64 {
    var c1: i64 = classify_parity_cf_049_if_else_chain(0 - 5);
    var c2: i64 = classify_parity_cf_049_if_else_chain(0);
    var c3: i64 = classify_parity_cf_049_if_else_chain(5);
    var c4: i64 = classify_parity_cf_049_if_else_chain(50);
    var c5: i64 = classify_parity_cf_049_if_else_chain(500);
    if c1 == 0 - 1 and c2 == 0 and c3 == 1 and c4 == 2 and c5 == 3 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_051_early_exit
fn find_div3_parity_cf_051_early_exit(start: i64, end: i64) i64 {
    var i: i64 = start;
    while i <= end {
        if i % 3 == 0 { return i; }
        i = i + 1;
    }
    return 0 - 1;
}
fn test_parity_cf_051_early_exit() i64 {
    if find_div3_parity_cf_051_early_exit(10, 20) == 12 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_052_count_matches
fn count_in_range_parity_cf_052_count_matches(start: i64, end: i64, divisor: i64) i64 {
    var count: i64 = 0;
    var i: i64 = start;
    while i <= end {
        if i % divisor == 0 {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}
fn test_parity_cf_052_count_matches() i64 {
    if count_in_range_parity_cf_052_count_matches(1, 100, 7) == 14 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_053_sum_range
fn sum_range_parity_cf_053_sum_range(start: i64, end: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = start;
    while i <= end {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}
fn test_parity_cf_053_sum_range() i64 {
    if sum_range_parity_cf_053_sum_range(1, 100) == 5050 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_054_product_range
fn product_range_parity_cf_054_product_range(start: i64, end: i64) i64 {
    var prod: i64 = 1;
    var i: i64 = start;
    while i <= end {
        prod = prod * i;
        i = i + 1;
    }
    return prod;
}
fn test_parity_cf_054_product_range() i64 {
    if product_range_parity_cf_054_product_range(1, 6) == 720 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_055_skip_evens
fn sum_odds_parity_cf_055_skip_evens(n: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    while i <= n {
        if i % 2 == 1 {
            sum = sum + i;
        }
        i = i + 1;
    }
    return sum;
}
fn test_parity_cf_055_skip_evens() i64 {
    if sum_odds_parity_cf_055_skip_evens(10) == 25 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_056_nested_return
fn check_parity_cf_056_nested_return(x: i64, y: i64) i64 {
    if x > 0 {
        if y > 0 {
            return 1;
        }
        return 2;
    }
    return 3;
}
fn test_parity_cf_056_nested_return() i64 {
    var r1: i64 = check_parity_cf_056_nested_return(1, 1);
    var r2: i64 = check_parity_cf_056_nested_return(1, 0 - 1);
    var r3: i64 = check_parity_cf_056_nested_return(0 - 1, 1);
    if r1 == 1 and r2 == 2 and r3 == 3 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_057_while_cond_complex
fn test_parity_cf_057_while_cond_complex() i64 {
    var i: i64 = 0;
    var sum: i64 = 0;
    while i < 10 and sum < 20 {
        sum = sum + i;
        i = i + 1;
    }
    if sum == 21 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_058_or_condition
fn test_parity_cf_058_or_condition() i64 {
    var x: i64 = 5;
    var ok: i64 = 0;
    if x < 0 or x > 10 {
        ok = 0;
    } else {
        ok = 1;
    }
    if ok == 1 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_059_while_true
fn test_parity_cf_059_while_true() i64 {
    var i: i64 = 0;
    while 1 == 1 {
        i = i + 1;
        if i >= 10 { return 42; }
    }
    return 1;
}


// Parity test: control_flow/cf_060_countdown
fn test_parity_cf_060_countdown() i64 {
    var n: i64 = 10;
    while n > 0 {
        n = n - 1;
    }
    if n == 0 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_061_step_by_2
fn test_parity_cf_061_step_by_2() i64 {
    var sum: i64 = 0;
    var i: i64 = 0;
    while i < 10 {
        sum = sum + i;
        i = i + 2;
    }
    if sum == 20 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_062_geometric
fn test_parity_cf_062_geometric() i64 {
    var x: i64 = 1;
    var i: i64 = 0;
    while i < 10 {
        x = x * 2;
        i = i + 1;
    }
    if x == 1024 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_063_harmonic
fn test_parity_cf_063_harmonic() i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    while i <= 100 {
        sum = sum + 1000 / i;
        i = i + 1;
    }
    if sum > 5000 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_064_double_loop
fn test_parity_cf_064_double_loop() i64 {
    var outer: i64 = 0;
    var i: i64 = 0;
    while i < 5 {
        var j: i64 = 0;
        while j < 5 {
            outer = outer + 1;
            j = j + 1;
        }
        i = i + 1;
    }
    if outer == 25 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_065_matrix_like
fn test_parity_cf_065_matrix_like() i64 {
    var mat: *i64 = malloc(72);
    var i: i64 = 0;
    while i < 3 {
        var j: i64 = 0;
        while j < 3 {
            (mat + i * 3 + j).* = i * 3 + j;
            j = j + 1;
        }
        i = i + 1;
    }
    if (mat + 4).* == 4 and (mat + 8).* == 8 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_066_diagonal
fn test_parity_cf_066_diagonal() i64 {
    var mat: *i64 = malloc(128);
    var i: i64 = 0;
    while i < 4 {
        var j: i64 = 0;
        while j < 4 {
            if i == j {
                (mat + i * 4 + j).* = 1;
            } else {
                (mat + i * 4 + j).* = 0;
            }
            j = j + 1;
        }
        i = i + 1;
    }
    var diag: i64 = (mat + 0).* + (mat + 5).* + (mat + 10).* + (mat + 15).*;
    if diag == 4 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_067_alternating
fn test_parity_cf_067_alternating() i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    var sign: i64 = 1;
    while i <= 10 {
        sum = sum + sign * i;
        sign = 0 - sign;
        i = i + 1;
    }
    if sum == 0 - 5 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_068_fibonacci_loop
fn test_parity_cf_068_fibonacci_loop() i64 {
    var a: i64 = 0;
    var b: i64 = 1;
    var i: i64 = 0;
    while i < 10 {
        var t: i64 = a + b;
        a = b;
        b = t;
        i = i + 1;
    }
    if a == 55 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_069_prime_sieve_small
fn test_parity_cf_069_prime_sieve_small() i64 {
    var n: i64 = 20;
    var sieve: *i64 = malloc(n * 8);
    var i: i64 = 0;
    while i < n {
        (sieve + i).* = 1;
        i = i + 1;
    }
    (sieve + 0).* = 0;
    (sieve + 1).* = 0;
    i = 2;
    while i * i < n {
        if (sieve + i).* == 1 {
            var j: i64 = i * i;
            while j < n {
                (sieve + j).* = 0;
                j = j + i;
            }
        }
        i = i + 1;
    }
    var count: i64 = 0;
    i = 0;
    while i < n {
        count = count + (sieve + i).*;
        i = i + 1;
    }
    if count == 8 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_070_count_primes
fn is_prime_parity_cf_070_count_primes(n: i64) i64 {
    if n <= 1 { return 0; }
    if n <= 3 { return 1; }
    if n % 2 == 0 { return 0; }
    var i: i64 = 3;
    while i * i <= n {
        if n % i == 0 { return 0; }
        i = i + 2;
    }
    return 1;
}
fn test_parity_cf_070_count_primes() i64 {
    var count: i64 = 0;
    var n: i64 = 2;
    while n <= 100 {
        count = count + is_prime_parity_cf_070_count_primes(n);
        n = n + 1;
    }
    if count == 25 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_071_switch_like
fn day_of_week_parity_cf_071_switch_like(d: i64) i64 {
    if d == 0 { return 0; }
    if d == 1 { return 1; }
    if d == 2 { return 2; }
    if d == 3 { return 3; }
    if d == 4 { return 4; }
    if d == 5 { return 5; }
    if d == 6 { return 6; }
    return 0 - 1;
}
fn test_parity_cf_071_switch_like() i64 {
    if day_of_week_parity_cf_071_switch_like(3) == 3 and day_of_week_parity_cf_071_switch_like(7) == 0 - 1 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_072_grade_classifier
fn grade_parity_cf_072_grade_classifier(score: i64) i64 {
    if score >= 90 { return 4; }
    if score >= 80 { return 3; }
    if score >= 70 { return 2; }
    if score >= 60 { return 1; }
    return 0;
}
fn test_parity_cf_072_grade_classifier() i64 {
    if grade_parity_cf_072_grade_classifier(95) == 4 and grade_parity_cf_072_grade_classifier(75) == 2 and grade_parity_cf_072_grade_classifier(55) == 0 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_073_range_check
fn in_range_parity_cf_073_range_check(x: i64, lo: i64, hi: i64) i64 {
    if x >= lo {
        if x <= hi {
            return 1;
        }
    }
    return 0;
}
fn test_parity_cf_073_range_check() i64 {
    if in_range_parity_cf_073_range_check(5, 0, 10) == 1 and in_range_parity_cf_073_range_check(15, 0, 10) == 0 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_074_clamp
fn clamp_parity_cf_074_clamp(x: i64, lo: i64, hi: i64) i64 {
    if x < lo { return lo; }
    if x > hi { return hi; }
    return x;
}
fn test_parity_cf_074_clamp() i64 {
    if clamp_parity_cf_074_clamp(5, 0, 10) == 5 and clamp_parity_cf_074_clamp(0-5, 0, 10) == 0 and clamp_parity_cf_074_clamp(15, 0, 10) == 10 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_075_loop_break_sim
fn find_first_positive_parity_cf_075_loop_break_sim(a: i64, b: i64, c: i64, d: i64) i64 {
    if a > 0 { return a; }
    if b > 0 { return b; }
    if c > 0 { return c; }
    if d > 0 { return d; }
    return 0;
}
fn test_parity_cf_075_loop_break_sim() i64 {
    if find_first_positive_parity_cf_075_loop_break_sim(0-1, 0-2, 3, 4) == 3 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_076_sign_function
fn sign_parity_cf_076_sign_function(x: i64) i64 {
    if x > 0 { return 1; }
    if x < 0 { return 0 - 1; }
    return 0;
}
fn test_parity_cf_076_sign_function() i64 {
    if sign_parity_cf_076_sign_function(42) == 1 and sign_parity_cf_076_sign_function(0-5) == 0-1 and sign_parity_cf_076_sign_function(0) == 0 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_077_boolean_chain
fn all_true_parity_cf_077_boolean_chain(a: i64, b: i64, c: i64) i64 {
    if a != 0 {
        if b != 0 {
            if c != 0 {
                return 1;
            }
        }
    }
    return 0;
}
fn test_parity_cf_077_boolean_chain() i64 {
    if all_true_parity_cf_077_boolean_chain(1, 1, 1) == 1 and all_true_parity_cf_077_boolean_chain(1, 0, 1) == 0 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_078_any_true
fn any_true_parity_cf_078_any_true(a: i64, b: i64, c: i64) i64 {
    if a != 0 { return 1; }
    if b != 0 { return 1; }
    if c != 0 { return 1; }
    return 0;
}
fn test_parity_cf_078_any_true() i64 {
    if any_true_parity_cf_078_any_true(0, 0, 1) == 1 and any_true_parity_cf_078_any_true(0, 0, 0) == 0 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_079_count_loop
fn count_divisible_parity_cf_079_count_loop(n: i64, d: i64) i64 {
    var count: i64 = 0;
    var i: i64 = 1;
    while i <= n {
        if i % d == 0 {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}
fn test_parity_cf_079_count_loop() i64 {
    if count_divisible_parity_cf_079_count_loop(20, 3) == 6 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_080_sum_divisible
fn sum_divisible_parity_cf_080_sum_divisible(n: i64, d: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    while i <= n {
        if i % d == 0 {
            sum = sum + i;
        }
        i = i + 1;
    }
    return sum;
}
fn test_parity_cf_080_sum_divisible() i64 {
    if sum_divisible_parity_cf_080_sum_divisible(10, 2) == 30 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_081_countdown
fn countdown_parity_cf_081_countdown(n: i64) i64 {
    var result: i64 = 0;
    var i: i64 = n;
    while i > 0 {
        result = result + i;
        i = i - 1;
    }
    return result;
}
fn test_parity_cf_081_countdown() i64 {
    if countdown_parity_cf_081_countdown(5) == 15 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_082_even_sum
fn even_sum_parity_cf_082_even_sum(n: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 2;
    while i <= n {
        sum = sum + i;
        i = i + 2;
    }
    return sum;
}
fn test_parity_cf_082_even_sum() i64 {
    if even_sum_parity_cf_082_even_sum(10) == 30 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_083_odd_sum
fn odd_sum_parity_cf_083_odd_sum(n: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    while i <= n {
        sum = sum + i;
        i = i + 2;
    }
    return sum;
}
fn test_parity_cf_083_odd_sum() i64 {
    if odd_sum_parity_cf_083_odd_sum(10) == 25 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_084_double_loop
fn test_parity_cf_084_double_loop() i64 {
    var sum: i64 = 0;
    var i: i64 = 0;
    while i < 3 {
        var j: i64 = 0;
        while j < 4 {
            sum = sum + 1;
            j = j + 1;
        }
        i = i + 1;
    }
    if sum == 12 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_085_triple_loop
fn test_parity_cf_085_triple_loop() i64 {
    var sum: i64 = 0;
    var i: i64 = 0;
    while i < 2 {
        var j: i64 = 0;
        while j < 3 {
            var k: i64 = 0;
            while k < 4 {
                sum = sum + 1;
                k = k + 1;
            }
            j = j + 1;
        }
        i = i + 1;
    }
    if sum == 24 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_086_complex_cond
fn test_parity_cf_086_complex_cond() i64 {
    var x: i64 = 15;
    var result: i64 = 0;
    if x > 10 {
        if x < 20 {
            result = 1;
        }
    }
    if result == 1 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_087_multiple_return
fn classify_parity_cf_087_multiple_return(x: i64) i64 {
    if x < 0 { return 0 - 1; }
    if x == 0 { return 0; }
    if x < 10 { return 1; }
    if x < 100 { return 2; }
    return 3;
}
fn test_parity_cf_087_multiple_return() i64 {
    if classify_parity_cf_087_multiple_return(50) == 2 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_088_loop_with_if
fn test_parity_cf_088_loop_with_if() i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    while i <= 20 {
        if i % 2 == 0 {
            sum = sum + i;
        }
        i = i + 1;
    }
    if sum == 110 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_089_nested_if_else
fn grade_parity_cf_089_nested_if_else(score: i64) i64 {
    if score >= 90 {
        return 4;
    } else {
        if score >= 80 {
            return 3;
        } else {
            if score >= 70 {
                return 2;
            } else {
                if score >= 60 {
                    return 1;
                } else {
                    return 0;
                }
            }
        }
    }
}
fn test_parity_cf_089_nested_if_else() i64 {
    if grade_parity_cf_089_nested_if_else(85) == 3 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_090_while_in_if
fn test_parity_cf_090_while_in_if() i64 {
    var x: i64 = 5;
    var result: i64 = 0;
    if x > 0 {
        var i: i64 = 0;
        while i < x {
            result = result + i;
            i = i + 1;
        }
    }
    if result == 10 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_091_early_return
fn find_first_even_parity_cf_091_early_return(a: i64, b: i64, c: i64, d: i64) i64 {
    if a % 2 == 0 { return a; }
    if b % 2 == 0 { return b; }
    if c % 2 == 0 { return c; }
    if d % 2 == 0 { return d; }
    return 0 - 1;
}
fn test_parity_cf_091_early_return() i64 {
    if find_first_even_parity_cf_091_early_return(1, 3, 4, 5) == 4 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_092_cascade_return
fn classify_char_parity_cf_092_cascade_return(c: i64) i64 {
    if c >= 48 {
        if c <= 57 { return 1; }
    }
    if c >= 65 {
        if c <= 90 { return 2; }
    }
    if c >= 97 {
        if c <= 122 { return 2; }
    }
    return 0;
}
fn test_parity_cf_092_cascade_return() i64 {
    if classify_char_parity_cf_092_cascade_return(65) == 2 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_093_loop_with_early_exit_sim
fn find_divisor_parity_cf_093_loop_with_early_exit_sim(n: i64) i64 {
    var i: i64 = 2;
    while i < n {
        if n % i == 0 { return i; }
        i = i + 1;
    }
    return 0 - 1;
}
fn test_parity_cf_093_loop_with_early_exit_sim() i64 {
    if find_divisor_parity_cf_093_loop_with_early_exit_sim(15) == 3 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_094_nested_loop_sum
fn test_parity_cf_094_nested_loop_sum() i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    while i <= 5 {
        var j: i64 = 1;
        while j <= i {
            sum = sum + j;
            j = j + 1;
        }
        i = i + 1;
    }
    if sum == 35 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_095_multiplication_table
fn test_parity_cf_095_multiplication_table() i64 {
    var table: *i64 = malloc(200);
    var i: i64 = 0;
    while i < 5 {
        var j: i64 = 0;
        while j < 5 {
            (table + i * 5 + j).* = (i + 1) * (j + 1);
            j = j + 1;
        }
        i = i + 1;
    }
    if (table + 2 * 5 + 3).* == 12 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_096_modulo_check
fn test_parity_cf_096_modulo_check() i64 {
    var n: i64 = 24;
    if n % 2 == 0 {
        if n % 3 == 0 {
            if n % 4 == 0 { return 42; }
        }
    }
    return 1;
}


// Parity test: control_flow/cf_097_fizzbuzz_logic
fn fizzbuzz_parity_cf_097_fizzbuzz_logic(n: i64) i64 {
    if n % 15 == 0 { return 3; }
    if n % 5 == 0 { return 2; }
    if n % 3 == 0 { return 1; }
    return 0;
}
fn test_parity_cf_097_fizzbuzz_logic() i64 {
    if fizzbuzz_parity_cf_097_fizzbuzz_logic(15) == 3 {
        if fizzbuzz_parity_cf_097_fizzbuzz_logic(9) == 1 {
            if fizzbuzz_parity_cf_097_fizzbuzz_logic(10) == 2 {
                if fizzbuzz_parity_cf_097_fizzbuzz_logic(7) == 0 { return 42; }
            }
        }
    }
    return 1;
}


// Parity test: control_flow/cf_098_loop_product
fn test_parity_cf_098_loop_product() i64 {
    var product: i64 = 1;
    var i: i64 = 1;
    while i <= 5 {
        product = product * i;
        i = i + 1;
    }
    if product == 120 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_099_nested_condition
fn test_parity_cf_099_nested_condition() i64 {
    var x: i64 = 15;
    var result: i64 = 0;
    if x > 10 {
        if x < 20 {
            if x % 5 == 0 {
                result = 1;
            }
        }
    }
    if result == 1 { return 42; }
    return 1;
}


// Parity test: control_flow/cf_100_complex_loop
fn test_parity_cf_100_complex_loop() i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    while i <= 100 {
        if i % 3 == 0 {
            sum = sum + i;
        }
        i = i + 1;
    }
    if sum == 1683 { return 42; }
    return 1;
}


// Parity test: expressions/expr_001_add
// Parity test: Simple addition
fn add_parity_expr_001_add(a: i64, b: i64) i64 {
    return a + b;
}

fn test_parity_expr_001_add() i64 {
    let result: i64 = add_parity_expr_001_add(40, 2);
    if result == 42 { return 42; }
    return 1;
}


// Parity test: expressions/expr_002_sub
// Parity test: Simple subtraction
fn sub_parity_expr_002_sub(a: i64, b: i64) i64 {
    return a - b;
}

fn test_parity_expr_002_sub() i64 {
    let result: i64 = sub_parity_expr_002_sub(50, 8);
    if result == 42 { return 42; }
    return 1;
}


// Parity test: expressions/expr_003_mul
fn mul_parity_expr_003_mul(a: i64, b: i64) i64 { return a * b; }
fn test_parity_expr_003_mul() i64 { if mul_parity_expr_003_mul(6, 7) == 42 { return 42; } return 1; }


// Parity test: expressions/expr_004_div
fn div_parity_expr_004_div(a: i64, b: i64) i64 { return a / b; }
fn test_parity_expr_004_div() i64 { if div_parity_expr_004_div(84, 2) == 42 { return 42; } return 1; }


// Parity test: expressions/expr_005_complex
fn calc_parity_expr_005_complex(a: i64, b: i64, c: i64) i64 { return (a + b) * c; }
fn test_parity_expr_005_complex() i64 { if calc_parity_expr_005_complex(3, 4, 6) == 42 { return 42; } return 1; }


// Parity test: expressions/expr_006_nested
fn inner_parity_expr_006_nested(x: i64) i64 { return x * 2; }
fn outer_parity_expr_006_nested(x: i64) i64 { return inner_parity_expr_006_nested(x) + 1; }
fn test_parity_expr_006_nested() i64 { if outer_parity_expr_006_nested(20) == 41 { return 42; } return 1; }


// Parity test: expressions/expr_007_mod
fn mod_parity_expr_007_mod(a: i64, b: i64) i64 { return a % b; }
fn test_parity_expr_007_mod() i64 { if mod_parity_expr_007_mod(17, 5) == 2 { return 42; } return 1; }


// Parity test: expressions/expr_008_neg
fn neg_parity_expr_008_neg(x: i64) i64 { return -x; }
fn test_parity_expr_008_neg() i64 { if neg_parity_expr_008_neg(42) == -42 { return 42; } return 1; }


// Parity test: expressions/expr_009_bitand
fn bitand_parity_expr_009_bitand(a: i64, b: i64) i64 { return a & b; }
fn test_parity_expr_009_bitand() i64 { if bitand_parity_expr_009_bitand(0xFF, 0x0F) == 0x0F { return 42; } return 1; }


// Parity test: expressions/expr_010_bitor
fn bitor_parity_expr_010_bitor(a: i64, b: i64) i64 { return a | b; }
fn test_parity_expr_010_bitor() i64 { if bitor_parity_expr_010_bitor(0xF0, 0x0F) == 0xFF { return 42; } return 1; }


// Parity test: expressions/expr_011_bitxor
fn bitxor_parity_expr_011_bitxor(a: i64, b: i64) i64 { return a ^ b; }
fn test_parity_expr_011_bitxor() i64 { if bitxor_parity_expr_011_bitxor(0xFF, 0x0F) == 0xF0 { return 42; } return 1; }


// Parity test: expressions/expr_012_shl
fn shl_parity_expr_012_shl(a: i64, b: i64) i64 { return a << b; }
fn test_parity_expr_012_shl() i64 { if shl_parity_expr_012_shl(1, 4) == 16 { return 42; } return 1; }


// Parity test: expressions/expr_013_shr
fn shr_parity_expr_013_shr(a: i64, b: i64) i64 { return a >> b; }
fn test_parity_expr_013_shr() i64 { if shr_parity_expr_013_shr(256, 4) == 16 { return 42; } return 1; }


// Parity test: expressions/expr_014_cmp_lt
fn lt_parity_expr_014_cmp_lt(a: i64, b: i64) i64 { if a < b { return 1; } return 0; }
fn test_parity_expr_014_cmp_lt() i64 { if lt_parity_expr_014_cmp_lt(5, 10) == 1 { return 42; } return 1; }


// Parity test: expressions/expr_015_cmp_le
fn le_parity_expr_015_cmp_le(a: i64, b: i64) i64 { if a <= b { return 1; } return 0; }
fn test_parity_expr_015_cmp_le() i64 { if le_parity_expr_015_cmp_le(5, 5) == 1 { return 42; } return 1; }


// Parity test: expressions/expr_016_cmp_gt
fn gt_parity_expr_016_cmp_gt(a: i64, b: i64) i64 { if a > b { return 1; } return 0; }
fn test_parity_expr_016_cmp_gt() i64 { if gt_parity_expr_016_cmp_gt(10, 5) == 1 { return 42; } return 1; }


// Parity test: expressions/expr_017_cmp_ge
fn ge_parity_expr_017_cmp_ge(a: i64, b: i64) i64 { if a >= b { return 1; } return 0; }
fn test_parity_expr_017_cmp_ge() i64 { if ge_parity_expr_017_cmp_ge(5, 5) == 1 { return 42; } return 1; }


// Parity test: expressions/expr_018_cmp_eq
fn eq_parity_expr_018_cmp_eq(a: i64, b: i64) i64 { if a == b { return 1; } return 0; }
fn test_parity_expr_018_cmp_eq() i64 { if eq_parity_expr_018_cmp_eq(42, 42) == 1 { return 42; } return 1; }


// Parity test: expressions/expr_019_cmp_ne
fn ne_parity_expr_019_cmp_ne(a: i64, b: i64) i64 { if a != b { return 1; } return 0; }
fn test_parity_expr_019_cmp_ne() i64 { if ne_parity_expr_019_cmp_ne(1, 2) == 1 { return 42; } return 1; }


// Parity test: expressions/expr_020_chained
fn chain_parity_expr_020_chained(a: i64, b: i64, c: i64) i64 { return a + b + c + a + b + c; }
fn test_parity_expr_020_chained() i64 { if chain_parity_expr_020_chained(1, 2, 3) == 12 { return 42; } return 1; }


// Parity test: expressions/expr_021_parens
fn calc_parity_expr_021_parens(a: i64, b: i64, c: i64) i64 { return (a + b) * c; }
fn test_parity_expr_021_parens() i64 { if calc_parity_expr_021_parens(2, 3, 4) == 20 { return 42; } return 1; }


// Parity test: expressions/expr_022_precedence
fn test_prec_parity_expr_022_precedence() i64 { return 2 + 3 * 4; }
fn test_parity_expr_022_precedence() i64 { if test_prec_parity_expr_022_precedence() == 14 { return 42; } return 1; }


// Parity test: expressions/expr_023_assoc_left
fn left_assoc_parity_expr_023_assoc_left() i64 { return 100 - 30 - 20; }
fn test_parity_expr_023_assoc_left() i64 { if left_assoc_parity_expr_023_assoc_left() == 50 { return 42; } return 1; }


// Parity test: expressions/expr_024_mixed_ops
fn mixed_parity_expr_024_mixed_ops() i64 { return 10 + 20 * 3 - 5; }
fn test_parity_expr_024_mixed_ops() i64 { if mixed_parity_expr_024_mixed_ops() == 65 { return 42; } return 1; }


// Parity test: expressions/expr_025_div_mod
fn div_mod_parity_expr_025_div_mod(a: i64, b: i64) i64 { return (a / b) + (a % b); }
fn test_parity_expr_025_div_mod() i64 { if div_mod_parity_expr_025_div_mod(17, 5) == 5 { return 42; } return 1; }


// Parity test: expressions/expr_026_longchain
fn chain_parity_expr_026_longchain(a: i64, b: i64, c: i64, d: i64) i64 {
    return a + b - c + d - a + b - c + d;
}
fn test_parity_expr_026_longchain() i64 { if chain_parity_expr_026_longchain(1, 2, 3, 4) == 6 { return 42; } return 1; }


// Parity test: expressions/expr_027_bitnot
fn bitnot_parity_expr_027_bitnot(x: i64) i64 { return ~x; }
fn test_parity_expr_027_bitnot() i64 { if (bitnot_parity_expr_027_bitnot(0) & 0xFF) == 0xFF { return 42; } return 1; }


// Parity test: expressions/expr_028_shift_chain
fn shift_chain_parity_expr_028_shift_chain(x: i64) i64 { return ((x << 2) >> 1) << 1; }
fn test_parity_expr_028_shift_chain() i64 { if shift_chain_parity_expr_028_shift_chain(1) == 4 { return 42; } return 1; }


// Parity test: expressions/expr_029_bit_combo
fn bitcombo_parity_expr_029_bit_combo(a: i64, b: i64) i64 { return (a & b) | (a ^ b); }
fn test_parity_expr_029_bit_combo() i64 { if bitcombo_parity_expr_029_bit_combo(0xF0, 0x0F) == 0xFF { return 42; } return 1; }


// Parity test: expressions/expr_030_arith_assign
fn arith_assign_parity_expr_030_arith_assign() i64 {
    var x: i64 = 10;
    x = x + 5;
    x = x * 2;
    x = x - 10;
    return x;
}
fn test_parity_expr_030_arith_assign() i64 { if arith_assign_parity_expr_030_arith_assign() == 20 { return 42; } return 1; }


// Parity test: expressions/expr_031_neg_arith
fn test_neg_parity_expr_031_neg_arith() i64 { return -10 + 20; }
fn test_parity_expr_031_neg_arith() i64 { if test_neg_parity_expr_031_neg_arith() == 10 { return 42; } return 1; }


// Parity test: expressions/expr_032_zero_cmp
fn is_zero_parity_expr_032_zero_cmp(x: i64) i64 { if x == 0 { return 1; } return 0; }
fn test_parity_expr_032_zero_cmp() i64 { if is_zero_parity_expr_032_zero_cmp(0) == 1 { return 42; } return 1; }


// Parity test: expressions/expr_033_neg_cmp
fn is_neg_parity_expr_033_neg_cmp(x: i64) i64 { if x < 0 { return 1; } return 0; }
fn test_parity_expr_033_neg_cmp() i64 { if is_neg_parity_expr_033_neg_cmp(-5) == 1 { return 42; } return 1; }


// Parity test: expressions/expr_034_multi_cmp
fn in_range_parity_expr_034_multi_cmp(x: i64, lo: i64, hi: i64) i64 {
    if x >= lo {
        if x <= hi { return 1; }
    }
    return 0;
}
fn test_parity_expr_034_multi_cmp() i64 { if in_range_parity_expr_034_multi_cmp(5, 1, 10) == 1 { return 42; } return 1; }


// Parity test: expressions/expr_035_max
fn max_parity_expr_035_max(a: i64, b: i64) i64 { if a > b { return a; } return b; }
fn test_parity_expr_035_max() i64 { if max_parity_expr_035_max(3, 7) == 7 { return 42; } return 1; }


// Parity test: expressions/expr_036_min
fn min_parity_expr_036_min(a: i64, b: i64) i64 { if a < b { return a; } return b; }
fn test_parity_expr_036_min() i64 { if min_parity_expr_036_min(3, 7) == 3 { return 42; } return 1; }


// Parity test: expressions/expr_037_abs
fn abs_parity_expr_037_abs(x: i64) i64 { if x < 0 { return -x; } return x; }
fn test_parity_expr_037_abs() i64 { if abs_parity_expr_037_abs(-42) == 42 { return 42; } return 1; }


// Parity test: expressions/expr_038_sign
fn sign_parity_expr_038_sign(x: i64) i64 {
    if x < 0 { return -1; }
    if x > 0 { return 1; }
    return 0;
}
fn test_parity_expr_038_sign() i64 { if sign_parity_expr_038_sign(-10) == -1 { return 42; } return 1; }


// Parity test: expressions/expr_039_clamp
fn clamp_parity_expr_039_clamp(x: i64, lo: i64, hi: i64) i64 {
    if x < lo { return lo; }
    if x > hi { return hi; }
    return x;
}
fn test_parity_expr_039_clamp() i64 { if clamp_parity_expr_039_clamp(50, 0, 10) == 10 { return 42; } return 1; }


// Parity test: expressions/expr_040_power
fn power_parity_expr_040_power(base: i64, exp: i64) i64 {
    var result: i64 = 1;
    var i: i64 = 0;
    while i < exp {
        result = result * base;
        i = i + 1;
    }
    return result;
}
fn test_parity_expr_040_power() i64 { if power_parity_expr_040_power(2, 10) == 1024 { return 42; } return 1; }


// Parity test: expressions/expr_041_square
fn square_parity_expr_041_square(x: i64) i64 { return x * x; }
fn test_parity_expr_041_square() i64 { if square_parity_expr_041_square(7) == 49 { return 42; } return 1; }


// Parity test: expressions/expr_042_cube
fn cube_parity_expr_042_cube(x: i64) i64 { return x * x * x; }
fn test_parity_expr_042_cube() i64 { if cube_parity_expr_042_cube(4) == 64 { return 42; } return 1; }


// Parity test: expressions/expr_043_sum_squares
fn sum_squares_parity_expr_043_sum_squares(n: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    while i <= n {
        sum = sum + i * i;
        i = i + 1;
    }
    return sum;
}
fn test_parity_expr_043_sum_squares() i64 { if sum_squares_parity_expr_043_sum_squares(5) == 55 { return 42; } return 1; }


// Parity test: expressions/expr_044_avg
fn avg_parity_expr_044_avg(a: i64, b: i64, c: i64) i64 { return (a + b + c) / 3; }
fn test_parity_expr_044_avg() i64 { if avg_parity_expr_044_avg(10, 20, 30) == 20 { return 42; } return 1; }


// Parity test: expressions/expr_045_tri_area
fn tri_area_parity_expr_045_tri_area(base: i64, height: i64) i64 { return (base * height) / 2; }
fn test_parity_expr_045_tri_area() i64 { if tri_area_parity_expr_045_tri_area(10, 8) == 40 { return 42; } return 1; }


// Parity test: expressions/expr_046_rect_area
fn rect_area_parity_expr_046_rect_area(w: i64, h: i64) i64 { return w * h; }
fn test_parity_expr_046_rect_area() i64 { if rect_area_parity_expr_046_rect_area(5, 7) == 35 { return 42; } return 1; }


// Parity test: expressions/expr_047_distance
fn abs_parity_expr_047_distance(x: i64) i64 { if x < 0 { return -x; } return x; }
fn distance_parity_expr_047_distance(x1: i64, y1: i64, x2: i64, y2: i64) i64 {
    return abs_parity_expr_047_distance(x2 - x1) + abs_parity_expr_047_distance(y2 - y1);
}
fn test_parity_expr_047_distance() i64 { if distance_parity_expr_047_distance(1, 2, 4, 6) == 7 { return 42; } return 1; }


// Parity test: expressions/expr_048_dot_prod
fn dot_parity_expr_048_dot_prod(x1: i64, y1: i64, x2: i64, y2: i64) i64 {
    return x1 * x2 + y1 * y2;
}
fn test_parity_expr_048_dot_prod() i64 { if dot_parity_expr_048_dot_prod(2, 3, 4, 5) == 23 { return 42; } return 1; }


// Parity test: expressions/expr_049_cross_prod
fn cross_parity_expr_049_cross_prod(x1: i64, y1: i64, x2: i64, y2: i64) i64 {
    return x1 * y2 - y1 * x2;
}
fn test_parity_expr_049_cross_prod() i64 { if cross_parity_expr_049_cross_prod(2, 3, 4, 5) == -2 { return 42; } return 1; }


// Parity test: expressions/expr_050_lerp
fn lerp_parity_expr_050_lerp(a: i64, b: i64, t: i64) i64 {
    return a + (b - a) * t / 100;
}
fn test_parity_expr_050_lerp() i64 { if lerp_parity_expr_050_lerp(0, 100, 50) == 50 { return 42; } return 1; }


// Parity test: expressions/expr_051_large_const
fn large_parity_expr_051_large_const() i64 { return 1000000000; }
fn test_parity_expr_051_large_const() i64 { if large_parity_expr_051_large_const() == 1000000000 { return 42; } return 1; }


// Parity test: expressions/expr_052_neg_const
fn neg_const_parity_expr_052_neg_const() i64 { return -123456; }
fn test_parity_expr_052_neg_const() i64 { if neg_const_parity_expr_052_neg_const() == -123456 { return 42; } return 1; }


// Parity test: expressions/expr_053_hex_const
fn hex_parity_expr_053_hex_const() i64 { return 0xDEADBEEF; }
fn test_parity_expr_053_hex_const() i64 { if hex_parity_expr_053_hex_const() == 0xDEADBEEF { return 42; } return 1; }


// Parity test: expressions/expr_054_zero
fn zero_parity_expr_054_zero() i64 { return 0; }
fn test_parity_expr_054_zero() i64 { if zero_parity_expr_054_zero() == 0 { return 42; } return 1; }


// Parity test: expressions/expr_055_one
fn one_parity_expr_055_one() i64 { return 1; }
fn test_parity_expr_055_one() i64 { if one_parity_expr_055_one() == 1 { return 42; } return 1; }


// Parity test: expressions/expr_056_mult_add
fn mult_add_parity_expr_056_mult_add(a: i64, b: i64, c: i64) i64 { return a * b + c; }
fn test_parity_expr_056_mult_add() i64 { if mult_add_parity_expr_056_mult_add(3, 4, 5) == 17 { return 42; } return 1; }


// Parity test: expressions/expr_057_div_sub
fn div_sub_parity_expr_057_div_sub(a: i64, b: i64, c: i64) i64 { return a / b - c; }
fn test_parity_expr_057_div_sub() i64 { if div_sub_parity_expr_057_div_sub(100, 10, 5) == 5 { return 42; } return 1; }


// Parity test: expressions/expr_058_nested_parens
fn nested_parity_expr_058_nested_parens(a: i64, b: i64, c: i64, d: i64) i64 {
    return ((a + b) * (c + d));
}
fn test_parity_expr_058_nested_parens() i64 { if nested_parity_expr_058_nested_parens(1, 2, 3, 4) == 21 { return 42; } return 1; }


// Parity test: expressions/expr_059_complex_arith
fn complex_arith_parity_expr_059_complex_arith(a: i64, b: i64, c: i64) i64 {
    return (a * a) + (b * b) + (c * c);
}
fn test_parity_expr_059_complex_arith() i64 { if complex_arith_parity_expr_059_complex_arith(3, 4, 5) == 50 { return 42; } return 1; }


// Parity test: expressions/expr_060_all_ops
fn all_ops_parity_expr_060_all_ops(a: i64, b: i64) i64 {
    var sum: i64 = a + b;
    var diff: i64 = a - b;
    var prod: i64 = a * b;
    var quot: i64 = a / b;
    return sum + diff + prod + quot;
}
// 20+4=24, 20-4=16, 20*4=80, 20/4=5, total=125
fn test_parity_expr_060_all_ops() i64 { if all_ops_parity_expr_060_all_ops(20, 4) == 125 { return 42; } return 1; }


// Parity test: expressions/expr_061_bitwise_combo
fn bitwise_parity_expr_061_bitwise_combo(a: i64, b: i64) i64 {
    return (a & b) ^ (a | b);
}
fn test_parity_expr_061_bitwise_combo() i64 { if bitwise_parity_expr_061_bitwise_combo(0xAA, 0x55) == 0xFF { return 42; } return 1; }


// Parity test: expressions/expr_062_mask_extract
fn extract_byte_parity_expr_062_mask_extract(val: i64, pos: i64) i64 {
    return (val >> (pos * 8)) & 0xFF;
}
fn test_parity_expr_062_mask_extract() i64 { if extract_byte_parity_expr_062_mask_extract(0x12345678, 1) == 0x56 { return 42; } return 1; }


// Parity test: expressions/expr_063_popcount
fn popcount_parity_expr_063_popcount(n: i64) i64 {
    var count: i64 = 0;
    var x: i64 = n;
    while x != 0 {
        count = count + (x & 1);
        x = x >> 1;
    }
    return count;
}
fn test_parity_expr_063_popcount() i64 { if popcount_parity_expr_063_popcount(0xFF) == 8 { return 42; } return 1; }


// Parity test: expressions/expr_064_reverse_bits
fn reverse8_parity_expr_064_reverse_bits(n: i64) i64 {
    var result: i64 = 0;
    var x: i64 = n;
    var i: i64 = 0;
    while i < 8 {
        result = result << 1;
        result = result | (x & 1);
        x = x >> 1;
        i = i + 1;
    }
    return result;
}
fn test_parity_expr_064_reverse_bits() i64 { if reverse8_parity_expr_064_reverse_bits(0b10110000) == 0b00001101 { return 42; } return 1; }


// Parity test: expressions/expr_065_ispow2
fn is_pow2_parity_expr_065_ispow2(n: i64) i64 {
    if n <= 0 { return 0; }
    if (n & (n - 1)) == 0 { return 1; }
    return 0;
}
fn test_parity_expr_065_ispow2() i64 { if is_pow2_parity_expr_065_ispow2(64) == 1 { return 42; } return 1; }


// Parity test: expressions/expr_066_neg_div
fn neg_div_parity_expr_066_neg_div(a: i64, b: i64) i64 { return (-a) / b; }
fn test_parity_expr_066_neg_div() i64 { if neg_div_parity_expr_066_neg_div(20, 4) == -5 { return 42; } return 1; }


// Parity test: expressions/expr_067_div_neg
fn div_neg_parity_expr_067_div_neg(a: i64, b: i64) i64 { return a / (-b); }
fn test_parity_expr_067_div_neg() i64 { if div_neg_parity_expr_067_div_neg(20, 4) == -5 { return 42; } return 1; }


// Parity test: expressions/expr_068_neg_mod
fn neg_mod_parity_expr_068_neg_mod(a: i64, b: i64) i64 { return (-a) % b; }
fn test_parity_expr_068_neg_mod() i64 { if neg_mod_parity_expr_068_neg_mod(17, 5) == -2 { return 42; } return 1; }


// Parity test: expressions/expr_069_double_neg
fn double_neg_parity_expr_069_double_neg(x: i64) i64 { return -(-x); }
fn test_parity_expr_069_double_neg() i64 { if double_neg_parity_expr_069_double_neg(42) == 42 { return 42; } return 1; }


// Parity test: expressions/expr_070_triple_neg
fn triple_neg_parity_expr_070_triple_neg(x: i64) i64 { return -(-(-x)); }
fn test_parity_expr_070_triple_neg() i64 { if triple_neg_parity_expr_070_triple_neg(42) == -42 { return 42; } return 1; }


// Parity test: expressions/expr_071_bitnot_twice
fn bitnot_twice_parity_expr_071_bitnot_twice(x: i64) i64 { return ~~x; }
fn test_parity_expr_071_bitnot_twice() i64 { if bitnot_twice_parity_expr_071_bitnot_twice(42) == 42 { return 42; } return 1; }


// Parity test: expressions/expr_072_shift_large
fn shift_large_parity_expr_072_shift_large(x: i64) i64 { return x << 32; }
fn test_parity_expr_072_shift_large() i64 { if shift_large_parity_expr_072_shift_large(1) == 0x100000000 { return 42; } return 1; }


// Parity test: expressions/expr_073_shift_zero
fn shift_zero_parity_expr_073_shift_zero(x: i64) i64 { return x << 0; }
fn test_parity_expr_073_shift_zero() i64 { if shift_zero_parity_expr_073_shift_zero(42) == 42 { return 42; } return 1; }


// Parity test: expressions/expr_074_complex_shift
fn complex_shift_parity_expr_074_complex_shift(a: i64, b: i64) i64 {
    return ((a << 4) | (b >> 4)) & 0xFF;
}
fn test_parity_expr_074_complex_shift() i64 { if complex_shift_parity_expr_074_complex_shift(0x0A, 0xB0) == 0xAB { return 42; } return 1; }


// Parity test: expressions/expr_075_overflow_add
fn will_overflow_parity_expr_075_overflow_add() i64 {
    var big: i64 = 0x7FFFFFFFFFFFFFFF;
    return big + 1;
}
fn test_parity_expr_075_overflow_add() i64 {
    var result: i64 = will_overflow_parity_expr_075_overflow_add();
    if result < 0 { return 42; }
    return 1;
}


// Parity test: expressions/expr_076_division_edge
fn test_parity_expr_076_division_edge() i64 {
    var x: i64 = 100;
    var y: i64 = 7;
    var q: i64 = x / y;
    var r: i64 = x % y;
    if q == 14 and r == 2 { return 42; }
    return 1;
}


// Parity test: expressions/expr_077_neg_division
fn test_parity_expr_077_neg_division() i64 {
    var x: i64 = 0 - 100;
    var y: i64 = 7;
    var q: i64 = x / y;
    if q == 0 - 14 { return 42; }
    return 1;
}


// Parity test: expressions/expr_078_chain_add
fn test_parity_expr_078_chain_add() i64 {
    var r: i64 = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10;
    if r == 55 { return 42; }
    return 1;
}


// Parity test: expressions/expr_079_chain_mult
fn test_parity_expr_079_chain_mult() i64 {
    var r: i64 = 1 * 2 * 3 * 4 * 5;
    if r == 120 { return 42; }
    return 1;
}


// Parity test: expressions/expr_080_mixed_chain
fn test_parity_expr_080_mixed_chain() i64 {
    var r: i64 = 10 + 20 * 2 - 30 / 3;
    if r == 40 { return 42; }
    return 1;
}


// Parity test: expressions/expr_081_parens
fn test_parity_expr_081_parens() i64 {
    var r: i64 = (10 + 20) * 2;
    if r == 60 { return 42; }
    return 1;
}


// Parity test: expressions/expr_082_nested_parens
fn test_parity_expr_082_nested_parens() i64 {
    var r: i64 = ((1 + 2) * (3 + 4)) * 2;
    if r == 42 { return 42; }
    return 1;
}


// Parity test: expressions/expr_083_bit_and
fn test_parity_expr_083_bit_and() i64 {
    var a: i64 = 0b1111;
    var b: i64 = 0b1010;
    var r: i64 = a & b;
    if r == 0b1010 { return 42; }
    return 1;
}


// Parity test: expressions/expr_084_bit_or
fn test_parity_expr_084_bit_or() i64 {
    var a: i64 = 0b1100;
    var b: i64 = 0b0011;
    var r: i64 = a | b;
    if r == 0b1111 { return 42; }
    return 1;
}


// Parity test: expressions/expr_085_bit_xor
fn test_parity_expr_085_bit_xor() i64 {
    var a: i64 = 0b1111;
    var b: i64 = 0b1010;
    var r: i64 = a ^ b;
    if r == 0b0101 { return 42; }
    return 1;
}


// Parity test: expressions/expr_086_large_numbers
fn test_parity_expr_086_large_numbers() i64 {
    var x: i64 = 1000000000;
    var y: i64 = 2000000000;
    var z: i64 = x + y;
    if z == 3000000000 { return 42; }
    return 1;
}


// Parity test: expressions/expr_087_very_large
fn test_parity_expr_087_very_large() i64 {
    var x: i64 = 4000000000000;
    var y: i64 = 5000000000000;
    var z: i64 = x + y;
    if z == 9000000000000 { return 42; }
    return 1;
}


// Parity test: expressions/expr_088_max_i64
fn test_parity_expr_088_max_i64() i64 {
    var max: i64 = 9223372036854775807;
    var one: i64 = 1;
    if max > max - one { return 42; }
    return 1;
}


// Parity test: expressions/expr_089_min_i64
fn test_parity_expr_089_min_i64() i64 {
    var min: i64 = 0 - 9223372036854775807 - 1;
    var one: i64 = 1;
    if min < min + one { return 42; }
    return 1;
}


// Parity test: expressions/expr_090_hex_literals
fn test_parity_expr_090_hex_literals() i64 {
    var x: i64 = 0xFF;
    var y: i64 = 0x100;
    if x + 1 == y { return 42; }
    return 1;
}


// Parity test: expressions/expr_091_shift_left
fn test_parity_expr_091_shift_left() i64 {
    var x: i64 = 1;
    var r: i64 = x << 4;
    if r == 16 { return 42; }
    return 1;
}


// Parity test: expressions/expr_092_shift_right
fn test_parity_expr_092_shift_right() i64 {
    var x: i64 = 256;
    var r: i64 = x >> 4;
    if r == 16 { return 42; }
    return 1;
}


// Parity test: expressions/expr_093_shift_both
fn test_parity_expr_093_shift_both() i64 {
    var x: i64 = 8;
    var l: i64 = x << 2;
    var r: i64 = x >> 2;
    if l == 32 and r == 2 { return 42; }
    return 1;
}


// Parity test: expressions/expr_094_bit_ops_combined
fn test_parity_expr_094_bit_ops_combined() i64 {
    var a: i64 = 0b1100;
    var b: i64 = 0b1010;
    var c: i64 = (a & b) | (a ^ b);
    if c == 0b1110 { return 42; }
    return 1;
}


// Parity test: expressions/expr_095_power_of_two
fn test_parity_expr_095_power_of_two() i64 {
    var n: i64 = 32;
    var is_pow2: i64 = 0;
    if (n & (n - 1)) == 0 {
        is_pow2 = 1;
    }
    if is_pow2 == 1 { return 42; }
    return 1;
}


// Parity test: expressions/expr_096_mask_low_bits
fn test_parity_expr_096_mask_low_bits() i64 {
    var x: i64 = 0b11111111;
    var mask: i64 = 0b00001111;
    var low: i64 = x & mask;
    if low == 0b00001111 { return 42; }
    return 1;
}


// Parity test: expressions/expr_097_set_bit
fn test_parity_expr_097_set_bit() i64 {
    var x: i64 = 0;
    var bit: i64 = 3;
    x = x | (1 << bit);
    if x == 8 { return 42; }
    return 1;
}


// Parity test: expressions/expr_098_clear_bit
fn test_parity_expr_098_clear_bit() i64 {
    var x: i64 = 0b1111;
    var bit: i64 = 2;
    x = x & (0 - 1 - (1 << bit));
    if x == 0b1011 { return 42; }
    return 1;
}


// Parity test: expressions/expr_099_toggle_bit
fn test_parity_expr_099_toggle_bit() i64 {
    var x: i64 = 0b1010;
    var bit: i64 = 1;
    x = x ^ (1 << bit);
    if x == 0b1000 { return 42; }
    return 1;
}


// Parity test: expressions/expr_100_count_bits
fn count_bits_parity_expr_100_count_bits(n: i64) i64 {
    var count: i64 = 0;
    var x: i64 = n;
    while x > 0 {
        count = count + (x & 1);
        x = x >> 1;
    }
    return count;
}
fn test_parity_expr_100_count_bits() i64 {
    if count_bits_parity_expr_100_count_bits(0b11101010) == 5 { return 42; }
    return 1;
}


// Parity test: expressions/expr_101_precedence
fn test_parity_expr_101_precedence() i64 {
    var r: i64 = 2 + 3 * 4;
    if r == 14 { return 42; }
    return 1;
}


// Parity test: expressions/expr_102_precedence2
fn test_parity_expr_102_precedence2() i64 {
    var r: i64 = 20 / 4 + 3 * 2;
    if r == 11 { return 42; }
    return 1;
}


// Parity test: expressions/expr_103_compare_chain
fn test_parity_expr_103_compare_chain() i64 {
    var a: i64 = 5;
    var b: i64 = 10;
    var c: i64 = 15;
    var r1: i64 = 0; if a < b { r1 = 1; }
    var r2: i64 = 0; if b < c { r2 = 1; }
    var r3: i64 = 0; if a < c { r3 = 1; }
    if r1 == 1 and r2 == 1 and r3 == 1 { return 42; }
    return 1;
}


// Parity test: expressions/expr_104_complex_cond
fn test_parity_expr_104_complex_cond() i64 {
    var x: i64 = 50;
    var ok: i64 = 0;
    if x >= 0 and x <= 100 {
        ok = 1;
    }
    if ok == 1 { return 42; }
    return 1;
}


// Parity test: expressions/expr_105_zero_compare
fn test_parity_expr_105_zero_compare() i64 {
    var x: i64 = 0;
    var r1: i64 = 0; if x == 0 { r1 = 1; }
    var r2: i64 = 0; if x >= 0 { r2 = 1; }
    var r3: i64 = 0; if x <= 0 { r3 = 1; }
    if r1 == 1 and r2 == 1 and r3 == 1 { return 42; }
    return 1;
}


// Parity test: expressions/expr_106_unary_minus
fn test_parity_expr_106_unary_minus() i64 {
    var x: i64 = 42;
    var y: i64 = 0 - x;
    if y == 0 - 42 { return 42; }
    return 1;
}


// Parity test: expressions/expr_107_double_neg
fn test_parity_expr_107_double_neg() i64 {
    var x: i64 = 42;
    var y: i64 = 0 - (0 - x);
    if y == 42 { return 42; }
    return 1;
}


// Parity test: expressions/expr_108_triple_mult
fn test_parity_expr_108_triple_mult() i64 {
    var a: i64 = 2;
    var b: i64 = 3;
    var c: i64 = 4;
    var r: i64 = a * b * c;
    if r == 24 { return 42; }
    return 1;
}


// Parity test: expressions/expr_109_quad_add
fn test_parity_expr_109_quad_add() i64 {
    var a: i64 = 10;
    var b: i64 = 20;
    var c: i64 = 30;
    var d: i64 = 40;
    var r: i64 = a + b + c + d;
    if r == 100 { return 42; }
    return 1;
}


// Parity test: expressions/expr_110_mixed_ops
fn test_parity_expr_110_mixed_ops() i64 {
    var r: i64 = 100 - 50 + 25 - 10 + 5;
    if r == 70 { return 42; }
    return 1;
}


// Parity test: expressions/expr_111_shift_multiply
fn test_parity_expr_111_shift_multiply() i64 {
    var x: i64 = 5;
    var mul8: i64 = x << 3;
    if mul8 == 40 { return 42; }
    return 1;
}


// Parity test: expressions/expr_112_shift_divide
fn test_parity_expr_112_shift_divide() i64 {
    var x: i64 = 64;
    var div8: i64 = x >> 3;
    if div8 == 8 { return 42; }
    return 1;
}


// Parity test: expressions/expr_113_align_up
fn align_up_parity_expr_113_align_up(n: i64, align: i64) i64 {
    return (n + align - 1) & (0 - align);
}
fn test_parity_expr_113_align_up() i64 {
    if align_up_parity_expr_113_align_up(13, 8) == 16 { return 42; }
    return 1;
}


// Parity test: expressions/expr_114_complex_shift
fn test_parity_expr_114_complex_shift() i64 {
    var x: i64 = 1;
    var y: i64 = x << 10;
    var z: i64 = y >> 5;
    if z == 32 { return 42; }
    return 1;
}


// Parity test: expressions/expr_115_bit_extract
fn extract_byte_parity_expr_115_bit_extract(x: i64, pos: i64) i64 {
    return (x >> (pos * 8)) & 0xFF;
}
fn test_parity_expr_115_bit_extract() i64 {
    var x: i64 = 0x12345678;
    if extract_byte_parity_expr_115_bit_extract(x, 0) == 0x78 { return 42; }
    return 1;
}


// Parity test: expressions/expr_116_rotate_bits
fn test_parity_expr_116_rotate_bits() i64 {
    var x: i64 = 0b11110000;
    var left: i64 = (x << 4) & 0xFF;
    var right: i64 = (x >> 4) & 0xFF;
    if left == 0 and right == 0b00001111 { return 42; }
    return 1;
}


// Parity test: expressions/expr_117_swap_bytes
fn test_parity_expr_117_swap_bytes() i64 {
    var x: i64 = 0x1234;
    var lo: i64 = x & 0xFF;
    var hi: i64 = (x >> 8) & 0xFF;
    var swapped: i64 = (lo << 8) | hi;
    if swapped == 0x3412 { return 42; }
    return 1;
}


// Parity test: expressions/expr_118_count_leading
fn count_leading_zeros_byte_parity_expr_118_count_leading(x: i64) i64 {
    var count: i64 = 0;
    var mask: i64 = 0x80;
    while mask > 0 {
        if (x & mask) != 0 {
            return count;
        }
        count = count + 1;
        mask = mask >> 1;
    }
    return 8;
}
fn test_parity_expr_118_count_leading() i64 {
    if count_leading_zeros_byte_parity_expr_118_count_leading(0x20) == 2 { return 42; }
    return 1;
}


// Parity test: expressions/expr_119_zero_checks
fn test_parity_expr_119_zero_checks() i64 {
    var x: i64 = 0;
    var is_zero: i64 = 0;
    if x == 0 { is_zero = 1; }
    var is_nonzero: i64 = 0;
    if x != 0 { is_nonzero = 1; }
    if is_zero == 1 and is_nonzero == 0 { return 42; }
    return 1;
}


// Parity test: expressions/expr_120_neg_compare
fn test_parity_expr_120_neg_compare() i64 {
    var neg: i64 = 0 - 10;
    var pos: i64 = 10;
    var r1: i64 = 0; if neg < 0 { r1 = 1; }
    var r2: i64 = 0; if neg < pos { r2 = 1; }
    var r3: i64 = 0; if pos > 0 { r3 = 1; }
    if r1 == 1 and r2 == 1 and r3 == 1 { return 42; }
    return 1;
}


// Parity test: expressions/expr_121_power_of_three
fn test_parity_expr_121_power_of_three() i64 {
    var p: i64 = 3 * 3 * 3 * 3;
    if p == 81 { return 42; }
    return 1;
}


// Parity test: expressions/expr_122_sum_of_products
fn test_parity_expr_122_sum_of_products() i64 {
    var x: i64 = 2 * 3 + 4 * 5 + 6 * 7;
    if x == 68 { return 42; }
    return 1;
}


// Parity test: expressions/expr_123_nested_mod
fn test_parity_expr_123_nested_mod() i64 {
    var x: i64 = 100 % 30 % 7;
    if x == 3 { return 42; }
    return 1;
}


// Parity test: expressions/expr_124_div_chain
fn test_parity_expr_124_div_chain() i64 {
    var x: i64 = 1000 / 10 / 5 / 2;
    if x == 10 { return 42; }
    return 1;
}


// Parity test: expressions/expr_125_mixed_arithmetic
fn test_parity_expr_125_mixed_arithmetic() i64 {
    var x: i64 = (10 + 5) * 3 - 20 / 4;
    if x == 40 { return 42; }
    return 1;
}


// Parity test: expressions/expr_126_compare_chain
fn test_parity_expr_126_compare_chain() i64 {
    var a: i64 = 5;
    var b: i64 = 10;
    var c: i64 = 15;
    var result: i64 = 0;
    if a < b {
        if b < c {
            result = 1;
        }
    }
    if result == 1 { return 42; }
    return 1;
}


// Parity test: expressions/expr_127_equality_chain
fn test_parity_expr_127_equality_chain() i64 {
    var a: i64 = 5;
    var b: i64 = 5;
    var c: i64 = 5;
    var result: i64 = 0;
    if a == b {
        if b == c {
            result = 1;
        }
    }
    if result == 1 { return 42; }
    return 1;
}


// Parity test: expressions/expr_128_negative_div
fn test_parity_expr_128_negative_div() i64 {
    var x: i64 = (0 - 20) / 4;
    if x == 0 - 5 { return 42; }
    return 1;
}


// Parity test: expressions/expr_129_negative_mod
fn test_parity_expr_129_negative_mod() i64 {
    var x: i64 = (0 - 17) % 5;
    if x == 0 - 2 { return 42; }
    return 1;
}


// Parity test: expressions/expr_130_abs_like
fn abs_parity_expr_130_abs_like(x: i64) i64 {
    if x < 0 { return 0 - x; }
    return x;
}
fn test_parity_expr_130_abs_like() i64 {
    if abs_parity_expr_130_abs_like(0 - 42) == 42 and abs_parity_expr_130_abs_like(42) == 42 { return 42; }
    return 1;
}


// Parity test: expressions/expr_131_bitwise_and
fn test_parity_expr_131_bitwise_and() i64 {
    var x: i64 = 15;
    var y: i64 = 9;
    var result: i64 = x & y;
    if result == 9 { return 42; }
    return 1;
}


// Parity test: expressions/expr_132_bitwise_or
fn test_parity_expr_132_bitwise_or() i64 {
    var x: i64 = 12;
    var y: i64 = 10;
    var result: i64 = x | y;
    if result == 14 { return 42; }
    return 1;
}


// Parity test: expressions/expr_133_bitwise_xor
fn test_parity_expr_133_bitwise_xor() i64 {
    var x: i64 = 12;
    var y: i64 = 10;
    var result: i64 = x ^ y;
    if result == 6 { return 42; }
    return 1;
}


// Parity test: expressions/expr_134_left_shift
fn test_parity_expr_134_left_shift() i64 {
    var x: i64 = 5;
    var result: i64 = x << 3;
    if result == 40 { return 42; }
    return 1;
}


// Parity test: expressions/expr_135_right_shift
fn test_parity_expr_135_right_shift() i64 {
    var x: i64 = 64;
    var result: i64 = x >> 3;
    if result == 8 { return 42; }
    return 1;
}


// Parity test: expressions/expr_136_combined_shift
fn test_parity_expr_136_combined_shift() i64 {
    var x: i64 = 1;
    var result: i64 = (x << 4) + (x << 2) + (x << 1);
    if result == 22 { return 42; }
    return 1;
}


// Parity test: expressions/expr_137_mask
fn test_parity_expr_137_mask() i64 {
    var x: i64 = 255;
    var mask: i64 = 15;
    var result: i64 = x & mask;
    if result == 15 { return 42; }
    return 1;
}


// Parity test: expressions/expr_138_set_bit
fn test_parity_expr_138_set_bit() i64 {
    var x: i64 = 0;
    x = x | (1 << 3);
    x = x | (1 << 5);
    if x == 40 { return 42; }
    return 1;
}


// Parity test: expressions/expr_139_clear_bit
fn test_parity_expr_139_clear_bit() i64 {
    var x: i64 = 255;
    x = x & (255 - 8);
    if x == 247 { return 42; }
    return 1;
}


// Parity test: expressions/expr_140_toggle_bit
fn test_parity_expr_140_toggle_bit() i64 {
    var x: i64 = 5;
    x = x ^ 4;
    if x == 1 { return 42; }
    return 1;
}


// Parity test: expressions/expr_141_chained_compare
fn test_parity_expr_141_chained_compare() i64 {
    var a: i64 = 5;
    var b: i64 = 10;
    var c: i64 = 15;
    var r1: i64 = 0;
    var r2: i64 = 0;
    if a < b { r1 = 1; }
    if b < c { r2 = 1; }
    if r1 == 1 {
        if r2 == 1 { return 42; }
    }
    return 1;
}


// Parity test: expressions/expr_142_compound_expr
fn test_parity_expr_142_compound_expr() i64 {
    var x: i64 = 2;
    var y: i64 = 3;
    var z: i64 = 4;
    var result: i64 = (x + y) * (y + z);
    if result == 35 { return 42; }
    return 1;
}


// Parity test: expressions/expr_143_div_by_power
fn test_parity_expr_143_div_by_power() i64 {
    var x: i64 = 256;
    var result: i64 = x / 4 / 4 / 4;
    if result == 4 { return 42; }
    return 1;
}


// Parity test: expressions/expr_144_mod_chain
fn test_parity_expr_144_mod_chain() i64 {
    var x: i64 = 100;
    var r1: i64 = x % 17;
    var r2: i64 = r1 % 5;
    if r2 == 0 { return 42; }
    return 1;
}


// Parity test: expressions/expr_146_nested_paren
fn test_parity_expr_146_nested_paren() i64 {
    var x: i64 = ((2 + 3) * (4 + 5)) - ((1 + 2) * (3 + 4));
    if x == 24 { return 42; }
    return 1;
}


// Parity test: expressions/expr_147_multi_mul
fn test_parity_expr_147_multi_mul() i64 {
    var x: i64 = 2 * 3 * 4 * 5;
    if x == 120 { return 42; }
    return 1;
}


// Parity test: expressions/expr_148_multi_add
fn test_parity_expr_148_multi_add() i64 {
    var x: i64 = 10 + 20 + 30 + 40 + 50;
    if x == 150 { return 42; }
    return 1;
}


// Parity test: expressions/expr_149_multi_sub
fn test_parity_expr_149_multi_sub() i64 {
    var x: i64 = 100 - 10 - 20 - 30;
    if x == 40 { return 42; }
    return 1;
}


// Parity test: expressions/expr_150_assoc_test
fn test_parity_expr_150_assoc_test() i64 {
    var a: i64 = 100 - 50 - 25;
    var b: i64 = 100 - (50 - 25);
    if a == 25 {
        if b == 75 { return 42; }
    }
    return 1;
}


// Parity test: expressions/expr_151_square_expr
fn test_parity_expr_151_square_expr() i64 {
    var x: i64 = 7;
    var sq: i64 = x * x;
    if sq == 49 { return 42; }
    return 1;
}


// Parity test: expressions/expr_152_cube_expr
fn test_parity_expr_152_cube_expr() i64 {
    var x: i64 = 4;
    var cu: i64 = x * x * x;
    if cu == 64 { return 42; }
    return 1;
}


// Parity test: expressions/expr_153_fourth_power
fn test_parity_expr_153_fourth_power() i64 {
    var x: i64 = 3;
    var p4: i64 = x * x * x * x;
    if p4 == 81 { return 42; }
    return 1;
}


// Parity test: expressions/expr_154_diff_squares
fn test_parity_expr_154_diff_squares() i64 {
    var a: i64 = 10;
    var b: i64 = 6;
    var diff: i64 = a * a - b * b;
    if diff == 64 { return 42; }
    return 1;
}


// Parity test: expressions/expr_155_sum_squares_expr
fn test_parity_expr_155_sum_squares_expr() i64 {
    var a: i64 = 3;
    var b: i64 = 4;
    var sum: i64 = a * a + b * b;
    if sum == 25 { return 42; }
    return 1;
}


// Parity test: expressions/expr_156_product_expr
fn test_parity_expr_156_product_expr() i64 {
    var a: i64 = 2;
    var b: i64 = 3;
    var c: i64 = 7;
    var prod: i64 = a * b * c;
    if prod == 42 { return 42; }
    return 1;
}


// Parity test: expressions/expr_157_quotient_expr
fn test_parity_expr_157_quotient_expr() i64 {
    var a: i64 = 84;
    var b: i64 = 2;
    var quot: i64 = a / b;
    if quot == 42 { return 42; }
    return 1;
}


// Parity test: expressions/expr_158_remainder_expr
fn test_parity_expr_158_remainder_expr() i64 {
    var a: i64 = 47;
    var b: i64 = 5;
    var rem: i64 = a % b;
    if rem == 2 { return 42; }
    return 1;
}


// Parity test: expressions/expr_159_complex_arith
fn test_parity_expr_159_complex_arith() i64 {
    var result: i64 = 2 + 3 * 4 - 6 / 2;
    if result == 11 { return 42; }
    return 1;
}


// Parity test: expressions/expr_160_paren_priority
fn test_parity_expr_160_paren_priority() i64 {
    var a: i64 = 2 + 3 * 4;
    var b: i64 = (2 + 3) * 4;
    if a == 14 {
        if b == 20 { return 42; }
    }
    return 1;
}


// Parity test: functions/fn_001_noargs
fn get42_parity_fn_001_noargs() i64 { return 42; }
fn test_parity_fn_001_noargs() i64 { if get42_parity_fn_001_noargs() == 42 { return 42; } return 1; }


// Parity test: functions/fn_002_manyargs
fn sum5_parity_fn_002_manyargs(a: i64, b: i64, c: i64, d: i64, e: i64) i64 { return a + b + c + d + e; }
fn test_parity_fn_002_manyargs() i64 { if sum5_parity_fn_002_manyargs(1, 2, 3, 4, 5) == 15 { return 42; } return 1; }


// Parity test: functions/fn_003_recursive
fn fib_parity_fn_003_recursive(n: i64) i64 {
    if n <= 1 { return n; }
    return fib_parity_fn_003_recursive(n - 1) + fib_parity_fn_003_recursive(n - 2);
}
fn test_parity_fn_003_recursive() i64 { if fib_parity_fn_003_recursive(10) == 55 { return 42; } return 1; }


// Parity test: functions/fn_004_mutual
fn is_odd_parity_fn_004_mutual(n: i64) i64 {
    if n == 0 { return 0; }
    return is_even_parity_fn_004_mutual(n - 1);
}
fn is_even_parity_fn_004_mutual(n: i64) i64 {
    if n == 0 { return 1; }
    return is_odd_parity_fn_004_mutual(n - 1);
}
fn test_parity_fn_004_mutual() i64 { if is_even_parity_fn_004_mutual(10) == 1 { return 42; } return 1; }


// Parity test: functions/fn_005_sixargs
fn sum6_parity_fn_005_sixargs(a: i64, b: i64, c: i64, d: i64, e: i64, f: i64) i64 {
    return a + b + c + d + e + f;
}
fn test_parity_fn_005_sixargs() i64 { if sum6_parity_fn_005_sixargs(1, 2, 3, 4, 5, 6) == 21 { return 42; } return 1; }


// Parity test: functions/fn_006_sevenargs
fn sum7_parity_fn_006_sevenargs(a: i64, b: i64, c: i64, d: i64, e: i64, f: i64, g: i64) i64 {
    return a + b + c + d + e + f + g;
}
fn test_parity_fn_006_sevenargs() i64 { if sum7_parity_fn_006_sevenargs(1, 2, 3, 4, 5, 6, 7) == 28 { return 42; } return 1; }


// Parity test: functions/fn_007_eightargs
fn sum8_parity_fn_007_eightargs(a: i64, b: i64, c: i64, d: i64, e: i64, f: i64, g: i64, h: i64) i64 {
    return a + b + c + d + e + f + g + h;
}
fn test_parity_fn_007_eightargs() i64 { if sum8_parity_fn_007_eightargs(1, 2, 3, 4, 5, 6, 7, 8) == 36 { return 42; } return 1; }


// Parity test: functions/fn_008_nested_call
fn double_parity_fn_008_nested_call(x: i64) i64 { return x * 2; }
fn triple_parity_fn_008_nested_call(x: i64) i64 { return x * 3; }
fn apply_both_parity_fn_008_nested_call(x: i64) i64 { return double_parity_fn_008_nested_call(triple_parity_fn_008_nested_call(x)); }
fn test_parity_fn_008_nested_call() i64 { if apply_both_parity_fn_008_nested_call(5) == 30 { return 42; } return 1; }


// Parity test: functions/fn_009_factorial
fn factorial_parity_fn_009_factorial(n: i64) i64 {
    if n <= 1 { return 1; }
    return n * factorial_parity_fn_009_factorial(n - 1);
}
fn test_parity_fn_009_factorial() i64 { if factorial_parity_fn_009_factorial(5) == 120 { return 42; } return 1; }


// Parity test: functions/fn_010_call_in_expr
fn square_parity_fn_010_call_in_expr(x: i64) i64 { return x * x; }
fn test_parity_fn_010_call_in_expr() i64 {
    var result: i64 = square_parity_fn_010_call_in_expr(3) + square_parity_fn_010_call_in_expr(4);
    if result == 25 { return 42; }
    return 1;
}


// Parity test: functions/fn_013_call_chain
fn f1_parity_fn_013_call_chain(x: i64) i64 { return x + 1; }
fn f2_parity_fn_013_call_chain(x: i64) i64 { return f1_parity_fn_013_call_chain(x) + 1; }
fn f3_parity_fn_013_call_chain(x: i64) i64 { return f2_parity_fn_013_call_chain(x) + 1; }
fn f4_parity_fn_013_call_chain(x: i64) i64 { return f3_parity_fn_013_call_chain(x) + 1; }
fn test_parity_fn_013_call_chain() i64 { if f4_parity_fn_013_call_chain(0) == 4 { return 42; } return 1; }


// Parity test: functions/fn_014_result_in_cond
fn double_parity_fn_014_result_in_cond(x: i64) i64 { return x * 2; }
fn test_parity_fn_014_result_in_cond() i64 {
    if double_parity_fn_014_result_in_cond(5) > 8 { return 42; }
    return 1;
}


// Parity test: functions/fn_015_call_as_arg
fn add_parity_fn_015_call_as_arg(a: i64, b: i64) i64 { return a + b; }
fn triple_parity_fn_015_call_as_arg(x: i64) i64 { return x * 3; }
fn test_parity_fn_015_call_as_arg() i64 { if add_parity_fn_015_call_as_arg(triple_parity_fn_015_call_as_arg(2), triple_parity_fn_015_call_as_arg(3)) == 15 { return 42; } return 1; }


// Parity test: functions/fn_016_many_calls
fn inc_parity_fn_016_many_calls(x: i64) i64 { return x + 1; }
fn test_parity_fn_016_many_calls() i64 {
    var a: i64 = inc_parity_fn_016_many_calls(0);
    var b: i64 = inc_parity_fn_016_many_calls(a);
    var c: i64 = inc_parity_fn_016_many_calls(b);
    var d: i64 = inc_parity_fn_016_many_calls(c);
    var e: i64 = inc_parity_fn_016_many_calls(d);
    if e == 5 { return 42; }
    return 1;
}


// Parity test: functions/fn_017_collatz
fn collatz_steps_parity_fn_017_collatz(n: i64) i64 {
    var steps: i64 = 0;
    var x: i64 = n;
    while x != 1 {
        if (x % 2) == 0 { x = x / 2; }
        else { x = x * 3 + 1; }
        steps = steps + 1;
    }
    return steps;
}
fn test_parity_fn_017_collatz() i64 { if collatz_steps_parity_fn_017_collatz(6) == 8 { return 42; } return 1; }


// Parity test: functions/fn_018_is_prime
fn is_prime_parity_fn_018_is_prime(n: i64) i64 {
    if n < 2 { return 0; }
    var i: i64 = 2;
    while i * i <= n {
        if (n % i) == 0 { return 0; }
        i = i + 1;
    }
    return 1;
}
fn test_parity_fn_018_is_prime() i64 { if is_prime_parity_fn_018_is_prime(17) == 1 { return 42; } return 1; }


// Parity test: functions/fn_019_count_primes
fn is_prime_parity_fn_019_count_primes(n: i64) i64 {
    if n < 2 { return 0; }
    var i: i64 = 2;
    while i * i <= n {
        if (n % i) == 0 { return 0; }
        i = i + 1;
    }
    return 1;
}
fn count_primes_parity_fn_019_count_primes(n: i64) i64 {
    var count: i64 = 0;
    var i: i64 = 2;
    while i <= n {
        if is_prime_parity_fn_019_count_primes(i) != 0 { count = count + 1; }
        i = i + 1;
    }
    return count;
}
fn test_parity_fn_019_count_primes() i64 { if count_primes_parity_fn_019_count_primes(20) == 8 { return 42; } return 1; }


// Parity test: functions/fn_020_nth_fib
fn fib_parity_fn_020_nth_fib(n: i64) i64 {
    if n <= 1 { return n; }
    var a: i64 = 0;
    var b: i64 = 1;
    var i: i64 = 2;
    while i <= n {
        var t: i64 = a + b;
        a = b;
        b = t;
        i = i + 1;
    }
    return b;
}
fn test_parity_fn_020_nth_fib() i64 { if fib_parity_fn_020_nth_fib(10) == 55 { return 42; } return 1; }


// Parity test: functions/fn_021_triangle
fn triangle_parity_fn_021_triangle(n: i64) i64 {
    return n * (n + 1) / 2;
}
fn test_parity_fn_021_triangle() i64 { if triangle_parity_fn_021_triangle(10) == 55 { return 42; } return 1; }


// Parity test: functions/fn_022_apply_twice
fn double_parity_fn_022_apply_twice(x: i64) i64 { return x * 2; }
fn apply_twice_parity_fn_022_apply_twice(x: i64) i64 { return double_parity_fn_022_apply_twice(double_parity_fn_022_apply_twice(x)); }
fn test_parity_fn_022_apply_twice() i64 { if apply_twice_parity_fn_022_apply_twice(5) == 20 { return 42; } return 1; }


// Parity test: functions/fn_023_compose
fn add5_parity_fn_023_compose(x: i64) i64 { return x + 5; }
fn mul2_parity_fn_023_compose(x: i64) i64 { return x * 2; }
fn compose_parity_fn_023_compose(x: i64) i64 { return mul2_parity_fn_023_compose(add5_parity_fn_023_compose(x)); }
fn test_parity_fn_023_compose() i64 { if compose_parity_fn_023_compose(10) == 30 { return 42; } return 1; }


// Parity test: functions/fn_024_ackermann
// Ackermann function - tests nested recursive calls
// ack_parity_fn_024_ackermann(m - 1, ack_parity_fn_024_ackermann(m, n - 1)) requires storing all args to temp locals
fn ack_parity_fn_024_ackermann(m: i64, n: i64) i64 {
    if m == 0 { return n + 1; }
    if n == 0 { return ack_parity_fn_024_ackermann(m - 1, 1); }
    return ack_parity_fn_024_ackermann(m - 1, ack_parity_fn_024_ackermann(m, n - 1));
}
fn test_parity_fn_024_ackermann() i64 { if ack_parity_fn_024_ackermann(2, 3) == 9 { return 42; } return 1; }


// Parity test: functions/fn_025_sum_range
fn sum_range_parity_fn_025_sum_range(a: i64, b: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = a;
    while i <= b {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}
fn test_parity_fn_025_sum_range() i64 { if sum_range_parity_fn_025_sum_range(5, 10) == 45 { return 42; } return 1; }


// Parity test: functions/fn_026_identity
fn identity_parity_fn_026_identity(x: i64) i64 { return x; }
fn test_parity_fn_026_identity() i64 { if identity_parity_fn_026_identity(42) == 42 { return 42; } return 1; }


// Parity test: functions/fn_027_swap_args
fn swap_sub_parity_fn_027_swap_args(a: i64, b: i64) i64 { return b - a; }
fn test_parity_fn_027_swap_args() i64 { if swap_sub_parity_fn_027_swap_args(3, 10) == 7 { return 42; } return 1; }


// Parity test: functions/fn_028_ignore_arg
fn ignore_second_parity_fn_028_ignore_arg(a: i64, b: i64) i64 { return a; }
fn test_parity_fn_028_ignore_arg() i64 { if ignore_second_parity_fn_028_ignore_arg(42, 999) == 42 { return 42; } return 1; }


// Parity test: functions/fn_029_all_args
fn use_all_parity_fn_029_all_args(a: i64, b: i64, c: i64, d: i64) i64 {
    return ((a - b) * c) + d;
}
fn test_parity_fn_029_all_args() i64 { if use_all_parity_fn_029_all_args(10, 3, 4, 5) == 33 { return 42; } return 1; }


// Parity test: functions/fn_030_chain_five
fn f1_parity_fn_030_chain_five(x: i64) i64 { return x + 1; }
fn f2_parity_fn_030_chain_five(x: i64) i64 { return f1_parity_fn_030_chain_five(x) + 1; }
fn f3_parity_fn_030_chain_five(x: i64) i64 { return f2_parity_fn_030_chain_five(x) + 1; }
fn f4_parity_fn_030_chain_five(x: i64) i64 { return f3_parity_fn_030_chain_five(x) + 1; }
fn f5_parity_fn_030_chain_five(x: i64) i64 { return f4_parity_fn_030_chain_five(x) + 1; }
fn test_parity_fn_030_chain_five() i64 { if f5_parity_fn_030_chain_five(0) == 5 { return 42; } return 1; }


// Parity test: functions/fn_031_deep_call
fn a_parity_fn_031_deep_call(x: i64) i64 { return b_parity_fn_031_deep_call(x + 1); }
fn b_parity_fn_031_deep_call(x: i64) i64 { return c_parity_fn_031_deep_call(x + 1); }
fn c_parity_fn_031_deep_call(x: i64) i64 { return d_parity_fn_031_deep_call(x + 1); }
fn d_parity_fn_031_deep_call(x: i64) i64 { return e_parity_fn_031_deep_call(x + 1); }
fn e_parity_fn_031_deep_call(x: i64) i64 { return f_parity_fn_031_deep_call(x + 1); }
fn f_parity_fn_031_deep_call(x: i64) i64 { return x; }
fn test_parity_fn_031_deep_call() i64 { if a_parity_fn_031_deep_call(0) == 5 { return 42; } return 1; }


// Parity test: functions/fn_032_many_params
fn sum9_parity_fn_032_many_params(a: i64, b: i64, c: i64, d: i64, e: i64, f: i64, g: i64, h: i64, i: i64) i64 {
    return a + b + c + d + e + f + g + h + i;
}
fn test_parity_fn_032_many_params() i64 { if sum9_parity_fn_032_many_params(1, 2, 3, 4, 5, 6, 7, 8, 9) == 45 { return 42; } return 1; }


// Parity test: functions/fn_033_tail_call
fn countdown_parity_fn_033_tail_call(n: i64) i64 {
    if n <= 0 { return 0; }
    return countdown_parity_fn_033_tail_call(n - 1);
}
fn test_parity_fn_033_tail_call() i64 { if countdown_parity_fn_033_tail_call(100) == 0 { return 42; } return 1; }


// Parity test: functions/fn_034_sum_recursive
fn sum_rec_parity_fn_034_sum_recursive(n: i64) i64 {
    if n <= 0 { return 0; }
    return n + sum_rec_parity_fn_034_sum_recursive(n - 1);
}
fn test_parity_fn_034_sum_recursive() i64 { if sum_rec_parity_fn_034_sum_recursive(10) == 55 { return 42; } return 1; }


// Parity test: functions/fn_035_mult_recursive
fn mult_rec_parity_fn_035_mult_recursive(a: i64, b: i64) i64 {
    if b <= 0 { return 0; }
    return a + mult_rec_parity_fn_035_mult_recursive(a, b - 1);
}
fn test_parity_fn_035_mult_recursive() i64 { if mult_rec_parity_fn_035_mult_recursive(7, 6) == 42 { return 42; } return 1; }


// Parity test: functions/fn_036_div_rem
fn div_rem_parity_fn_036_div_rem(a: i64, b: i64, q: *i64, r: *i64) void {
    q.* = a / b;
    r.* = a % b;
}
fn test_parity_fn_036_div_rem() i64 {
    var quot: i64 = 0;
    var rem: i64 = 0;
    div_rem_parity_fn_036_div_rem(17, 5, &quot, &rem);
    if quot == 3 {
        if rem == 2 { return 42; }
    }
    return 1;
}


// Parity test: functions/fn_037_minmax
fn minmax_parity_fn_037_minmax(a: i64, b: i64, min: *i64, max: *i64) void {
    if a < b { min.* = a; max.* = b; }
    else { min.* = b; max.* = a; }
}
fn test_parity_fn_037_minmax() i64 {
    var lo: i64 = 0;
    var hi: i64 = 0;
    minmax_parity_fn_037_minmax(7, 3, &lo, &hi);
    if lo == 3 {
        if hi == 7 { return 42; }
    }
    return 1;
}


// Parity test: functions/fn_038_nested_call_3
fn add1_parity_fn_038_nested_call_3(x: i64) i64 { return x + 1; }
fn nested3_parity_fn_038_nested_call_3(x: i64) i64 { return add1_parity_fn_038_nested_call_3(add1_parity_fn_038_nested_call_3(add1_parity_fn_038_nested_call_3(x))); }
fn test_parity_fn_038_nested_call_3() i64 { if nested3_parity_fn_038_nested_call_3(0) == 3 { return 42; } return 1; }


// Parity test: functions/fn_039_call_in_binop
fn double_parity_fn_039_call_in_binop(x: i64) i64 { return x * 2; }
fn call_in_binop_parity_fn_039_call_in_binop(a: i64, b: i64) i64 { return double_parity_fn_039_call_in_binop(a) + double_parity_fn_039_call_in_binop(b); }
fn test_parity_fn_039_call_in_binop() i64 { if call_in_binop_parity_fn_039_call_in_binop(3, 4) == 14 { return 42; } return 1; }


// Parity test: functions/fn_040_call_in_call
fn add_parity_fn_040_call_in_call(a: i64, b: i64) i64 { return a + b; }
fn mul_parity_fn_040_call_in_call(a: i64, b: i64) i64 { return a * b; }
fn call_in_call_parity_fn_040_call_in_call(x: i64) i64 { return add_parity_fn_040_call_in_call(mul_parity_fn_040_call_in_call(x, 2), mul_parity_fn_040_call_in_call(x, 3)); }
fn test_parity_fn_040_call_in_call() i64 { if call_in_call_parity_fn_040_call_in_call(5) == 25 { return 42; } return 1; }


// Parity test: functions/fn_041_call_both_args
fn inc_parity_fn_041_call_both_args(x: i64) i64 { return x + 1; }
fn add_parity_fn_041_call_both_args(a: i64, b: i64) i64 { return a + b; }
fn both_args_parity_fn_041_call_both_args(x: i64, y: i64) i64 { return add_parity_fn_041_call_both_args(inc_parity_fn_041_call_both_args(x), inc_parity_fn_041_call_both_args(y)); }
fn test_parity_fn_041_call_both_args() i64 { if both_args_parity_fn_041_call_both_args(5, 10) == 17 { return 42; } return 1; }


// Parity test: functions/fn_042_recursive_sum
fn rec_sum_parity_fn_042_recursive_sum(a: i64, b: i64, c: i64) i64 {
    if a <= 0 { return c; }
    return rec_sum_parity_fn_042_recursive_sum(a - 1, b, c + b);
}
fn test_parity_fn_042_recursive_sum() i64 { if rec_sum_parity_fn_042_recursive_sum(5, 3, 0) == 15 { return 42; } return 1; }


// Parity test: functions/fn_043_mutual_simple
fn ping_parity_fn_043_mutual_simple(n: i64) i64 {
    if n <= 0 { return 0; }
    return pong_parity_fn_043_mutual_simple(n - 1) + 1;
}
fn pong_parity_fn_043_mutual_simple(n: i64) i64 {
    if n <= 0 { return 0; }
    return ping_parity_fn_043_mutual_simple(n - 1) + 1;
}
fn test_parity_fn_043_mutual_simple() i64 { if ping_parity_fn_043_mutual_simple(10) == 10 { return 42; } return 1; }


// Parity test: functions/fn_044_many_params
fn sum6_parity_fn_044_many_params(a: i64, b: i64, c: i64, d: i64, e: i64, f: i64) i64 {
    return a + b + c + d + e + f;
}
fn test_parity_fn_044_many_params() i64 {
    if sum6_parity_fn_044_many_params(1, 2, 3, 4, 5, 6) == 21 { return 42; }
    return 1;
}


// Parity test: functions/fn_045_8_params
fn sum8_parity_fn_045_8_params(a: i64, b: i64, c: i64, d: i64, e: i64, f: i64, g: i64, h: i64) i64 {
    return a + b + c + d + e + f + g + h;
}
fn test_parity_fn_045_8_params() i64 {
    if sum8_parity_fn_045_8_params(1, 2, 3, 4, 5, 6, 7, 8) == 36 { return 42; }
    return 1;
}


// Parity test: functions/fn_046_call_chain
fn double_parity_fn_046_call_chain(x: i64) i64 { return x * 2; }
fn triple_parity_fn_046_call_chain(x: i64) i64 { return x * 3; }
fn quadruple_parity_fn_046_call_chain(x: i64) i64 { return x * 4; }
fn test_parity_fn_046_call_chain() i64 {
    var r: i64 = quadruple_parity_fn_046_call_chain(triple_parity_fn_046_call_chain(double_parity_fn_046_call_chain(5)));
    if r == 120 { return 42; }
    return 1;
}


// Parity test: functions/fn_047_mixed_calls
fn add_parity_fn_047_mixed_calls(a: i64, b: i64) i64 { return a + b; }
fn mul_parity_fn_047_mixed_calls(a: i64, b: i64) i64 { return a * b; }
fn test_parity_fn_047_mixed_calls() i64 {
    var r: i64 = add_parity_fn_047_mixed_calls(mul_parity_fn_047_mixed_calls(2, 3), mul_parity_fn_047_mixed_calls(4, 5));
    if r == 26 { return 42; }
    return 1;
}


// Parity test: functions/fn_048_call_in_cond
fn is_even_parity_fn_048_call_in_cond(x: i64) i64 {
    if x % 2 == 0 { return 1; }
    return 0;
}
fn test_parity_fn_048_call_in_cond() i64 {
    if is_even_parity_fn_048_call_in_cond(4) == 1 and is_even_parity_fn_048_call_in_cond(7) == 0 { return 42; }
    return 1;
}


// Parity test: functions/fn_049_call_in_while
fn square_parity_fn_049_call_in_while(x: i64) i64 { return x * x; }
fn test_parity_fn_049_call_in_while() i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    while i <= 5 {
        sum = sum + square_parity_fn_049_call_in_while(i);
        i = i + 1;
    }
    if sum == 55 { return 42; }
    return 1;
}


// Parity test: functions/fn_050_void_fn
fn set_value_parity_fn_050_void_fn(ptr: *i64, val: i64) void {
    ptr.* = val;
}
fn test_parity_fn_050_void_fn() i64 {
    var arr: *i64 = malloc(8);
    set_value_parity_fn_050_void_fn(arr, 42);
    if arr.* == 42 { return 42; }
    return 1;
}


// Parity test: functions/fn_051_return_ptr
fn make_array_parity_fn_051_return_ptr(size: i64) *i64 {
    return malloc(size * 8);
}
fn test_parity_fn_051_return_ptr() i64 {
    var arr: *i64 = make_array_parity_fn_051_return_ptr(3);
    arr.* = 100;
    if arr.* == 100 { return 42; }
    return 1;
}


// Parity test: functions/fn_052_ptr_param
fn swap_parity_fn_052_ptr_param(a: *i64, b: *i64) void {
    var tmp: i64 = a.*;
    a.* = b.*;
    b.* = tmp;
}
fn test_parity_fn_052_ptr_param() i64 {
    var x: i64 = 10;
    var y: i64 = 20;
    swap_parity_fn_052_ptr_param(&x, &y);
    if x == 20 and y == 10 { return 42; }
    return 1;
}


// Parity test: functions/fn_053_triple_call
fn add_parity_fn_053_triple_call(a: i64, b: i64) i64 { return a + b; }
fn test_parity_fn_053_triple_call() i64 {
    var r: i64 = add_parity_fn_053_triple_call(add_parity_fn_053_triple_call(add_parity_fn_053_triple_call(1, 2), 3), 4);
    if r == 10 { return 42; }
    return 1;
}


// Parity test: functions/fn_054_closure_like
fn adder_parity_fn_054_closure_like(base: i64, x: i64) i64 {
    return base + x;
}
fn test_parity_fn_054_closure_like() i64 {
    var b: i64 = 100;
    var r1: i64 = adder_parity_fn_054_closure_like(b, 1);
    var r2: i64 = adder_parity_fn_054_closure_like(b, 2);
    var r3: i64 = adder_parity_fn_054_closure_like(b, 3);
    if r1 == 101 and r2 == 102 and r3 == 103 { return 42; }
    return 1;
}


// Parity test: functions/fn_055_call_result_expr
fn double_parity_fn_055_call_result_expr(x: i64) i64 { return x * 2; }
fn test_parity_fn_055_call_result_expr() i64 {
    var r: i64 = double_parity_fn_055_call_result_expr(5) + double_parity_fn_055_call_result_expr(10);
    if r == 30 { return 42; }
    return 1;
}


// Parity test: functions/fn_056_call_result_cmp
fn square_parity_fn_056_call_result_cmp(x: i64) i64 { return x * x; }
fn test_parity_fn_056_call_result_cmp() i64 {
    if square_parity_fn_056_call_result_cmp(3) < square_parity_fn_056_call_result_cmp(4) { return 42; }
    return 1;
}


// Parity test: functions/fn_057_fibonacci_iter
fn fib_iter_parity_fn_057_fibonacci_iter(n: i64) i64 {
    if n <= 1 { return n; }
    var a: i64 = 0;
    var b: i64 = 1;
    var i: i64 = 2;
    while i <= n {
        var tmp: i64 = a + b;
        a = b;
        b = tmp;
        i = i + 1;
    }
    return b;
}
fn test_parity_fn_057_fibonacci_iter() i64 {
    if fib_iter_parity_fn_057_fibonacci_iter(10) == 55 { return 42; }
    return 1;
}


// Parity test: functions/fn_058_factorial_iter
fn fact_iter_parity_fn_058_factorial_iter(n: i64) i64 {
    var result: i64 = 1;
    var i: i64 = 2;
    while i <= n {
        result = result * i;
        i = i + 1;
    }
    return result;
}
fn test_parity_fn_058_factorial_iter() i64 {
    if fact_iter_parity_fn_058_factorial_iter(6) == 720 { return 42; }
    return 1;
}


// Parity test: functions/fn_059_power
fn power_parity_fn_059_power(base: i64, exp: i64) i64 {
    var result: i64 = 1;
    var i: i64 = 0;
    while i < exp {
        result = result * base;
        i = i + 1;
    }
    return result;
}
fn test_parity_fn_059_power() i64 {
    if power_parity_fn_059_power(2, 10) == 1024 { return 42; }
    return 1;
}


// Parity test: functions/fn_060_is_prime
fn is_prime_parity_fn_060_is_prime(n: i64) i64 {
    if n <= 1 { return 0; }
    if n <= 3 { return 1; }
    if n % 2 == 0 { return 0; }
    var i: i64 = 3;
    while i * i <= n {
        if n % i == 0 { return 0; }
        i = i + 2;
    }
    return 1;
}
fn test_parity_fn_060_is_prime() i64 {
    var p1: i64 = is_prime_parity_fn_060_is_prime(2);
    var p2: i64 = is_prime_parity_fn_060_is_prime(17);
    var p3: i64 = is_prime_parity_fn_060_is_prime(18);
    var p4: i64 = is_prime_parity_fn_060_is_prime(97);
    if p1 == 1 and p2 == 1 and p3 == 0 and p4 == 1 { return 42; }
    return 1;
}


// Parity test: functions/fn_061_collatz
fn collatz_steps_parity_fn_061_collatz(n: i64) i64 {
    var steps: i64 = 0;
    var x: i64 = n;
    while x > 1 {
        if x % 2 == 0 {
            x = x / 2;
        } else {
            x = 3 * x + 1;
        }
        steps = steps + 1;
    }
    return steps;
}
fn test_parity_fn_061_collatz() i64 {
    if collatz_steps_parity_fn_061_collatz(27) == 111 { return 42; }
    return 1;
}


// Parity test: functions/fn_062_digit_sum
fn digit_sum_parity_fn_062_digit_sum(n: i64) i64 {
    var sum: i64 = 0;
    var x: i64 = n;
    while x > 0 {
        sum = sum + (x % 10);
        x = x / 10;
    }
    return sum;
}
fn test_parity_fn_062_digit_sum() i64 {
    if digit_sum_parity_fn_062_digit_sum(12345) == 15 { return 42; }
    return 1;
}


// Parity test: functions/fn_063_reverse_digits
fn reverse_num_parity_fn_063_reverse_digits(n: i64) i64 {
    var rev: i64 = 0;
    var x: i64 = n;
    while x > 0 {
        rev = rev * 10 + (x % 10);
        x = x / 10;
    }
    return rev;
}
fn test_parity_fn_063_reverse_digits() i64 {
    if reverse_num_parity_fn_063_reverse_digits(12345) == 54321 { return 42; }
    return 1;
}


// Parity test: functions/fn_064_count_digits
fn count_digits_parity_fn_064_count_digits(n: i64) i64 {
    if n == 0 { return 1; }
    var count: i64 = 0;
    var x: i64 = n;
    while x > 0 {
        count = count + 1;
        x = x / 10;
    }
    return count;
}
fn test_parity_fn_064_count_digits() i64 {
    var c1: i64 = count_digits_parity_fn_064_count_digits(0);
    var c2: i64 = count_digits_parity_fn_064_count_digits(12345);
    var c3: i64 = count_digits_parity_fn_064_count_digits(1000000);
    if c1 == 1 and c2 == 5 and c3 == 7 { return 42; }
    return 1;
}


// Parity test: functions/fn_065_min_max
fn min_parity_fn_065_min_max(a: i64, b: i64) i64 {
    if a < b { return a; }
    return b;
}
fn max_parity_fn_065_min_max(a: i64, b: i64) i64 {
    if a > b { return a; }
    return b;
}
fn test_parity_fn_065_min_max() i64 {
    var a: i64 = 5;
    var b: i64 = 10;
    if min_parity_fn_065_min_max(a, b) == 5 and max_parity_fn_065_min_max(a, b) == 10 { return 42; }
    return 1;
}


// Parity test: functions/fn_066_clamp
fn clamp_parity_fn_066_clamp(x: i64, lo: i64, hi: i64) i64 {
    if x < lo { return lo; }
    if x > hi { return hi; }
    return x;
}
fn test_parity_fn_066_clamp() i64 {
    var c1: i64 = clamp_parity_fn_066_clamp(5, 0, 10);
    var c2: i64 = clamp_parity_fn_066_clamp(0 - 5, 0, 10);
    var c3: i64 = clamp_parity_fn_066_clamp(15, 0, 10);
    if c1 == 5 and c2 == 0 and c3 == 10 { return 42; }
    return 1;
}


// Parity test: functions/fn_067_abs
fn abs_parity_fn_067_abs(x: i64) i64 {
    if x < 0 { return 0 - x; }
    return x;
}
fn test_parity_fn_067_abs() i64 {
    var a1: i64 = abs_parity_fn_067_abs(5);
    var a2: i64 = abs_parity_fn_067_abs(0 - 5);
    var a3: i64 = abs_parity_fn_067_abs(0);
    if a1 == 5 and a2 == 5 and a3 == 0 { return 42; }
    return 1;
}


// Parity test: functions/fn_068_sign
fn sign_parity_fn_068_sign(x: i64) i64 {
    if x < 0 { return 0 - 1; }
    if x > 0 { return 1; }
    return 0;
}
fn test_parity_fn_068_sign() i64 {
    var s1: i64 = sign_parity_fn_068_sign(42);
    var s2: i64 = sign_parity_fn_068_sign(0 - 42);
    var s3: i64 = sign_parity_fn_068_sign(0);
    if s1 == 1 and s2 == 0 - 1 and s3 == 0 { return 42; }
    return 1;
}


// Parity test: functions/fn_069_euclidean
fn gcd_euclid_parity_fn_069_euclidean(a: i64, b: i64) i64 {
    var x: i64 = a;
    var y: i64 = b;
    while y > 0 {
        var t: i64 = y;
        y = x % y;
        x = t;
    }
    return x;
}
fn test_parity_fn_069_euclidean() i64 {
    if gcd_euclid_parity_fn_069_euclidean(48, 18) == 6 { return 42; }
    return 1;
}


// Parity test: functions/fn_070_lcm
fn gcd_parity_fn_070_lcm(a: i64, b: i64) i64 {
    var x: i64 = a;
    var y: i64 = b;
    while y > 0 {
        var t: i64 = y;
        y = x % y;
        x = t;
    }
    return x;
}
fn lcm_parity_fn_070_lcm(a: i64, b: i64) i64 {
    return (a / gcd_parity_fn_070_lcm(a, b)) * b;
}
fn test_parity_fn_070_lcm() i64 {
    if lcm_parity_fn_070_lcm(12, 18) == 36 { return 42; }
    return 1;
}


// Parity test: functions/fn_071_sum_sq
fn sum_of_squares_parity_fn_071_sum_sq(n: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    while i <= n {
        sum = sum + i * i;
        i = i + 1;
    }
    return sum;
}
fn test_parity_fn_071_sum_sq() i64 {
    if sum_of_squares_parity_fn_071_sum_sq(10) == 385 { return 42; }
    return 1;
}


// Parity test: functions/fn_072_sum_cubes
fn sum_of_cubes_parity_fn_072_sum_cubes(n: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    while i <= n {
        sum = sum + i * i * i;
        i = i + 1;
    }
    return sum;
}
fn test_parity_fn_072_sum_cubes() i64 {
    if sum_of_cubes_parity_fn_072_sum_cubes(10) == 3025 { return 42; }
    return 1;
}


// Parity test: functions/fn_073_nth_prime
fn is_prime_parity_fn_073_nth_prime(n: i64) i64 {
    if n <= 1 { return 0; }
    if n <= 3 { return 1; }
    if n % 2 == 0 { return 0; }
    var i: i64 = 3;
    while i * i <= n {
        if n % i == 0 { return 0; }
        i = i + 2;
    }
    return 1;
}
fn nth_prime_parity_fn_073_nth_prime(n: i64) i64 {
    var count: i64 = 0;
    var num: i64 = 2;
    while count < n {
        if is_prime_parity_fn_073_nth_prime(num) == 1 {
            count = count + 1;
            if count == n { return num; }
        }
        num = num + 1;
    }
    return num;
}
fn test_parity_fn_073_nth_prime() i64 {
    if nth_prime_parity_fn_073_nth_prime(10) == 29 { return 42; }
    return 1;
}


// Parity test: functions/fn_074_triangular
fn triangular_parity_fn_074_triangular(n: i64) i64 {
    return n * (n + 1) / 2;
}
fn test_parity_fn_074_triangular() i64 {
    if triangular_parity_fn_074_triangular(100) == 5050 { return 42; }
    return 1;
}


// Parity test: functions/fn_075_square_check
fn is_perfect_square_parity_fn_075_square_check(n: i64) i64 {
    var i: i64 = 1;
    while i * i <= n {
        if i * i == n { return 1; }
        i = i + 1;
    }
    return 0;
}
fn test_parity_fn_075_square_check() i64 {
    var r1: i64 = is_perfect_square_parity_fn_075_square_check(16);
    var r2: i64 = is_perfect_square_parity_fn_075_square_check(17);
    var r3: i64 = is_perfect_square_parity_fn_075_square_check(100);
    if r1 == 1 and r2 == 0 and r3 == 1 { return 42; }
    return 1;
}


// Parity test: functions/fn_076_integer_sqrt
fn isqrt_parity_fn_076_integer_sqrt(n: i64) i64 {
    var x: i64 = n;
    var y: i64 = (x + 1) / 2;
    while y < x {
        x = y;
        y = (x + n / x) / 2;
    }
    return x;
}
fn test_parity_fn_076_integer_sqrt() i64 {
    if isqrt_parity_fn_076_integer_sqrt(100) == 10 { return 42; }
    return 1;
}


// Parity test: functions/fn_077_divisors_count
fn count_divisors_parity_fn_077_divisors_count(n: i64) i64 {
    var count: i64 = 0;
    var i: i64 = 1;
    while i <= n {
        if n % i == 0 {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}
fn test_parity_fn_077_divisors_count() i64 {
    if count_divisors_parity_fn_077_divisors_count(12) == 6 { return 42; }
    return 1;
}


// Parity test: functions/fn_078_divisors_sum
fn sum_divisors_parity_fn_078_divisors_sum(n: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    while i <= n {
        if n % i == 0 {
            sum = sum + i;
        }
        i = i + 1;
    }
    return sum;
}
fn test_parity_fn_078_divisors_sum() i64 {
    if sum_divisors_parity_fn_078_divisors_sum(12) == 28 { return 42; }
    return 1;
}


// Parity test: functions/fn_079_exp_by_squaring
fn fast_pow_parity_fn_079_exp_by_squaring(base: i64, exp: i64) i64 {
    var result: i64 = 1;
    var b: i64 = base;
    var e: i64 = exp;
    while e > 0 {
        if e % 2 == 1 {
            result = result * b;
        }
        e = e / 2;
        b = b * b;
    }
    return result;
}
fn test_parity_fn_079_exp_by_squaring() i64 {
    if fast_pow_parity_fn_079_exp_by_squaring(2, 10) == 1024 { return 42; }
    return 1;
}


// Parity test: functions/fn_080_modular_exp
fn mod_pow_parity_fn_080_modular_exp(base: i64, exp: i64, mod: i64) i64 {
    var result: i64 = 1;
    var b: i64 = base % mod;
    var e: i64 = exp;
    while e > 0 {
        if e % 2 == 1 {
            result = (result * b) % mod;
        }
        e = e / 2;
        b = (b * b) % mod;
    }
    return result;
}
fn test_parity_fn_080_modular_exp() i64 {
    if mod_pow_parity_fn_080_modular_exp(2, 10, 1000) == 24 { return 42; }
    return 1;
}


// Parity test: functions/fn_081_extended_gcd
fn gcd_parity_fn_081_extended_gcd(a: i64, b: i64) i64 {
    var x: i64 = a;
    var y: i64 = b;
    while y > 0 {
        var t: i64 = y;
        y = x % y;
        x = t;
    }
    return x;
}
fn test_parity_fn_081_extended_gcd() i64 {
    var g1: i64 = gcd_parity_fn_081_extended_gcd(252, 105);
    var g2: i64 = gcd_parity_fn_081_extended_gcd(1071, 462);
    if g1 == 21 and g2 == 21 { return 42; }
    return 1;
}


// Parity test: functions/fn_082_call_side_effect
fn increment_parity_fn_082_call_side_effect(p: *i64) i64 {
    var old: i64 = p.*;
    p.* = p.* + 1;
    return old;
}
fn test_parity_fn_082_call_side_effect() i64 {
    var arr: *i64 = malloc(8);
    arr.* = 5;
    var r1: i64 = increment_parity_fn_082_call_side_effect(arr);
    var r2: i64 = increment_parity_fn_082_call_side_effect(arr);
    if r1 == 5 and r2 == 6 and arr.* == 7 { return 42; }
    return 1;
}


// Parity test: functions/fn_083_tail_like
fn count_down_parity_fn_083_tail_like(n: i64) i64 {
    if n <= 0 { return 0; }
    return count_down_parity_fn_083_tail_like(n - 1) + 1;
}
fn test_parity_fn_083_tail_like() i64 {
    if count_down_parity_fn_083_tail_like(100) == 100 { return 42; }
    return 1;
}


// Parity test: functions/fn_084_sum_rec
fn sum_to_parity_fn_084_sum_rec(n: i64) i64 {
    if n <= 0 { return 0; }
    return n + sum_to_parity_fn_084_sum_rec(n - 1);
}
fn test_parity_fn_084_sum_rec() i64 {
    if sum_to_parity_fn_084_sum_rec(10) == 55 { return 42; }
    return 1;
}


// Parity test: functions/fn_085_product_rec
fn factorial_parity_fn_085_product_rec(n: i64) i64 {
    if n <= 1 { return 1; }
    return n * factorial_parity_fn_085_product_rec(n - 1);
}
fn test_parity_fn_085_product_rec() i64 {
    if factorial_parity_fn_085_product_rec(10) == 3628800 { return 42; }
    return 1;
}


// Parity test: functions/fn_086_mutual_even_odd
fn is_odd_parity_fn_086_mutual_even_odd(n: i64) i64 {
    if n == 0 { return 0; }
    return is_even_parity_fn_086_mutual_even_odd(n - 1);
}
fn is_even_parity_fn_086_mutual_even_odd(n: i64) i64 {
    if n == 0 { return 1; }
    return is_odd_parity_fn_086_mutual_even_odd(n - 1);
}
fn test_parity_fn_086_mutual_even_odd() i64 {
    if is_even_parity_fn_086_mutual_even_odd(10) == 1 {
        if is_odd_parity_fn_086_mutual_even_odd(7) == 1 { return 42; }
    }
    return 1;
}


// Parity test: functions/fn_087_collatz_steps
fn collatz_steps_parity_fn_087_collatz_steps(n: i64) i64 {
    if n == 1 { return 0; }
    if n % 2 == 0 {
        return 1 + collatz_steps_parity_fn_087_collatz_steps(n / 2);
    }
    return 1 + collatz_steps_parity_fn_087_collatz_steps(3 * n + 1);
}
fn test_parity_fn_087_collatz_steps() i64 {
    if collatz_steps_parity_fn_087_collatz_steps(6) == 8 { return 42; }
    return 1;
}


// Parity test: functions/fn_090_reverse_digits
fn reverse_helper_parity_fn_090_reverse_digits(n: i64, acc: i64) i64 {
    if n == 0 { return acc; }
    return reverse_helper_parity_fn_090_reverse_digits(n / 10, acc * 10 + n % 10);
}
fn reverse_digits_parity_fn_090_reverse_digits(n: i64) i64 {
    return reverse_helper_parity_fn_090_reverse_digits(n, 0);
}
fn test_parity_fn_090_reverse_digits() i64 {
    if reverse_digits_parity_fn_090_reverse_digits(12345) == 54321 { return 42; }
    return 1;
}


// Parity test: functions/fn_091_is_palindrome
fn reverse_helper_parity_fn_091_is_palindrome(n: i64, acc: i64) i64 {
    if n == 0 { return acc; }
    return reverse_helper_parity_fn_091_is_palindrome(n / 10, acc * 10 + n % 10);
}
fn is_palindrome_parity_fn_091_is_palindrome(n: i64) i64 {
    if n < 0 { return 0; }
    if reverse_helper_parity_fn_091_is_palindrome(n, 0) == n { return 1; }
    return 0;
}
fn test_parity_fn_091_is_palindrome() i64 {
    if is_palindrome_parity_fn_091_is_palindrome(12321) == 1 and is_palindrome_parity_fn_091_is_palindrome(12345) == 0 { return 42; }
    return 1;
}


// Parity test: functions/fn_092_is_power_of_two
fn is_power_of_two_parity_fn_092_is_power_of_two(n: i64) i64 {
    if n <= 0 { return 0; }
    if n == 1 { return 1; }
    if n % 2 != 0 { return 0; }
    return is_power_of_two_parity_fn_092_is_power_of_two(n / 2);
}
fn test_parity_fn_092_is_power_of_two() i64 {
    if is_power_of_two_parity_fn_092_is_power_of_two(16) == 1 and is_power_of_two_parity_fn_092_is_power_of_two(15) == 0 { return 42; }
    return 1;
}


// Parity test: functions/fn_093_log2_floor
fn log2_floor_parity_fn_093_log2_floor(n: i64) i64 {
    if n < 1 { return 0 - 1; }
    if n == 1 { return 0; }
    return 1 + log2_floor_parity_fn_093_log2_floor(n / 2);
}
fn test_parity_fn_093_log2_floor() i64 {
    if log2_floor_parity_fn_093_log2_floor(16) == 4 and log2_floor_parity_fn_093_log2_floor(15) == 3 { return 42; }
    return 1;
}


// Parity test: functions/fn_094_sum_to_n
fn sum_to_n_parity_fn_094_sum_to_n(n: i64) i64 {
    if n <= 0 { return 0; }
    return n + sum_to_n_parity_fn_094_sum_to_n(n - 1);
}
fn test_parity_fn_094_sum_to_n() i64 {
    if sum_to_n_parity_fn_094_sum_to_n(10) == 55 { return 42; }
    return 1;
}


// Parity test: functions/fn_095_sum_squares
fn sum_squares_parity_fn_095_sum_squares(n: i64) i64 {
    if n <= 0 { return 0; }
    return n * n + sum_squares_parity_fn_095_sum_squares(n - 1);
}
fn test_parity_fn_095_sum_squares() i64 {
    if sum_squares_parity_fn_095_sum_squares(5) == 55 { return 42; }
    return 1;
}


// Parity test: functions/fn_096_power
fn power_parity_fn_096_power(base: i64, exp: i64) i64 {
    if exp == 0 { return 1; }
    return base * power_parity_fn_096_power(base, exp - 1);
}
fn test_parity_fn_096_power() i64 {
    if power_parity_fn_096_power(2, 10) == 1024 { return 42; }
    return 1;
}


// Parity test: functions/fn_097_power_iter
fn power_iter_parity_fn_097_power_iter(base: i64, exp: i64) i64 {
    var result: i64 = 1;
    var i: i64 = 0;
    while i < exp {
        result = result * base;
        i = i + 1;
    }
    return result;
}
fn test_parity_fn_097_power_iter() i64 {
    if power_iter_parity_fn_097_power_iter(3, 5) == 243 { return 42; }
    return 1;
}


// Parity test: functions/fn_098_factorial_iter
fn factorial_iter_parity_fn_098_factorial_iter(n: i64) i64 {
    var result: i64 = 1;
    var i: i64 = 2;
    while i <= n {
        result = result * i;
        i = i + 1;
    }
    return result;
}
fn test_parity_fn_098_factorial_iter() i64 {
    if factorial_iter_parity_fn_098_factorial_iter(6) == 720 { return 42; }
    return 1;
}


// Parity test: functions/fn_099_triangle
fn triangle_parity_fn_099_triangle(n: i64) i64 {
    return n * (n + 1) / 2;
}
fn test_parity_fn_099_triangle() i64 {
    if triangle_parity_fn_099_triangle(10) == 55 { return 42; }
    return 1;
}


// Parity test: functions/fn_100_square
fn square_parity_fn_100_square(n: i64) i64 {
    return n * n;
}
fn test_parity_fn_100_square() i64 {
    if square_parity_fn_100_square(12) == 144 { return 42; }
    return 1;
}


// Parity test: functions/fn_101_cube
fn cube_parity_fn_101_cube(n: i64) i64 {
    return n * n * n;
}
fn test_parity_fn_101_cube() i64 {
    if cube_parity_fn_101_cube(5) == 125 { return 42; }
    return 1;
}


// Parity test: functions/fn_102_sum_cubes
fn sum_cubes_parity_fn_102_sum_cubes(n: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    while i <= n {
        sum = sum + i * i * i;
        i = i + 1;
    }
    return sum;
}
fn test_parity_fn_102_sum_cubes() i64 {
    if sum_cubes_parity_fn_102_sum_cubes(4) == 100 { return 42; }
    return 1;
}


// Parity test: functions/fn_103_double
fn double_parity_fn_103_double(n: i64) i64 {
    return n + n;
}
fn test_parity_fn_103_double() i64 {
    if double_parity_fn_103_double(21) == 42 { return 42; }
    return 1;
}


// Parity test: functions/fn_104_half
fn half_parity_fn_104_half(n: i64) i64 {
    return n / 2;
}
fn test_parity_fn_104_half() i64 {
    if half_parity_fn_104_half(84) == 42 { return 42; }
    return 1;
}


// Parity test: functions/fn_105_negate
fn negate_parity_fn_105_negate(n: i64) i64 {
    return 0 - n;
}
fn test_parity_fn_105_negate() i64 {
    if negate_parity_fn_105_negate(42) == 0 - 42 { return 42; }
    return 1;
}


// Parity test: functions/fn_106_inc
fn inc_parity_fn_106_inc(n: i64) i64 {
    return n + 1;
}
fn test_parity_fn_106_inc() i64 {
    if inc_parity_fn_106_inc(41) == 42 { return 42; }
    return 1;
}


// Parity test: functions/fn_107_dec
fn dec_parity_fn_107_dec(n: i64) i64 {
    return n - 1;
}
fn test_parity_fn_107_dec() i64 {
    if dec_parity_fn_107_dec(43) == 42 { return 42; }
    return 1;
}


// Parity test: functions/fn_108_is_zero
fn is_zero_parity_fn_108_is_zero(n: i64) i64 {
    if n == 0 { return 1; }
    return 0;
}
fn test_parity_fn_108_is_zero() i64 {
    if is_zero_parity_fn_108_is_zero(0) == 1 {
        if is_zero_parity_fn_108_is_zero(5) == 0 { return 42; }
    }
    return 1;
}


// Parity test: functions/fn_109_is_positive
fn is_positive_parity_fn_109_is_positive(n: i64) i64 {
    if n > 0 { return 1; }
    return 0;
}
fn test_parity_fn_109_is_positive() i64 {
    if is_positive_parity_fn_109_is_positive(5) == 1 {
        if is_positive_parity_fn_109_is_positive(0 - 5) == 0 { return 42; }
    }
    return 1;
}


// Parity test: functions/fn_110_is_negative
fn is_negative_parity_fn_110_is_negative(n: i64) i64 {
    if n < 0 { return 1; }
    return 0;
}
fn test_parity_fn_110_is_negative() i64 {
    if is_negative_parity_fn_110_is_negative(0 - 5) == 1 {
        if is_negative_parity_fn_110_is_negative(5) == 0 { return 42; }
    }
    return 1;
}


// Parity test: functions/fn_111_clamp_fn
fn clamp_parity_fn_111_clamp_fn(x: i64, lo: i64, hi: i64) i64 {
    if x < lo { return lo; }
    if x > hi { return hi; }
    return x;
}
fn test_parity_fn_111_clamp_fn() i64 {
    if clamp_parity_fn_111_clamp_fn(5, 0, 10) == 5 {
        if clamp_parity_fn_111_clamp_fn(0 - 5, 0, 10) == 0 {
            if clamp_parity_fn_111_clamp_fn(15, 0, 10) == 10 { return 42; }
        }
    }
    return 1;
}


// Parity test: functions/fn_112_lerp
fn lerp_parity_fn_112_lerp(a: i64, b: i64, t: i64) i64 {
    return a + (b - a) * t / 100;
}
fn test_parity_fn_112_lerp() i64 {
    if lerp_parity_fn_112_lerp(0, 100, 50) == 50 { return 42; }
    return 1;
}


// Parity test: functions/fn_113_average
fn avg_parity_fn_113_average(a: i64, b: i64) i64 {
    return (a + b) / 2;
}
fn test_parity_fn_113_average() i64 {
    if avg_parity_fn_113_average(40, 44) == 42 { return 42; }
    return 1;
}


// Parity test: functions/fn_114_distance
fn abs_parity_fn_114_distance(x: i64) i64 {
    if x < 0 { return 0 - x; }
    return x;
}
fn distance_parity_fn_114_distance(a: i64, b: i64) i64 {
    return abs_parity_fn_114_distance(a - b);
}
fn test_parity_fn_114_distance() i64 {
    if distance_parity_fn_114_distance(10, 52) == 42 { return 42; }
    return 1;
}


// Parity test: functions/fn_115_chain_call
fn inc_parity_fn_115_chain_call(n: i64) i64 { return n + 1; }
fn double_parity_fn_115_chain_call(n: i64) i64 { return n * 2; }
fn square_parity_fn_115_chain_call(n: i64) i64 { return n * n; }
fn test_parity_fn_115_chain_call() i64 {
    var x: i64 = inc_parity_fn_115_chain_call(3);
    x = double_parity_fn_115_chain_call(x);
    x = square_parity_fn_115_chain_call(x);
    if x == 64 { return 42; }
    return 1;
}


// Parity test: memory/mem_001_stack_local
fn test_stack_parity_mem_001_stack_local() i64 {
    var a: i64 = 1;
    var b: i64 = 2;
    var c: i64 = 3;
    var d: i64 = 4;
    var e: i64 = 5;
    return a + b + c + d + e;
}
fn test_parity_mem_001_stack_local() i64 { if test_stack_parity_mem_001_stack_local() == 15 { return 42; } return 1; }


// Parity test: memory/mem_002_many_locals
fn many_locals_parity_mem_002_many_locals() i64 {
    var v1: i64 = 1; var v2: i64 = 2; var v3: i64 = 3; var v4: i64 = 4;
    var v5: i64 = 5; var v6: i64 = 6; var v7: i64 = 7; var v8: i64 = 8;
    return v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8;
}
fn test_parity_mem_002_many_locals() i64 { if many_locals_parity_mem_002_many_locals() == 36 { return 42; } return 1; }


// Parity test: memory/mem_003_malloc_i64
fn test_parity_mem_003_malloc_i64() i64 {
    var arr: *i64 = malloc(80);
    var i: i64 = 0;
    while i < 10 {
        (arr + i).* = i;
        i = i + 1;
    }
    var sum: i64 = 0;
    i = 0;
    while i < 10 {
        sum = sum + (arr + i).*;
        i = i + 1;
    }
    if sum == 45 { return 42; }
    return 1;
}


// Parity test: memory/mem_004_array_copy
fn copy_array_parity_mem_004_array_copy(src: *i64, dst: *i64, len: i64) void {
    var i: i64 = 0;
    while i < len {
        (dst + i).* = (src + i).*;
        i = i + 1;
    }
}
fn test_parity_mem_004_array_copy() i64 {
    var a: *i64 = malloc(40);
    var b: *i64 = malloc(40);
    (a + 0).* = 1; (a + 1).* = 2; (a + 2).* = 3; (a + 3).* = 4; (a + 4).* = 5;
    copy_array_parity_mem_004_array_copy(a, b, 5);
    if (b + 2).* == 3 { return 42; }
    return 1;
}


// Parity test: memory/mem_007_array_sum
fn array_sum_parity_mem_007_array_sum(arr: *i64, len: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 0;
    while i < len {
        sum = sum + (arr + i).*;
        i = i + 1;
    }
    return sum;
}
fn test_parity_mem_007_array_sum() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 10;
    (arr + 1).* = 20;
    (arr + 2).* = 30;
    (arr + 3).* = 40;
    (arr + 4).* = 50;
    if array_sum_parity_mem_007_array_sum(arr, 5) == 150 { return 42; }
    return 1;
}


// Parity test: memory/mem_009_swap
fn swap_parity_mem_009_swap(a: *i64, b: *i64) void {
    var t: i64 = a.*;
    a.* = b.*;
    b.* = t;
}
fn test_parity_mem_009_swap() i64 {
    var x: i64 = 10;
    var y: i64 = 20;
    swap_parity_mem_009_swap(&x, &y);
    if x == 20 { return 42; }
    return 1;
}


// Parity test: memory/mem_010_indirect
fn indirect_add_parity_mem_010_indirect(ptr: *i64, val: i64) void {
    ptr.* = ptr.* + val;
}
fn test_parity_mem_010_indirect() i64 {
    var x: i64 = 10;
    indirect_add_parity_mem_010_indirect(&x, 5);
    indirect_add_parity_mem_010_indirect(&x, 5);
    if x == 20 { return 42; }
    return 1;
}


// Parity test: memory/mem_011_reverse
fn reverse_parity_mem_011_reverse(arr: *i64, len: i64) void {
    var i: i64 = 0;
    while i < len / 2 {
        var t: i64 = (arr + i).*;
        (arr + i).* = (arr + len - 1 - i).*;
        (arr + len - 1 - i).* = t;
        i = i + 1;
    }
}
fn test_parity_mem_011_reverse() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 1; (arr + 1).* = 2; (arr + 2).* = 3;
    (arr + 3).* = 4; (arr + 4).* = 5;
    reverse_parity_mem_011_reverse(arr, 5);
    if (arr + 0).* == 5 { return 42; }
    return 1;
}


// Parity test: memory/mem_012_fill
fn fill_parity_mem_012_fill(arr: *i64, len: i64, val: i64) void {
    var i: i64 = 0;
    while i < len {
        (arr + i).* = val;
        i = i + 1;
    }
}
fn test_parity_mem_012_fill() i64 {
    var arr: *i64 = malloc(80);
    fill_parity_mem_012_fill(arr, 10, 42);
    var sum: i64 = 0;
    var i: i64 = 0;
    while i < 10 {
        sum = sum + (arr + i).*;
        i = i + 1;
    }
    if sum == 420 { return 42; }
    return 1;
}


// Parity test: memory/mem_013_count_val
fn count_val_parity_mem_013_count_val(arr: *i64, len: i64, val: i64) i64 {
    var count: i64 = 0;
    var i: i64 = 0;
    while i < len {
        if (arr + i).* == val { count = count + 1; }
        i = i + 1;
    }
    return count;
}
fn test_parity_mem_013_count_val() i64 {
    var arr: *i64 = malloc(56);
    (arr + 0).* = 1; (arr + 1).* = 2; (arr + 2).* = 1;
    (arr + 3).* = 3; (arr + 4).* = 1; (arr + 5).* = 2;
    (arr + 6).* = 1;
    if count_val_parity_mem_013_count_val(arr, 7, 1) == 4 { return 42; }
    return 1;
}


// Parity test: memory/mem_014_ptr_param
fn inc_ptr_parity_mem_014_ptr_param(p: *i64) void { p.* = p.* + 1; }
fn test_parity_mem_014_ptr_param() i64 {
    var x: i64 = 41;
    inc_ptr_parity_mem_014_ptr_param(&x);
    if x == 42 { return 42; }
    return 1;
}


// Parity test: memory/mem_015_double_deref
fn test_parity_mem_015_double_deref() i64 {
    var x: i64 = 42;
    var p1: *i64 = &x;
    var p2: **i64 = &p1;
    if p2.*.* == 42 { return 42; }
    return 1;
}


// Parity test: memory/mem_016_addr_of_local
fn get_addr_parity_mem_016_addr_of_local(p: **i64, x: *i64) void { p.* = x; }
fn test_parity_mem_016_addr_of_local() i64 {
    var val: i64 = 100;
    var ptr: *i64 = null;
    get_addr_parity_mem_016_addr_of_local(&ptr, &val);
    if ptr.* == 100 { return 42; }
    return 1;
}


// Parity test: memory/mem_017_array_fill
fn fill_range_parity_mem_017_array_fill(arr: *i64, start: i64, count: i64) void {
    var i: i64 = 0;
    while i < count {
        (arr + i).* = start + i;
        i = i + 1;
    }
}
fn test_parity_mem_017_array_fill() i64 {
    var arr: *i64 = malloc(40);
    fill_range_parity_mem_017_array_fill(arr, 10, 5);
    if (arr + 2).* == 12 { return 42; }
    return 1;
}


// Parity test: memory/mem_018_array_contains
fn contains_parity_mem_018_array_contains(arr: *i64, len: i64, val: i64) i64 {
    var i: i64 = 0;
    while i < len {
        if (arr + i).* == val { return 1; }
        i = i + 1;
    }
    return 0;
}
fn test_parity_mem_018_array_contains() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 10; (arr + 1).* = 20; (arr + 2).* = 30;
    (arr + 3).* = 40; (arr + 4).* = 50;
    if contains_parity_mem_018_array_contains(arr, 5, 30) == 1 { return 42; }
    return 1;
}


// Parity test: memory/mem_019_array_index
fn index_of_parity_mem_019_array_index(arr: *i64, len: i64, val: i64) i64 {
    var i: i64 = 0;
    while i < len {
        if (arr + i).* == val { return i; }
        i = i + 1;
    }
    return -1;
}
fn test_parity_mem_019_array_index() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 5; (arr + 1).* = 10; (arr + 2).* = 15;
    (arr + 3).* = 20; (arr + 4).* = 25;
    if index_of_parity_mem_019_array_index(arr, 5, 15) == 2 { return 42; }
    return 1;
}


// Parity test: memory/mem_021_ptr_chain
fn test_parity_mem_021_ptr_chain() i64 {
    var a: i64 = 42;
    var p1: *i64 = &a;
    var p2: *i64 = p1;
    var p3: *i64 = p2;
    if p3.* == 42 { return 42; }
    return 1;
}


// Parity test: memory/mem_022_modify_via_ptr
fn test_parity_mem_022_modify_via_ptr() i64 {
    var x: i64 = 10;
    var p: *i64 = &x;
    p.* = p.* + 5;
    p.* = p.* * 2;
    if x == 30 { return 42; }
    return 1;
}


// Parity test: memory/mem_023_multi_ptr_mod
fn test_parity_mem_023_multi_ptr_mod() i64 {
    var a: i64 = 1;
    var b: i64 = 2;
    var pa: *i64 = &a;
    var pb: *i64 = &b;
    pa.* = pa.* + pb.*;
    pb.* = pa.* + pb.*;
    if a + b == 8 { return 42; }
    return 1;
}


// Parity test: memory/mem_024_ptr_reassign
fn test_parity_mem_024_ptr_reassign() i64 {
    var a: i64 = 10;
    var b: i64 = 20;
    var p: *i64 = &a;
    var sum: i64 = p.*;
    p = &b;
    sum = sum + p.*;
    if sum == 30 { return 42; }
    return 1;
}


// Parity test: memory/mem_025_ptr_offset_calc
fn test_parity_mem_025_ptr_offset_calc() i64 {
    var arr: *i64 = malloc(80);
    var i: i64 = 0;
    while i < 10 {
        (arr + i).* = i * i;
        i = i + 1;
    }
    var sum: i64 = 0;
    i = 0;
    while i < 10 {
        sum = sum + (arr + i).*;
        i = i + 1;
    }
    if sum == 285 { return 42; }
    return 1;
}


// Parity test: memory/mem_026_ptr_deref_in_expr
fn test_parity_mem_026_ptr_deref_in_expr() i64 {
    var arr: *i64 = malloc(24);
    (arr + 0).* = 10;
    (arr + 1).* = 20;
    (arr + 2).* = 30;
    var result: i64 = (arr + 0).* + (arr + 1).* * 2 + (arr + 2).* / 3;
    if result == 60 { return 42; }
    return 1;
}


// Parity test: memory/mem_028_nested_ptr_deref
fn test_parity_mem_028_nested_ptr_deref() i64 {
    var a: i64 = 100;
    var b: i64 = 200;
    var pa: *i64 = &a;
    var pb: *i64 = &b;
    var ppa: **i64 = &pa;
    var ppb: **i64 = &pb;
    var sum: i64 = ppa.*.* + ppb.*.*;
    if sum == 300 { return 42; }
    return 1;
}


// Parity test: memory/mem_029_ptr_swap
fn test_parity_mem_029_ptr_swap() i64 {
    var a: i64 = 10;
    var b: i64 = 20;
    var pa: *i64 = &a;
    var pb: *i64 = &b;
    var tmp: *i64 = pa;
    pa = pb;
    pb = tmp;
    if pa.* == 20 and pb.* == 10 { return 42; }
    return 1;
}


// Parity test: memory/mem_030_ptr_arith_fn
fn get_at_parity_mem_030_ptr_arith_fn(arr: *i64, idx: i64) i64 {
    return (arr + idx).*;
}
fn set_at_parity_mem_030_ptr_arith_fn(arr: *i64, idx: i64, val: i64) void {
    (arr + idx).* = val;
}
fn test_parity_mem_030_ptr_arith_fn() i64 {
    var arr: *i64 = malloc(40);
    set_at_parity_mem_030_ptr_arith_fn(arr, 0, 10);
    set_at_parity_mem_030_ptr_arith_fn(arr, 4, 50);
    if get_at_parity_mem_030_ptr_arith_fn(arr, 0) == 10 and get_at_parity_mem_030_ptr_arith_fn(arr, 4) == 50 { return 42; }
    return 1;
}


// Parity test: memory/mem_032_double_ptr
fn test_parity_mem_032_double_ptr() i64 {
    var arr: *i64 = malloc(24);
    (arr + 0).* = 10;
    (arr + 1).* = 20;
    (arr + 2).* = 30;
    var p: *i64 = arr;
    var pp: **i64 = &p;
    if pp.*.* == 10 { return 42; }
    return 1;
}


// Parity test: memory/mem_033_ptr_advance
fn test_parity_mem_033_ptr_advance() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 10;
    (arr + 1).* = 20;
    (arr + 2).* = 30;
    (arr + 3).* = 40;
    (arr + 4).* = 50;
    var p: *i64 = arr;
    var sum: i64 = 0;
    var i: i64 = 0;
    while i < 5 {
        sum = sum + (p + i).*;
        i = i + 1;
    }
    if sum == 150 { return 42; }
    return 1;
}


// Parity test: memory/mem_036_local_array
fn sum5_parity_mem_036_local_array() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 3;
    (arr + 3).* = 4;
    (arr + 4).* = 5;
    var sum: i64 = 0;
    var i: i64 = 0;
    while i < 5 {
        sum = sum + (arr + i).*;
        i = i + 1;
    }
    return sum;
}
fn test_parity_mem_036_local_array() i64 {
    if sum5_parity_mem_036_local_array() == 15 { return 42; }
    return 1;
}


// Parity test: memory/mem_037_nested_loop_ptr
fn test_parity_mem_037_nested_loop_ptr() i64 {
    var arr: *i64 = malloc(200);
    var idx: i64 = 0;
    var i: i64 = 0;
    while i < 5 {
        var j: i64 = 0;
        while j < 5 {
            (arr + idx).* = i * 5 + j;
            idx = idx + 1;
            j = j + 1;
        }
        i = i + 1;
    }
    if (arr + 0).* == 0 and (arr + 24).* == 24 { return 42; }
    return 1;
}


// Parity test: memory/mem_038_array_of_pointers
fn test_parity_mem_038_array_of_pointers() i64 {
    var arr: *i64 = malloc(24);
    var a: *i64 = malloc(8);
    var b: *i64 = malloc(8);
    a.* = 10;
    b.* = 20;
    (arr + 0).* = a.*;
    (arr + 1).* = b.*;
    (arr + 2).* = a.* + b.*;
    if (arr + 2).* == 30 { return 42; }
    return 1;
}


// Parity test: memory/mem_039_indirect_store
fn set_value_parity_mem_039_indirect_store(ptr: *i64, val: i64) void {
    ptr.* = val;
}
fn test_parity_mem_039_indirect_store() i64 {
    var x: *i64 = malloc(8);
    set_value_parity_mem_039_indirect_store(x, 42);
    if x.* == 42 { return 42; }
    return 1;
}


// Parity test: memory/mem_040_indirect_load
fn get_value_parity_mem_040_indirect_load(ptr: *i64) i64 {
    return ptr.*;
}
fn test_parity_mem_040_indirect_load() i64 {
    var x: *i64 = malloc(8);
    x.* = 42;
    if get_value_parity_mem_040_indirect_load(x) == 42 { return 42; }
    return 1;
}


// Parity test: memory/mem_041_swap_via_ptr
fn swap_ptr_parity_mem_041_swap_via_ptr(a: *i64, b: *i64) void {
    var t: i64 = a.*;
    a.* = b.*;
    b.* = t;
}
fn test_parity_mem_041_swap_via_ptr() i64 {
    var x: *i64 = malloc(8);
    var y: *i64 = malloc(8);
    x.* = 10;
    y.* = 20;
    swap_ptr_parity_mem_041_swap_via_ptr(x, y);
    if x.* == 20 and y.* == 10 { return 42; }
    return 1;
}


// Parity test: memory/mem_042_increment_via_ptr
fn increment_parity_mem_042_increment_via_ptr(ptr: *i64) void {
    ptr.* = ptr.* + 1;
}
fn test_parity_mem_042_increment_via_ptr() i64 {
    var x: *i64 = malloc(8);
    x.* = 41;
    increment_parity_mem_042_increment_via_ptr(x);
    if x.* == 42 { return 42; }
    return 1;
}


// Parity test: memory/mem_043_double_ptr
fn test_parity_mem_043_double_ptr() i64 {
    var a: *i64 = malloc(8);
    var b: *i64 = malloc(8);
    a.* = 10;
    b.* = 20;
    a.* = a.* + b.*;
    if a.* == 30 { return 42; }
    return 1;
}


// Parity test: memory/mem_044_array_pass
fn sum_array_parity_mem_044_array_pass(arr: *i64, n: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 0;
    while i < n {
        sum = sum + (arr + i).*;
        i = i + 1;
    }
    return sum;
}
fn test_parity_mem_044_array_pass() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 3;
    (arr + 3).* = 4;
    (arr + 4).* = 5;
    if sum_array_parity_mem_044_array_pass(arr, 5) == 15 { return 42; }
    return 1;
}


// Parity test: memory/mem_045_nested_ptr
fn test_parity_mem_045_nested_ptr() i64 {
    var arr: *i64 = malloc(24);
    (arr + 0).* = 10;
    (arr + 1).* = 20;
    (arr + 2).* = 30;
    var p: *i64 = arr + 1;
    var val: i64 = p.*;
    if val == 20 { return 42; }
    return 1;
}


// Parity test: memory/mem_046_modify_via_ptr
fn double_value_parity_mem_046_modify_via_ptr(p: *i64) void {
    p.* = p.* * 2;
}
fn test_parity_mem_046_modify_via_ptr() i64 {
    var x: *i64 = malloc(8);
    x.* = 21;
    double_value_parity_mem_046_modify_via_ptr(x);
    if x.* == 42 { return 42; }
    return 1;
}


// Parity test: memory/mem_047_zero_array
fn zero_array_parity_mem_047_zero_array(arr: *i64, n: i64) void {
    var i: i64 = 0;
    while i < n {
        (arr + i).* = 0;
        i = i + 1;
    }
}
fn test_parity_mem_047_zero_array() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 1;
    (arr + 1).* = 2;
    (arr + 2).* = 3;
    (arr + 3).* = 4;
    (arr + 4).* = 5;
    zero_array_parity_mem_047_zero_array(arr, 5);
    var sum: i64 = (arr + 0).* + (arr + 1).* + (arr + 2).* + (arr + 3).* + (arr + 4).*;
    if sum == 0 { return 42; }
    return 1;
}


// Parity test: memory/mem_048_init_array
fn init_sequence_parity_mem_048_init_array(arr: *i64, n: i64) void {
    var i: i64 = 0;
    while i < n {
        (arr + i).* = i + 1;
        i = i + 1;
    }
}
fn test_parity_mem_048_init_array() i64 {
    var arr: *i64 = malloc(40);
    init_sequence_parity_mem_048_init_array(arr, 5);
    if (arr + 4).* == 5 { return 42; }
    return 1;
}


// Parity test: memory/mem_049_powers_array
fn init_powers_parity_mem_049_powers_array(arr: *i64, n: i64, base: i64) void {
    var val: i64 = 1;
    var i: i64 = 0;
    while i < n {
        (arr + i).* = val;
        val = val * base;
        i = i + 1;
    }
}
fn test_parity_mem_049_powers_array() i64 {
    var arr: *i64 = malloc(40);
    init_powers_parity_mem_049_powers_array(arr, 5, 2);
    if (arr + 4).* == 16 { return 42; }
    return 1;
}


// Parity test: memory/mem_050_fibonacci_array
fn init_fib_parity_mem_050_fibonacci_array(arr: *i64, n: i64) void {
    if n >= 1 { (arr + 0).* = 0; }
    if n >= 2 { (arr + 1).* = 1; }
    var i: i64 = 2;
    while i < n {
        (arr + i).* = (arr + i - 1).* + (arr + i - 2).*;
        i = i + 1;
    }
}
fn test_parity_mem_050_fibonacci_array() i64 {
    var arr: *i64 = malloc(80);
    init_fib_parity_mem_050_fibonacci_array(arr, 10);
    if (arr + 9).* == 34 { return 42; }
    return 1;
}


// Parity test: memory/mem_051_stack_sim
var stack: *i64 = null;
var sp: i64 = 0;
fn push_parity_mem_051_stack_sim(val: i64) void {
    (stack + sp).* = val;
    sp = sp + 1;
}
fn pop_parity_mem_051_stack_sim() i64 {
    sp = sp - 1;
    return (stack + sp).*;
}
fn test_parity_mem_051_stack_sim() i64 {
    stack = malloc(80);
    push_parity_mem_051_stack_sim(10);
    push_parity_mem_051_stack_sim(20);
    push_parity_mem_051_stack_sim(30);
    var a: i64 = pop_parity_mem_051_stack_sim();
    var b: i64 = pop_parity_mem_051_stack_sim();
    if a == 30 {
        if b == 20 { return 42; }
    }
    return 1;
}


// Parity test: memory/mem_052_queue_sim
var queue: *i64 = null;
var head: i64 = 0;
var tail: i64 = 0;
fn enqueue_parity_mem_052_queue_sim(val: i64) void {
    (queue + tail).* = val;
    tail = tail + 1;
}
fn dequeue_parity_mem_052_queue_sim() i64 {
    var val: i64 = (queue + head).*;
    head = head + 1;
    return val;
}
fn test_parity_mem_052_queue_sim() i64 {
    queue = malloc(80);
    enqueue_parity_mem_052_queue_sim(10);
    enqueue_parity_mem_052_queue_sim(20);
    enqueue_parity_mem_052_queue_sim(30);
    var a: i64 = dequeue_parity_mem_052_queue_sim();
    var b: i64 = dequeue_parity_mem_052_queue_sim();
    if a == 10 {
        if b == 20 { return 42; }
    }
    return 1;
}


// Parity test: memory/mem_053_ptr_param
fn add_to_parity_mem_053_ptr_param(ptr: *i64, val: i64) void {
    ptr.* = ptr.* + val;
}
fn test_parity_mem_053_ptr_param() i64 {
    var x: *i64 = malloc(8);
    x.* = 30;
    add_to_parity_mem_053_ptr_param(x, 12);
    if x.* == 42 { return 42; }
    return 1;
}


// Parity test: variables/var_001_simple
fn test_parity_var_001_simple() i64 {
    var x: i64 = 42;
    if x == 42 { return 42; }
    return 1;
}


// Parity test: variables/var_002_reassign
fn test_parity_var_002_reassign() i64 {
    var x: i64 = 10;
    x = 20;
    x = 30;
    if x == 30 { return 42; }
    return 1;
}


// Parity test: variables/var_003_many_vars
fn test_parity_var_003_many_vars() i64 {
    var a: i64 = 1;
    var b: i64 = 2;
    var c: i64 = 3;
    var d: i64 = 4;
    var e: i64 = 5;
    var f: i64 = 6;
    var g: i64 = 7;
    var h: i64 = 8;
    var sum: i64 = a + b + c + d + e + f + g + h;
    if sum == 36 { return 42; }
    return 1;
}


// Parity test: variables/var_004_more_vars
fn test_parity_var_004_more_vars() i64 {
    var v1: i64 = 1; var v2: i64 = 2; var v3: i64 = 3; var v4: i64 = 4;
    var v5: i64 = 5; var v6: i64 = 6; var v7: i64 = 7; var v8: i64 = 8;
    var v9: i64 = 9; var v10: i64 = 10; var v11: i64 = 11; var v12: i64 = 12;
    var sum: i64 = v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8 + v9 + v10 + v11 + v12;
    if sum == 78 { return 42; }
    return 1;
}


// Parity test: variables/var_005_16_vars
fn test_parity_var_005_16_vars() i64 {
    var v1: i64 = 1; var v2: i64 = 2; var v3: i64 = 3; var v4: i64 = 4;
    var v5: i64 = 5; var v6: i64 = 6; var v7: i64 = 7; var v8: i64 = 8;
    var v9: i64 = 9; var v10: i64 = 10; var v11: i64 = 11; var v12: i64 = 12;
    var v13: i64 = 13; var v14: i64 = 14; var v15: i64 = 15; var v16: i64 = 16;
    var sum: i64 = v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8;
    sum = sum + v9 + v10 + v11 + v12 + v13 + v14 + v15 + v16;
    if sum == 136 { return 42; }
    return 1;
}


// Parity test: variables/var_006_20_vars
fn test_parity_var_006_20_vars() i64 {
    var v1: i64 = 1; var v2: i64 = 2; var v3: i64 = 3; var v4: i64 = 4;
    var v5: i64 = 5; var v6: i64 = 6; var v7: i64 = 7; var v8: i64 = 8;
    var v9: i64 = 9; var v10: i64 = 10; var v11: i64 = 11; var v12: i64 = 12;
    var v13: i64 = 13; var v14: i64 = 14; var v15: i64 = 15; var v16: i64 = 16;
    var v17: i64 = 17; var v18: i64 = 18; var v19: i64 = 19; var v20: i64 = 20;
    var sum: i64 = v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8 + v9 + v10;
    sum = sum + v11 + v12 + v13 + v14 + v15 + v16 + v17 + v18 + v19 + v20;
    if sum == 210 { return 42; }
    return 1;
}


// Parity test: variables/var_007_nested_scope
fn test_parity_var_007_nested_scope() i64 {
    var x: i64 = 10;
    if x > 5 {
        var y: i64 = 20;
        x = x + y;
    }
    if x == 30 { return 42; }
    return 1;
}


// Parity test: variables/var_008_while_scope
fn test_parity_var_008_while_scope() i64 {
    var sum: i64 = 0;
    var i: i64 = 0;
    while i < 5 {
        var term: i64 = i * 2;
        sum = sum + term;
        i = i + 1;
    }
    if sum == 20 { return 42; }
    return 1;
}


// Parity test: variables/var_009_deep_nesting
fn test_parity_var_009_deep_nesting() i64 {
    var a: i64 = 1;
    if a > 0 {
        var b: i64 = 2;
        if b > 0 {
            var c: i64 = 3;
            if c > 0 {
                var d: i64 = 4;
                a = a + b + c + d;
            }
        }
    }
    if a == 10 { return 42; }
    return 1;
}


// Parity test: variables/var_010_chain_assign
fn test_parity_var_010_chain_assign() i64 {
    var a: i64 = 5;
    var b: i64 = a;
    var c: i64 = b;
    var d: i64 = c;
    if d == 5 { return 42; }
    return 1;
}


// Parity test: variables/var_011_swap_vars
fn test_parity_var_011_swap_vars() i64 {
    var a: i64 = 10;
    var b: i64 = 20;
    var tmp: i64 = a;
    a = b;
    b = tmp;
    if a == 20 and b == 10 { return 42; }
    return 1;
}


// Parity test: variables/var_012_accumulate
fn test_parity_var_012_accumulate() i64 {
    var sum: i64 = 0;
    sum = sum + 10;
    sum = sum + 20;
    sum = sum + 30;
    sum = sum + 40;
    if sum == 100 { return 42; }
    return 1;
}


// Parity test: variables/var_013_product_acc
fn test_parity_var_013_product_acc() i64 {
    var prod: i64 = 1;
    prod = prod * 2;
    prod = prod * 3;
    prod = prod * 4;
    prod = prod * 5;
    if prod == 120 { return 42; }
    return 1;
}


// Parity test: variables/var_014_negative
fn test_parity_var_014_negative() i64 {
    var x: i64 = 0 - 42;
    var y: i64 = 0 - x;
    if y == 42 { return 42; }
    return 1;
}


// Parity test: variables/var_015_compound
fn test_parity_var_015_compound() i64 {
    var a: i64 = 10;
    var b: i64 = 5;
    var c: i64 = a + b;
    var d: i64 = a - b;
    var e: i64 = a * b;
    var f: i64 = a / b;
    if c == 15 and d == 5 and e == 50 and f == 2 { return 42; }
    return 1;
}


// Parity test: variables/var_016_many_temps
fn test_parity_var_016_many_temps() i64 {
    var a: i64 = 1;
    var b: i64 = a + 1;
    var c: i64 = b + 1;
    var d: i64 = c + 1;
    var e: i64 = d + 1;
    var f: i64 = e + 1;
    var g: i64 = f + 1;
    var h: i64 = g + 1;
    var i: i64 = h + 1;
    var j: i64 = i + 1;
    if j == 10 { return 42; }
    return 1;
}


// Parity test: variables/var_017_long_chain
fn test_parity_var_017_long_chain() i64 {
    var a: i64 = 1;
    var b: i64 = a * 2;
    var c: i64 = b * 2;
    var d: i64 = c * 2;
    var e: i64 = d * 2;
    var f: i64 = e * 2;
    var g: i64 = f * 2;
    var h: i64 = g * 2;
    if h == 128 { return 42; }
    return 1;
}


// Parity test: variables/var_018_reassign_chain
fn test_parity_var_018_reassign_chain() i64 {
    var x: i64 = 1;
    x = x + x;
    x = x + x;
    x = x + x;
    x = x + x;
    if x == 16 { return 42; }
    return 1;
}


// Parity test: variables/var_020_mixed_ops
fn test_parity_var_020_mixed_ops() i64 {
    var a: i64 = 100;
    var b: i64 = 7;
    var q: i64 = a / b;
    var r: i64 = a % b;
    var check: i64 = q * b + r;
    if check == a { return 42; }
    return 1;
}


// Parity test: variables/var_021_reuse_name
fn test_parity_var_021_reuse_name() i64 {
    var x: i64 = 10;
    x = x + 5;
    x = x * 2;
    x = x - 10;
    if x == 20 { return 42; }
    return 1;
}


// Parity test: variables/var_022_temp_swap
fn test_parity_var_022_temp_swap() i64 {
    var a: i64 = 1;
    var b: i64 = 2;
    var c: i64 = 3;
    var t: i64 = a;
    a = b;
    b = c;
    c = t;
    if a == 2 and b == 3 and c == 1 { return 42; }
    return 1;
}


// Parity test: variables/var_023_increment
fn test_parity_var_023_increment() i64 {
    var x: i64 = 0;
    x = x + 1;
    x = x + 1;
    x = x + 1;
    x = x + 1;
    x = x + 1;
    if x == 5 { return 42; }
    return 1;
}


// Parity test: variables/var_024_decrement
fn test_parity_var_024_decrement() i64 {
    var x: i64 = 10;
    x = x - 1;
    x = x - 1;
    x = x - 1;
    if x == 7 { return 42; }
    return 1;
}


// Parity test: variables/var_025_self_mult
fn test_parity_var_025_self_mult() i64 {
    var x: i64 = 2;
    x = x * x;
    x = x * x;
    if x == 16 { return 42; }
    return 1;
}


// Parity test: variables/var_026_parallel_assign
fn test_parity_var_026_parallel_assign() i64 {
    var a: i64 = 1;
    var b: i64 = 2;
    var c: i64 = 3;
    var ta: i64 = a;
    var tb: i64 = b;
    var tc: i64 = c;
    a = tc;
    b = ta;
    c = tb;
    if a == 3 and b == 1 and c == 2 { return 42; }
    return 1;
}


// Parity test: variables/var_027_accumulator
fn test_parity_var_027_accumulator() i64 {
    var acc: i64 = 0;
    var i: i64 = 1;
    while i <= 10 {
        acc = acc + i * i;
        i = i + 1;
    }
    if acc == 385 { return 42; }
    return 1;
}


// Parity test: variables/var_028_running_max
fn test_parity_var_028_running_max() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 3;
    (arr + 1).* = 7;
    (arr + 2).* = 2;
    (arr + 3).* = 9;
    (arr + 4).* = 4;
    var max: i64 = (arr + 0).*;
    var i: i64 = 1;
    while i < 5 {
        if (arr + i).* > max {
            max = (arr + i).*;
        }
        i = i + 1;
    }
    if max == 9 { return 42; }
    return 1;
}


// Parity test: variables/var_029_running_min
fn test_parity_var_029_running_min() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 3;
    (arr + 1).* = 7;
    (arr + 2).* = 2;
    (arr + 3).* = 9;
    (arr + 4).* = 4;
    var min: i64 = (arr + 0).*;
    var i: i64 = 1;
    while i < 5 {
        if (arr + i).* < min {
            min = (arr + i).*;
        }
        i = i + 1;
    }
    if min == 2 { return 42; }
    return 1;
}


// Parity test: variables/var_030_both_minmax
fn test_parity_var_030_both_minmax() i64 {
    var arr: *i64 = malloc(40);
    (arr + 0).* = 3;
    (arr + 1).* = 7;
    (arr + 2).* = 2;
    (arr + 3).* = 9;
    (arr + 4).* = 4;
    var min: i64 = (arr + 0).*;
    var max: i64 = (arr + 0).*;
    var i: i64 = 1;
    while i < 5 {
        if (arr + i).* < min { min = (arr + i).*; }
        if (arr + i).* > max { max = (arr + i).*; }
        i = i + 1;
    }
    if min == 2 and max == 9 { return 42; }
    return 1;
}


// Parity test: variables/var_031_local_shadow
fn test_parity_var_031_local_shadow() i64 {
    var x: i64 = 1;
    {
        var x: i64 = 2;
        if x != 2 { return 1; }
    }
    if x != 1 { return 1; }
    return 42;
}


// Parity test: variables/var_033_loop_counter
fn test_parity_var_033_loop_counter() i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    while i <= 10 {
        sum = sum + i;
        i = i + 1;
    }
    if sum == 55 { return 42; }
    return 1;
}


// Parity test: variables/var_034_flag_toggle
fn test_parity_var_034_flag_toggle() i64 {
    var flag: i64 = 0;
    var i: i64 = 0;
    while i < 5 {
        if flag == 0 {
            flag = 1;
        } else {
            flag = 0;
        }
        i = i + 1;
    }
    if flag == 1 { return 42; }
    return 1;
}


// Parity test: variables/var_035_temp_swap
fn test_parity_var_035_temp_swap() i64 {
    var a: i64 = 10;
    var b: i64 = 20;
    var t: i64 = a;
    a = b;
    b = t;
    if a == 20 and b == 10 { return 42; }
    return 1;
}


// Parity test: variables/var_036_fibonacci_vars
fn test_parity_var_036_fibonacci_vars() i64 {
    var a: i64 = 0;
    var b: i64 = 1;
    var i: i64 = 0;
    while i < 10 {
        var t: i64 = a + b;
        a = b;
        b = t;
        i = i + 1;
    }
    if a == 55 { return 42; }
    return 1;
}


// Parity test: variables/var_037_running_product
fn test_parity_var_037_running_product() i64 {
    var product: i64 = 1;
    var i: i64 = 1;
    while i <= 5 {
        product = product * i;
        i = i + 1;
    }
    if product == 120 { return 42; }
    return 1;
}


// Parity test: variables/var_038_gcd_vars
fn test_parity_var_038_gcd_vars() i64 {
    var a: i64 = 48;
    var b: i64 = 18;
    while b != 0 {
        var t: i64 = b;
        b = a % b;
        a = t;
    }
    if a == 6 { return 42; }
    return 1;
}


// Parity test: variables/var_039_binary_search_vars
fn test_parity_var_039_binary_search_vars() i64 {
    var target: i64 = 37;
    var lo: i64 = 0;
    var hi: i64 = 100;
    var steps: i64 = 0;
    while lo < hi {
        var mid: i64 = (lo + hi) / 2;
        if mid < target {
            lo = mid + 1;
        } else {
            hi = mid;
        }
        steps = steps + 1;
    }
    if lo == 37 { return 42; }
    return 1;
}


// Parity test: variables/var_040_collatz_vars
fn test_parity_var_040_collatz_vars() i64 {
    var n: i64 = 27;
    var steps: i64 = 0;
    while n != 1 {
        if n % 2 == 0 {
            n = n / 2;
        } else {
            n = 3 * n + 1;
        }
        steps = steps + 1;
    }
    if steps == 111 { return 42; }
    return 1;
}


// Parity test: variables/var_041_count_bits
fn test_parity_var_041_count_bits() i64 {
    var n: i64 = 255;
    var count: i64 = 0;
    while n > 0 {
        count = count + (n & 1);
        n = n >> 1;
    }
    if count == 8 { return 42; }
    return 1;
}


// Parity test: variables/var_042_reverse_bits
fn test_parity_var_042_reverse_bits() i64 {
    var n: i64 = 12;
    var rev: i64 = 0;
    var bits: i64 = 4;
    var i: i64 = 0;
    while i < bits {
        rev = rev << 1;
        rev = rev | (n & 1);
        n = n >> 1;
        i = i + 1;
    }
    if rev == 3 { return 42; }
    return 1;
}


// Parity test: variables/var_043_prime_check
fn test_parity_var_043_prime_check() i64 {
    var n: i64 = 17;
    var is_prime: i64 = 1;
    var i: i64 = 2;
    while i < n {
        if n % i == 0 {
            is_prime = 0;
        }
        i = i + 1;
    }
    if is_prime == 1 { return 42; }
    return 1;
}


// Parity test: variables/var_044_perfect_check
fn test_parity_var_044_perfect_check() i64 {
    var n: i64 = 6;
    var sum: i64 = 0;
    var i: i64 = 1;
    while i < n {
        if n % i == 0 {
            sum = sum + i;
        }
        i = i + 1;
    }
    if sum == n { return 42; }
    return 1;
}


// Parity test: variables/var_045_digit_reverse
fn test_parity_var_045_digit_reverse() i64 {
    var n: i64 = 123;
    var rev: i64 = 0;
    while n > 0 {
        rev = rev * 10 + n % 10;
        n = n / 10;
    }
    if rev == 321 { return 42; }
    return 1;
}


// Parity test: variables/var_046_accumulator
fn test_parity_var_046_accumulator() i64 {
    var acc: i64 = 0;
    acc = acc + 10;
    acc = acc + 20;
    acc = acc + 30;
    if acc == 60 { return 42; }
    return 1;
}


// Parity test: variables/var_047_multiplier
fn test_parity_var_047_multiplier() i64 {
    var mul: i64 = 1;
    mul = mul * 2;
    mul = mul * 3;
    mul = mul * 7;
    if mul == 42 { return 42; }
    return 1;
}

// Parity test: cf_050 - while break (returns 21)
fn test_parity_cf_050_while_break_simple() i64 {
    var sum: i64 = 0;
    var i: i64 = 0;
    while i < 100 {
        sum = sum + i;
        if sum > 20 {
            i = i + 1;
            if i > 0 {
                return sum;
            }
        }
        i = i + 1;
    }
    return 0;
}

// Parity test: expr_145 - arithmetic mix (13+7+30+3+1=54)
fn test_parity_expr_145_arithmetic_mix() i64 {
    var a: i64 = 10;
    var b: i64 = 3;
    var sum: i64 = a + b;
    var diff: i64 = a - b;
    var prod: i64 = a * b;
    var quot: i64 = a / b;
    var rem: i64 = a % b;
    var result: i64 = sum + diff + prod + quot + rem;
    if result == 54 { return 42; }
    return 1;
}


fn main() i64 {
    var failed: i64 = 0

    // TIER 1: Basic arithmetic
    if test_return() != 42 { println("FAIL: test_return"); failed += 1 }
    if test_mul() != 42 { println("FAIL: test_mul"); failed += 1 }
    if test_div() != 42 { println("FAIL: test_div"); failed += 1 }
    if test_sub() != 42 { println("FAIL: test_sub"); failed += 1 }
    if test_neg() != 42 { println("FAIL: test_neg"); failed += 1 }

    // TIER 2: Function calls
    if test_call() != 42 { println("FAIL: test_call"); failed += 1 }
    if test_nested_call() != 42 { println("FAIL: test_nested_call"); failed += 1 }
    if test_call_spill() != 6 { println("FAIL: test_call_spill"); failed += 1 }
    if test_fn_call() != 42 { println("FAIL: test_fn_call"); failed += 1 }

    // TIER 3: Local variables
    if test_var_assign() != 42 { println("FAIL: test_var_assign"); failed += 1 }
    if test_const() != 42 { println("FAIL: test_const"); failed += 1 }

    // TIER 4: Comparisons
    if test_ne() != 42 { println("FAIL: test_ne"); failed += 1 }
    if test_lt() != 42 { println("FAIL: test_lt"); failed += 1 }
    if test_gt() != 42 { println("FAIL: test_gt"); failed += 1 }

    // TIER 5: If/else
    if test_if() != 42 { println("FAIL: test_if"); failed += 1 }
    if test_if_false() != 42 { println("FAIL: test_if_false"); failed += 1 }
    if test_nested_if() != 42 { println("FAIL: test_nested_if"); failed += 1 }

    // TIER 6: While loops
    if test_while_simple() != 42 { println("FAIL: test_while_simple"); failed += 1 }
    if test_while() != 42 { println("FAIL: test_while"); failed += 1 }
    if test_fibonacci() != 55 { println("FAIL: test_fibonacci"); failed += 1 }

    // TIER 6.5: Edge cases
    if test_neg_compare() != 42 { println("FAIL: test_neg_compare"); failed += 1 }
    if test_chain() != 42 { println("FAIL: test_chain"); failed += 1 }
    if test_countdown() != 42 { println("FAIL: test_countdown"); failed += 1 }
    if test_multi_var() != 42 { println("FAIL: test_multi_var"); failed += 1 }
    if test_early_return() != 42 { println("FAIL: test_early_return"); failed += 1 }
    if test_le() != 42 { println("FAIL: test_le"); failed += 1 }
    if test_ge() != 42 { println("FAIL: test_ge"); failed += 1 }
    if test_mod() != 42 { println("FAIL: test_mod"); failed += 1 }
    if test_recursion() != 42 { println("FAIL: test_recursion"); failed += 1 }
    if test_bool() != 42 { println("FAIL: test_bool"); failed += 1 }
    if test_8args() != 42 { println("FAIL: test_8args"); failed += 1 }
    if test_9args() != 42 { println("FAIL: test_9args"); failed += 1 }
    if test_nested_while() != 42 { println("FAIL: test_nested_while"); failed += 1 }
    if test_break() != 42 { println("FAIL: test_break"); failed += 1 }
    if test_continue() != 42 { println("FAIL: test_continue"); failed += 1 }
    if test_precedence() != 42 { println("FAIL: test_precedence"); failed += 1 }
    if test_parens() != 42 { println("FAIL: test_parens"); failed += 1 }
    if test_void() != 42 { println("FAIL: test_void"); failed += 1 }
    if test_large() != 42 { println("FAIL: test_large"); failed += 1 }

    // TIER 7: Structs
    if test_struct_simple() != 42 { println("FAIL: test_struct_simple"); failed += 1 }
    if test_struct_reassign() != 42 { println("FAIL: test_struct_reassign"); failed += 1 }
    if test_nested_struct() != 42 { println("FAIL: test_nested_struct"); failed += 1 }
    if test_large_struct() != 42 { println("FAIL: test_large_struct"); failed += 1 }

    // TIER 8: Characters
    if test_char_simple() != 42 { println("FAIL: test_char_simple"); failed += 1 }
    if test_char_escape() != 42 { println("FAIL: test_char_escape"); failed += 1 }
    if test_char_compare() != 42 { println("FAIL: test_char_compare"); failed += 1 }

    // TIER 8: Strings
    if test_string_simple() != 42 { println("FAIL: test_string_simple"); failed += 1 }
    if test_len_string() != 42 { println("FAIL: test_len_string"); failed += 1 }
    if test_len_escape() != 42 { println("FAIL: test_len_escape"); failed += 1 }
    if test_len_string_var() != 42 { println("FAIL: test_len_string_var"); failed += 1 }

    // TIER 9: Arrays
    if test_array_index() != 42 { println("FAIL: test_array_index"); failed += 1 }
    if test_array_assign() != 42 { println("FAIL: test_array_assign"); failed += 1 }
    if test_array_var_index() != 42 { println("FAIL: test_array_var_index"); failed += 1 }
    if test_array_param() != 42 { println("FAIL: test_array_param"); failed += 1 }

    // TIER 10: Pointers
    if test_ptr_read() != 42 { println("FAIL: test_ptr_read"); failed += 1 }
    if test_ptr_write() != 42 { println("FAIL: test_ptr_write"); failed += 1 }
    if test_ptr_modify() != 50 { println("FAIL: test_ptr_modify"); failed += 1 }
    if test_ptr_param() != 42 { println("FAIL: test_ptr_param"); failed += 1 }
    if test_ptr_expr() != 42 { println("FAIL: test_ptr_expr"); failed += 1 }
    if test_ptr_field_store() != 42 { println("FAIL: test_ptr_field_store"); failed += 1 }
    if test_fn_type() != 42 { println("FAIL: test_fn_type"); failed += 1 }

    // TIER 11: Bitwise operators
    if test_bitwise_and() != 10 { println("FAIL: test_bitwise_and"); failed += 1 }
    if test_bitwise_or() != 15 { println("FAIL: test_bitwise_or"); failed += 1 }
    if test_bitwise_xor() != 5 { println("FAIL: test_bitwise_xor"); failed += 1 }
    if test_shl() != 32 { println("FAIL: test_shl"); failed += 1 }
    if test_shr() != 4 { println("FAIL: test_shr"); failed += 1 }
    if test_bitwise_combo() != 12 { println("FAIL: test_bitwise_combo"); failed += 1 }
    if test_shift_var() != 64 { println("FAIL: test_shift_var"); failed += 1 }
    if test_mask_extract() != 15 { println("FAIL: test_mask_extract"); failed += 1 }

    // TIER 12: Logical operators (short-circuit)
    if test_logical_and_true() != 42 { println("FAIL: test_logical_and_true"); failed += 1 }
    if test_logical_and_false_first() != 42 { println("FAIL: test_logical_and_false_first"); failed += 1 }
    if test_logical_and_false_second() != 42 { println("FAIL: test_logical_and_false_second"); failed += 1 }
    if test_logical_or_false() != 42 { println("FAIL: test_logical_or_false"); failed += 1 }
    if test_logical_or_true_first() != 42 { println("FAIL: test_logical_or_true_first"); failed += 1 }
    if test_logical_or_true_second() != 42 { println("FAIL: test_logical_or_true_second"); failed += 1 }
    if test_logical_and_chain() != 42 { println("FAIL: test_logical_and_chain"); failed += 1 }
    if test_logical_or_chain() != 42 { println("FAIL: test_logical_or_chain"); failed += 1 }
    if test_logical_or_chain_all_false() != 42 { println("FAIL: test_logical_or_chain_all_false"); failed += 1 }
    if test_logical_or_chain_4_false() != 42 { println("FAIL: test_logical_or_chain_4_false"); failed += 1 }

    // TIER 13: Enums
    if test_enum_first() != 42 { println("FAIL: test_enum_first"); failed += 1 }
    if test_enum_second() != 42 { println("FAIL: test_enum_second"); failed += 1 }
    if test_enum_third() != 42 { println("FAIL: test_enum_third"); failed += 1 }
    if test_enum_ne() != 42 { println("FAIL: test_enum_ne"); failed += 1 }
    if test_enum_param() != 42 { println("FAIL: test_enum_param"); failed += 1 }

    // TIER 14: Null and Pointers
    if test_null_eq() != 42 { println("FAIL: test_null_eq"); failed += 1 }
    if test_null_ne() != 42 { println("FAIL: test_null_ne"); failed += 1 }
    if test_null_eq_right() != 42 { println("FAIL: test_null_eq_right"); failed += 1 }
    if test_ptr_not_null() != 42 { println("FAIL: test_ptr_not_null"); failed += 1 }

    // TIER 15: Slices
    if test_slice_create() != 42 { println("FAIL: test_slice_create"); failed += 1 }
    if test_slice_start() != 42 { println("FAIL: test_slice_start"); failed += 1 }
    if test_slice_index_first() != 10 { println("FAIL: test_slice_index_first"); failed += 1 }
    if test_slice_index_middle() != 30 { println("FAIL: test_slice_index_middle"); failed += 1 }
    if test_slice_index_offset() != 30 { println("FAIL: test_slice_index_offset"); failed += 1 }
    if test_slice_len() != 3 { println("FAIL: test_slice_len"); failed += 1 }
    if test_slice_len_full() != 5 { println("FAIL: test_slice_len_full"); failed += 1 }
    if test_slice_write() != 42 { println("FAIL: test_slice_write"); failed += 1 }
    if test_slice_implicit_end() != 30 { println("FAIL: test_slice_implicit_end"); failed += 1 }
    if test_slice_full() != 5 { println("FAIL: test_slice_full"); failed += 1 }
    if test_slice_implicit_start() != 30 { println("FAIL: test_slice_implicit_start"); failed += 1 }

    // TIER 15.4: Computed Base Index Assignment
    if test_computed_base_assign() != 42 { println("FAIL: test_computed_base_assign"); failed += 1 }

    // TIER 15.5: Array Copy
    if test_array_copy() != 10 { println("FAIL: test_array_copy"); failed += 1 }
    if test_array_copy_values() != 60 { println("FAIL: test_array_copy_values"); failed += 1 }

    // TIER 15.6: String Variable Assignment
    if test_string_var_copy() != 5 { println("FAIL: test_string_var_copy"); failed += 1 }
    if test_string_var_copy2() != 8 { println("FAIL: test_string_var_copy2"); failed += 1 }

    // TIER 15.7: String Indexing and Slicing
    if test_string_index_first() != 42 { println("FAIL: test_string_index_first"); failed += 1 }
    if test_string_index_middle() != 42 { println("FAIL: test_string_index_middle"); failed += 1 }
    if test_string_slice() != 3 { println("FAIL: test_string_slice"); failed += 1 }
    if test_string_slice_content() != 42 { println("FAIL: test_string_slice_content"); failed += 1 }

    // TIER 15.8: String Concatenation
    if test_str_concat_basic() != 42 { println("FAIL: test_str_concat_basic"); failed += 1 }
    if test_str_concat_empty() != 42 { println("FAIL: test_str_concat_empty"); failed += 1 }
    if test_str_concat_multi() != 42 { println("FAIL: test_str_concat_multi"); failed += 1 }

    // TIER 15.9: @string Builtin
    if test_string_builtin_len() != 42 { println("FAIL: test_string_builtin_len"); failed += 1 }
    if test_string_builtin_content() != 42 { println("FAIL: test_string_builtin_content"); failed += 1 }
    if test_string_builtin_empty() != 42 { println("FAIL: test_string_builtin_empty"); failed += 1 }

    // TIER 16: For-In Loops
    if test_for_array() != 15 { println("FAIL: test_for_array"); failed += 1 }
    if test_for_break() != 30 { println("FAIL: test_for_break"); failed += 1 }
    if test_for_continue() != 12 { println("FAIL: test_for_continue"); failed += 1 }
    if test_for_slice() != 90 { println("FAIL: test_for_slice"); failed += 1 }

    // TIER 17: Switch Statement
    if test_switch_int() != 42 { println("FAIL: test_switch_int"); failed += 1 }
    if test_switch_default() != 42 { println("FAIL: test_switch_default"); failed += 1 }
    if test_switch_multi() != 42 { println("FAIL: test_switch_multi"); failed += 1 }
    if test_switch_first() != 42 { println("FAIL: test_switch_first"); failed += 1 }

    // TIER 18: Indirect Function Calls
    if test_fn_ptr_call() != 42 { println("FAIL: test_fn_ptr_call"); failed += 1 }
    if test_fn_ptr_reassign() != 42 { println("FAIL: test_fn_ptr_reassign"); failed += 1 }
    if test_fn_ptr_no_args() != 42 { println("FAIL: test_fn_ptr_no_args"); failed += 1 }

    // TIER 19: Pointer Arithmetic
    if test_ptr_add() != 42 { println("FAIL: test_ptr_add"); failed += 1 }
    if test_ptr_sub() != 42 { println("FAIL: test_ptr_sub"); failed += 1 }

    // TIER 20: Bitwise NOT
    if test_bitwise_not_zero() != 42 { println("FAIL: test_bitwise_not_zero"); failed += 1 }
    if test_bitwise_not_neg() != 42 { println("FAIL: test_bitwise_not_neg"); failed += 1 }
    if test_bitwise_not_double() != 42 { println("FAIL: test_bitwise_not_double"); failed += 1 }

    // TIER 21: Compound Assignments
    if test_add_assign() != 42 { println("FAIL: test_add_assign"); failed += 1 }
    if test_sub_assign() != 42 { println("FAIL: test_sub_assign"); failed += 1 }
    if test_mul_assign() != 42 { println("FAIL: test_mul_assign"); failed += 1 }
    if test_div_assign() != 42 { println("FAIL: test_div_assign"); failed += 1 }
    if test_bitwise_and_assign() != 42 { println("FAIL: test_bitwise_and_assign"); failed += 1 }
    if test_bitwise_or_assign() != 42 { println("FAIL: test_bitwise_or_assign"); failed += 1 }

    // TIER 22: @intCast
    if test_intcast_widen() != 42 { println("FAIL: test_intcast_widen"); failed += 1 }
    if test_intcast_truncate() != 42 { println("FAIL: test_intcast_truncate"); failed += 1 }
    if test_intcast_roundtrip() != 42 { println("FAIL: test_intcast_roundtrip"); failed += 1 }

    // TIER 23: Defer Statement
    if test_defer_simple() != 42 { println("FAIL: test_defer_simple"); failed += 1 }
    if test_defer_early_return() != 42 { println("FAIL: test_defer_early_return"); failed += 1 }
    if test_defer_multiple() != 42 { println("FAIL: test_defer_multiple"); failed += 1 }
    if test_defer_block() != 42 { println("FAIL: test_defer_block"); failed += 1 }

    // TIER 24: Global Variables
    if test_global_basic() != 42 { println("FAIL: test_global_basic"); failed += 1 }
    if test_global_increment() != 42 { println("FAIL: test_global_increment"); failed += 1 }
    if test_global_arithmetic() != 42 { println("FAIL: test_global_arithmetic"); failed += 1 }
    if test_global_multi_access() != 42 { println("FAIL: test_global_multi_access"); failed += 1 }

    // TIER 25: Stress Tests
    // Register pressure - forces spilling
    if test_regpressure_15() != 120 { println("FAIL: test_regpressure_15"); failed += 1 }
    if test_regpressure_20() != 210 { println("FAIL: test_regpressure_20"); failed += 1 }
    if test_regpressure_with_calls() != 84 { println("FAIL: test_regpressure_with_calls"); failed += 1 }

    // Phi nodes with 3+ predecessors
    if test_phi_3way_driver() != 42 { println("FAIL: test_phi_3way_driver"); failed += 1 }
    if test_phi_4way_driver() != 42 { println("FAIL: test_phi_4way_driver"); failed += 1 }

    // Many arguments (stack passing stress)
    if test_16args() != 42 { println("FAIL: test_16args"); failed += 1 }

    // String across branches (16-byte phi nodes)
    if test_string_branch() != 13 { println("FAIL: test_string_branch"); failed += 1 }
    if test_string_loop() != 3 { println("FAIL: test_string_loop"); failed += 1 }

    // Deep nesting (3+ levels)
    if test_nest3() != 5 { println("FAIL: test_nest3"); failed += 1 }
    if test_nest4() != 3 { println("FAIL: test_nest4"); failed += 1 }

    // Complex expressions
    if test_long_expr() != 42 { println("FAIL: test_long_expr"); failed += 1 }
    if test_nested_arith() != 120 { println("FAIL: test_nested_arith"); failed += 1 }

    // Combined stress: register pressure in loops
    if test_pressure_in_loop() != 140 { println("FAIL: test_pressure_in_loop"); failed += 1 }

    // TIER 26: Bug Regression Tests
    if test_bug003_struct_enum_field() != 30 { println("FAIL: test_bug003_struct_enum_field"); failed += 1 }
    if test_bug004_large_struct_return() != 42 { println("FAIL: test_bug004_large_struct_return"); failed += 1 }
    if test_bug012_ptr_deref_field() != 42 { println("FAIL: test_bug012_ptr_deref_field"); failed += 1 }
    if test_bug016_const_right_side() != 42 { println("FAIL: test_bug016_const_right_side"); failed += 1 }
    if test_bug019_large_struct_arg() != 42 { println("FAIL: test_bug019_large_struct_arg"); failed += 1 }
    if test_bug019b_large_struct_literal_arg() != 42 { println("FAIL: test_bug019b_large_struct_literal_arg"); failed += 1 }


    // TIER 27: Parity Tests
    if test_parity_bubble_sort() != 42 { println("FAIL: test_parity_bubble_sort"); failed += 1 }
    if test_parity_insertion_sort() != 42 { println("FAIL: test_parity_insertion_sort"); failed += 1 }
    if test_parity_selection_sort() != 42 { println("FAIL: test_parity_selection_sort"); failed += 1 }
    if test_parity_binary_search() != 42 { println("FAIL: test_parity_binary_search"); failed += 1 }
    if test_parity_collatz() != 42 { println("FAIL: test_parity_collatz"); failed += 1 }
    if test_parity_is_prime() != 42 { println("FAIL: test_parity_is_prime"); failed += 1 }
    if test_parity_power() != 42 { println("FAIL: test_parity_power"); failed += 1 }
    if test_parity_triple_loop() != 42 { println("FAIL: test_parity_triple_loop"); failed += 1 }
    if test_parity_nested_loop() != 42 { println("FAIL: test_parity_nested_loop"); failed += 1 }
    if test_parity_count_bits() != 42 { println("FAIL: test_parity_count_bits"); failed += 1 }

    if test_parity_reverse() != 42 { println("FAIL: test_parity_reverse"); failed += 1 }
    if test_parity_find_max() != 42 { println("FAIL: test_parity_find_max"); failed += 1 }
    if test_parity_find_min() != 42 { println("FAIL: test_parity_find_min"); failed += 1 }
    if test_parity_array_count() != 42 { println("FAIL: test_parity_array_count"); failed += 1 }
    if test_parity_partial_sum() != 42 { println("FAIL: test_parity_partial_sum"); failed += 1 }
    if test_parity_count_primes() != 42 { println("FAIL: test_parity_count_primes"); failed += 1 }
    if test_parity_sum_divisible() != 42 { println("FAIL: test_parity_sum_divisible"); failed += 1 }
    if test_parity_fizzbuzz() != 42 { println("FAIL: test_parity_fizzbuzz"); failed += 1 }
    if test_parity_align_up() != 42 { println("FAIL: test_parity_align_up"); failed += 1 }
    if test_parity_bit_extract() != 42 { println("FAIL: test_parity_bit_extract"); failed += 1 }
    if test_parity_fib_iter() != 42 { println("FAIL: test_parity_fib_iter"); failed += 1 }
    if test_parity_factorial() != 42 { println("FAIL: test_parity_factorial"); failed += 1 }
    if test_parity_nth_prime() != 42 { println("FAIL: test_parity_nth_prime"); failed += 1 }
    if test_parity_fib_array() != 42 { println("FAIL: test_parity_fib_array"); failed += 1 }


    // TIER 27: Parity Tests
    if test_parity_arr_001_basic_i64() != 42 { println("FAIL: test_parity_arr_001_basic_i64"); failed += 1 }
    if test_parity_arr_002_index_calc() != 42 { println("FAIL: test_parity_arr_002_index_calc"); failed += 1 }
    if test_parity_arr_003_sum_loop() != 42 { println("FAIL: test_parity_arr_003_sum_loop"); failed += 1 }
    if test_parity_arr_004_pass_to_fn() != 42 { println("FAIL: test_parity_arr_004_pass_to_fn"); failed += 1 }
    if test_parity_arr_005_modify_in_fn() != 42 { println("FAIL: test_parity_arr_005_modify_in_fn"); failed += 1 }
    if test_parity_arr_006_copy_array() != 42 { println("FAIL: test_parity_arr_006_copy_array"); failed += 1 }
    if test_parity_arr_007_find_max() != 42 { println("FAIL: test_parity_arr_007_find_max"); failed += 1 }
    if test_parity_arr_008_find_min() != 42 { println("FAIL: test_parity_arr_008_find_min"); failed += 1 }
    if test_parity_arr_009_reverse() != 42 { println("FAIL: test_parity_arr_009_reverse"); failed += 1 }
    if test_parity_arr_010_swap() != 42 { println("FAIL: test_parity_arr_010_swap"); failed += 1 }
    if test_parity_arr_011_bubble_sort() != 42 { println("FAIL: test_parity_arr_011_bubble_sort"); failed += 1 }
    if test_parity_arr_012_linear_search() != 42 { println("FAIL: test_parity_arr_012_linear_search"); failed += 1 }
    if test_parity_arr_013_count() != 42 { println("FAIL: test_parity_arr_013_count"); failed += 1 }
    if test_parity_arr_014_product() != 42 { println("FAIL: test_parity_arr_014_product"); failed += 1 }
    if test_parity_arr_015_all_positive() != 42 { println("FAIL: test_parity_arr_015_all_positive"); failed += 1 }
    if test_parity_arr_016_insertion_sort() != 42 { println("FAIL: test_parity_arr_016_insertion_sort"); failed += 1 }
    if test_parity_arr_017_selection_sort() != 42 { println("FAIL: test_parity_arr_017_selection_sort"); failed += 1 }
    if test_parity_arr_018_binary_search() != 42 { println("FAIL: test_parity_arr_018_binary_search"); failed += 1 }
    if test_parity_arr_019_merge_arrays() != 42 { println("FAIL: test_parity_arr_019_merge_arrays"); failed += 1 }
    if test_parity_arr_020_fill_pattern() != 42 { println("FAIL: test_parity_arr_020_fill_pattern"); failed += 1 }
    if test_parity_arr_021_partial_sum() != 42 { println("FAIL: test_parity_arr_021_partial_sum"); failed += 1 }
    if test_parity_arr_022_rotate() != 42 { println("FAIL: test_parity_arr_022_rotate"); failed += 1 }
    if test_parity_arr_023_filter() != 42 { println("FAIL: test_parity_arr_023_filter"); failed += 1 }
    if test_parity_arr_024_average() != 42 { println("FAIL: test_parity_arr_024_average"); failed += 1 }
    if test_parity_arr_025_map() != 42 { println("FAIL: test_parity_arr_025_map"); failed += 1 }
    if test_parity_arr_026_dot_product() != 42 { println("FAIL: test_parity_arr_026_dot_product"); failed += 1 }
    if test_parity_arr_027_norm_squared() != 42 { println("FAIL: test_parity_arr_027_norm_squared"); failed += 1 }
    if test_parity_arr_028_diff_array() != 42 { println("FAIL: test_parity_arr_028_diff_array"); failed += 1 }
    if test_parity_arr_029_scale() != 42 { println("FAIL: test_parity_arr_029_scale"); failed += 1 }
    if test_parity_arr_030_add_arrays() != 42 { println("FAIL: test_parity_arr_030_add_arrays"); failed += 1 }
    if test_parity_arr_031_reverse_in_place() != 42 { println("FAIL: test_parity_arr_031_reverse_in_place"); failed += 1 }
    if test_parity_arr_032_partition() != 42 { println("FAIL: test_parity_arr_032_partition"); failed += 1 }
    if test_parity_arr_033_find_index() != 42 { println("FAIL: test_parity_arr_033_find_index"); failed += 1 }
    if test_parity_arr_034_contains() != 42 { println("FAIL: test_parity_arr_034_contains"); failed += 1 }
    if test_parity_arr_035_unique_count() != 42 { println("FAIL: test_parity_arr_035_unique_count"); failed += 1 }
    if test_parity_arr_036_copy_array() != 42 { println("FAIL: test_parity_arr_036_copy_array"); failed += 1 }
    if test_parity_arr_037_fill_array() != 42 { println("FAIL: test_parity_arr_037_fill_array"); failed += 1 }
    if test_parity_arr_038_swap_elements() != 42 { println("FAIL: test_parity_arr_038_swap_elements"); failed += 1 }
    if test_parity_arr_039_rotate_left() != 42 { println("FAIL: test_parity_arr_039_rotate_left"); failed += 1 }
    if test_parity_arr_040_rotate_right() != 42 { println("FAIL: test_parity_arr_040_rotate_right"); failed += 1 }
    if test_parity_arr_041_is_sorted() != 42 { println("FAIL: test_parity_arr_041_is_sorted"); failed += 1 }
    if test_parity_arr_042_count_if() != 42 { println("FAIL: test_parity_arr_042_count_if"); failed += 1 }
    if test_parity_arr_043_all_positive() != 42 { println("FAIL: test_parity_arr_043_all_positive"); failed += 1 }
    if test_parity_arr_044_any_zero() != 42 { println("FAIL: test_parity_arr_044_any_zero"); failed += 1 }
    if test_parity_arr_045_second_largest() != 42 { println("FAIL: test_parity_arr_045_second_largest"); failed += 1 }
    if test_parity_arr_046_selection_sort() != 42 { println("FAIL: test_parity_arr_046_selection_sort"); failed += 1 }
    if test_parity_arr_047_find_max_index() != 42 { println("FAIL: test_parity_arr_047_find_max_index"); failed += 1 }
    if test_parity_arr_048_find_min_index() != 42 { println("FAIL: test_parity_arr_048_find_min_index"); failed += 1 }
    if test_parity_arr_049_prefix_sum() != 42 { println("FAIL: test_parity_arr_049_prefix_sum"); failed += 1 }
    if test_parity_arr_050_difference() != 42 { println("FAIL: test_parity_arr_050_difference"); failed += 1 }
    if test_parity_arr_051_dot_product() != 42 { println("FAIL: test_parity_arr_051_dot_product"); failed += 1 }
    if test_parity_arr_052_element_wise_add() != 42 { println("FAIL: test_parity_arr_052_element_wise_add"); failed += 1 }
    if test_parity_arr_053_scale_array() != 42 { println("FAIL: test_parity_arr_053_scale_array"); failed += 1 }
    if test_parity_arr_054_find_last() != 42 { println("FAIL: test_parity_arr_054_find_last"); failed += 1 }
    if test_parity_arr_055_count_value() != 42 { println("FAIL: test_parity_arr_055_count_value"); failed += 1 }
    if test_parity_arr_056_binary_search() != 42 { println("FAIL: test_parity_arr_056_binary_search"); failed += 1 }
    if test_parity_arr_057_lower_bound() != 42 { println("FAIL: test_parity_arr_057_lower_bound"); failed += 1 }
    if test_parity_arr_058_upper_bound() != 42 { println("FAIL: test_parity_arr_058_upper_bound"); failed += 1 }
    if test_parity_arr_059_merge() != 42 { println("FAIL: test_parity_arr_059_merge"); failed += 1 }
    if test_parity_arr_060_remove_element() != 42 { println("FAIL: test_parity_arr_060_remove_element"); failed += 1 }
    if test_parity_cf_001_if() != 42 { println("FAIL: test_parity_cf_001_if"); failed += 1 }
    if test_parity_cf_002_while() != 42 { println("FAIL: test_parity_cf_002_while"); failed += 1 }
    if test_parity_cf_003_nested_if() != 42 { println("FAIL: test_parity_cf_003_nested_if"); failed += 1 }
    if test_parity_cf_004_else() != 42 { println("FAIL: test_parity_cf_004_else"); failed += 1 }
    if test_parity_cf_005_else_if() != 42 { println("FAIL: test_parity_cf_005_else_if"); failed += 1 }
    if test_parity_cf_006_while_break() != 42 { println("FAIL: test_parity_cf_006_while_break"); failed += 1 }
    if test_parity_cf_007_while_continue() != 42 { println("FAIL: test_parity_cf_007_while_continue"); failed += 1 }
    if test_parity_cf_008_nested_while() != 42 { println("FAIL: test_parity_cf_008_nested_while"); failed += 1 }
    if test_parity_cf_009_early_return() != 42 { println("FAIL: test_parity_cf_009_early_return"); failed += 1 }
    if test_parity_cf_010_multi_cond() != 42 { println("FAIL: test_parity_cf_010_multi_cond"); failed += 1 }
    if test_parity_cf_011_deep_nest() != 42 { println("FAIL: test_parity_cf_011_deep_nest"); failed += 1 }
    if test_parity_cf_012_if_in_while() != 42 { println("FAIL: test_parity_cf_012_if_in_while"); failed += 1 }
    if test_parity_cf_013_while_in_if() != 42 { println("FAIL: test_parity_cf_013_while_in_if"); failed += 1 }
    if test_parity_cf_014_break_nested() != 42 { println("FAIL: test_parity_cf_014_break_nested"); failed += 1 }
    if test_parity_cf_015_multi_return() != 42 { println("FAIL: test_parity_cf_015_multi_return"); failed += 1 }
    if test_parity_cf_016_count_down() != 42 { println("FAIL: test_parity_cf_016_count_down"); failed += 1 }
    if test_parity_cf_017_gcd() != 42 { println("FAIL: test_parity_cf_017_gcd"); failed += 1 }
    if test_parity_cf_018_fizzbuzz_count() != 42 { println("FAIL: test_parity_cf_018_fizzbuzz_count"); failed += 1 }
    if test_parity_cf_019_find_first() != 42 { println("FAIL: test_parity_cf_019_find_first"); failed += 1 }
    if test_parity_cf_020_sum_digits() != 42 { println("FAIL: test_parity_cf_020_sum_digits"); failed += 1 }
    if test_parity_cf_021_binary_search() != 42 { println("FAIL: test_parity_cf_021_binary_search"); failed += 1 }
    if test_parity_cf_022_linear_search() != 42 { println("FAIL: test_parity_cf_022_linear_search"); failed += 1 }
    if test_parity_cf_023_bubble_sort() != 42 { println("FAIL: test_parity_cf_023_bubble_sort"); failed += 1 }
    if test_parity_cf_024_array_max() != 42 { println("FAIL: test_parity_cf_024_array_max"); failed += 1 }
    if test_parity_cf_025_array_min() != 42 { println("FAIL: test_parity_cf_025_array_min"); failed += 1 }
    if test_parity_cf_026_empty_while() != 42 { println("FAIL: test_parity_cf_026_empty_while"); failed += 1 }
    if test_parity_cf_027_false_cond() != 42 { println("FAIL: test_parity_cf_027_false_cond"); failed += 1 }
    if test_parity_cf_028_true_cond() != 42 { println("FAIL: test_parity_cf_028_true_cond"); failed += 1 }
    if test_parity_cf_029_nested_break() != 42 { println("FAIL: test_parity_cf_029_nested_break"); failed += 1 }
    if test_parity_cf_030_multiple_breaks() != 42 { println("FAIL: test_parity_cf_030_multiple_breaks"); failed += 1 }
    if test_parity_cf_031_long_chain() != 42 { println("FAIL: test_parity_cf_031_long_chain"); failed += 1 }
    if test_parity_cf_032_while_zero() != 42 { println("FAIL: test_parity_cf_032_while_zero"); failed += 1 }
    if test_parity_cf_033_nested_else() != 42 { println("FAIL: test_parity_cf_033_nested_else"); failed += 1 }
    if test_parity_cf_034_count_matches() != 42 { println("FAIL: test_parity_cf_034_count_matches"); failed += 1 }
    if test_parity_cf_035_alternating() != 42 { println("FAIL: test_parity_cf_035_alternating"); failed += 1 }
    if test_parity_cf_036_nested_continue() != 42 { println("FAIL: test_parity_cf_036_nested_continue"); failed += 1 }
    if test_parity_cf_037_double_loop() != 42 { println("FAIL: test_parity_cf_037_double_loop"); failed += 1 }
    if test_parity_cf_038_nested_while() != 42 { println("FAIL: test_parity_cf_038_nested_while"); failed += 1 }
    if test_parity_cf_039_triple_nested() != 42 { println("FAIL: test_parity_cf_039_triple_nested"); failed += 1 }
    if test_parity_cf_040_if_in_while() != 42 { println("FAIL: test_parity_cf_040_if_in_while"); failed += 1 }
    if test_parity_cf_041_while_in_if() != 42 { println("FAIL: test_parity_cf_041_while_in_if"); failed += 1 }
    if test_parity_cf_042_multi_cond() != 42 { println("FAIL: test_parity_cf_042_multi_cond"); failed += 1 }
    if test_parity_cf_043_or_cond() != 42 { println("FAIL: test_parity_cf_043_or_cond"); failed += 1 }
    if test_parity_cf_044_complex_bool() != 42 { println("FAIL: test_parity_cf_044_complex_bool"); failed += 1 }
    if test_parity_cf_045_early_return() != 42 { println("FAIL: test_parity_cf_045_early_return"); failed += 1 }
    if test_parity_cf_046_cascade_if() != 42 { println("FAIL: test_parity_cf_046_cascade_if"); failed += 1 }
    if test_parity_cf_047_while_flag() != 42 { println("FAIL: test_parity_cf_047_while_flag"); failed += 1 }
    if test_parity_cf_048_deeply_nested() != 42 { println("FAIL: test_parity_cf_048_deeply_nested"); failed += 1 }
    if test_parity_cf_049_if_else_chain() != 42 { println("FAIL: test_parity_cf_049_if_else_chain"); failed += 1 }
    if test_parity_cf_051_early_exit() != 42 { println("FAIL: test_parity_cf_051_early_exit"); failed += 1 }
    if test_parity_cf_052_count_matches() != 42 { println("FAIL: test_parity_cf_052_count_matches"); failed += 1 }
    if test_parity_cf_053_sum_range() != 42 { println("FAIL: test_parity_cf_053_sum_range"); failed += 1 }
    if test_parity_cf_054_product_range() != 42 { println("FAIL: test_parity_cf_054_product_range"); failed += 1 }
    if test_parity_cf_055_skip_evens() != 42 { println("FAIL: test_parity_cf_055_skip_evens"); failed += 1 }
    if test_parity_cf_056_nested_return() != 42 { println("FAIL: test_parity_cf_056_nested_return"); failed += 1 }
    if test_parity_cf_057_while_cond_complex() != 42 { println("FAIL: test_parity_cf_057_while_cond_complex"); failed += 1 }
    if test_parity_cf_058_or_condition() != 42 { println("FAIL: test_parity_cf_058_or_condition"); failed += 1 }
    if test_parity_cf_059_while_true() != 42 { println("FAIL: test_parity_cf_059_while_true"); failed += 1 }
    if test_parity_cf_060_countdown() != 42 { println("FAIL: test_parity_cf_060_countdown"); failed += 1 }
    if test_parity_cf_061_step_by_2() != 42 { println("FAIL: test_parity_cf_061_step_by_2"); failed += 1 }
    if test_parity_cf_062_geometric() != 42 { println("FAIL: test_parity_cf_062_geometric"); failed += 1 }
    if test_parity_cf_063_harmonic() != 42 { println("FAIL: test_parity_cf_063_harmonic"); failed += 1 }
    if test_parity_cf_064_double_loop() != 42 { println("FAIL: test_parity_cf_064_double_loop"); failed += 1 }
    if test_parity_cf_065_matrix_like() != 42 { println("FAIL: test_parity_cf_065_matrix_like"); failed += 1 }
    if test_parity_cf_066_diagonal() != 42 { println("FAIL: test_parity_cf_066_diagonal"); failed += 1 }
    if test_parity_cf_067_alternating() != 42 { println("FAIL: test_parity_cf_067_alternating"); failed += 1 }
    if test_parity_cf_068_fibonacci_loop() != 42 { println("FAIL: test_parity_cf_068_fibonacci_loop"); failed += 1 }
    if test_parity_cf_069_prime_sieve_small() != 42 { println("FAIL: test_parity_cf_069_prime_sieve_small"); failed += 1 }
    if test_parity_cf_070_count_primes() != 42 { println("FAIL: test_parity_cf_070_count_primes"); failed += 1 }
    if test_parity_cf_071_switch_like() != 42 { println("FAIL: test_parity_cf_071_switch_like"); failed += 1 }
    if test_parity_cf_072_grade_classifier() != 42 { println("FAIL: test_parity_cf_072_grade_classifier"); failed += 1 }
    if test_parity_cf_073_range_check() != 42 { println("FAIL: test_parity_cf_073_range_check"); failed += 1 }
    if test_parity_cf_074_clamp() != 42 { println("FAIL: test_parity_cf_074_clamp"); failed += 1 }
    if test_parity_cf_075_loop_break_sim() != 42 { println("FAIL: test_parity_cf_075_loop_break_sim"); failed += 1 }
    if test_parity_cf_076_sign_function() != 42 { println("FAIL: test_parity_cf_076_sign_function"); failed += 1 }
    if test_parity_cf_077_boolean_chain() != 42 { println("FAIL: test_parity_cf_077_boolean_chain"); failed += 1 }
    if test_parity_cf_078_any_true() != 42 { println("FAIL: test_parity_cf_078_any_true"); failed += 1 }
    if test_parity_cf_079_count_loop() != 42 { println("FAIL: test_parity_cf_079_count_loop"); failed += 1 }
    if test_parity_cf_080_sum_divisible() != 42 { println("FAIL: test_parity_cf_080_sum_divisible"); failed += 1 }
    if test_parity_cf_081_countdown() != 42 { println("FAIL: test_parity_cf_081_countdown"); failed += 1 }
    if test_parity_cf_082_even_sum() != 42 { println("FAIL: test_parity_cf_082_even_sum"); failed += 1 }
    if test_parity_cf_083_odd_sum() != 42 { println("FAIL: test_parity_cf_083_odd_sum"); failed += 1 }
    if test_parity_cf_084_double_loop() != 42 { println("FAIL: test_parity_cf_084_double_loop"); failed += 1 }
    if test_parity_cf_085_triple_loop() != 42 { println("FAIL: test_parity_cf_085_triple_loop"); failed += 1 }
    if test_parity_cf_086_complex_cond() != 42 { println("FAIL: test_parity_cf_086_complex_cond"); failed += 1 }
    if test_parity_cf_087_multiple_return() != 42 { println("FAIL: test_parity_cf_087_multiple_return"); failed += 1 }
    if test_parity_cf_088_loop_with_if() != 42 { println("FAIL: test_parity_cf_088_loop_with_if"); failed += 1 }
    if test_parity_cf_089_nested_if_else() != 42 { println("FAIL: test_parity_cf_089_nested_if_else"); failed += 1 }
    if test_parity_cf_090_while_in_if() != 42 { println("FAIL: test_parity_cf_090_while_in_if"); failed += 1 }
    if test_parity_cf_091_early_return() != 42 { println("FAIL: test_parity_cf_091_early_return"); failed += 1 }
    if test_parity_cf_092_cascade_return() != 42 { println("FAIL: test_parity_cf_092_cascade_return"); failed += 1 }
    if test_parity_cf_093_loop_with_early_exit_sim() != 42 { println("FAIL: test_parity_cf_093_loop_with_early_exit_sim"); failed += 1 }
    if test_parity_cf_094_nested_loop_sum() != 42 { println("FAIL: test_parity_cf_094_nested_loop_sum"); failed += 1 }
    if test_parity_cf_095_multiplication_table() != 42 { println("FAIL: test_parity_cf_095_multiplication_table"); failed += 1 }
    if test_parity_cf_096_modulo_check() != 42 { println("FAIL: test_parity_cf_096_modulo_check"); failed += 1 }
    if test_parity_cf_097_fizzbuzz_logic() != 42 { println("FAIL: test_parity_cf_097_fizzbuzz_logic"); failed += 1 }
    if test_parity_cf_098_loop_product() != 42 { println("FAIL: test_parity_cf_098_loop_product"); failed += 1 }
    if test_parity_cf_099_nested_condition() != 42 { println("FAIL: test_parity_cf_099_nested_condition"); failed += 1 }
    if test_parity_cf_100_complex_loop() != 42 { println("FAIL: test_parity_cf_100_complex_loop"); failed += 1 }
    if test_parity_expr_001_add() != 42 { println("FAIL: test_parity_expr_001_add"); failed += 1 }
    if test_parity_expr_002_sub() != 42 { println("FAIL: test_parity_expr_002_sub"); failed += 1 }
    if test_parity_expr_003_mul() != 42 { println("FAIL: test_parity_expr_003_mul"); failed += 1 }
    if test_parity_expr_004_div() != 42 { println("FAIL: test_parity_expr_004_div"); failed += 1 }
    if test_parity_expr_005_complex() != 42 { println("FAIL: test_parity_expr_005_complex"); failed += 1 }
    if test_parity_expr_006_nested() != 42 { println("FAIL: test_parity_expr_006_nested"); failed += 1 }
    if test_parity_expr_007_mod() != 42 { println("FAIL: test_parity_expr_007_mod"); failed += 1 }
    if test_parity_expr_008_neg() != 42 { println("FAIL: test_parity_expr_008_neg"); failed += 1 }
    if test_parity_expr_009_bitand() != 42 { println("FAIL: test_parity_expr_009_bitand"); failed += 1 }
    if test_parity_expr_010_bitor() != 42 { println("FAIL: test_parity_expr_010_bitor"); failed += 1 }
    if test_parity_expr_011_bitxor() != 42 { println("FAIL: test_parity_expr_011_bitxor"); failed += 1 }
    if test_parity_expr_012_shl() != 42 { println("FAIL: test_parity_expr_012_shl"); failed += 1 }
    if test_parity_expr_013_shr() != 42 { println("FAIL: test_parity_expr_013_shr"); failed += 1 }
    if test_parity_expr_014_cmp_lt() != 42 { println("FAIL: test_parity_expr_014_cmp_lt"); failed += 1 }
    if test_parity_expr_015_cmp_le() != 42 { println("FAIL: test_parity_expr_015_cmp_le"); failed += 1 }
    if test_parity_expr_016_cmp_gt() != 42 { println("FAIL: test_parity_expr_016_cmp_gt"); failed += 1 }
    if test_parity_expr_017_cmp_ge() != 42 { println("FAIL: test_parity_expr_017_cmp_ge"); failed += 1 }
    if test_parity_expr_018_cmp_eq() != 42 { println("FAIL: test_parity_expr_018_cmp_eq"); failed += 1 }
    if test_parity_expr_019_cmp_ne() != 42 { println("FAIL: test_parity_expr_019_cmp_ne"); failed += 1 }
    if test_parity_expr_020_chained() != 42 { println("FAIL: test_parity_expr_020_chained"); failed += 1 }
    if test_parity_expr_021_parens() != 42 { println("FAIL: test_parity_expr_021_parens"); failed += 1 }
    if test_parity_expr_022_precedence() != 42 { println("FAIL: test_parity_expr_022_precedence"); failed += 1 }
    if test_parity_expr_023_assoc_left() != 42 { println("FAIL: test_parity_expr_023_assoc_left"); failed += 1 }
    if test_parity_expr_024_mixed_ops() != 42 { println("FAIL: test_parity_expr_024_mixed_ops"); failed += 1 }
    if test_parity_expr_025_div_mod() != 42 { println("FAIL: test_parity_expr_025_div_mod"); failed += 1 }
    if test_parity_expr_026_longchain() != 42 { println("FAIL: test_parity_expr_026_longchain"); failed += 1 }
    if test_parity_expr_027_bitnot() != 42 { println("FAIL: test_parity_expr_027_bitnot"); failed += 1 }
    if test_parity_expr_028_shift_chain() != 42 { println("FAIL: test_parity_expr_028_shift_chain"); failed += 1 }
    if test_parity_expr_029_bit_combo() != 42 { println("FAIL: test_parity_expr_029_bit_combo"); failed += 1 }
    if test_parity_expr_030_arith_assign() != 42 { println("FAIL: test_parity_expr_030_arith_assign"); failed += 1 }
    if test_parity_expr_031_neg_arith() != 42 { println("FAIL: test_parity_expr_031_neg_arith"); failed += 1 }
    if test_parity_expr_032_zero_cmp() != 42 { println("FAIL: test_parity_expr_032_zero_cmp"); failed += 1 }
    if test_parity_expr_033_neg_cmp() != 42 { println("FAIL: test_parity_expr_033_neg_cmp"); failed += 1 }
    if test_parity_expr_034_multi_cmp() != 42 { println("FAIL: test_parity_expr_034_multi_cmp"); failed += 1 }
    if test_parity_expr_035_max() != 42 { println("FAIL: test_parity_expr_035_max"); failed += 1 }
    if test_parity_expr_036_min() != 42 { println("FAIL: test_parity_expr_036_min"); failed += 1 }
    if test_parity_expr_037_abs() != 42 { println("FAIL: test_parity_expr_037_abs"); failed += 1 }
    if test_parity_expr_038_sign() != 42 { println("FAIL: test_parity_expr_038_sign"); failed += 1 }
    if test_parity_expr_039_clamp() != 42 { println("FAIL: test_parity_expr_039_clamp"); failed += 1 }
    if test_parity_expr_040_power() != 42 { println("FAIL: test_parity_expr_040_power"); failed += 1 }
    if test_parity_expr_041_square() != 42 { println("FAIL: test_parity_expr_041_square"); failed += 1 }
    if test_parity_expr_042_cube() != 42 { println("FAIL: test_parity_expr_042_cube"); failed += 1 }
    if test_parity_expr_043_sum_squares() != 42 { println("FAIL: test_parity_expr_043_sum_squares"); failed += 1 }
    if test_parity_expr_044_avg() != 42 { println("FAIL: test_parity_expr_044_avg"); failed += 1 }
    if test_parity_expr_045_tri_area() != 42 { println("FAIL: test_parity_expr_045_tri_area"); failed += 1 }
    if test_parity_expr_046_rect_area() != 42 { println("FAIL: test_parity_expr_046_rect_area"); failed += 1 }
    if test_parity_expr_047_distance() != 42 { println("FAIL: test_parity_expr_047_distance"); failed += 1 }
    if test_parity_expr_048_dot_prod() != 42 { println("FAIL: test_parity_expr_048_dot_prod"); failed += 1 }
    if test_parity_expr_049_cross_prod() != 42 { println("FAIL: test_parity_expr_049_cross_prod"); failed += 1 }
    if test_parity_expr_050_lerp() != 42 { println("FAIL: test_parity_expr_050_lerp"); failed += 1 }
    if test_parity_expr_051_large_const() != 42 { println("FAIL: test_parity_expr_051_large_const"); failed += 1 }
    if test_parity_expr_052_neg_const() != 42 { println("FAIL: test_parity_expr_052_neg_const"); failed += 1 }
    if test_parity_expr_053_hex_const() != 42 { println("FAIL: test_parity_expr_053_hex_const"); failed += 1 }
    if test_parity_expr_054_zero() != 42 { println("FAIL: test_parity_expr_054_zero"); failed += 1 }
    if test_parity_expr_055_one() != 42 { println("FAIL: test_parity_expr_055_one"); failed += 1 }
    if test_parity_expr_056_mult_add() != 42 { println("FAIL: test_parity_expr_056_mult_add"); failed += 1 }
    if test_parity_expr_057_div_sub() != 42 { println("FAIL: test_parity_expr_057_div_sub"); failed += 1 }
    if test_parity_expr_058_nested_parens() != 42 { println("FAIL: test_parity_expr_058_nested_parens"); failed += 1 }
    if test_parity_expr_059_complex_arith() != 42 { println("FAIL: test_parity_expr_059_complex_arith"); failed += 1 }
    if test_parity_expr_060_all_ops() != 42 { println("FAIL: test_parity_expr_060_all_ops"); failed += 1 }
    if test_parity_expr_061_bitwise_combo() != 42 { println("FAIL: test_parity_expr_061_bitwise_combo"); failed += 1 }
    if test_parity_expr_062_mask_extract() != 42 { println("FAIL: test_parity_expr_062_mask_extract"); failed += 1 }
    if test_parity_expr_063_popcount() != 42 { println("FAIL: test_parity_expr_063_popcount"); failed += 1 }
    if test_parity_expr_064_reverse_bits() != 42 { println("FAIL: test_parity_expr_064_reverse_bits"); failed += 1 }
    if test_parity_expr_065_ispow2() != 42 { println("FAIL: test_parity_expr_065_ispow2"); failed += 1 }
    if test_parity_expr_066_neg_div() != 42 { println("FAIL: test_parity_expr_066_neg_div"); failed += 1 }
    if test_parity_expr_067_div_neg() != 42 { println("FAIL: test_parity_expr_067_div_neg"); failed += 1 }
    if test_parity_expr_068_neg_mod() != 42 { println("FAIL: test_parity_expr_068_neg_mod"); failed += 1 }
    if test_parity_expr_069_double_neg() != 42 { println("FAIL: test_parity_expr_069_double_neg"); failed += 1 }
    if test_parity_expr_070_triple_neg() != 42 { println("FAIL: test_parity_expr_070_triple_neg"); failed += 1 }
    if test_parity_expr_071_bitnot_twice() != 42 { println("FAIL: test_parity_expr_071_bitnot_twice"); failed += 1 }
    if test_parity_expr_072_shift_large() != 42 { println("FAIL: test_parity_expr_072_shift_large"); failed += 1 }
    if test_parity_expr_073_shift_zero() != 42 { println("FAIL: test_parity_expr_073_shift_zero"); failed += 1 }
    if test_parity_expr_074_complex_shift() != 42 { println("FAIL: test_parity_expr_074_complex_shift"); failed += 1 }
    if test_parity_expr_075_overflow_add() != 42 { println("FAIL: test_parity_expr_075_overflow_add"); failed += 1 }
    if test_parity_expr_076_division_edge() != 42 { println("FAIL: test_parity_expr_076_division_edge"); failed += 1 }
    if test_parity_expr_077_neg_division() != 42 { println("FAIL: test_parity_expr_077_neg_division"); failed += 1 }
    if test_parity_expr_078_chain_add() != 42 { println("FAIL: test_parity_expr_078_chain_add"); failed += 1 }
    if test_parity_expr_079_chain_mult() != 42 { println("FAIL: test_parity_expr_079_chain_mult"); failed += 1 }
    if test_parity_expr_080_mixed_chain() != 42 { println("FAIL: test_parity_expr_080_mixed_chain"); failed += 1 }
    if test_parity_expr_081_parens() != 42 { println("FAIL: test_parity_expr_081_parens"); failed += 1 }
    if test_parity_expr_082_nested_parens() != 42 { println("FAIL: test_parity_expr_082_nested_parens"); failed += 1 }
    if test_parity_expr_083_bit_and() != 42 { println("FAIL: test_parity_expr_083_bit_and"); failed += 1 }
    if test_parity_expr_084_bit_or() != 42 { println("FAIL: test_parity_expr_084_bit_or"); failed += 1 }
    if test_parity_expr_085_bit_xor() != 42 { println("FAIL: test_parity_expr_085_bit_xor"); failed += 1 }
    if test_parity_expr_086_large_numbers() != 42 { println("FAIL: test_parity_expr_086_large_numbers"); failed += 1 }
    if test_parity_expr_087_very_large() != 42 { println("FAIL: test_parity_expr_087_very_large"); failed += 1 }
    if test_parity_expr_088_max_i64() != 42 { println("FAIL: test_parity_expr_088_max_i64"); failed += 1 }
    if test_parity_expr_089_min_i64() != 42 { println("FAIL: test_parity_expr_089_min_i64"); failed += 1 }
    if test_parity_expr_090_hex_literals() != 42 { println("FAIL: test_parity_expr_090_hex_literals"); failed += 1 }
    if test_parity_expr_091_shift_left() != 42 { println("FAIL: test_parity_expr_091_shift_left"); failed += 1 }
    if test_parity_expr_092_shift_right() != 42 { println("FAIL: test_parity_expr_092_shift_right"); failed += 1 }
    if test_parity_expr_093_shift_both() != 42 { println("FAIL: test_parity_expr_093_shift_both"); failed += 1 }
    if test_parity_expr_094_bit_ops_combined() != 42 { println("FAIL: test_parity_expr_094_bit_ops_combined"); failed += 1 }
    if test_parity_expr_095_power_of_two() != 42 { println("FAIL: test_parity_expr_095_power_of_two"); failed += 1 }
    if test_parity_expr_096_mask_low_bits() != 42 { println("FAIL: test_parity_expr_096_mask_low_bits"); failed += 1 }
    if test_parity_expr_097_set_bit() != 42 { println("FAIL: test_parity_expr_097_set_bit"); failed += 1 }
    if test_parity_expr_098_clear_bit() != 42 { println("FAIL: test_parity_expr_098_clear_bit"); failed += 1 }
    if test_parity_expr_099_toggle_bit() != 42 { println("FAIL: test_parity_expr_099_toggle_bit"); failed += 1 }
    if test_parity_expr_100_count_bits() != 42 { println("FAIL: test_parity_expr_100_count_bits"); failed += 1 }
    if test_parity_expr_101_precedence() != 42 { println("FAIL: test_parity_expr_101_precedence"); failed += 1 }
    if test_parity_expr_102_precedence2() != 42 { println("FAIL: test_parity_expr_102_precedence2"); failed += 1 }
    if test_parity_expr_103_compare_chain() != 42 { println("FAIL: test_parity_expr_103_compare_chain"); failed += 1 }
    if test_parity_expr_104_complex_cond() != 42 { println("FAIL: test_parity_expr_104_complex_cond"); failed += 1 }
    if test_parity_expr_105_zero_compare() != 42 { println("FAIL: test_parity_expr_105_zero_compare"); failed += 1 }
    if test_parity_expr_106_unary_minus() != 42 { println("FAIL: test_parity_expr_106_unary_minus"); failed += 1 }
    if test_parity_expr_107_double_neg() != 42 { println("FAIL: test_parity_expr_107_double_neg"); failed += 1 }
    if test_parity_expr_108_triple_mult() != 42 { println("FAIL: test_parity_expr_108_triple_mult"); failed += 1 }
    if test_parity_expr_109_quad_add() != 42 { println("FAIL: test_parity_expr_109_quad_add"); failed += 1 }
    if test_parity_expr_110_mixed_ops() != 42 { println("FAIL: test_parity_expr_110_mixed_ops"); failed += 1 }
    if test_parity_expr_111_shift_multiply() != 42 { println("FAIL: test_parity_expr_111_shift_multiply"); failed += 1 }
    if test_parity_expr_112_shift_divide() != 42 { println("FAIL: test_parity_expr_112_shift_divide"); failed += 1 }
    if test_parity_expr_113_align_up() != 42 { println("FAIL: test_parity_expr_113_align_up"); failed += 1 }
    if test_parity_expr_114_complex_shift() != 42 { println("FAIL: test_parity_expr_114_complex_shift"); failed += 1 }
    if test_parity_expr_115_bit_extract() != 42 { println("FAIL: test_parity_expr_115_bit_extract"); failed += 1 }
    if test_parity_expr_116_rotate_bits() != 42 { println("FAIL: test_parity_expr_116_rotate_bits"); failed += 1 }
    if test_parity_expr_117_swap_bytes() != 42 { println("FAIL: test_parity_expr_117_swap_bytes"); failed += 1 }
    if test_parity_expr_118_count_leading() != 42 { println("FAIL: test_parity_expr_118_count_leading"); failed += 1 }
    if test_parity_expr_119_zero_checks() != 42 { println("FAIL: test_parity_expr_119_zero_checks"); failed += 1 }
    if test_parity_expr_120_neg_compare() != 42 { println("FAIL: test_parity_expr_120_neg_compare"); failed += 1 }
    if test_parity_expr_121_power_of_three() != 42 { println("FAIL: test_parity_expr_121_power_of_three"); failed += 1 }
    if test_parity_expr_122_sum_of_products() != 42 { println("FAIL: test_parity_expr_122_sum_of_products"); failed += 1 }
    if test_parity_expr_123_nested_mod() != 42 { println("FAIL: test_parity_expr_123_nested_mod"); failed += 1 }
    if test_parity_expr_124_div_chain() != 42 { println("FAIL: test_parity_expr_124_div_chain"); failed += 1 }
    if test_parity_expr_125_mixed_arithmetic() != 42 { println("FAIL: test_parity_expr_125_mixed_arithmetic"); failed += 1 }
    if test_parity_expr_126_compare_chain() != 42 { println("FAIL: test_parity_expr_126_compare_chain"); failed += 1 }
    if test_parity_expr_127_equality_chain() != 42 { println("FAIL: test_parity_expr_127_equality_chain"); failed += 1 }
    if test_parity_expr_128_negative_div() != 42 { println("FAIL: test_parity_expr_128_negative_div"); failed += 1 }
    if test_parity_expr_129_negative_mod() != 42 { println("FAIL: test_parity_expr_129_negative_mod"); failed += 1 }
    if test_parity_expr_130_abs_like() != 42 { println("FAIL: test_parity_expr_130_abs_like"); failed += 1 }
    if test_parity_expr_131_bitwise_and() != 42 { println("FAIL: test_parity_expr_131_bitwise_and"); failed += 1 }
    if test_parity_expr_132_bitwise_or() != 42 { println("FAIL: test_parity_expr_132_bitwise_or"); failed += 1 }
    if test_parity_expr_133_bitwise_xor() != 42 { println("FAIL: test_parity_expr_133_bitwise_xor"); failed += 1 }
    if test_parity_expr_134_left_shift() != 42 { println("FAIL: test_parity_expr_134_left_shift"); failed += 1 }
    if test_parity_expr_135_right_shift() != 42 { println("FAIL: test_parity_expr_135_right_shift"); failed += 1 }
    if test_parity_expr_136_combined_shift() != 42 { println("FAIL: test_parity_expr_136_combined_shift"); failed += 1 }
    if test_parity_expr_137_mask() != 42 { println("FAIL: test_parity_expr_137_mask"); failed += 1 }
    if test_parity_expr_138_set_bit() != 42 { println("FAIL: test_parity_expr_138_set_bit"); failed += 1 }
    if test_parity_expr_139_clear_bit() != 42 { println("FAIL: test_parity_expr_139_clear_bit"); failed += 1 }
    if test_parity_expr_140_toggle_bit() != 42 { println("FAIL: test_parity_expr_140_toggle_bit"); failed += 1 }
    if test_parity_expr_141_chained_compare() != 42 { println("FAIL: test_parity_expr_141_chained_compare"); failed += 1 }
    if test_parity_expr_142_compound_expr() != 42 { println("FAIL: test_parity_expr_142_compound_expr"); failed += 1 }
    if test_parity_expr_143_div_by_power() != 42 { println("FAIL: test_parity_expr_143_div_by_power"); failed += 1 }
    if test_parity_expr_144_mod_chain() != 42 { println("FAIL: test_parity_expr_144_mod_chain"); failed += 1 }
    if test_parity_expr_146_nested_paren() != 42 { println("FAIL: test_parity_expr_146_nested_paren"); failed += 1 }
    if test_parity_expr_147_multi_mul() != 42 { println("FAIL: test_parity_expr_147_multi_mul"); failed += 1 }
    if test_parity_expr_148_multi_add() != 42 { println("FAIL: test_parity_expr_148_multi_add"); failed += 1 }
    if test_parity_expr_149_multi_sub() != 42 { println("FAIL: test_parity_expr_149_multi_sub"); failed += 1 }
    if test_parity_expr_150_assoc_test() != 42 { println("FAIL: test_parity_expr_150_assoc_test"); failed += 1 }
    if test_parity_expr_151_square_expr() != 42 { println("FAIL: test_parity_expr_151_square_expr"); failed += 1 }
    if test_parity_expr_152_cube_expr() != 42 { println("FAIL: test_parity_expr_152_cube_expr"); failed += 1 }
    if test_parity_expr_153_fourth_power() != 42 { println("FAIL: test_parity_expr_153_fourth_power"); failed += 1 }
    if test_parity_expr_154_diff_squares() != 42 { println("FAIL: test_parity_expr_154_diff_squares"); failed += 1 }
    if test_parity_expr_155_sum_squares_expr() != 42 { println("FAIL: test_parity_expr_155_sum_squares_expr"); failed += 1 }
    if test_parity_expr_156_product_expr() != 42 { println("FAIL: test_parity_expr_156_product_expr"); failed += 1 }
    if test_parity_expr_157_quotient_expr() != 42 { println("FAIL: test_parity_expr_157_quotient_expr"); failed += 1 }
    if test_parity_expr_158_remainder_expr() != 42 { println("FAIL: test_parity_expr_158_remainder_expr"); failed += 1 }
    if test_parity_expr_159_complex_arith() != 42 { println("FAIL: test_parity_expr_159_complex_arith"); failed += 1 }
    if test_parity_expr_160_paren_priority() != 42 { println("FAIL: test_parity_expr_160_paren_priority"); failed += 1 }
    if test_parity_fn_001_noargs() != 42 { println("FAIL: test_parity_fn_001_noargs"); failed += 1 }
    if test_parity_fn_002_manyargs() != 42 { println("FAIL: test_parity_fn_002_manyargs"); failed += 1 }
    if test_parity_fn_003_recursive() != 42 { println("FAIL: test_parity_fn_003_recursive"); failed += 1 }
    if test_parity_fn_004_mutual() != 42 { println("FAIL: test_parity_fn_004_mutual"); failed += 1 }
    if test_parity_fn_005_sixargs() != 42 { println("FAIL: test_parity_fn_005_sixargs"); failed += 1 }
    if test_parity_fn_006_sevenargs() != 42 { println("FAIL: test_parity_fn_006_sevenargs"); failed += 1 }
    if test_parity_fn_007_eightargs() != 42 { println("FAIL: test_parity_fn_007_eightargs"); failed += 1 }
    if test_parity_fn_008_nested_call() != 42 { println("FAIL: test_parity_fn_008_nested_call"); failed += 1 }
    if test_parity_fn_009_factorial() != 42 { println("FAIL: test_parity_fn_009_factorial"); failed += 1 }
    if test_parity_fn_010_call_in_expr() != 42 { println("FAIL: test_parity_fn_010_call_in_expr"); failed += 1 }
    if test_parity_fn_013_call_chain() != 42 { println("FAIL: test_parity_fn_013_call_chain"); failed += 1 }
    if test_parity_fn_014_result_in_cond() != 42 { println("FAIL: test_parity_fn_014_result_in_cond"); failed += 1 }
    if test_parity_fn_015_call_as_arg() != 42 { println("FAIL: test_parity_fn_015_call_as_arg"); failed += 1 }
    if test_parity_fn_016_many_calls() != 42 { println("FAIL: test_parity_fn_016_many_calls"); failed += 1 }
    if test_parity_fn_017_collatz() != 42 { println("FAIL: test_parity_fn_017_collatz"); failed += 1 }
    if test_parity_fn_018_is_prime() != 42 { println("FAIL: test_parity_fn_018_is_prime"); failed += 1 }
    if test_parity_fn_019_count_primes() != 42 { println("FAIL: test_parity_fn_019_count_primes"); failed += 1 }
    if test_parity_fn_020_nth_fib() != 42 { println("FAIL: test_parity_fn_020_nth_fib"); failed += 1 }
    if test_parity_fn_021_triangle() != 42 { println("FAIL: test_parity_fn_021_triangle"); failed += 1 }
    if test_parity_fn_022_apply_twice() != 42 { println("FAIL: test_parity_fn_022_apply_twice"); failed += 1 }
    if test_parity_fn_023_compose() != 42 { println("FAIL: test_parity_fn_023_compose"); failed += 1 }
    if test_parity_fn_024_ackermann() != 42 { println("FAIL: test_parity_fn_024_ackermann"); failed += 1 }
    if test_parity_fn_025_sum_range() != 42 { println("FAIL: test_parity_fn_025_sum_range"); failed += 1 }
    if test_parity_fn_026_identity() != 42 { println("FAIL: test_parity_fn_026_identity"); failed += 1 }
    if test_parity_fn_027_swap_args() != 42 { println("FAIL: test_parity_fn_027_swap_args"); failed += 1 }
    if test_parity_fn_028_ignore_arg() != 42 { println("FAIL: test_parity_fn_028_ignore_arg"); failed += 1 }
    if test_parity_fn_029_all_args() != 42 { println("FAIL: test_parity_fn_029_all_args"); failed += 1 }
    if test_parity_fn_030_chain_five() != 42 { println("FAIL: test_parity_fn_030_chain_five"); failed += 1 }
    if test_parity_fn_031_deep_call() != 42 { println("FAIL: test_parity_fn_031_deep_call"); failed += 1 }
    if test_parity_fn_032_many_params() != 42 { println("FAIL: test_parity_fn_032_many_params"); failed += 1 }
    if test_parity_fn_033_tail_call() != 42 { println("FAIL: test_parity_fn_033_tail_call"); failed += 1 }
    if test_parity_fn_034_sum_recursive() != 42 { println("FAIL: test_parity_fn_034_sum_recursive"); failed += 1 }
    if test_parity_fn_035_mult_recursive() != 42 { println("FAIL: test_parity_fn_035_mult_recursive"); failed += 1 }
    if test_parity_fn_036_div_rem() != 42 { println("FAIL: test_parity_fn_036_div_rem"); failed += 1 }
    if test_parity_fn_037_minmax() != 42 { println("FAIL: test_parity_fn_037_minmax"); failed += 1 }
    if test_parity_fn_038_nested_call_3() != 42 { println("FAIL: test_parity_fn_038_nested_call_3"); failed += 1 }
    if test_parity_fn_039_call_in_binop() != 42 { println("FAIL: test_parity_fn_039_call_in_binop"); failed += 1 }
    if test_parity_fn_040_call_in_call() != 42 { println("FAIL: test_parity_fn_040_call_in_call"); failed += 1 }
    if test_parity_fn_041_call_both_args() != 42 { println("FAIL: test_parity_fn_041_call_both_args"); failed += 1 }
    if test_parity_fn_042_recursive_sum() != 42 { println("FAIL: test_parity_fn_042_recursive_sum"); failed += 1 }
    if test_parity_fn_043_mutual_simple() != 42 { println("FAIL: test_parity_fn_043_mutual_simple"); failed += 1 }
    if test_parity_fn_044_many_params() != 42 { println("FAIL: test_parity_fn_044_many_params"); failed += 1 }
    if test_parity_fn_045_8_params() != 42 { println("FAIL: test_parity_fn_045_8_params"); failed += 1 }
    if test_parity_fn_046_call_chain() != 42 { println("FAIL: test_parity_fn_046_call_chain"); failed += 1 }
    if test_parity_fn_047_mixed_calls() != 42 { println("FAIL: test_parity_fn_047_mixed_calls"); failed += 1 }
    if test_parity_fn_048_call_in_cond() != 42 { println("FAIL: test_parity_fn_048_call_in_cond"); failed += 1 }
    if test_parity_fn_049_call_in_while() != 42 { println("FAIL: test_parity_fn_049_call_in_while"); failed += 1 }
    if test_parity_fn_050_void_fn() != 42 { println("FAIL: test_parity_fn_050_void_fn"); failed += 1 }
    if test_parity_fn_051_return_ptr() != 42 { println("FAIL: test_parity_fn_051_return_ptr"); failed += 1 }
    if test_parity_fn_052_ptr_param() != 42 { println("FAIL: test_parity_fn_052_ptr_param"); failed += 1 }
    if test_parity_fn_053_triple_call() != 42 { println("FAIL: test_parity_fn_053_triple_call"); failed += 1 }
    if test_parity_fn_054_closure_like() != 42 { println("FAIL: test_parity_fn_054_closure_like"); failed += 1 }
    if test_parity_fn_055_call_result_expr() != 42 { println("FAIL: test_parity_fn_055_call_result_expr"); failed += 1 }
    if test_parity_fn_056_call_result_cmp() != 42 { println("FAIL: test_parity_fn_056_call_result_cmp"); failed += 1 }
    if test_parity_fn_057_fibonacci_iter() != 42 { println("FAIL: test_parity_fn_057_fibonacci_iter"); failed += 1 }
    if test_parity_fn_058_factorial_iter() != 42 { println("FAIL: test_parity_fn_058_factorial_iter"); failed += 1 }
    if test_parity_fn_059_power() != 42 { println("FAIL: test_parity_fn_059_power"); failed += 1 }
    if test_parity_fn_060_is_prime() != 42 { println("FAIL: test_parity_fn_060_is_prime"); failed += 1 }
    if test_parity_fn_061_collatz() != 42 { println("FAIL: test_parity_fn_061_collatz"); failed += 1 }
    if test_parity_fn_062_digit_sum() != 42 { println("FAIL: test_parity_fn_062_digit_sum"); failed += 1 }
    if test_parity_fn_063_reverse_digits() != 42 { println("FAIL: test_parity_fn_063_reverse_digits"); failed += 1 }
    if test_parity_fn_064_count_digits() != 42 { println("FAIL: test_parity_fn_064_count_digits"); failed += 1 }
    if test_parity_fn_065_min_max() != 42 { println("FAIL: test_parity_fn_065_min_max"); failed += 1 }
    if test_parity_fn_066_clamp() != 42 { println("FAIL: test_parity_fn_066_clamp"); failed += 1 }
    if test_parity_fn_067_abs() != 42 { println("FAIL: test_parity_fn_067_abs"); failed += 1 }
    if test_parity_fn_068_sign() != 42 { println("FAIL: test_parity_fn_068_sign"); failed += 1 }
    if test_parity_fn_069_euclidean() != 42 { println("FAIL: test_parity_fn_069_euclidean"); failed += 1 }
    if test_parity_fn_070_lcm() != 42 { println("FAIL: test_parity_fn_070_lcm"); failed += 1 }
    if test_parity_fn_071_sum_sq() != 42 { println("FAIL: test_parity_fn_071_sum_sq"); failed += 1 }
    if test_parity_fn_072_sum_cubes() != 42 { println("FAIL: test_parity_fn_072_sum_cubes"); failed += 1 }
    if test_parity_fn_073_nth_prime() != 42 { println("FAIL: test_parity_fn_073_nth_prime"); failed += 1 }
    if test_parity_fn_074_triangular() != 42 { println("FAIL: test_parity_fn_074_triangular"); failed += 1 }
    if test_parity_fn_075_square_check() != 42 { println("FAIL: test_parity_fn_075_square_check"); failed += 1 }
    if test_parity_fn_076_integer_sqrt() != 42 { println("FAIL: test_parity_fn_076_integer_sqrt"); failed += 1 }
    if test_parity_fn_077_divisors_count() != 42 { println("FAIL: test_parity_fn_077_divisors_count"); failed += 1 }
    if test_parity_fn_078_divisors_sum() != 42 { println("FAIL: test_parity_fn_078_divisors_sum"); failed += 1 }
    if test_parity_fn_079_exp_by_squaring() != 42 { println("FAIL: test_parity_fn_079_exp_by_squaring"); failed += 1 }
    if test_parity_fn_080_modular_exp() != 42 { println("FAIL: test_parity_fn_080_modular_exp"); failed += 1 }
    if test_parity_fn_081_extended_gcd() != 42 { println("FAIL: test_parity_fn_081_extended_gcd"); failed += 1 }
    if test_parity_fn_082_call_side_effect() != 42 { println("FAIL: test_parity_fn_082_call_side_effect"); failed += 1 }
    if test_parity_fn_083_tail_like() != 42 { println("FAIL: test_parity_fn_083_tail_like"); failed += 1 }
    if test_parity_fn_084_sum_rec() != 42 { println("FAIL: test_parity_fn_084_sum_rec"); failed += 1 }
    if test_parity_fn_085_product_rec() != 42 { println("FAIL: test_parity_fn_085_product_rec"); failed += 1 }
    if test_parity_fn_086_mutual_even_odd() != 42 { println("FAIL: test_parity_fn_086_mutual_even_odd"); failed += 1 }
    if test_parity_fn_087_collatz_steps() != 42 { println("FAIL: test_parity_fn_087_collatz_steps"); failed += 1 }
    if test_parity_fn_090_reverse_digits() != 42 { println("FAIL: test_parity_fn_090_reverse_digits"); failed += 1 }
    if test_parity_fn_091_is_palindrome() != 42 { println("FAIL: test_parity_fn_091_is_palindrome"); failed += 1 }
    if test_parity_fn_092_is_power_of_two() != 42 { println("FAIL: test_parity_fn_092_is_power_of_two"); failed += 1 }
    if test_parity_fn_093_log2_floor() != 42 { println("FAIL: test_parity_fn_093_log2_floor"); failed += 1 }
    if test_parity_fn_094_sum_to_n() != 42 { println("FAIL: test_parity_fn_094_sum_to_n"); failed += 1 }
    if test_parity_fn_095_sum_squares() != 42 { println("FAIL: test_parity_fn_095_sum_squares"); failed += 1 }
    if test_parity_fn_096_power() != 42 { println("FAIL: test_parity_fn_096_power"); failed += 1 }
    if test_parity_fn_097_power_iter() != 42 { println("FAIL: test_parity_fn_097_power_iter"); failed += 1 }
    if test_parity_fn_098_factorial_iter() != 42 { println("FAIL: test_parity_fn_098_factorial_iter"); failed += 1 }
    if test_parity_fn_099_triangle() != 42 { println("FAIL: test_parity_fn_099_triangle"); failed += 1 }
    if test_parity_fn_100_square() != 42 { println("FAIL: test_parity_fn_100_square"); failed += 1 }
    if test_parity_fn_101_cube() != 42 { println("FAIL: test_parity_fn_101_cube"); failed += 1 }
    if test_parity_fn_102_sum_cubes() != 42 { println("FAIL: test_parity_fn_102_sum_cubes"); failed += 1 }
    if test_parity_fn_103_double() != 42 { println("FAIL: test_parity_fn_103_double"); failed += 1 }
    if test_parity_fn_104_half() != 42 { println("FAIL: test_parity_fn_104_half"); failed += 1 }
    if test_parity_fn_105_negate() != 42 { println("FAIL: test_parity_fn_105_negate"); failed += 1 }
    if test_parity_fn_106_inc() != 42 { println("FAIL: test_parity_fn_106_inc"); failed += 1 }
    if test_parity_fn_107_dec() != 42 { println("FAIL: test_parity_fn_107_dec"); failed += 1 }
    if test_parity_fn_108_is_zero() != 42 { println("FAIL: test_parity_fn_108_is_zero"); failed += 1 }
    if test_parity_fn_109_is_positive() != 42 { println("FAIL: test_parity_fn_109_is_positive"); failed += 1 }
    if test_parity_fn_110_is_negative() != 42 { println("FAIL: test_parity_fn_110_is_negative"); failed += 1 }
    if test_parity_fn_111_clamp_fn() != 42 { println("FAIL: test_parity_fn_111_clamp_fn"); failed += 1 }
    if test_parity_fn_112_lerp() != 42 { println("FAIL: test_parity_fn_112_lerp"); failed += 1 }
    if test_parity_fn_113_average() != 42 { println("FAIL: test_parity_fn_113_average"); failed += 1 }
    if test_parity_fn_114_distance() != 42 { println("FAIL: test_parity_fn_114_distance"); failed += 1 }
    if test_parity_fn_115_chain_call() != 42 { println("FAIL: test_parity_fn_115_chain_call"); failed += 1 }
    if test_parity_mem_001_stack_local() != 42 { println("FAIL: test_parity_mem_001_stack_local"); failed += 1 }
    if test_parity_mem_002_many_locals() != 42 { println("FAIL: test_parity_mem_002_many_locals"); failed += 1 }
    if test_parity_mem_003_malloc_i64() != 42 { println("FAIL: test_parity_mem_003_malloc_i64"); failed += 1 }
    if test_parity_mem_004_array_copy() != 42 { println("FAIL: test_parity_mem_004_array_copy"); failed += 1 }
    if test_parity_mem_007_array_sum() != 42 { println("FAIL: test_parity_mem_007_array_sum"); failed += 1 }
    if test_parity_mem_009_swap() != 42 { println("FAIL: test_parity_mem_009_swap"); failed += 1 }
    if test_parity_mem_010_indirect() != 42 { println("FAIL: test_parity_mem_010_indirect"); failed += 1 }
    if test_parity_mem_011_reverse() != 42 { println("FAIL: test_parity_mem_011_reverse"); failed += 1 }
    if test_parity_mem_012_fill() != 42 { println("FAIL: test_parity_mem_012_fill"); failed += 1 }
    if test_parity_mem_013_count_val() != 42 { println("FAIL: test_parity_mem_013_count_val"); failed += 1 }
    if test_parity_mem_014_ptr_param() != 42 { println("FAIL: test_parity_mem_014_ptr_param"); failed += 1 }
    if test_parity_mem_015_double_deref() != 42 { println("FAIL: test_parity_mem_015_double_deref"); failed += 1 }
    if test_parity_mem_016_addr_of_local() != 42 { println("FAIL: test_parity_mem_016_addr_of_local"); failed += 1 }
    if test_parity_mem_017_array_fill() != 42 { println("FAIL: test_parity_mem_017_array_fill"); failed += 1 }
    if test_parity_mem_018_array_contains() != 42 { println("FAIL: test_parity_mem_018_array_contains"); failed += 1 }
    if test_parity_mem_019_array_index() != 42 { println("FAIL: test_parity_mem_019_array_index"); failed += 1 }
    if test_parity_mem_021_ptr_chain() != 42 { println("FAIL: test_parity_mem_021_ptr_chain"); failed += 1 }
    if test_parity_mem_022_modify_via_ptr() != 42 { println("FAIL: test_parity_mem_022_modify_via_ptr"); failed += 1 }
    if test_parity_mem_023_multi_ptr_mod() != 42 { println("FAIL: test_parity_mem_023_multi_ptr_mod"); failed += 1 }
    if test_parity_mem_024_ptr_reassign() != 42 { println("FAIL: test_parity_mem_024_ptr_reassign"); failed += 1 }
    if test_parity_mem_025_ptr_offset_calc() != 42 { println("FAIL: test_parity_mem_025_ptr_offset_calc"); failed += 1 }
    if test_parity_mem_026_ptr_deref_in_expr() != 42 { println("FAIL: test_parity_mem_026_ptr_deref_in_expr"); failed += 1 }
    if test_parity_mem_028_nested_ptr_deref() != 42 { println("FAIL: test_parity_mem_028_nested_ptr_deref"); failed += 1 }
    if test_parity_mem_029_ptr_swap() != 42 { println("FAIL: test_parity_mem_029_ptr_swap"); failed += 1 }
    if test_parity_mem_030_ptr_arith_fn() != 42 { println("FAIL: test_parity_mem_030_ptr_arith_fn"); failed += 1 }
    if test_parity_mem_032_double_ptr() != 42 { println("FAIL: test_parity_mem_032_double_ptr"); failed += 1 }
    if test_parity_mem_033_ptr_advance() != 42 { println("FAIL: test_parity_mem_033_ptr_advance"); failed += 1 }
    if test_parity_mem_036_local_array() != 42 { println("FAIL: test_parity_mem_036_local_array"); failed += 1 }
    if test_parity_mem_037_nested_loop_ptr() != 42 { println("FAIL: test_parity_mem_037_nested_loop_ptr"); failed += 1 }
    if test_parity_mem_038_array_of_pointers() != 42 { println("FAIL: test_parity_mem_038_array_of_pointers"); failed += 1 }
    if test_parity_mem_039_indirect_store() != 42 { println("FAIL: test_parity_mem_039_indirect_store"); failed += 1 }
    if test_parity_mem_040_indirect_load() != 42 { println("FAIL: test_parity_mem_040_indirect_load"); failed += 1 }
    if test_parity_mem_041_swap_via_ptr() != 42 { println("FAIL: test_parity_mem_041_swap_via_ptr"); failed += 1 }
    if test_parity_mem_042_increment_via_ptr() != 42 { println("FAIL: test_parity_mem_042_increment_via_ptr"); failed += 1 }
    if test_parity_mem_043_double_ptr() != 42 { println("FAIL: test_parity_mem_043_double_ptr"); failed += 1 }
    if test_parity_mem_044_array_pass() != 42 { println("FAIL: test_parity_mem_044_array_pass"); failed += 1 }
    if test_parity_mem_045_nested_ptr() != 42 { println("FAIL: test_parity_mem_045_nested_ptr"); failed += 1 }
    if test_parity_mem_046_modify_via_ptr() != 42 { println("FAIL: test_parity_mem_046_modify_via_ptr"); failed += 1 }
    if test_parity_mem_047_zero_array() != 42 { println("FAIL: test_parity_mem_047_zero_array"); failed += 1 }
    if test_parity_mem_048_init_array() != 42 { println("FAIL: test_parity_mem_048_init_array"); failed += 1 }
    if test_parity_mem_049_powers_array() != 42 { println("FAIL: test_parity_mem_049_powers_array"); failed += 1 }
    if test_parity_mem_050_fibonacci_array() != 42 { println("FAIL: test_parity_mem_050_fibonacci_array"); failed += 1 }
    if test_parity_mem_051_stack_sim() != 42 { println("FAIL: test_parity_mem_051_stack_sim"); failed += 1 }
    if test_parity_mem_052_queue_sim() != 42 { println("FAIL: test_parity_mem_052_queue_sim"); failed += 1 }
    if test_parity_mem_053_ptr_param() != 42 { println("FAIL: test_parity_mem_053_ptr_param"); failed += 1 }
    if test_parity_var_001_simple() != 42 { println("FAIL: test_parity_var_001_simple"); failed += 1 }
    if test_parity_var_002_reassign() != 42 { println("FAIL: test_parity_var_002_reassign"); failed += 1 }
    if test_parity_var_003_many_vars() != 42 { println("FAIL: test_parity_var_003_many_vars"); failed += 1 }
    if test_parity_var_004_more_vars() != 42 { println("FAIL: test_parity_var_004_more_vars"); failed += 1 }
    if test_parity_var_005_16_vars() != 42 { println("FAIL: test_parity_var_005_16_vars"); failed += 1 }
    if test_parity_var_006_20_vars() != 42 { println("FAIL: test_parity_var_006_20_vars"); failed += 1 }
    if test_parity_var_007_nested_scope() != 42 { println("FAIL: test_parity_var_007_nested_scope"); failed += 1 }
    if test_parity_var_008_while_scope() != 42 { println("FAIL: test_parity_var_008_while_scope"); failed += 1 }
    if test_parity_var_009_deep_nesting() != 42 { println("FAIL: test_parity_var_009_deep_nesting"); failed += 1 }
    if test_parity_var_010_chain_assign() != 42 { println("FAIL: test_parity_var_010_chain_assign"); failed += 1 }
    if test_parity_var_011_swap_vars() != 42 { println("FAIL: test_parity_var_011_swap_vars"); failed += 1 }
    if test_parity_var_012_accumulate() != 42 { println("FAIL: test_parity_var_012_accumulate"); failed += 1 }
    if test_parity_var_013_product_acc() != 42 { println("FAIL: test_parity_var_013_product_acc"); failed += 1 }
    if test_parity_var_014_negative() != 42 { println("FAIL: test_parity_var_014_negative"); failed += 1 }
    if test_parity_var_015_compound() != 42 { println("FAIL: test_parity_var_015_compound"); failed += 1 }
    if test_parity_var_016_many_temps() != 42 { println("FAIL: test_parity_var_016_many_temps"); failed += 1 }
    if test_parity_var_017_long_chain() != 42 { println("FAIL: test_parity_var_017_long_chain"); failed += 1 }
    if test_parity_var_018_reassign_chain() != 42 { println("FAIL: test_parity_var_018_reassign_chain"); failed += 1 }
    if test_parity_var_020_mixed_ops() != 42 { println("FAIL: test_parity_var_020_mixed_ops"); failed += 1 }
    if test_parity_var_021_reuse_name() != 42 { println("FAIL: test_parity_var_021_reuse_name"); failed += 1 }
    if test_parity_var_022_temp_swap() != 42 { println("FAIL: test_parity_var_022_temp_swap"); failed += 1 }
    if test_parity_var_023_increment() != 42 { println("FAIL: test_parity_var_023_increment"); failed += 1 }
    if test_parity_var_024_decrement() != 42 { println("FAIL: test_parity_var_024_decrement"); failed += 1 }
    if test_parity_var_025_self_mult() != 42 { println("FAIL: test_parity_var_025_self_mult"); failed += 1 }
    if test_parity_var_026_parallel_assign() != 42 { println("FAIL: test_parity_var_026_parallel_assign"); failed += 1 }
    if test_parity_var_027_accumulator() != 42 { println("FAIL: test_parity_var_027_accumulator"); failed += 1 }
    if test_parity_var_028_running_max() != 42 { println("FAIL: test_parity_var_028_running_max"); failed += 1 }
    if test_parity_var_029_running_min() != 42 { println("FAIL: test_parity_var_029_running_min"); failed += 1 }
    if test_parity_var_030_both_minmax() != 42 { println("FAIL: test_parity_var_030_both_minmax"); failed += 1 }
    if test_parity_var_031_local_shadow() != 42 { println("FAIL: test_parity_var_031_local_shadow"); failed += 1 }
    if test_parity_var_033_loop_counter() != 42 { println("FAIL: test_parity_var_033_loop_counter"); failed += 1 }
    if test_parity_var_034_flag_toggle() != 42 { println("FAIL: test_parity_var_034_flag_toggle"); failed += 1 }
    if test_parity_var_035_temp_swap() != 42 { println("FAIL: test_parity_var_035_temp_swap"); failed += 1 }
    if test_parity_var_036_fibonacci_vars() != 42 { println("FAIL: test_parity_var_036_fibonacci_vars"); failed += 1 }
    if test_parity_var_037_running_product() != 42 { println("FAIL: test_parity_var_037_running_product"); failed += 1 }
    if test_parity_var_038_gcd_vars() != 42 { println("FAIL: test_parity_var_038_gcd_vars"); failed += 1 }
    if test_parity_var_039_binary_search_vars() != 42 { println("FAIL: test_parity_var_039_binary_search_vars"); failed += 1 }
    if test_parity_var_040_collatz_vars() != 42 { println("FAIL: test_parity_var_040_collatz_vars"); failed += 1 }
    if test_parity_var_041_count_bits() != 42 { println("FAIL: test_parity_var_041_count_bits"); failed += 1 }
    if test_parity_var_042_reverse_bits() != 42 { println("FAIL: test_parity_var_042_reverse_bits"); failed += 1 }
    if test_parity_var_043_prime_check() != 42 { println("FAIL: test_parity_var_043_prime_check"); failed += 1 }
    if test_parity_var_044_perfect_check() != 42 { println("FAIL: test_parity_var_044_perfect_check"); failed += 1 }
    if test_parity_var_045_digit_reverse() != 42 { println("FAIL: test_parity_var_045_digit_reverse"); failed += 1 }
    if test_parity_var_046_accumulator() != 42 { println("FAIL: test_parity_var_046_accumulator"); failed += 1 }
    if test_parity_var_047_multiplier() != 42 { println("FAIL: test_parity_var_047_multiplier"); failed += 1 }
    if test_parity_cf_050_while_break_simple() != 21 { println("FAIL: test_parity_cf_050_while_break_simple"); failed += 1 }
    if test_parity_expr_145_arithmetic_mix() != 42 { println("FAIL: test_parity_expr_145_arithmetic_mix"); failed += 1 }

    // Summary
    if failed == 0 {
        println("All 715 tests passed!")
    }

    return failed
}

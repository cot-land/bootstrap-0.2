// Cot0 Self-Hosting Compiler
// Full pipeline: Source → Scanner → Parser → Lowerer → SSA → genssa → Mach-O
//
// Usage: cot0 <source.cot> -o <output>

// ============================================================================
// Module Imports
// ============================================================================

// Frontend modules - import in specific order (required for compatibility)
import "frontend/token.cot"
import "frontend/scanner.cot"
import "frontend/types.cot"
import "frontend/ast.cot"
import "frontend/parser.cot"
import "frontend/lower.cot"

// Codegen - genssa.cot imports ../ssa/func.cot transitively
import "codegen/genssa.cot"

// Object file writer
import "obj/macho.cot"

// ============================================================================
// Syscall Wrappers (libc)
// ============================================================================

extern fn open(path: *u8, flags: i32, mode: i32) i32;
extern fn read(fd: i32, buf: *u8, count: i64) i64;
extern fn write(fd: i32, buf: *u8, count: i64) i64;
extern fn close(fd: i32) i32;

// File flags (macOS)
const O_RDONLY: i32 = 0;
const O_WRONLY: i32 = 1;
const O_CREAT: i32 = 512;
const O_TRUNC: i32 = 1024;
const FILE_MODE: i32 = 420;  // 0o644

// ============================================================================
// Global Buffers - Use MAIN_ prefix to avoid conflicts with imported modules
// Note: MAX_NODES and MAX_CHILDREN are defined in ast.cot
// ============================================================================

const MAIN_MAX_SOURCE: i64 = 1048576;    // 1 MB source file
var g_source: [1048576]u8;
var g_source_len: i64 = 0;

const MAIN_MAX_OUTPUT_PATH: i64 = 256;
var g_output_path: [256]u8;
var g_output_path_len: i64 = 0;

// AST storage - uses MAX_NODES/MAX_CHILDREN from ast.cot
var g_nodes: [10000]Node;
var g_children: [50000]i64;
var g_pool: NodePool;

// IR storage
const MAIN_MAX_IR_NODES: i64 = 10000;
const MAIN_MAX_IR_LOCALS: i64 = 1000;
var g_ir_nodes: [10000]IRNode;
var g_ir_locals: [1000]IRLocal;

// SSA storage
const MAIN_MAX_SSA_BLOCKS: i64 = 1000;
const MAIN_MAX_SSA_VALUES: i64 = 10000;
const MAIN_MAX_SSA_LOCALS: i64 = 500;
var g_ssa_blocks: [1000]Block;
var g_ssa_values: [10000]Value;
var g_ssa_locals: [500]Local;

// Codegen storage
const MAIN_MAX_CODE: i64 = 65536;
var g_code: [65536]u8;
var g_bstart: [1000]i64;
var g_branches: [1000]Branch;

// Mach-O storage
const MAIN_MAX_DATA: i64 = 65536;
const MAIN_MAX_SYMBOLS: i64 = 1000;
const MAIN_MAX_STRINGS: i64 = 32768;
const MAIN_MAX_RELOCS: i64 = 10000;
const MAIN_MAX_OUTPUT: i64 = 1048576;
var g_data: [65536]u8;
var g_symbols: [1000]Symbol;
var g_strings: [32768]u8;
var g_relocs: [10000]Reloc;
var g_output: [1048576]u8;

// IR to SSA mapping (IR node index -> SSA value ID)
var g_ir_to_ssa_id: [10000]i64;

// Local variable to SSA value mapping (local index -> SSA value ID)
var g_local_to_ssa_id: [1000]i64;

// ============================================================================
// Helper Functions
// ============================================================================

// Map IR binary operation to SSA Op
fn ir_op_to_ssa_op(ir_op: i64) Op {
    // Cast to IRBinaryOp conceptually - compare as i64
    if ir_op == 0 { return Op.Add64; }     // IRBinaryOp.Add
    if ir_op == 1 { return Op.Sub64; }     // IRBinaryOp.Sub
    if ir_op == 2 { return Op.Mul64; }     // IRBinaryOp.Mul
    if ir_op == 3 { return Op.Div64; }     // IRBinaryOp.Div
    if ir_op == 4 { return Op.Mod64; }     // IRBinaryOp.Mod
    if ir_op == 5 { return Op.Eq64; }      // IRBinaryOp.Eq
    if ir_op == 6 { return Op.Ne64; }      // IRBinaryOp.Ne
    if ir_op == 7 { return Op.Lt64; }      // IRBinaryOp.Lt
    if ir_op == 8 { return Op.Le64; }      // IRBinaryOp.Le
    if ir_op == 9 { return Op.Gt64; }      // IRBinaryOp.Gt
    if ir_op == 10 { return Op.Ge64; }     // IRBinaryOp.Ge
    if ir_op == 11 { return Op.And64; }    // IRBinaryOp.And (logical - use bitwise)
    if ir_op == 12 { return Op.Or64; }     // IRBinaryOp.Or (logical - use bitwise)
    if ir_op == 13 { return Op.And64; }    // IRBinaryOp.BitAnd
    if ir_op == 14 { return Op.Or64; }     // IRBinaryOp.BitOr
    if ir_op == 15 { return Op.Xor64; }    // IRBinaryOp.BitXor
    if ir_op == 16 { return Op.Shl64; }    // IRBinaryOp.Shl
    if ir_op == 17 { return Op.Shr64; }    // IRBinaryOp.Shr
    return Op.Add64;  // Default fallback
}

fn print_str(s: string) {
    write(1, s.ptr, len(s));
}

fn print_num(n: i64) {
    var buf: [20]u8;
    var i: i64 = 19;
    var val: i64 = n;

    if val == 0 {
        buf[i] = @intCast(u8, 48);
        write(1, &buf[i], 1);
        return;
    }

    if val < 0 {
        print_str("-");
        val = 0 - val;
    }

    while val > 0 {
        let digit: i64 = val - (val / 10) * 10;
        buf[i] = @intCast(u8, 48 + digit);
        val = val / 10;
        i = i - 1;
    }

    write(1, &buf[i + 1], 19 - i);
}

fn print_newline() {
    print_str("\n");
}

// ============================================================================
// File I/O
// ============================================================================

fn read_file(path: *u8) i64 {
    let fd: i32 = open(path, O_RDONLY, 0);
    if fd < 0 {
        print_str("Error: Cannot open file\n");
        return -1;
    }

    g_source_len = read(fd, &g_source[0], MAIN_MAX_SOURCE - 1);
    close(fd);

    if g_source_len < 0 {
        print_str("Error: Cannot read file\n");
        return -1;
    }

    g_source[g_source_len] = 0;
    return g_source_len;
}

fn write_file(path: *u8, data: *u8, data_len: i64) i64 {
    let fd: i32 = open(path, O_WRONLY | O_CREAT | O_TRUNC, FILE_MODE);
    if fd < 0 {
        print_str("Error: Cannot open output file\n");
        return -1;
    }

    let written: i64 = write(fd, data, data_len);
    close(fd);

    if written != data_len {
        print_str("Error: Failed to write output\n");
        return -1;
    }

    return written;
}

// ============================================================================
// Pool Initialization
// ============================================================================

fn init_node_pool() *NodePool {
    g_pool.nodes = &g_nodes[0];
    g_pool.count = 0;
    g_pool.children = &g_children[0];
    g_pool.children_count = 0;
    return &g_pool;
}

// ============================================================================
// Compilation Pipeline
// ============================================================================

fn compile(source: string, out_path: *u8, out_path_len: i64) i64 {
    print_str("Phase 1: Scanning...\n");

    // Phase 1: Scan and count tokens
    var scanner: Scanner = scanner_new(source);
    var tok_count: i64 = 0;
    var tok: Token = scanner_next(&scanner);
    while tok.kind != TokenType.Eof {
        tok_count = tok_count + 1;
        tok = scanner_next(&scanner);
    }
    print_str("  Tokens: ");
    print_num(tok_count);
    print_newline();

    // Phase 2: Parse
    print_str("Phase 2: Parsing...\n");
    let pool: *NodePool = init_node_pool();
    var parser: Parser = parser_new(source, pool);
    let file_node: i64 = parse_file(&parser);

    if parser_had_error(&parser) {
        print_str("  FAIL: Parser error\n");
        return 1;
    }

    print_str("  Nodes: ");
    print_num(pool.count);
    print_newline();

    // Phase 3: Lower to IR
    print_str("Phase 3: Lowering to IR...\n");
    var lowerer: Lowerer = undefined;
    lowerer_init(&lowerer,
                 &g_nodes[0], pool.count,
                 &g_children[0], pool.children_count,
                 source.ptr, len(source),
                 &g_ir_nodes[0], MAIN_MAX_IR_NODES,
                 &g_ir_locals[0], MAIN_MAX_IR_LOCALS);

    let ir_count: i64 = lowerer_lower_all(&lowerer);
    print_str("  IR nodes: ");
    print_num(ir_count);
    print_newline();

    // Debug: dump IR node block_ids
    print_str("  IR block_ids: ");
    var debug_idx: i64 = 0;
    while debug_idx < ir_count {
        let debug_node: *IRNode = &g_ir_nodes[debug_idx];
        print_num(debug_node.block_id);
        print_str(" ");
        debug_idx = debug_idx + 1;
    }
    print_newline();

    // Phase 4: Build SSA from IR nodes
    print_str("Phase 4: Building SSA...\n");

    var ssa_func: Func = undefined;
    func_init(&ssa_func, 0, 0, TYPE_I64,
              &g_ssa_blocks[0], MAIN_MAX_SSA_BLOCKS,
              &g_ssa_values[0], MAIN_MAX_SSA_VALUES,
              &g_ssa_locals[0], MAIN_MAX_SSA_LOCALS);

    // First pass: find max block_id to know how many blocks we need
    var max_block_id: i64 = 0;
    var ir_idx: i64 = 0;
    while ir_idx < ir_count {
        let ir_node: *IRNode = &g_ir_nodes[ir_idx];
        if ir_node.block_id > max_block_id {
            max_block_id = ir_node.block_id;
        }
        ir_idx = ir_idx + 1;
    }

    // Create all SSA blocks (entry block is 0)
    let entry: i64 = func_new_entry_block(&ssa_func);
    var block_idx: i64 = 1;
    while block_idx <= max_block_id {
        func_new_block(&ssa_func, BlockKind.Plain);
        block_idx = block_idx + 1;
    }

    // Register IR locals with SSA function (for memory-based Load/Store)
    var local_idx: i64 = 0;
    while local_idx < lowerer.ir_locals_count {
        let ir_local: *IRLocal = &g_ir_locals[local_idx];
        func_add_local(&ssa_func, ir_local.name_start, ir_local.name_len,
                       ir_local.type_idx, ir_local.is_mutable);
        local_idx = local_idx + 1;
    }

    // Compute stack layout: set local offsets and frame size
    local_idx = 0;
    while local_idx < ssa_func.locals_count {
        let ssa_local: *Local = func_get_local(&ssa_func, local_idx);
        ssa_local.offset = local_idx * 8;  // Each local is 8 bytes
        local_idx = local_idx + 1;
    }
    // Frame size = locals * 8, aligned to 16
    ssa_func.frame_size = ssa_func.locals_count * 8;
    if ssa_func.frame_size % 16 != 0 {
        ssa_func.frame_size = ssa_func.frame_size + (16 - (ssa_func.frame_size % 16));
    }

    // Second pass: convert IR nodes to SSA values
    // Track current block and switch when block_id changes
    var current_ir_block: i64 = 0;
    var next_reg: i64 = X1;  // Start from X1, reserve X0 for return/compare
    ir_idx = 0;
    while ir_idx < ir_count {
        let ir_node: *IRNode = &g_ir_nodes[ir_idx];

        // Switch SSA block if IR block changed
        if ir_node.block_id != current_ir_block {
            current_ir_block = ir_node.block_id;
            func_set_block(&ssa_func, current_ir_block);
        }

        if ir_node.kind == IRNodeKind.ConstInt {
            let val: *Value = func_emit_const_int(&ssa_func, ir_node.value, TYPE_I64);
            val.reg = next_reg;
            next_reg = next_reg + 1;
            g_ir_to_ssa_id[ir_idx] = val.id;
        } else if ir_node.kind == IRNodeKind.Binary {
            let left_id: i64 = g_ir_to_ssa_id[ir_node.left];
            let right_id: i64 = g_ir_to_ssa_id[ir_node.right];
            let left_val: *Value = func_get_value(&ssa_func, left_id);
            let right_val: *Value = func_get_value(&ssa_func, right_id);
            let ssa_op: Op = ir_op_to_ssa_op(ir_node.op);
            let val: *Value = func_emit_binary(&ssa_func, ssa_op, left_val, right_val, TYPE_I64);
            // All results to X0 for simplicity
            val.reg = X0;
            g_ir_to_ssa_id[ir_idx] = val.id;
        } else if ir_node.kind == IRNodeKind.StoreLocal {
            // Use memory-based store (LocalAddr + Store) for proper loop handling
            let local_idx: i64 = ir_node.left;
            let value_idx: i64 = ir_node.right;
            let value_ssa_id: i64 = g_ir_to_ssa_id[value_idx];
            let value_val: *Value = func_get_value(&ssa_func, value_ssa_id);
            let store_val: *Value = func_emit_store_local(&ssa_func, local_idx, value_val);
            g_ir_to_ssa_id[ir_idx] = store_val.id;
        } else if ir_node.kind == IRNodeKind.LoadLocal {
            // Use memory-based load (LocalAddr + Load) for proper loop handling
            let local_idx: i64 = ir_node.left;
            let load_val: *Value = func_emit_load_local(&ssa_func, local_idx);
            load_val.reg = next_reg;
            next_reg = next_reg + 1;
            g_ir_to_ssa_id[ir_idx] = load_val.id;
        } else if ir_node.kind == IRNodeKind.Call {
            let val: *Value = func_emit_call(&ssa_func,
                                             ir_node.func_name_start,
                                             ir_node.func_name_len,
                                             TYPE_I64);
            var arg_idx: i64 = 0;
            while arg_idx < ir_node.args_count {
                let arg_ir_idx: i64 = ir_node.args_start + arg_idx;
                let arg_ssa_id: i64 = g_ir_to_ssa_id[arg_ir_idx];
                let arg_val: *Value = func_get_value(&ssa_func, arg_ssa_id);
                value_add_arg(val, arg_val);
                arg_idx = arg_idx + 1;
            }
            val.reg = X0;
            g_ir_to_ssa_id[ir_idx] = val.id;
        } else if ir_node.kind == IRNodeKind.Branch {
            // Conditional branch: set up block successors
            let cond_id: i64 = g_ir_to_ssa_id[ir_node.left];
            let then_block: i64 = ir_node.right;
            let else_block: i64 = ir_node.value;
            let cond_val: *Value = func_get_value(&ssa_func, cond_id);
            func_emit_if(&ssa_func, cond_val, then_block, else_block);
            g_ir_to_ssa_id[ir_idx] = -1;
        } else if ir_node.kind == IRNodeKind.Jump {
            // Unconditional jump
            let target_block: i64 = ir_node.left;
            func_emit_jump(&ssa_func, target_block);
            g_ir_to_ssa_id[ir_idx] = -1;
        } else if ir_node.kind == IRNodeKind.Return {
            if ir_node.left >= 0 {
                let val_id: i64 = g_ir_to_ssa_id[ir_node.left];
                let ret_val: *Value = func_get_value(&ssa_func, val_id);
                func_emit_return(&ssa_func, ret_val);
            }
        }

        ir_idx = ir_idx + 1;
    }

    // Finish the function
    func_emit_return_block(&ssa_func);

    print_str("  Blocks: ");
    print_num(ssa_func.blocks_count);
    print_str(", Values: ");
    print_num(ssa_func.values_count);
    print_newline();

    // Phase 5: Generate machine code
    print_str("Phase 5: Generating machine code...\n");

    var gs: GenState = undefined;
    genstate_init(&gs, &ssa_func,
                  &g_code[0], MAIN_MAX_CODE,
                  &g_bstart[0], MAIN_MAX_SSA_BLOCKS,
                  &g_branches[0], 1000);

    let genssa_result: i64 = genssa(&gs);
    if genssa_result != 0 {
        print_str("  FAIL: genssa error\n");
        return 2;
    }

    print_str("  Code bytes: ");
    print_num(gs.code_count);
    print_newline();

    // Phase 6: Create Mach-O object
    print_str("Phase 6: Creating Mach-O object...\n");

    var writer: MachOWriter = undefined;
    macho_writer_init(&writer,
                      &g_code[0], gs.code_count,
                      &g_data[0], MAIN_MAX_DATA,
                      &g_symbols[0], MAIN_MAX_SYMBOLS,
                      &g_strings[0], MAIN_MAX_STRINGS,
                      &g_relocs[0], MAIN_MAX_RELOCS,
                      &g_output[0], MAIN_MAX_OUTPUT);

    // Copy code from genssa output
    writer.code_count = gs.code_count;

    // Add _main symbol
    var main_name: [5]u8;
    main_name[0] = 95;   // '_'
    main_name[1] = 109;  // 'm'
    main_name[2] = 97;   // 'a'
    main_name[3] = 105;  // 'i'
    main_name[4] = 110;  // 'n'
    macho_add_symbol(&writer, &main_name[0], 5, 0, SECT_TEXT, true);

    let macho_bytes: i64 = write_macho(&writer);
    print_str("  Mach-O bytes: ");
    print_num(macho_bytes);
    print_newline();

    // Phase 7: Write to output file
    print_str("Phase 7: Writing output...\n");

    if out_path_len > 0 {
        let written: i64 = write_file(out_path, &g_output[0], macho_bytes);
        if written < 0 {
            return 3;
        }
        print_str("  Wrote ");
        print_num(written);
        print_str(" bytes\n");
    } else {
        print_str("  (No output path specified, skipping write)\n");
    }

    return 0;
}

// ============================================================================
// Main Entry Point
// ============================================================================

fn main() i64 {
    print_str("Cot0 Self-Hosting Compiler v0.2\n");
    print_str("================================\n\n");

    // For now, compile a simple test string
    // TODO: Parse command line arguments (argc, argv)

    let test_source: string = "fn main() i64 { var x: i64 = 0; while x < 5 { x = x + 1; } return x; }";

    // Set output path for testing using local array
    var out_path: [16]u8;
    out_path[0] = @intCast(u8, 47);   // '/'
    out_path[1] = @intCast(u8, 116);  // 't'
    out_path[2] = @intCast(u8, 109);  // 'm'
    out_path[3] = @intCast(u8, 112);  // 'p'
    out_path[4] = @intCast(u8, 47);   // '/'
    out_path[5] = @intCast(u8, 99);   // 'c'
    out_path[6] = @intCast(u8, 111);  // 'o'
    out_path[7] = @intCast(u8, 116);  // 't'
    out_path[8] = @intCast(u8, 48);   // '0'
    out_path[9] = @intCast(u8, 46);   // '.'
    out_path[10] = @intCast(u8, 111); // 'o'
    out_path[11] = @intCast(u8, 0);
    let out_path_len: i64 = 11;  // /tmp/cot0.o

    print_str("Compiling: ");
    print_str(test_source);
    print_str("\n\n");

    let result: i64 = compile(test_source, &out_path[0], out_path_len);

    if result == 0 {
        print_str("\nCompilation successful!\n");
    } else {
        print_str("\nCompilation failed with code ");
        print_num(result);
        print_newline();
    }

    return result;
}

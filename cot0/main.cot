// Cot0 Self-Hosting Compiler
// Full pipeline: Source → Scanner → Parser → Lowerer → SSA → genssa → Mach-O
//
// Usage: cot0 <source.cot> -o <output>

// ============================================================================
// Module Imports
// ============================================================================

// Frontend modules - import in specific order (required for compatibility)
import "frontend/token.cot"
import "frontend/scanner.cot"
import "frontend/types.cot"
import "frontend/ast.cot"
import "frontend/parser.cot"
import "frontend/lower.cot"

// Codegen - genssa.cot imports ../ssa/func.cot transitively
import "codegen/genssa.cot"

// Object file writer
import "obj/macho.cot"

// ============================================================================
// Syscall Wrappers (libc)
// ============================================================================

extern fn open(path: *u8, flags: i32, mode: i32) i32;
extern fn read(fd: i32, buf: *u8, count: i64) i64;
extern fn write(fd: i32, buf: *u8, count: i64) i64;
extern fn close(fd: i32) i32;

// File flags (macOS)
const O_RDONLY: i32 = 0;
const O_WRONLY: i32 = 1;
const O_CREAT: i32 = 512;
const O_TRUNC: i32 = 1024;
const FILE_MODE: i32 = 420;  // 0o644

// ============================================================================
// Global Buffers - Use MAIN_ prefix to avoid conflicts with imported modules
// Note: MAX_NODES and MAX_CHILDREN are defined in ast.cot
// ============================================================================

const MAIN_MAX_SOURCE: i64 = 1048576;    // 1 MB source file
var g_source: [1048576]u8;
var g_source_len: i64 = 0;

const MAIN_MAX_OUTPUT_PATH: i64 = 256;
var g_output_path: [256]u8;
var g_output_path_len: i64 = 0;

// AST storage - uses MAX_NODES/MAX_CHILDREN from ast.cot
var g_nodes: [10000]Node;
var g_children: [50000]i64;
var g_pool: NodePool;

// Type pool storage
const MAIN_MAX_TYPES: i64 = 1000;
const MAIN_MAX_PARAMS: i64 = 5000;
const MAIN_MAX_FIELDS: i64 = 5000;
var g_types: [1000]Type;
var g_type_params: [5000]i64;
var g_type_fields: [5000]FieldInfo;
var g_type_pool: TypePool;

// IR storage
const MAIN_MAX_IR_NODES: i64 = 10000;
const MAIN_MAX_IR_LOCALS: i64 = 1000;
const MAIN_MAX_IR_FUNCS: i64 = 100;
const MAIN_MAX_CONSTANTS: i64 = 500;
var g_ir_nodes: [10000]IRNode;
var g_ir_locals: [1000]IRLocal;
var g_ir_funcs: [100]IRFunc;
var g_constants: [500]ConstEntry;

// SSA storage
const MAIN_MAX_SSA_BLOCKS: i64 = 1000;
const MAIN_MAX_SSA_VALUES: i64 = 10000;
const MAIN_MAX_SSA_LOCALS: i64 = 500;
var g_ssa_blocks: [1000]Block;
var g_ssa_values: [10000]Value;
var g_ssa_locals: [500]Local;

// Codegen storage
const MAIN_MAX_CODE: i64 = 65536;
const MAIN_MAX_CALL_SITES: i64 = 1000;
var g_code: [65536]u8;
var g_bstart: [1000]i64;
var g_branches: [1000]Branch;
var g_call_sites: [1000]CallSite;

// Mach-O storage
const MAIN_MAX_DATA: i64 = 65536;
const MAIN_MAX_SYMBOLS: i64 = 1000;
const MAIN_MAX_STRINGS: i64 = 32768;
const MAIN_MAX_RELOCS: i64 = 10000;
const MAIN_MAX_OUTPUT: i64 = 1048576;
var g_data: [65536]u8;
var g_symbols: [1000]Symbol;
var g_strings: [32768]u8;
var g_relocs: [10000]Reloc;
var g_output: [1048576]u8;

// IR to SSA mapping (IR node index -> SSA value ID)
var g_ir_to_ssa_id: [10000]i64;

// Local variable to SSA value mapping (local index -> SSA value ID)
var g_local_to_ssa_id: [1000]i64;

// ============================================================================
// Helper Functions
// ============================================================================

// Map IR binary operation to SSA Op
fn ir_op_to_ssa_op(ir_op: i64) Op {
    // Cast to IRBinaryOp conceptually - compare as i64
    if ir_op == 0 { return Op.Add64; }     // IRBinaryOp.Add
    if ir_op == 1 { return Op.Sub64; }     // IRBinaryOp.Sub
    if ir_op == 2 { return Op.Mul64; }     // IRBinaryOp.Mul
    if ir_op == 3 { return Op.Div64; }     // IRBinaryOp.Div
    if ir_op == 4 { return Op.Mod64; }     // IRBinaryOp.Mod
    if ir_op == 5 { return Op.Eq64; }      // IRBinaryOp.Eq
    if ir_op == 6 { return Op.Ne64; }      // IRBinaryOp.Ne
    if ir_op == 7 { return Op.Lt64; }      // IRBinaryOp.Lt
    if ir_op == 8 { return Op.Le64; }      // IRBinaryOp.Le
    if ir_op == 9 { return Op.Gt64; }      // IRBinaryOp.Gt
    if ir_op == 10 { return Op.Ge64; }     // IRBinaryOp.Ge
    if ir_op == 11 { return Op.And64; }    // IRBinaryOp.And (logical - use bitwise)
    if ir_op == 12 { return Op.Or64; }     // IRBinaryOp.Or (logical - use bitwise)
    if ir_op == 13 { return Op.And64; }    // IRBinaryOp.BitAnd
    if ir_op == 14 { return Op.Or64; }     // IRBinaryOp.BitOr
    if ir_op == 15 { return Op.Xor64; }    // IRBinaryOp.BitXor
    if ir_op == 16 { return Op.Shl64; }    // IRBinaryOp.Shl
    if ir_op == 17 { return Op.Shr64; }    // IRBinaryOp.Shr
    return Op.Add64;  // Default fallback
}

fn print_str(s: string) {
    write(1, s.ptr, len(s));
}

fn print_num(n: i64) {
    var buf: [20]u8;
    var i: i64 = 19;
    var val: i64 = n;

    if val == 0 {
        buf[i] = @intCast(u8, 48);
        write(1, &buf[i], 1);
        return;
    }

    if val < 0 {
        print_str("-");
        val = 0 - val;
    }

    while val > 0 {
        let digit: i64 = val - (val / 10) * 10;
        buf[i] = @intCast(u8, 48 + digit);
        val = val / 10;
        i = i - 1;
    }

    write(1, &buf[i + 1], 19 - i);
}

fn print_newline() {
    print_str("\n");
}

// ============================================================================
// File I/O
// ============================================================================

fn read_file(path: *u8) i64 {
    let fd: i32 = open(path, O_RDONLY, 0);
    if fd < 0 {
        print_str("Error: Cannot open file\n");
        return -1;
    }

    g_source_len = read(fd, &g_source[0], MAIN_MAX_SOURCE - 1);
    close(fd);

    if g_source_len < 0 {
        print_str("Error: Cannot read file\n");
        return -1;
    }

    g_source[g_source_len] = 0;
    return g_source_len;
}

fn write_file(path: *u8, data: *u8, data_len: i64) i64 {
    let fd: i32 = open(path, O_WRONLY | O_CREAT | O_TRUNC, FILE_MODE);
    if fd < 0 {
        print_str("Error: Cannot open output file\n");
        return -1;
    }

    let written: i64 = write(fd, data, data_len);
    close(fd);

    if written != data_len {
        print_str("Error: Failed to write output\n");
        return -1;
    }

    return written;
}

// ============================================================================
// Pool Initialization
// ============================================================================

fn init_node_pool() *NodePool {
    g_pool.nodes = &g_nodes[0];
    g_pool.count = 0;
    g_pool.children = &g_children[0];
    g_pool.children_count = 0;
    return &g_pool;
}

// ============================================================================
// Compilation Pipeline
// ============================================================================

fn compile(source: string, out_path: *u8, out_path_len: i64) i64 {
    print_str("Phase 1: Scanning...\n");

    // Phase 1: Scan and count tokens
    var scanner: Scanner = scanner_new(source);
    var tok_count: i64 = 0;
    var tok: Token = scanner_next(&scanner);
    while tok.kind != TokenType.Eof {
        tok_count = tok_count + 1;
        tok = scanner_next(&scanner);
    }
    print_str("  Tokens: ");
    print_num(tok_count);
    print_newline();

    // Phase 2: Parse
    print_str("Phase 2: Parsing...\n");
    let pool: *NodePool = init_node_pool();
    var parser: Parser = parser_new(source, pool);
    let file_node: i64 = parse_file(&parser);

    if parser_had_error(&parser) {
        print_str("  FAIL: Parser error\n");
        return 1;
    }

    print_str("  Nodes: ");
    print_num(pool.count);
    print_newline();

    // Phase 3: Lower to IR
    print_str("Phase 3: Lowering to IR...\n");

    // Initialize type pool for field access
    g_type_pool.types = &g_types[0];
    g_type_pool.params = &g_type_params[0];
    g_type_pool.fields = &g_type_fields[0];
    pool_init(&g_type_pool);
    pool_set_source(&g_type_pool, source.ptr, len(source));

    var lowerer: Lowerer = undefined;
    lowerer_init(&lowerer,
                 &g_nodes[0], pool.count,
                 &g_children[0], pool.children_count,
                 source.ptr, len(source),
                 &g_type_pool,
                 &g_ir_nodes[0], MAIN_MAX_IR_NODES,
                 &g_ir_locals[0], MAIN_MAX_IR_LOCALS,
                 &g_ir_funcs[0], MAIN_MAX_IR_FUNCS,
                 &g_constants[0], MAIN_MAX_CONSTANTS);

    let ir_count: i64 = lowerer_lower_all(&lowerer);
    print_str("  IR nodes: ");
    print_num(ir_count);
    print_str(", Functions: ");
    print_num(lowerer.ir_funcs_count);
    print_newline();

    // Phase 4 & 5: Build SSA and generate code for each function
    print_str("Phase 4/5: Building SSA and generating code...\n");

    // Initialize code generator state (shared across functions)
    var gs: GenState = undefined;
    genstate_init(&gs, null,  // Will set func for each function
                  &g_code[0], MAIN_MAX_CODE,
                  &g_bstart[0], MAIN_MAX_SSA_BLOCKS,
                  &g_branches[0], 1000,
                  &g_call_sites[0], MAIN_MAX_CALL_SITES);

    var total_blocks: i64 = 0;
    var total_values: i64 = 0;

    // Process each function
    var func_idx: i64 = 0;
    while func_idx < lowerer.ir_funcs_count {
        let ir_func: *IRFunc = &g_ir_funcs[func_idx];

        // Record code offset for this function
        ir_func.code_offset = gs.code_count;

        // Initialize SSA function (reuse global arrays, they'll be overwritten)
        var ssa_func: Func = undefined;
        func_init(&ssa_func, ir_func.name_start, ir_func.name_len, TYPE_I64,
                  &g_ssa_blocks[0], MAIN_MAX_SSA_BLOCKS,
                  &g_ssa_values[0], MAIN_MAX_SSA_VALUES,
                  &g_ssa_locals[0], MAIN_MAX_SSA_LOCALS);

        // Find max block_id for this function's IR nodes
        var max_block_id: i64 = 0;
        var ir_idx: i64 = ir_func.nodes_start;
        let ir_end: i64 = ir_func.nodes_start + ir_func.nodes_count;
        while ir_idx < ir_end {
            let ir_node: *IRNode = &g_ir_nodes[ir_idx];
            if ir_node.block_id > max_block_id {
                max_block_id = ir_node.block_id;
            }
            ir_idx = ir_idx + 1;
        }

        // Create SSA blocks
        let entry: i64 = func_new_entry_block(&ssa_func);
        var block_idx: i64 = 1;
        while block_idx <= max_block_id {
            func_new_block(&ssa_func, BlockKind.Plain);
            block_idx = block_idx + 1;
        }

        // Register this function's locals (params first, then regular locals)
        var local_idx: i64 = ir_func.locals_start;
        let locals_end: i64 = ir_func.locals_start + ir_func.locals_count;
        while local_idx < locals_end {
            let ir_local: *IRLocal = &g_ir_locals[local_idx];
            if ir_local.is_param {
                func_add_param(&ssa_func, ir_local.name_start, ir_local.name_len,
                               ir_local.type_idx);
            } else {
                func_add_local(&ssa_func, ir_local.name_start, ir_local.name_len,
                               ir_local.type_idx, ir_local.is_mutable);
            }
            local_idx = local_idx + 1;
        }

        // Compute stack layout
        local_idx = 0;
        while local_idx < ssa_func.locals_count {
            let ssa_local: *Local = func_get_local(&ssa_func, local_idx);
            ssa_local.offset = local_idx * 8;
            local_idx = local_idx + 1;
        }
        ssa_func.frame_size = ssa_func.locals_count * 8;
        if ssa_func.frame_size % 16 != 0 {
            ssa_func.frame_size = ssa_func.frame_size + (16 - (ssa_func.frame_size % 16));
        }

        // Convert this function's IR nodes to SSA
        var current_ir_block: i64 = 0;
        var next_reg: i64 = X1;
        ir_idx = ir_func.nodes_start;
        while ir_idx < ir_end {
            let ir_node: *IRNode = &g_ir_nodes[ir_idx];

            if ir_node.block_id != current_ir_block {
                current_ir_block = ir_node.block_id;
                func_set_block(&ssa_func, current_ir_block);
            }

            if ir_node.kind == IRNodeKind.ConstInt {
                let val: *Value = func_emit_const_int(&ssa_func, ir_node.value, TYPE_I64);
                val.reg = next_reg;
                next_reg = next_reg + 1;
                g_ir_to_ssa_id[ir_idx] = val.id;
            } else if ir_node.kind == IRNodeKind.ConstString {
                // String literal: left=str_start, right=str_len in source
                let val: *Value = func_emit_const_string(&ssa_func, ir_node.left, ir_node.right);
                val.reg = next_reg;
                next_reg = next_reg + 1;
                g_ir_to_ssa_id[ir_idx] = val.id;
            } else if ir_node.kind == IRNodeKind.Binary {
                // left and right are relative IR indices
                let left_abs: i64 = ir_func.nodes_start + ir_node.left;
                let right_abs: i64 = ir_func.nodes_start + ir_node.right;
                let left_id: i64 = g_ir_to_ssa_id[left_abs];
                let right_id: i64 = g_ir_to_ssa_id[right_abs];
                let left_val: *Value = func_get_value(&ssa_func, left_id);
                let right_val: *Value = func_get_value(&ssa_func, right_id);
                let ssa_op: Op = ir_op_to_ssa_op(ir_node.op);
                let val: *Value = func_emit_binary(&ssa_func, ssa_op, left_val, right_val, TYPE_I64);
                val.reg = X0;
                g_ir_to_ssa_id[ir_idx] = val.id;
            } else if ir_node.kind == IRNodeKind.StoreLocal {
                let loc_idx: i64 = ir_node.left;  // local index (not IR node)
                // right is relative IR index of value to store
                let value_abs: i64 = ir_func.nodes_start + ir_node.right;
                let value_ssa_id: i64 = g_ir_to_ssa_id[value_abs];
                let value_val: *Value = func_get_value(&ssa_func, value_ssa_id);
                let store_val: *Value = func_emit_store_local(&ssa_func, loc_idx, value_val);
                g_ir_to_ssa_id[ir_idx] = store_val.id;
            } else if ir_node.kind == IRNodeKind.LoadLocal {
                let loc_idx: i64 = ir_node.left;
                let ssa_local: *Local = func_get_local(&ssa_func, loc_idx);
                if ssa_local.is_param {
                    // Parameters are in X0-X7 at function entry
                    // Create a value that represents the argument register
                    let arg_val: *Value = func_new_value(&ssa_func, Op.Arg, TYPE_I64);
                    arg_val.aux_int = ssa_local.param_idx;  // Which parameter
                    arg_val.reg = X0 + ssa_local.param_idx;  // X0, X1, etc.
                    g_ir_to_ssa_id[ir_idx] = arg_val.id;
                } else {
                    let load_val: *Value = func_emit_load_local(&ssa_func, loc_idx);
                    load_val.reg = next_reg;
                    next_reg = next_reg + 1;
                    g_ir_to_ssa_id[ir_idx] = load_val.id;
                }
            } else if ir_node.kind == IRNodeKind.AddrLocal {
                // Address of local variable: left = local index
                let loc_idx: i64 = ir_node.left;
                let addr_val: *Value = func_new_value(&ssa_func, Op.LocalAddr, TYPE_I64);
                addr_val.aux_int = loc_idx;
                addr_val.reg = next_reg;
                next_reg = next_reg + 1;
                g_ir_to_ssa_id[ir_idx] = addr_val.id;
            } else if ir_node.kind == IRNodeKind.Load {
                // Load from pointer: left = ptr expr (relative IR index)
                let ptr_abs: i64 = ir_func.nodes_start + ir_node.left;
                let ptr_id: i64 = g_ir_to_ssa_id[ptr_abs];
                let ptr_val: *Value = func_get_value(&ssa_func, ptr_id);
                let load_val: *Value = func_new_value(&ssa_func, Op.Load, TYPE_I64);
                value_add_arg(load_val, ptr_val);
                load_val.reg = next_reg;
                next_reg = next_reg + 1;
                g_ir_to_ssa_id[ir_idx] = load_val.id;
            } else if ir_node.kind == IRNodeKind.Store {
                // Store to pointer: left = ptr expr, right = value expr (relative)
                let ptr_abs: i64 = ir_func.nodes_start + ir_node.left;
                let val_abs: i64 = ir_func.nodes_start + ir_node.right;
                let ptr_id: i64 = g_ir_to_ssa_id[ptr_abs];
                let val_id: i64 = g_ir_to_ssa_id[val_abs];
                let ptr_val: *Value = func_get_value(&ssa_func, ptr_id);
                let val_val: *Value = func_get_value(&ssa_func, val_id);
                let store_val: *Value = func_new_value(&ssa_func, Op.Store, TYPE_VOID);
                value_add_arg2(store_val, ptr_val, val_val);
                g_ir_to_ssa_id[ir_idx] = store_val.id;
            } else if ir_node.kind == IRNodeKind.FieldLocal {
                // Access field of local struct: left = local_idx, right = offset
                // SSA pattern: LocalAddr + OffPtr + Load
                let loc_idx: i64 = ir_node.left;
                let offset: i64 = ir_node.right;

                // 1. Get address of local
                let addr_val: *Value = func_new_value(&ssa_func, Op.LocalAddr, TYPE_I64);
                addr_val.aux_int = loc_idx;

                // 2. Add offset to get field address
                let off_val: *Value = func_new_value(&ssa_func, Op.OffPtr, TYPE_I64);
                value_add_arg(off_val, addr_val);
                off_val.aux_int = offset;

                // 3. Load the field value
                let load_val: *Value = func_new_value(&ssa_func, Op.Load, ir_node.type_idx);
                value_add_arg(load_val, off_val);
                load_val.reg = next_reg;
                next_reg = next_reg + 1;
                g_ir_to_ssa_id[ir_idx] = load_val.id;
            } else if ir_node.kind == IRNodeKind.FieldValue {
                // Access field via computed address: left = base_expr, right = offset
                // SSA pattern: base + OffPtr + Load
                let base_abs: i64 = ir_func.nodes_start + ir_node.left;
                let offset: i64 = ir_node.right;
                let base_id: i64 = g_ir_to_ssa_id[base_abs];
                let base_val: *Value = func_get_value(&ssa_func, base_id);

                // 1. Add offset to base to get field address
                let off_val: *Value = func_new_value(&ssa_func, Op.OffPtr, TYPE_I64);
                value_add_arg(off_val, base_val);
                off_val.aux_int = offset;

                // 2. Load the field value
                let load_val: *Value = func_new_value(&ssa_func, Op.Load, ir_node.type_idx);
                value_add_arg(load_val, off_val);
                load_val.reg = next_reg;
                next_reg = next_reg + 1;
                g_ir_to_ssa_id[ir_idx] = load_val.id;
            } else if ir_node.kind == IRNodeKind.StoreFieldLocal {
                // Store to field of local struct: left = local_idx, right = offset, value = stored_expr
                let loc_idx: i64 = ir_node.left;
                let offset: i64 = ir_node.right;
                let val_abs: i64 = ir_func.nodes_start + ir_node.value;
                let val_id: i64 = g_ir_to_ssa_id[val_abs];
                let val_val: *Value = func_get_value(&ssa_func, val_id);

                // 1. Get address of local
                let addr_val: *Value = func_new_value(&ssa_func, Op.LocalAddr, TYPE_I64);
                addr_val.aux_int = loc_idx;

                // 2. Add offset to get field address
                let off_val: *Value = func_new_value(&ssa_func, Op.OffPtr, TYPE_I64);
                value_add_arg(off_val, addr_val);
                off_val.aux_int = offset;

                // 3. Store the value
                let store_val: *Value = func_new_value(&ssa_func, Op.Store, TYPE_VOID);
                value_add_arg2(store_val, off_val, val_val);
                g_ir_to_ssa_id[ir_idx] = store_val.id;
            } else if ir_node.kind == IRNodeKind.StoreField {
                // Store to field via computed address: left = base_expr, right = offset, value = stored_expr
                let base_abs: i64 = ir_func.nodes_start + ir_node.left;
                let offset: i64 = ir_node.right;
                let val_abs: i64 = ir_func.nodes_start + ir_node.value;
                let base_id: i64 = g_ir_to_ssa_id[base_abs];
                let val_id: i64 = g_ir_to_ssa_id[val_abs];
                let base_val: *Value = func_get_value(&ssa_func, base_id);
                let val_val: *Value = func_get_value(&ssa_func, val_id);

                // 1. Add offset to base to get field address
                let off_val: *Value = func_new_value(&ssa_func, Op.OffPtr, TYPE_I64);
                value_add_arg(off_val, base_val);
                off_val.aux_int = offset;

                // 2. Store the value
                let store_val: *Value = func_new_value(&ssa_func, Op.Store, TYPE_VOID);
                value_add_arg2(store_val, off_val, val_val);
                g_ir_to_ssa_id[ir_idx] = store_val.id;
            } else if ir_node.kind == IRNodeKind.IndexLocal {
                // Index into local array: left = local_idx, right = index_expr, value = elem_size
                // SSA pattern: LocalAddr + (index * elem_size) + AddPtr + Load
                let loc_idx: i64 = ir_node.left;
                let idx_abs: i64 = ir_func.nodes_start + ir_node.right;
                let elem_size: i64 = ir_node.value;
                let idx_id: i64 = g_ir_to_ssa_id[idx_abs];
                let idx_val: *Value = func_get_value(&ssa_func, idx_id);

                // 1. Get address of local array
                let addr_val: *Value = func_new_value(&ssa_func, Op.LocalAddr, TYPE_I64);
                addr_val.aux_int = loc_idx;

                // 2. Compute byte offset: index * elem_size
                let size_val: *Value = func_emit_const_int(&ssa_func, elem_size, TYPE_I64);
                let offset_val: *Value = func_emit_binary(&ssa_func, Op.Mul64, idx_val, size_val, TYPE_I64);

                // 3. Add offset to base address
                let ptr_val: *Value = func_emit_binary(&ssa_func, Op.AddPtr, addr_val, offset_val, TYPE_I64);

                // 4. Load the element value
                let load_val: *Value = func_new_value(&ssa_func, Op.Load, ir_node.type_idx);
                value_add_arg(load_val, ptr_val);
                load_val.reg = next_reg;
                next_reg = next_reg + 1;
                g_ir_to_ssa_id[ir_idx] = load_val.id;
            } else if ir_node.kind == IRNodeKind.IndexValue {
                // Index via computed address: left = base_expr, right = index_expr, value = elem_size
                // SSA pattern: base + (index * elem_size) + AddPtr + Load
                let base_abs: i64 = ir_func.nodes_start + ir_node.left;
                let idx_abs: i64 = ir_func.nodes_start + ir_node.right;
                let elem_size: i64 = ir_node.value;
                let base_id: i64 = g_ir_to_ssa_id[base_abs];
                let idx_id: i64 = g_ir_to_ssa_id[idx_abs];
                let base_val: *Value = func_get_value(&ssa_func, base_id);
                let idx_val: *Value = func_get_value(&ssa_func, idx_id);

                // 1. Compute byte offset: index * elem_size
                let size_val: *Value = func_emit_const_int(&ssa_func, elem_size, TYPE_I64);
                let offset_val: *Value = func_emit_binary(&ssa_func, Op.Mul64, idx_val, size_val, TYPE_I64);

                // 2. Add offset to base address
                let ptr_val: *Value = func_emit_binary(&ssa_func, Op.AddPtr, base_val, offset_val, TYPE_I64);

                // 3. Load the element value
                let load_val: *Value = func_new_value(&ssa_func, Op.Load, ir_node.type_idx);
                value_add_arg(load_val, ptr_val);
                load_val.reg = next_reg;
                next_reg = next_reg + 1;
                g_ir_to_ssa_id[ir_idx] = load_val.id;
            } else if ir_node.kind == IRNodeKind.StoreIndexLocal {
                // Store to local array element: left = local_idx, right = index_expr, value = stored_expr, op = elem_size
                let loc_idx: i64 = ir_node.left;
                let idx_abs: i64 = ir_func.nodes_start + ir_node.right;
                let val_abs: i64 = ir_func.nodes_start + ir_node.value;
                let elem_size: i64 = ir_node.op;
                let idx_id: i64 = g_ir_to_ssa_id[idx_abs];
                let val_id: i64 = g_ir_to_ssa_id[val_abs];
                let idx_val: *Value = func_get_value(&ssa_func, idx_id);
                let val_val: *Value = func_get_value(&ssa_func, val_id);

                // 1. Get address of local array
                let addr_val: *Value = func_new_value(&ssa_func, Op.LocalAddr, TYPE_I64);
                addr_val.aux_int = loc_idx;

                // 2. Compute byte offset: index * elem_size
                let size_val: *Value = func_emit_const_int(&ssa_func, elem_size, TYPE_I64);
                let offset_val: *Value = func_emit_binary(&ssa_func, Op.Mul64, idx_val, size_val, TYPE_I64);

                // 3. Add offset to base address
                let ptr_val: *Value = func_emit_binary(&ssa_func, Op.AddPtr, addr_val, offset_val, TYPE_I64);

                // 4. Store the value
                let store_val: *Value = func_new_value(&ssa_func, Op.Store, TYPE_VOID);
                value_add_arg2(store_val, ptr_val, val_val);
                g_ir_to_ssa_id[ir_idx] = store_val.id;
            } else if ir_node.kind == IRNodeKind.StoreIndexValue {
                // Store via indexed address: left = base_expr, right = index_expr, value = stored_expr, op = elem_size
                let base_abs: i64 = ir_func.nodes_start + ir_node.left;
                let idx_abs: i64 = ir_func.nodes_start + ir_node.right;
                let val_abs: i64 = ir_func.nodes_start + ir_node.value;
                let elem_size: i64 = ir_node.op;
                let base_id: i64 = g_ir_to_ssa_id[base_abs];
                let idx_id: i64 = g_ir_to_ssa_id[idx_abs];
                let val_id: i64 = g_ir_to_ssa_id[val_abs];
                let base_val: *Value = func_get_value(&ssa_func, base_id);
                let idx_val: *Value = func_get_value(&ssa_func, idx_id);
                let val_val: *Value = func_get_value(&ssa_func, val_id);

                // 1. Compute byte offset: index * elem_size
                let size_val: *Value = func_emit_const_int(&ssa_func, elem_size, TYPE_I64);
                let offset_val: *Value = func_emit_binary(&ssa_func, Op.Mul64, idx_val, size_val, TYPE_I64);

                // 2. Add offset to base address
                let ptr_val: *Value = func_emit_binary(&ssa_func, Op.AddPtr, base_val, offset_val, TYPE_I64);

                // 3. Store the value
                let store_val: *Value = func_new_value(&ssa_func, Op.Store, TYPE_VOID);
                value_add_arg2(store_val, ptr_val, val_val);
                g_ir_to_ssa_id[ir_idx] = store_val.id;
            } else if ir_node.kind == IRNodeKind.Call {
                let val: *Value = func_emit_call(&ssa_func,
                                                 ir_node.func_name_start,
                                                 ir_node.func_name_len,
                                                 TYPE_I64);
                var arg_idx: i64 = 0;
                while arg_idx < ir_node.args_count {
                    // args_start is relative to function, convert to absolute
                    let arg_ir_idx: i64 = ir_func.nodes_start + ir_node.args_start + arg_idx;
                    let arg_ssa_id: i64 = g_ir_to_ssa_id[arg_ir_idx];
                    let arg_val: *Value = func_get_value(&ssa_func, arg_ssa_id);
                    value_add_arg(val, arg_val);
                    arg_idx = arg_idx + 1;
                }
                val.reg = X0;
                g_ir_to_ssa_id[ir_idx] = val.id;
            } else if ir_node.kind == IRNodeKind.Branch {
                // left is relative IR index of condition
                let cond_abs: i64 = ir_func.nodes_start + ir_node.left;
                let cond_id: i64 = g_ir_to_ssa_id[cond_abs];
                let then_block: i64 = ir_node.right;
                let else_block: i64 = ir_node.value;
                let cond_val: *Value = func_get_value(&ssa_func, cond_id);
                func_emit_if(&ssa_func, cond_val, then_block, else_block);
                g_ir_to_ssa_id[ir_idx] = -1;
            } else if ir_node.kind == IRNodeKind.Jump {
                let target_block: i64 = ir_node.left;
                func_emit_jump(&ssa_func, target_block);
                g_ir_to_ssa_id[ir_idx] = -1;
            } else if ir_node.kind == IRNodeKind.Return {
                if ir_node.left >= 0 {
                    // left is relative to function, convert to absolute
                    let abs_idx: i64 = ir_func.nodes_start + ir_node.left;
                    let val_id: i64 = g_ir_to_ssa_id[abs_idx];
                    let ret_val: *Value = func_get_value(&ssa_func, val_id);
                    func_emit_return(&ssa_func, ret_val);
                }
            }

            ir_idx = ir_idx + 1;
        }

        func_emit_return_block(&ssa_func);

        total_blocks = total_blocks + ssa_func.blocks_count;
        total_values = total_values + ssa_func.values_count;

        // Generate code for this function
        gs.func = &ssa_func;
        let genssa_result: i64 = genssa(&gs);
        if genssa_result != 0 {
            print_str("  FAIL: genssa error\n");
            return 2;
        }

        func_idx = func_idx + 1;
    }

    print_str("  Total blocks: ");
    print_num(total_blocks);
    print_str(", Total values: ");
    print_num(total_values);
    print_str(", Code bytes: ");
    print_num(gs.code_count);
    print_str(", Call sites: ");
    print_num(gs.call_sites_count);
    print_newline();

    // Resolve call sites: patch BL instructions with correct offsets
    var call_idx: i64 = 0;
    while call_idx < gs.call_sites_count {
        let cs: *CallSite = &g_call_sites[call_idx];

        // Find target function by name
        var target_offset: i64 = -1;
        var target_idx: i64 = 0;
        while target_idx < lowerer.ir_funcs_count {
            let ir_func: *IRFunc = &g_ir_funcs[target_idx];
            // Compare function names
            if ir_func.name_len == cs.func_name_len {
                var match: bool = true;
                var name_i: i64 = 0;
                while name_i < cs.func_name_len {
                    let src_char: *u8 = source.ptr + ir_func.name_start + name_i;
                    let call_char: *u8 = source.ptr + cs.func_name_start + name_i;
                    if src_char.* != call_char.* {
                        match = false;
                    }
                    name_i = name_i + 1;
                }
                if match {
                    target_offset = ir_func.code_offset;
                }
            }
            target_idx = target_idx + 1;
        }

        // Patch BL instruction if target found
        if target_offset >= 0 {
            // BL offset = (target - call_site) / 4, encoded in bits 25:0
            let call_addr: i64 = cs.code_offset;
            let offset: i64 = (target_offset - call_addr) / 4;
            print_str("  Patching call at ");
            print_num(call_addr);
            print_str(" -> target ");
            print_num(target_offset);
            print_str(", offset ");
            print_num(offset);
            print_newline();
            // Re-encode BL with correct offset
            let bl_inst: i64 = encode_bl(offset);
            // Patch the code buffer (4 bytes, little endian)
            let code_ptr: *u8 = &g_code[call_addr];
            code_ptr.* = @intCast(u8, bl_inst & 255);
            let code_ptr1: *u8 = &g_code[call_addr + 1];
            code_ptr1.* = @intCast(u8, (bl_inst >> 8) & 255);
            let code_ptr2: *u8 = &g_code[call_addr + 2];
            code_ptr2.* = @intCast(u8, (bl_inst >> 16) & 255);
            let code_ptr3: *u8 = &g_code[call_addr + 3];
            code_ptr3.* = @intCast(u8, (bl_inst >> 24) & 255);
        } else {
            print_str("  WARNING: Could not find target function!\n");
        }

        call_idx = call_idx + 1;
    }

    // Phase 6: Create Mach-O object
    print_str("Phase 6: Creating Mach-O object...\n");

    var writer: MachOWriter = undefined;
    macho_writer_init(&writer,
                      &g_code[0], gs.code_count,
                      &g_data[0], MAIN_MAX_DATA,
                      &g_symbols[0], MAIN_MAX_SYMBOLS,
                      &g_strings[0], MAIN_MAX_STRINGS,
                      &g_relocs[0], MAIN_MAX_RELOCS,
                      &g_output[0], MAIN_MAX_OUTPUT);

    // Copy code from genssa output
    writer.code_count = gs.code_count;

    // Add symbols for all functions
    var sym_name: [128]u8;  // Buffer for mangled name (_funcname)
    func_idx = 0;
    while func_idx < lowerer.ir_funcs_count {
        let ir_func: *IRFunc = &g_ir_funcs[func_idx];

        // Build symbol name: "_" + function name from source
        sym_name[0] = 95;  // '_'
        var name_idx: i64 = 0;
        while name_idx < ir_func.name_len and name_idx < 126 {
            let src_ptr: *u8 = source.ptr + ir_func.name_start + name_idx;
            sym_name[1 + name_idx] = src_ptr.*;
            name_idx = name_idx + 1;
        }
        let sym_len: i64 = 1 + ir_func.name_len;

        // Add symbol at function's code offset
        macho_add_symbol(&writer, &sym_name[0], sym_len, ir_func.code_offset, SECT_TEXT, true);

        func_idx = func_idx + 1;
    }

    let macho_bytes: i64 = write_macho(&writer);
    print_str("  Mach-O bytes: ");
    print_num(macho_bytes);
    print_newline();

    // Phase 7: Write to output file
    print_str("Phase 7: Writing output...\n");

    if out_path_len > 0 {
        let written: i64 = write_file(out_path, &g_output[0], macho_bytes);
        if written < 0 {
            return 3;
        }
        print_str("  Wrote ");
        print_num(written);
        print_str(" bytes\n");
    } else {
        print_str("  (No output path specified, skipping write)\n");
    }

    return 0;
}

// ============================================================================
// Command Line Parsing
// ============================================================================

// Get string length (null-terminated)
fn strlen(s: *u8) i64 {
    var len: i64 = 0;
    var ptr: *u8 = s;
    while ptr.* != 0 {
        len = len + 1;
        ptr = ptr + 1;
    }
    return len;
}

// Compare two strings for equality
fn streq(a: *u8, b: *u8) bool {
    var pa: *u8 = a;
    var pb: *u8 = b;
    while pa.* != 0 and pb.* != 0 {
        if pa.* != pb.* {
            return false;
        }
        pa = pa + 1;
        pb = pb + 1;
    }
    return pa.* == pb.*;
}

// Copy string to buffer, return length
fn strcpy(dest: *u8, src: *u8, max_len: i64) i64 {
    var i: i64 = 0;
    var src_ptr: *u8 = src;
    var dst_ptr: *u8 = dest;
    while src_ptr.* != 0 and i < max_len - 1 {
        dst_ptr.* = src_ptr.*;
        src_ptr = src_ptr + 1;
        dst_ptr = dst_ptr + 1;
        i = i + 1;
    }
    dst_ptr.* = 0;  // Null terminate
    return i;
}

fn print_usage() {
    print_str("Usage: cot0 <source.cot> -o <output>\n");
    print_str("\n");
    print_str("  <source.cot>  Input Cot source file\n");
    print_str("  -o <output>   Output object file\n");
}

// ============================================================================
// Main Entry Point
// ============================================================================

fn main(argc: i64, argv: **u8) i64 {
    print_str("Cot0 Self-Hosting Compiler v0.2\n");
    print_str("================================\n\n");

    // Parse command line arguments
    // Expected: cot0 <source.cot> -o <output>
    if argc < 4 {
        print_str("Error: Not enough arguments\n\n");
        print_usage();
        return 1;
    }

    // Get source file path (argv[1])
    let argv_ptr1: **u8 = argv + 1;
    let source_path: *u8 = argv_ptr1.*;

    // Check for -o flag (argv[2])
    let argv_ptr2: **u8 = argv + 2;
    let flag: *u8 = argv_ptr2.*;

    // Build expected flag string
    var dash_o: [3]u8;
    dash_o[0] = 45;  // '-'
    dash_o[1] = 111; // 'o'
    dash_o[2] = 0;

    if !streq(flag, &dash_o[0]) {
        print_str("Error: Expected -o flag\n\n");
        print_usage();
        return 1;
    }

    // Get output path (argv[3])
    let argv_ptr3: **u8 = argv + 3;
    let output_path: *u8 = argv_ptr3.*;
    let output_len: i64 = strlen(output_path);

    // Copy output path to global buffer (for null-termination)
    g_output_path_len = strcpy(&g_output_path[0], output_path, MAIN_MAX_OUTPUT_PATH);

    // Read source file
    print_str("Reading: ");
    var source_ptr: *u8 = source_path;
    while source_ptr.* != 0 {
        write(1, source_ptr, 1);
        source_ptr = source_ptr + 1;
    }
    print_newline();

    let bytes_read: i64 = read_file(source_path);
    if bytes_read < 0 {
        return 1;
    }

    print_str("  Read ");
    print_num(bytes_read);
    print_str(" bytes\n\n");

    // Create string view of source
    let source: string = @string(&g_source[0], g_source_len);

    let result: i64 = compile(source, &g_output_path[0], g_output_path_len);

    if result == 0 {
        print_str("\nCompilation successful!\n");
    } else {
        print_str("\nCompilation failed with code ");
        print_num(result);
        print_newline();
    }

    return result;
}

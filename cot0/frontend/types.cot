// Cot0 Type Representation
// Minimal type system for: i64, bool, void, functions
//
// Design follows Go's go/types package patterns:
// - TypeKind enum for type discrimination
// - TypeIndex (i64) for compact storage and interning
// - TypePool for type creation and lookup
// - Predicate functions for type checking
//
// Reference: ~/learning/go/src/cmd/compile/internal/types/type.go
// Reference: bootstrap-0.2/src/frontend/types.zig

import "token.cot"

// ============================================================================
// Type Index
// ============================================================================

// Index into type pool. -1 = invalid/error type.
const INVALID_TYPE: i64 = -1;

// ============================================================================
// Type Kinds (Go's Kind enum)
// ============================================================================

// Kind of type.
enum TypeKind {
    Invalid,    // Error/unknown type

    // Basic types
    Bool,       // bool
    I8,         // i8
    I16,        // i16
    I32,        // i32
    I64,        // i64
    U8,         // u8
    U16,        // u16
    U32,        // u32
    U64,        // u64
    F32,        // f32
    F64,        // f64
    Void,       // void (no value)

    // Composite types
    Pointer,    // *T
    Slice,      // []T
    Array,      // [N]T
    Func,       // fn(args) ret
    Struct,     // struct { fields }
    Enum,       // enum { variants }
    String,     // string (slice of u8)
}

// ============================================================================
// Type Structure
// ============================================================================

// Type represents a Cot type.
// Uses a flat struct with kind-specific interpretation of fields.
struct Type {
    kind: TypeKind,

    // Kind-specific fields:
    // For Pointer: elem is the pointee type index
    // For Slice: elem is the element type index
    // For Array: elem is element type, len is array length
    // For Func: params_start, params_count, ret_type
    // For Struct: name_start, name_len, fields_start, fields_count

    elem: i64,          // Element type index (for Pointer, Slice, Array)
    len: i64,           // Array length (for Array)
    ret_type: i64,      // Return type index (for Func)
    params_start: i64,  // Start index in params array (for Func)
    params_count: i64,  // Number of parameters (for Func)
    name_start: i64,    // Name offset in source (for Struct, Enum)
    name_len: i64,      // Name length (for Struct, Enum)
    size: i64,          // Size in bytes
    align: i64,         // Alignment in bytes
}

// ============================================================================
// Type Pool (arena allocation for type interning)
// ============================================================================

const MAX_TYPES: i64 = 1000;
const MAX_PARAMS: i64 = 5000;  // For function parameter lists

struct TypePool {
    types: *Type,       // Array of MAX_TYPES types
    count: i64,         // Current type count

    // Parameter arrays (for function types)
    params: *i64,       // Array of type indices for function params
    params_count: i64,
}

// ============================================================================
// Pre-defined Type Indices
// ============================================================================

// These match the order in which types are registered in pool_init
const TYPE_INVALID: i64 = 0;
const TYPE_BOOL: i64 = 1;
const TYPE_I8: i64 = 2;
const TYPE_I16: i64 = 3;
const TYPE_I32: i64 = 4;
const TYPE_I64: i64 = 5;
const TYPE_U8: i64 = 6;
const TYPE_U16: i64 = 7;
const TYPE_U32: i64 = 8;
const TYPE_U64: i64 = 9;
const TYPE_F32: i64 = 10;
const TYPE_F64: i64 = 11;
const TYPE_VOID: i64 = 12;
const TYPE_STRING: i64 = 13;

// Aliases
const TYPE_INT: i64 = 5;   // i64 is the default int
const TYPE_FLOAT: i64 = 11; // f64 is the default float
const TYPE_BYTE: i64 = 6;  // u8 is byte

// First user-defined type index
const FIRST_USER_TYPE: i64 = 14;

// ============================================================================
// Type Pool Initialization
// ============================================================================

// Initialize type pool with pre-registered basic types
fn pool_init(pool: *TypePool) {
    pool.count = 0;
    pool.params_count = 0;

    // Register basic types in order
    register_basic(pool, TypeKind.Invalid, 0, 0);   // 0: invalid
    register_basic(pool, TypeKind.Bool, 1, 1);      // 1: bool
    register_basic(pool, TypeKind.I8, 1, 1);        // 2: i8
    register_basic(pool, TypeKind.I16, 2, 2);       // 3: i16
    register_basic(pool, TypeKind.I32, 4, 4);       // 4: i32
    register_basic(pool, TypeKind.I64, 8, 8);       // 5: i64
    register_basic(pool, TypeKind.U8, 1, 1);        // 6: u8
    register_basic(pool, TypeKind.U16, 2, 2);       // 7: u16
    register_basic(pool, TypeKind.U32, 4, 4);       // 8: u32
    register_basic(pool, TypeKind.U64, 8, 8);       // 9: u64
    register_basic(pool, TypeKind.F32, 4, 4);       // 10: f32
    register_basic(pool, TypeKind.F64, 8, 8);       // 11: f64
    register_basic(pool, TypeKind.Void, 0, 0);      // 12: void
    register_basic(pool, TypeKind.String, 16, 8);   // 13: string (ptr + len)
}

// Helper to register a basic type
fn register_basic(pool: *TypePool, kind: TypeKind, size: i64, align: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let t: *Type = pool.types + idx;
    t.kind = kind;
    t.elem = INVALID_TYPE;
    t.len = 0;
    t.ret_type = INVALID_TYPE;
    t.params_start = 0;
    t.params_count = 0;
    t.name_start = 0;
    t.name_len = 0;
    t.size = size;
    t.align = align;

    return idx;
}

// ============================================================================
// Type Accessors
// ============================================================================

// Get type at index
fn type_get(pool: *TypePool, idx: i64) *Type {
    if idx < 0 or idx >= pool.count {
        return pool.types + 0;  // Return invalid type
    }
    return pool.types + idx;
}

// Check if type index is valid
fn type_valid(idx: i64) bool {
    return idx != INVALID_TYPE and idx >= 0;
}

// ============================================================================
// Type Creation
// ============================================================================

// Create a pointer type: *elem
fn type_make_pointer(pool: *TypePool, elem: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let t: *Type = pool.types + idx;
    t.kind = TypeKind.Pointer;
    t.elem = elem;
    t.len = 0;
    t.ret_type = INVALID_TYPE;
    t.params_start = 0;
    t.params_count = 0;
    t.name_start = 0;
    t.name_len = 0;
    t.size = 8;  // Pointers are 8 bytes on 64-bit
    t.align = 8;

    return idx;
}

// Create a slice type: []elem
fn type_make_slice(pool: *TypePool, elem: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let t: *Type = pool.types + idx;
    t.kind = TypeKind.Slice;
    t.elem = elem;
    t.len = 0;
    t.ret_type = INVALID_TYPE;
    t.params_start = 0;
    t.params_count = 0;
    t.name_start = 0;
    t.name_len = 0;
    t.size = 16;  // ptr + len
    t.align = 8;

    return idx;
}

// Create an array type: [len]elem
fn type_make_array(pool: *TypePool, elem: i64, array_len: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let elem_type: *Type = type_get(pool, elem);
    let elem_size: i64 = elem_type.size;

    let t: *Type = pool.types + idx;
    t.kind = TypeKind.Array;
    t.elem = elem;
    t.len = array_len;
    t.ret_type = INVALID_TYPE;
    t.params_start = 0;
    t.params_count = 0;
    t.name_start = 0;
    t.name_len = 0;
    t.size = elem_size * array_len;
    t.align = elem_type.align;

    return idx;
}

// Create a function type: fn(params) ret
fn type_make_func(pool: *TypePool, params_start: i64, params_count: i64, ret_type: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let t: *Type = pool.types + idx;
    t.kind = TypeKind.Func;
    t.elem = INVALID_TYPE;
    t.len = 0;
    t.ret_type = ret_type;
    t.params_start = params_start;
    t.params_count = params_count;
    t.name_start = 0;
    t.name_len = 0;
    t.size = 8;  // Function pointer
    t.align = 8;

    return idx;
}

// Add a parameter type to the params array
fn type_add_param(pool: *TypePool, param_type: i64) i64 {
    let idx: i64 = pool.params_count;
    let ptr: *i64 = pool.params + idx;
    ptr.* = param_type;
    pool.params_count = pool.params_count + 1;
    return idx;
}

// Get parameter type at index
fn type_get_param(pool: *TypePool, params_start: i64, offset: i64) i64 {
    let ptr: *i64 = pool.params + params_start + offset;
    return ptr.*;
}

// ============================================================================
// Type Predicates
// ============================================================================

// Check if type is integer (signed or unsigned)
fn is_integer(pool: *TypePool, idx: i64) bool {
    let t: *Type = type_get(pool, idx);
    return t.kind == TypeKind.I8 or t.kind == TypeKind.I16 or
           t.kind == TypeKind.I32 or t.kind == TypeKind.I64 or
           t.kind == TypeKind.U8 or t.kind == TypeKind.U16 or
           t.kind == TypeKind.U32 or t.kind == TypeKind.U64;
}

// Check if type is signed integer
fn is_signed(pool: *TypePool, idx: i64) bool {
    let t: *Type = type_get(pool, idx);
    return t.kind == TypeKind.I8 or t.kind == TypeKind.I16 or
           t.kind == TypeKind.I32 or t.kind == TypeKind.I64;
}

// Check if type is unsigned integer
fn is_unsigned(pool: *TypePool, idx: i64) bool {
    let t: *Type = type_get(pool, idx);
    return t.kind == TypeKind.U8 or t.kind == TypeKind.U16 or
           t.kind == TypeKind.U32 or t.kind == TypeKind.U64;
}

// Check if type is floating point
fn is_float(pool: *TypePool, idx: i64) bool {
    let t: *Type = type_get(pool, idx);
    return t.kind == TypeKind.F32 or t.kind == TypeKind.F64;
}

// Check if type is numeric (integer or float)
fn is_numeric(pool: *TypePool, idx: i64) bool {
    return is_integer(pool, idx) or is_float(pool, idx);
}

// Check if type is boolean
fn is_bool(pool: *TypePool, idx: i64) bool {
    let t: *Type = type_get(pool, idx);
    return t.kind == TypeKind.Bool;
}

// Check if type is void
fn is_void(pool: *TypePool, idx: i64) bool {
    let t: *Type = type_get(pool, idx);
    return t.kind == TypeKind.Void;
}

// Check if type is a pointer
fn is_pointer(pool: *TypePool, idx: i64) bool {
    let t: *Type = type_get(pool, idx);
    return t.kind == TypeKind.Pointer;
}

// Check if type is a slice
fn is_slice(pool: *TypePool, idx: i64) bool {
    let t: *Type = type_get(pool, idx);
    return t.kind == TypeKind.Slice;
}

// Check if type is an array
fn is_array(pool: *TypePool, idx: i64) bool {
    let t: *Type = type_get(pool, idx);
    return t.kind == TypeKind.Array;
}

// Check if type is a function
fn is_func(pool: *TypePool, idx: i64) bool {
    let t: *Type = type_get(pool, idx);
    return t.kind == TypeKind.Func;
}

// Check if type is a string
fn is_string(pool: *TypePool, idx: i64) bool {
    let t: *Type = type_get(pool, idx);
    return t.kind == TypeKind.String;
}

// ============================================================================
// Type Accessors
// ============================================================================

// Get element type of pointer/slice/array
fn type_elem(pool: *TypePool, idx: i64) i64 {
    let t: *Type = type_get(pool, idx);
    return t.elem;
}

// Get array length
fn type_array_len(pool: *TypePool, idx: i64) i64 {
    let t: *Type = type_get(pool, idx);
    return t.len;
}

// Get function return type
fn type_ret(pool: *TypePool, idx: i64) i64 {
    let t: *Type = type_get(pool, idx);
    return t.ret_type;
}

// Get function parameter count
fn type_param_count(pool: *TypePool, idx: i64) i64 {
    let t: *Type = type_get(pool, idx);
    return t.params_count;
}

// Get type size in bytes
fn type_size(pool: *TypePool, idx: i64) i64 {
    let t: *Type = type_get(pool, idx);
    return t.size;
}

// Get type alignment
fn type_align(pool: *TypePool, idx: i64) i64 {
    let t: *Type = type_get(pool, idx);
    return t.align;
}

// ============================================================================
// Type Equality
// ============================================================================

// Check if two types are equal
fn types_equal(pool: *TypePool, a: i64, b: i64) bool {
    if a == b { return true; }
    if a < 0 or b < 0 { return false; }

    let ta: *Type = type_get(pool, a);
    let tb: *Type = type_get(pool, b);

    // Different kinds are never equal
    if ta.kind != tb.kind { return false; }

    // For basic types, same kind means equal
    if ta.kind == TypeKind.Bool or
       ta.kind == TypeKind.I8 or ta.kind == TypeKind.I16 or
       ta.kind == TypeKind.I32 or ta.kind == TypeKind.I64 or
       ta.kind == TypeKind.U8 or ta.kind == TypeKind.U16 or
       ta.kind == TypeKind.U32 or ta.kind == TypeKind.U64 or
       ta.kind == TypeKind.F32 or ta.kind == TypeKind.F64 or
       ta.kind == TypeKind.Void or ta.kind == TypeKind.String {
        return true;
    }

    // For Pointer, Slice: compare element types
    if ta.kind == TypeKind.Pointer or ta.kind == TypeKind.Slice {
        return types_equal(pool, ta.elem, tb.elem);
    }

    // For Array: compare element types and lengths
    if ta.kind == TypeKind.Array {
        return ta.len == tb.len and types_equal(pool, ta.elem, tb.elem);
    }

    // For Func: compare params and return type
    if ta.kind == TypeKind.Func {
        if ta.params_count != tb.params_count { return false; }
        if not types_equal(pool, ta.ret_type, tb.ret_type) { return false; }

        var i: i64 = 0;
        while i < ta.params_count {
            let pa: i64 = type_get_param(pool, ta.params_start, i);
            let pb: i64 = type_get_param(pool, tb.params_start, i);
            if not types_equal(pool, pa, pb) { return false; }
            i = i + 1;
        }
        return true;
    }

    return false;
}

// ============================================================================
// Type Name Lookup
// ============================================================================

// Look up basic type by name
// Returns type index or INVALID_TYPE if not found
fn lookup_basic_type(source: *u8, name_start: i64, name_len: i64) i64 {
    // Single character type names
    if name_len == 2 {
        let c0: u8 = (source + name_start).*;
        let c1: u8 = (source + name_start + 1).*;

        if c0 == 105 and c1 == 56 { return TYPE_I8; }  // "i8"
        if c0 == 117 and c1 == 56 { return TYPE_U8; }  // "u8"
    }

    if name_len == 3 {
        let c0: u8 = (source + name_start).*;
        let c1: u8 = (source + name_start + 1).*;
        let c2: u8 = (source + name_start + 2).*;

        if c0 == 105 and c1 == 49 and c2 == 54 { return TYPE_I16; }  // "i16"
        if c0 == 105 and c1 == 51 and c2 == 50 { return TYPE_I32; }  // "i32"
        if c0 == 105 and c1 == 54 and c2 == 52 { return TYPE_I64; }  // "i64"
        if c0 == 117 and c1 == 49 and c2 == 54 { return TYPE_U16; }  // "u16"
        if c0 == 117 and c1 == 51 and c2 == 50 { return TYPE_U32; }  // "u32"
        if c0 == 117 and c1 == 54 and c2 == 52 { return TYPE_U64; }  // "u64"
        if c0 == 102 and c1 == 51 and c2 == 50 { return TYPE_F32; }  // "f32"
        if c0 == 102 and c1 == 54 and c2 == 52 { return TYPE_F64; }  // "f64"
        if c0 == 105 and c1 == 110 and c2 == 116 { return TYPE_INT; }  // "int"
    }

    if name_len == 4 {
        let c0: u8 = (source + name_start).*;
        let c1: u8 = (source + name_start + 1).*;
        let c2: u8 = (source + name_start + 2).*;
        let c3: u8 = (source + name_start + 3).*;

        if c0 == 98 and c1 == 111 and c2 == 111 and c3 == 108 { return TYPE_BOOL; }  // "bool"
        if c0 == 118 and c1 == 111 and c2 == 105 and c3 == 100 { return TYPE_VOID; }  // "void"
        if c0 == 98 and c1 == 121 and c2 == 116 and c3 == 101 { return TYPE_BYTE; }  // "byte"
    }

    if name_len == 5 {
        let c0: u8 = (source + name_start).*;
        let c1: u8 = (source + name_start + 1).*;
        let c2: u8 = (source + name_start + 2).*;
        let c3: u8 = (source + name_start + 3).*;
        let c4: u8 = (source + name_start + 4).*;

        if c0 == 102 and c1 == 108 and c2 == 111 and c3 == 97 and c4 == 116 { return TYPE_FLOAT; }  // "float"
    }

    if name_len == 6 {
        let c0: u8 = (source + name_start).*;
        let c1: u8 = (source + name_start + 1).*;
        let c2: u8 = (source + name_start + 2).*;
        let c3: u8 = (source + name_start + 3).*;
        let c4: u8 = (source + name_start + 4).*;
        let c5: u8 = (source + name_start + 5).*;

        // "string"
        if c0 == 115 and c1 == 116 and c2 == 114 and c3 == 105 and c4 == 110 and c5 == 103 {
            return TYPE_STRING;
        }
    }

    return INVALID_TYPE;
}

// ============================================================================
// Type Assignability
// ============================================================================

// Check if a value of type `from` can be assigned to a variable of type `to`
fn is_assignable(pool: *TypePool, from: i64, to: i64) bool {
    // Same type is always assignable
    if from == to { return true; }

    // Error types are assignable (for error recovery)
    if from < 0 or to < 0 { return true; }

    let from_t: *Type = type_get(pool, from);
    let to_t: *Type = type_get(pool, to);

    // Same basic types are assignable
    if from_t.kind == to_t.kind {
        if from_t.kind == TypeKind.Bool or
           from_t.kind == TypeKind.I8 or from_t.kind == TypeKind.I16 or
           from_t.kind == TypeKind.I32 or from_t.kind == TypeKind.I64 or
           from_t.kind == TypeKind.U8 or from_t.kind == TypeKind.U16 or
           from_t.kind == TypeKind.U32 or from_t.kind == TypeKind.U64 or
           from_t.kind == TypeKind.F32 or from_t.kind == TypeKind.F64 or
           from_t.kind == TypeKind.Void or from_t.kind == TypeKind.String {
            return true;
        }
    }

    // Pointer types with same element
    if from_t.kind == TypeKind.Pointer and to_t.kind == TypeKind.Pointer {
        return types_equal(pool, from_t.elem, to_t.elem);
    }

    // Slice types with same element
    if from_t.kind == TypeKind.Slice and to_t.kind == TypeKind.Slice {
        return types_equal(pool, from_t.elem, to_t.elem);
    }

    // Array to slice with same element type
    if from_t.kind == TypeKind.Array and to_t.kind == TypeKind.Slice {
        return types_equal(pool, from_t.elem, to_t.elem);
    }

    // Array types with same element and length
    if from_t.kind == TypeKind.Array and to_t.kind == TypeKind.Array {
        return from_t.len == to_t.len and types_equal(pool, from_t.elem, to_t.elem);
    }

    return false;
}

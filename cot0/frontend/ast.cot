// Cot0 AST Node Definitions
// Minimal AST for: i64, arithmetic, functions, return
//
// Design follows Go's cmd/compile/internal/syntax patterns:
// - Nodes identified by kind enum
// - Expressions and statements distinguished by kind
// - Functions store lists of parameters and body statements
//
// Reference: ~/learning/go/src/cmd/compile/internal/syntax/nodes.go

import "token.cot"

// ============================================================================
// Node Kinds
// ============================================================================

// NodeKind identifies what type of AST node this is.
// Split into expressions (produce values) and statements (perform actions).
enum NodeKind {
    // Expressions (produce values)
    IntLit,         // Integer literal: 42
    StringLit,      // String literal: "hello"
    Ident,          // Identifier: foo
    BinaryExpr,     // Binary operation: a + b
    CallExpr,       // Function call: add(1, 2)
    UnaryExpr,      // Unary operation: -x, !x
    AddressOf,      // Address-of: &x
    DerefExpr,      // Dereference: ptr.*
    AssignExpr,     // Assignment: x = expr

    // Statements (perform actions)
    ReturnStmt,     // return expr;
    ExprStmt,       // expression as statement: foo();
    BlockStmt,      // { stmt; stmt; }
    IfStmt,         // if cond { body } else { body }
    WhileStmt,      // while cond { body }

    // Declarations
    FnDecl,         // fn name(params) ret { body }
    ParamDecl,      // name: type
    VarDecl,        // let/var name: type = expr;
    ConstDecl,      // const name = expr;
    StructDecl,     // struct Name { fields }
    EnumDecl,       // enum Name { variants }
    FieldDecl,      // name: type (struct field)
    ImportDecl,     // import "path";

    // Member access
    FieldAccess,    // expr.field

    // Special
    BadNode,        // Error placeholder
}

// Binary operators for expressions
// Follows Go's operator precedence (precMul > precAdd > precCmp > precAnd > precOr)
enum BinaryOp {
    // Arithmetic (precMul, precAdd)
    Add,        // +
    Sub,        // -
    Mul,        // *
    Div,        // /
    Mod,        // %

    // Comparison (precCmp)
    Equal,      // ==
    NotEqual,   // !=
    Less,       // <
    LessEq,     // <=
    Greater,    // >
    GreaterEq,  // >=

    // Logical (precAnd < precOr)
    And,        // and, &&
    Or,         // or, ||
}

// Unary operators
enum UnaryOp {
    Neg,        // - (negation)
    Not,        // !, not (logical not)
    BitNot,     // ~ (bitwise not)
}

// ============================================================================
// Node Index (pool-based allocation)
// ============================================================================

// Node indices are i64 for simplicity. -1 = null/invalid.
const NULL_NODE: i64 = -1;

// ============================================================================
// AST Node Structure
// ============================================================================

// Node is the universal AST node type.
// Each node has a kind and kind-specific fields stored in a flat layout.
// This mirrors Go's approach where each node type embeds a base node.
struct Node {
    kind: NodeKind,

    // Source location (token start/end)
    start: i64,
    end: i64,

    // Kind-specific fields (union-like, interpret based on kind)
    // For IntLit: value is the integer value
    // For Ident: name_start, name_len index into source
    // For BinaryExpr: left, right are Node indices, op is BinaryOp
    // For CallExpr: callee is Node index, args_start, args_count in args array
    // For ReturnStmt: value is Node index (-1 if no value)
    // For ExprStmt: value is Node index
    // For BlockStmt: stmts_start, stmts_count in stmts array
    // For FnDecl: name_start, name_len, params_start, params_count, ret_type, body
    // For ParamDecl: name_start, name_len, type_start, type_len

    // Generic fields (interpreted by kind)
    field0: i64,    // Multi-purpose field 0
    field1: i64,    // Multi-purpose field 1
    field2: i64,    // Multi-purpose field 2
    field3: i64,    // Multi-purpose field 3
    field4: i64,    // Multi-purpose field 4 (for FnDecl: ret_type)
    field5: i64,    // Multi-purpose field 5 (for FnDecl: body node index)
}

// ============================================================================
// Node Pool (arena allocation)
// ============================================================================

// Maximum nodes in a compilation unit
const MAX_NODES: i64 = 10000;
const MAX_CHILDREN: i64 = 50000;  // For args, stmts, params arrays

struct NodePool {
    nodes: *Node,           // Array of MAX_NODES nodes
    count: i64,             // Current node count

    // Child arrays (for storing lists of node indices)
    children: *i64,         // Array of node indices for args/stmts/params
    children_count: i64,
}

// ============================================================================
// Node Constructors
// ============================================================================

// Create an integer literal node
fn node_int_lit(pool: *NodePool, value: i64, start: i64, end: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let n: *Node = pool.nodes + idx;
    n.kind = NodeKind.IntLit;
    n.start = start;
    n.end = end;
    n.field0 = value;  // The integer value
    n.field1 = 0;
    n.field2 = 0;
    n.field3 = 0;

    return idx;
}

// Create an identifier node
fn node_ident(pool: *NodePool, name_start: i64, name_len: i64, start: i64, end: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let n: *Node = pool.nodes + idx;
    n.kind = NodeKind.Ident;
    n.start = start;
    n.end = end;
    n.field0 = name_start;  // Offset in source
    n.field1 = name_len;    // Length of name
    n.field2 = 0;
    n.field3 = 0;

    return idx;
}

// Create a binary expression node
fn node_binary(pool: *NodePool, op: BinaryOp, left: i64, right: i64, start: i64, end: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let n: *Node = pool.nodes + idx;
    n.kind = NodeKind.BinaryExpr;
    n.start = start;
    n.end = end;
    n.field0 = left;        // Left operand (node index)
    n.field1 = right;       // Right operand (node index)
    // Store op as integer - BinaryOp enum ordinal
    // Arithmetic
    if op == BinaryOp.Add { n.field2 = 0; }
    if op == BinaryOp.Sub { n.field2 = 1; }
    if op == BinaryOp.Mul { n.field2 = 2; }
    if op == BinaryOp.Div { n.field2 = 3; }
    if op == BinaryOp.Mod { n.field2 = 4; }
    // Comparison
    if op == BinaryOp.Equal { n.field2 = 5; }
    if op == BinaryOp.NotEqual { n.field2 = 6; }
    if op == BinaryOp.Less { n.field2 = 7; }
    if op == BinaryOp.LessEq { n.field2 = 8; }
    if op == BinaryOp.Greater { n.field2 = 9; }
    if op == BinaryOp.GreaterEq { n.field2 = 10; }
    // Logical
    if op == BinaryOp.And { n.field2 = 11; }
    if op == BinaryOp.Or { n.field2 = 12; }
    n.field3 = 0;

    return idx;
}

// Create a function call node
fn node_call(pool: *NodePool, callee: i64, args_start: i64, args_count: i64, start: i64, end: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let n: *Node = pool.nodes + idx;
    n.kind = NodeKind.CallExpr;
    n.start = start;
    n.end = end;
    n.field0 = callee;      // Callee node index
    n.field1 = args_start;  // Start index in children array
    n.field2 = args_count;  // Number of arguments
    n.field3 = 0;

    return idx;
}

// Create a return statement node
fn node_return(pool: *NodePool, value: i64, start: i64, end: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let n: *Node = pool.nodes + idx;
    n.kind = NodeKind.ReturnStmt;
    n.start = start;
    n.end = end;
    n.field0 = value;       // Return value (-1 if void)
    n.field1 = 0;
    n.field2 = 0;
    n.field3 = 0;

    return idx;
}

// Create an expression statement node
fn node_expr_stmt(pool: *NodePool, expr: i64, start: i64, end: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let n: *Node = pool.nodes + idx;
    n.kind = NodeKind.ExprStmt;
    n.start = start;
    n.end = end;
    n.field0 = expr;        // Expression node index
    n.field1 = 0;
    n.field2 = 0;
    n.field3 = 0;

    return idx;
}

// Create a block statement node
fn node_block(pool: *NodePool, stmts_start: i64, stmts_count: i64, start: i64, end: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let n: *Node = pool.nodes + idx;
    n.kind = NodeKind.BlockStmt;
    n.start = start;
    n.end = end;
    n.field0 = stmts_start; // Start index in children array
    n.field1 = stmts_count; // Number of statements
    n.field2 = 0;
    n.field3 = 0;

    return idx;
}

// Create a parameter declaration node
fn node_param(pool: *NodePool, name_start: i64, name_len: i64, type_start: i64, type_len: i64, start: i64, end: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let n: *Node = pool.nodes + idx;
    n.kind = NodeKind.ParamDecl;
    n.start = start;
    n.end = end;
    n.field0 = name_start;  // Parameter name offset
    n.field1 = name_len;    // Parameter name length
    n.field2 = type_start;  // Type name offset
    n.field3 = type_len;    // Type name length

    return idx;
}

// Create a function declaration node
fn node_fn_decl(pool: *NodePool, name_start: i64, name_len: i64,
                params_start: i64, params_count: i64,
                ret_type_start: i64, ret_type_len: i64,
                body: i64, start: i64, end: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let n: *Node = pool.nodes + idx;
    n.kind = NodeKind.FnDecl;
    n.start = start;
    n.end = end;
    n.field0 = name_start;      // Function name offset
    n.field1 = name_len;        // Function name length
    n.field2 = params_start;    // Start index in children array
    n.field3 = params_count;    // Number of parameters
    n.field4 = ret_type_len;    // Return type (type handle from parse_type)
    n.field5 = body;            // Body block node index

    return idx;
}

// Create a variable declaration node (let or var)
// field0: is_let (1 = let, 0 = var)
// field1: name index in children array (stores name_start, name_len via extra node)
// field2: type index in children array (stores type_start, type_len, -1 if inferred)
// field3: init_expr node index (-1 if no initializer)
fn node_var_decl(pool: *NodePool, is_let: i64, name_start: i64, name_len: i64,
                 type_start: i64, type_len: i64, init_expr: i64,
                 start: i64, end: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let n: *Node = pool.nodes + idx;
    n.kind = NodeKind.VarDecl;
    n.start = start;
    n.end = end;
    n.field0 = is_let;          // 1 = let, 0 = var
    // Pack name and type info: use children array for names
    // For simplicity, store name_start in field1, name_len in field2
    // Store init_expr in field3
    n.field1 = name_start;      // Name offset in source
    n.field2 = name_len;        // Name length
    n.field3 = init_expr;       // Init expression (-1 if none)

    // Note: type info could be stored in extra slot if needed
    // For cot0, we'll handle type separately in parser

    return idx;
}

// Create an if statement node
// field0: condition expr node index
// field1: then body node index (block)
// field2: else body node index (-1 if no else)
// field3: unused
fn node_if_stmt(pool: *NodePool, cond: i64, then_body: i64, else_body: i64,
                start: i64, end: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let n: *Node = pool.nodes + idx;
    n.kind = NodeKind.IfStmt;
    n.start = start;
    n.end = end;
    n.field0 = cond;            // Condition expression
    n.field1 = then_body;       // Then block
    n.field2 = else_body;       // Else block (-1 if none)
    n.field3 = 0;

    return idx;
}

// Create a while statement node
// field0: condition expr node index
// field1: body node index (block)
// field2, field3: unused
fn node_while_stmt(pool: *NodePool, cond: i64, body: i64, start: i64, end: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let n: *Node = pool.nodes + idx;
    n.kind = NodeKind.WhileStmt;
    n.start = start;
    n.end = end;
    n.field0 = cond;            // Condition expression
    n.field1 = body;            // Body block
    n.field2 = 0;
    n.field3 = 0;

    return idx;
}

// Create a unary expression node
// field0: operand node index
// field1: UnaryOp (as int)
fn node_unary(pool: *NodePool, op: UnaryOp, operand: i64, start: i64, end: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let n: *Node = pool.nodes + idx;
    n.kind = NodeKind.UnaryExpr;
    n.start = start;
    n.end = end;
    n.field0 = operand;         // Operand expression
    // Store op as integer
    if op == UnaryOp.Neg { n.field1 = 0; }
    if op == UnaryOp.Not { n.field1 = 1; }
    if op == UnaryOp.BitNot { n.field1 = 2; }
    n.field2 = 0;
    n.field3 = 0;

    return idx;
}

// ============================================================================
// Sprint C: Pointers and Strings
// Following Go's cmd/compile/internal/syntax/nodes.go patterns
// ============================================================================

// Create a string literal node
// field0: string_start (offset in source, after opening quote)
// field1: string_len (length of string content, excluding quotes)
fn node_string_lit(pool: *NodePool, str_start: i64, str_len: i64, start: i64, end: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let n: *Node = pool.nodes + idx;
    n.kind = NodeKind.StringLit;
    n.start = start;
    n.end = end;
    n.field0 = str_start;       // String content offset (after quote)
    n.field1 = str_len;         // String content length
    n.field2 = 0;
    n.field3 = 0;

    return idx;
}

// Create an address-of expression node: &expr
// field0: operand node index
fn node_address_of(pool: *NodePool, operand: i64, start: i64, end: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let n: *Node = pool.nodes + idx;
    n.kind = NodeKind.AddressOf;
    n.start = start;
    n.end = end;
    n.field0 = operand;         // Operand expression
    n.field1 = 0;
    n.field2 = 0;
    n.field3 = 0;

    return idx;
}

// Create a dereference expression node: expr.*
// field0: operand node index (the pointer expression)
fn node_deref(pool: *NodePool, operand: i64, start: i64, end: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let n: *Node = pool.nodes + idx;
    n.kind = NodeKind.DerefExpr;
    n.start = start;
    n.end = end;
    n.field0 = operand;         // Pointer expression
    n.field1 = 0;
    n.field2 = 0;
    n.field3 = 0;

    return idx;
}

// Create an assignment expression node: target = value
// field0: target (identifier node index - the variable being assigned)
// field1: value (expression node index - the value being assigned)
fn node_assign(pool: *NodePool, target: i64, value: i64, start: i64, end: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let n: *Node = pool.nodes + idx;
    n.kind = NodeKind.AssignExpr;
    n.start = start;
    n.end = end;
    n.field0 = target;          // Target variable
    n.field1 = value;           // Value expression
    n.field2 = 0;
    n.field3 = 0;

    return idx;
}

// ============================================================================
// Sprint D: Imports and Constants
// Following Go's cmd/compile/internal/syntax/nodes.go patterns
// ============================================================================

// Create an import declaration node: import "path";
// field0: path_start (offset in source, after opening quote)
// field1: path_len (length of path string, excluding quotes)
fn node_import_decl(pool: *NodePool, path_start: i64, path_len: i64, start: i64, end: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let n: *Node = pool.nodes + idx;
    n.kind = NodeKind.ImportDecl;
    n.start = start;
    n.end = end;
    n.field0 = path_start;      // Import path offset (after quote)
    n.field1 = path_len;        // Import path length
    n.field2 = 0;
    n.field3 = 0;

    return idx;
}

// Create a const declaration node: const NAME = expr;
// field0: name_start
// field1: name_len
// field2: type_handle (-1 if no type annotation)
// field3: init_expr node index
fn node_const_decl(pool: *NodePool, name_start: i64, name_len: i64,
                   type_handle: i64, init_expr: i64, start: i64, end: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let n: *Node = pool.nodes + idx;
    n.kind = NodeKind.ConstDecl;
    n.start = start;
    n.end = end;
    n.field0 = name_start;      // Constant name offset
    n.field1 = name_len;        // Constant name length
    n.field2 = type_handle;     // Type (-1 if inferred)
    n.field3 = init_expr;       // Initializer expression

    return idx;
}

// ============================================================================
// Sprint B: Struct/Enum Declarations
// Following Go's cmd/compile/internal/syntax/nodes.go patterns
// ============================================================================

// Create a struct declaration node
// struct Name { field1: type1; field2: type2; }
// field0: name_start (offset in source)
// field1: name_len
// field2: fields_start (index in children array)
// field3: fields_count
fn node_struct_decl(pool: *NodePool, name_start: i64, name_len: i64,
                    fields_start: i64, fields_count: i64,
                    start: i64, end: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let n: *Node = pool.nodes + idx;
    n.kind = NodeKind.StructDecl;
    n.start = start;
    n.end = end;
    n.field0 = name_start;      // Struct name offset
    n.field1 = name_len;        // Struct name length
    n.field2 = fields_start;    // Start index in children array
    n.field3 = fields_count;    // Number of fields

    return idx;
}

// Create an enum declaration node
// enum Name { Variant1, Variant2, Variant3 }
// field0: name_start (offset in source)
// field1: name_len
// field2: variants_start (index in children array)
// field3: variants_count
fn node_enum_decl(pool: *NodePool, name_start: i64, name_len: i64,
                  variants_start: i64, variants_count: i64,
                  start: i64, end: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let n: *Node = pool.nodes + idx;
    n.kind = NodeKind.EnumDecl;
    n.start = start;
    n.end = end;
    n.field0 = name_start;      // Enum name offset
    n.field1 = name_len;        // Enum name length
    n.field2 = variants_start;  // Start index in children array
    n.field3 = variants_count;  // Number of variants

    return idx;
}

// Create a field declaration node (for struct fields)
// name: type
// field0: name_start
// field1: name_len
// field2: type_start
// field3: type_len
fn node_field_decl(pool: *NodePool, name_start: i64, name_len: i64,
                   type_start: i64, type_len: i64,
                   start: i64, end: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let n: *Node = pool.nodes + idx;
    n.kind = NodeKind.FieldDecl;
    n.start = start;
    n.end = end;
    n.field0 = name_start;      // Field name offset
    n.field1 = name_len;        // Field name length
    n.field2 = type_start;      // Type offset
    n.field3 = type_len;        // Type length

    return idx;
}

// Create a field access expression node
// expr.field or Type.Variant
// field0: base expression node index
// field1: field_name_start
// field2: field_name_len
// field3: unused
fn node_field_access(pool: *NodePool, base: i64,
                     field_start: i64, field_len: i64,
                     start: i64, end: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let n: *Node = pool.nodes + idx;
    n.kind = NodeKind.FieldAccess;
    n.start = start;
    n.end = end;
    n.field0 = base;            // Base expression
    n.field1 = field_start;     // Field name offset
    n.field2 = field_len;       // Field name length
    n.field3 = 0;

    return idx;
}

// ============================================================================
// Node Accessors
// ============================================================================

// Get node at index
fn node_get(pool: *NodePool, idx: i64) *Node {
    return pool.nodes + idx;
}

// Check if node index is valid
fn node_valid(idx: i64) bool {
    return idx != NULL_NODE;
}

// Get child node index from children array
fn node_child(pool: *NodePool, children_start: i64, offset: i64) i64 {
    let ptr: *i64 = pool.children + children_start + offset;
    return ptr.*;
}

// Add child node to children array
fn node_add_child(pool: *NodePool, child_idx: i64) i64 {
    let idx: i64 = pool.children_count;
    let ptr: *i64 = pool.children + idx;
    ptr.* = child_idx;
    pool.children_count = pool.children_count + 1;
    return idx;
}

// ============================================================================
// Node Kind Helpers
// ============================================================================

fn is_expr(kind: NodeKind) bool {
    return kind == NodeKind.IntLit or
           kind == NodeKind.StringLit or
           kind == NodeKind.Ident or
           kind == NodeKind.BinaryExpr or
           kind == NodeKind.CallExpr or
           kind == NodeKind.UnaryExpr or
           kind == NodeKind.AddressOf or
           kind == NodeKind.DerefExpr or
           kind == NodeKind.FieldAccess or
           kind == NodeKind.AssignExpr;
}

fn is_stmt(kind: NodeKind) bool {
    return kind == NodeKind.ReturnStmt or
           kind == NodeKind.ExprStmt or
           kind == NodeKind.BlockStmt or
           kind == NodeKind.IfStmt or
           kind == NodeKind.WhileStmt;
}

fn is_decl(kind: NodeKind) bool {
    return kind == NodeKind.FnDecl or
           kind == NodeKind.ParamDecl or
           kind == NodeKind.VarDecl or
           kind == NodeKind.ConstDecl or
           kind == NodeKind.StructDecl or
           kind == NodeKind.EnumDecl or
           kind == NodeKind.FieldDecl or
           kind == NodeKind.ImportDecl;
}

// ============================================================================
// BinaryOp Helpers
// ============================================================================

// Convert token to binary op (returns -1 if not a binary op token)
fn token_to_binop(tok_kind: TokenType) i64 {
    // Arithmetic
    if tok_kind == TokenType.Plus    { return 0; }   // BinaryOp.Add
    if tok_kind == TokenType.Minus   { return 1; }   // BinaryOp.Sub
    if tok_kind == TokenType.Star    { return 2; }   // BinaryOp.Mul
    if tok_kind == TokenType.Slash   { return 3; }   // BinaryOp.Div
    if tok_kind == TokenType.Percent { return 4; }   // BinaryOp.Mod

    // Comparison
    if tok_kind == TokenType.EqEq      { return 5; }  // BinaryOp.Equal
    if tok_kind == TokenType.NotEq     { return 6; }  // BinaryOp.NotEqual
    if tok_kind == TokenType.Less      { return 7; }  // BinaryOp.Less
    if tok_kind == TokenType.LessEq    { return 8; }  // BinaryOp.LessEq
    if tok_kind == TokenType.Greater   { return 9; }  // BinaryOp.Greater
    if tok_kind == TokenType.GreaterEq { return 10; } // BinaryOp.GreaterEq

    // Logical (both word and symbol forms)
    if tok_kind == TokenType.And      { return 11; }  // BinaryOp.And
    if tok_kind == TokenType.AmpAmp   { return 11; }  // BinaryOp.And (symbol form)
    if tok_kind == TokenType.Or       { return 12; }  // BinaryOp.Or
    if tok_kind == TokenType.PipePipe { return 12; }  // BinaryOp.Or (symbol form)

    return -1;
}

fn binop_from_int(val: i64) BinaryOp {
    // Arithmetic
    if val == 0 { return BinaryOp.Add; }
    if val == 1 { return BinaryOp.Sub; }
    if val == 2 { return BinaryOp.Mul; }
    if val == 3 { return BinaryOp.Div; }
    if val == 4 { return BinaryOp.Mod; }

    // Comparison
    if val == 5  { return BinaryOp.Equal; }
    if val == 6  { return BinaryOp.NotEqual; }
    if val == 7  { return BinaryOp.Less; }
    if val == 8  { return BinaryOp.LessEq; }
    if val == 9  { return BinaryOp.Greater; }
    if val == 10 { return BinaryOp.GreaterEq; }

    // Logical
    if val == 11 { return BinaryOp.And; }
    if val == 12 { return BinaryOp.Or; }

    return BinaryOp.Add;  // Default (should not happen)
}

// Convert token to unary op (returns -1 if not a unary op token)
fn token_to_unaryop(tok_kind: TokenType) i64 {
    if tok_kind == TokenType.Minus { return 0; }  // UnaryOp.Neg
    if tok_kind == TokenType.Bang  { return 1; }  // UnaryOp.Not
    if tok_kind == TokenType.Not   { return 1; }  // UnaryOp.Not (keyword form)
    if tok_kind == TokenType.Tilde { return 2; }  // UnaryOp.BitNot
    return -1;
}

fn unaryop_from_int(val: i64) UnaryOp {
    if val == 0 { return UnaryOp.Neg; }
    if val == 1 { return UnaryOp.Not; }
    if val == 2 { return UnaryOp.BitNot; }
    return UnaryOp.Neg;  // Default
}

// ============================================================================
// Operator Precedence (following Go's design)
// ============================================================================

// Precedence levels (higher = binds tighter)
const PREC_OR: i64 = 1;      // or, ||
const PREC_AND: i64 = 2;     // and, &&
const PREC_CMP: i64 = 3;     // ==, !=, <, <=, >, >=
const PREC_ADD: i64 = 4;     // +, -
const PREC_MUL: i64 = 5;     // *, /, %

// Get precedence of a binary operator token
fn token_precedence(tok_kind: TokenType) i64 {
    // Logical OR (lowest)
    if tok_kind == TokenType.Or { return PREC_OR; }
    if tok_kind == TokenType.PipePipe { return PREC_OR; }

    // Logical AND
    if tok_kind == TokenType.And { return PREC_AND; }
    if tok_kind == TokenType.AmpAmp { return PREC_AND; }

    // Comparison
    if tok_kind == TokenType.EqEq { return PREC_CMP; }
    if tok_kind == TokenType.NotEq { return PREC_CMP; }
    if tok_kind == TokenType.Less { return PREC_CMP; }
    if tok_kind == TokenType.LessEq { return PREC_CMP; }
    if tok_kind == TokenType.Greater { return PREC_CMP; }
    if tok_kind == TokenType.GreaterEq { return PREC_CMP; }

    // Additive
    if tok_kind == TokenType.Plus { return PREC_ADD; }
    if tok_kind == TokenType.Minus { return PREC_ADD; }

    // Multiplicative (highest)
    if tok_kind == TokenType.Star { return PREC_MUL; }
    if tok_kind == TokenType.Slash { return PREC_MUL; }
    if tok_kind == TokenType.Percent { return PREC_MUL; }

    return 0;  // Not a binary operator
}

// Lower Test - Tests for lower.cot
// Run with: ./zig-out/bin/cot cot0/frontend/lower_test.cot -o /tmp/lower_test && /tmp/lower_test
//
// Tests AST to IR lowering.

import "lower.cot"
// Note: ast.cot and ir.cot are imported transitively through lower.cot

// Storage arrays for tests (global to avoid stack issues)
var g_nodes: [100]Node;
var g_ir_nodes: [100]IRNode;
var g_ir_locals: [50]IRLocal;

fn main() i64 {
    let result: i64 = 0;

    result = result + test_operator_conversion();
    result = result + test_lower_int_lit();
    result = result + test_lower_binary();

    return result;
}

// ============================================================================
// Test: Operator conversion
// ============================================================================

fn test_operator_conversion() i64 {
    // Test AST op to IR op conversion
    // In lower.cot, ast ops are: Add=0, Sub=1, Mul=2, Div=3, Mod=4,
    // Equal=5, NotEqual=6, Less=7, LessEq=8, Greater=9, GreaterEq=10,
    // And=11, Or=12
    if ast_op_to_ir_op(0) != IR_OP_ADD { return 1; }  // Add
    if ast_op_to_ir_op(1) != IR_OP_SUB { return 2; }  // Sub
    if ast_op_to_ir_op(2) != IR_OP_MUL { return 3; }  // Mul
    if ast_op_to_ir_op(5) != IR_OP_EQ { return 4; }   // Equal
    if ast_op_to_ir_op(7) != IR_OP_LT { return 5; }   // Less

    // Test comparison check
    if not is_comparison_op(5) { return 10; }   // Equal
    if not is_comparison_op(6) { return 11; }   // NotEqual
    if not is_comparison_op(7) { return 12; }   // Less
    if is_comparison_op(0) { return 13; }       // Add is not comparison
    if is_comparison_op(2) { return 14; }       // Mul is not comparison

    return 0;
}

// ============================================================================
// Test: Lower integer literal
// ============================================================================

fn test_lower_int_lit() i64 {
    // Create a simple AST with one int literal node
    // Node struct: kind, start, end, field0, field1, field2, field3
    // IntLit: field0 = value

    // Use pointer access to avoid codegen issue with direct array.field access
    let node: *Node = &g_nodes[0];
    node.kind = NodeKind.IntLit;
    node.start = 0;
    node.end = 2;
    node.field0 = 42;      // value
    node.field1 = 0;
    node.field2 = 0;
    node.field3 = 0;

    // Create lowerer
    var l: Lowerer = undefined;
    lowerer_init(&l,
                 &g_nodes[0], 1,
                 null, 0,
                 &g_ir_nodes[0], 100,
                 &g_ir_locals[0], 50);

    // Create a function builder manually for testing
    var fb: FuncBuilder = undefined;
    func_builder_init(&fb, 0, 4, TYPE_I64,
                      &g_ir_locals[0], 50,
                      &g_ir_nodes[0], 100);
    l.current_func = &fb;

    // Lower the int literal
    let result: i64 = lower_expr(&l, &g_nodes[0]);

    // Should have emitted a ConstInt node
    if result != 0 { return 20; }  // First node at index 0
    if fb.nodes_count != 1 { return 21; }

    let ir_node: *IRNode = &g_ir_nodes[0];
    if ir_node.kind != IRNodeKind.ConstInt { return 22; }
    if ir_node.value != 42 { return 23; }

    return 0;
}

// ============================================================================
// Test: Lower binary expression
// ============================================================================

fn test_lower_binary() i64 {
    // Create AST for: 10 + 20
    // Node 0: IntLit(10)
    // Node 1: IntLit(20)
    // Node 2: BinaryExpr(+, left=0, right=1)

    // IntLit: field0 = value
    let n0: *Node = &g_nodes[0];
    n0.kind = NodeKind.IntLit;
    n0.start = 0;
    n0.end = 2;
    n0.field0 = 10;      // value
    n0.field1 = 0;
    n0.field2 = 0;
    n0.field3 = 0;

    let n1: *Node = &g_nodes[1];
    n1.kind = NodeKind.IntLit;
    n1.start = 5;
    n1.end = 7;
    n1.field0 = 20;      // value
    n1.field1 = 0;
    n1.field2 = 0;
    n1.field3 = 0;

    // BinaryExpr: field0 = left, field1 = right, field2 = op
    // Op 0 = Add
    let n2: *Node = &g_nodes[2];
    n2.kind = NodeKind.BinaryExpr;
    n2.start = 0;
    n2.end = 7;
    n2.field0 = 0;       // left = node 0
    n2.field1 = 1;       // right = node 1
    n2.field2 = 0;       // op = Add (0)
    n2.field3 = 0;

    // Create lowerer
    var l: Lowerer = undefined;
    lowerer_init(&l,
                 &g_nodes[0], 3,
                 null, 0,
                 &g_ir_nodes[0], 100,
                 &g_ir_locals[0], 50);

    // Create function builder
    var fb: FuncBuilder = undefined;
    func_builder_init(&fb, 0, 4, TYPE_I64,
                      &g_ir_locals[0], 50,
                      &g_ir_nodes[0], 100);
    l.current_func = &fb;

    // Lower the binary expression
    let result: i64 = lower_expr(&l, &g_nodes[2]);

    // Should have emitted 3 nodes: ConstInt(10), ConstInt(20), Binary(+)
    if fb.nodes_count != 3 { return 30; }
    if result != 2 { return 31; }  // Binary node at index 2

    // Check the nodes
    let ir0: *IRNode = &g_ir_nodes[0];
    if ir0.kind != IRNodeKind.ConstInt { return 32; }
    if ir0.value != 10 { return 33; }

    let ir1: *IRNode = &g_ir_nodes[1];
    if ir1.kind != IRNodeKind.ConstInt { return 34; }
    if ir1.value != 20 { return 35; }

    let ir2: *IRNode = &g_ir_nodes[2];
    if ir2.kind != IRNodeKind.Binary { return 36; }
    if ir2.op != IR_OP_ADD { return 37; }
    if ir2.left != 0 { return 38; }
    if ir2.right != 1 { return 39; }

    return 0;
}

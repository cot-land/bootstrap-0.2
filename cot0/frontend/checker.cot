// Cot0 Type Checker
// Minimal type checking for: i64, bool, void, functions
//
// Design follows Go's go/types package patterns:
// - Multi-phase: collect declarations, then check bodies
// - Scope hierarchy with parent chain for name lookup
// - Symbol table for tracking declared names
//
// Reference: ~/learning/go/src/cmd/compile/internal/types2/
// Reference: bootstrap-0.2/src/frontend/checker.zig

import "token.cot"
import "types.cot"
import "ast.cot"

// ============================================================================
// Symbol Kinds
// ============================================================================

enum SymbolKind {
    Variable,
    Constant,
    Function,
    TypeName,
    Parameter,
}

// ============================================================================
// Symbol (Go's Object)
// ============================================================================

struct Symbol {
    name_start: i64,     // Name offset in source
    name_len: i64,       // Name length
    kind: SymbolKind,    // What kind of symbol
    type_idx: i64,       // Type index from TypePool
    node_idx: i64,       // AST node where defined
    mutable: bool,       // var vs let/const
    is_extern: bool,     // extern fn?
    const_value: i64,    // Value for constants (-1 if not const)
}

fn symbol_new(name_start: i64, name_len: i64, kind: SymbolKind, type_idx: i64, node_idx: i64, mutable: bool) Symbol {
    return Symbol{
        .name_start = name_start,
        .name_len = name_len,
        .kind = kind,
        .type_idx = type_idx,
        .node_idx = node_idx,
        .mutable = mutable,
        .is_extern = false,
        .const_value = -1,
    };
}

fn symbol_new_const(name_start: i64, name_len: i64, type_idx: i64, node_idx: i64, value: i64) Symbol {
    return Symbol{
        .name_start = name_start,
        .name_len = name_len,
        .kind = SymbolKind.Constant,
        .type_idx = type_idx,
        .node_idx = node_idx,
        .mutable = false,
        .is_extern = false,
        .const_value = value,
    };
}

fn symbol_new_extern(name_start: i64, name_len: i64, kind: SymbolKind, type_idx: i64, node_idx: i64) Symbol {
    return Symbol{
        .name_start = name_start,
        .name_len = name_len,
        .kind = kind,
        .type_idx = type_idx,
        .node_idx = node_idx,
        .mutable = false,
        .is_extern = true,
        .const_value = -1,
    };
}

// ============================================================================
// Scope (Go's Scope)
// ============================================================================

const MAX_SYMBOLS: i64 = 1000;

struct Scope {
    symbols: *Symbol,       // Array of symbols
    count: i64,             // Number of symbols in this scope
    parent_idx: i64,        // Parent scope index (-1 for none)
}

// ============================================================================
// Scope Pool
// ============================================================================

const MAX_SCOPES: i64 = 100;

struct ScopePool {
    scopes: *Scope,         // Array of scopes
    count: i64,             // Number of scopes
    symbols: *Symbol,       // Global symbol storage
    symbols_count: i64,     // Total symbols allocated
}

fn scope_pool_init(pool: *ScopePool) {
    pool.count = 0;
    pool.symbols_count = 0;
}

fn scope_new(pool: *ScopePool, parent_idx: i64) i64 {
    let idx: i64 = pool.count;
    pool.count = pool.count + 1;

    let s: *Scope = pool.scopes + idx;
    s.symbols = pool.symbols + pool.symbols_count;
    s.count = 0;
    s.parent_idx = parent_idx;

    return idx;
}

fn scope_define(pool: *ScopePool, scope_idx: i64, sym: Symbol) {
    let s: *Scope = pool.scopes + scope_idx;
    let sym_ptr: *Symbol = s.symbols + s.count;
    sym_ptr.* = sym;
    s.count = s.count + 1;
    pool.symbols_count = pool.symbols_count + 1;
}

// Look up symbol in scope and parents
// Returns the symbol's type index, or -1 if not found
fn scope_lookup_type(pool: *ScopePool, scope_idx: i64, source: *u8, name_start: i64, name_len: i64) i64 {
    var current_idx: i64 = scope_idx;

    while current_idx >= 0 {
        let s: *Scope = pool.scopes + current_idx;

        // Search symbols in this scope
        var i: i64 = 0;
        while i < s.count {
            let sym: *Symbol = s.symbols + i;
            if names_equal(source, sym.name_start, sym.name_len, source, name_start, name_len) {
                return sym.type_idx;
            }
            i = i + 1;
        }

        current_idx = s.parent_idx;
    }

    return -1;  // Not found
}

// Check if two names are equal
fn names_equal(src1: *u8, start1: i64, len1: i64, src2: *u8, start2: i64, len2: i64) bool {
    if len1 != len2 { return false; }

    var i: i64 = 0;
    while i < len1 {
        let c1: u8 = (src1 + start1 + i).*;
        let c2: u8 = (src2 + start2 + i).*;
        if c1 != c2 { return false; }
        i = i + 1;
    }

    return true;
}

// ============================================================================
// Checker State
// ============================================================================

struct Checker {
    type_pool: *TypePool,   // Type registry
    scope_pool: *ScopePool, // Scope pool
    ast_pool: *NodePool,    // AST nodes
    source: *u8,            // Source text
    current_scope: i64,     // Current scope index
    return_type: i64,       // Expected return type for current function
    in_loop: bool,          // Inside a loop?
    error_count: i64,       // Number of errors found
}

fn checker_init(chk: *Checker, type_pool: *TypePool, scope_pool: *ScopePool,
                ast_pool: *NodePool, source: *u8) {
    chk.type_pool = type_pool;
    chk.scope_pool = scope_pool;
    chk.ast_pool = ast_pool;
    chk.source = source;
    chk.current_scope = scope_new(scope_pool, -1);  // Global scope
    chk.return_type = 12;  // 12 = 12 (workaround for BUG-017)
    chk.in_loop = false;
    chk.error_count = 0;
}

// ============================================================================
// Type Checking - Expressions
// ============================================================================

// Check an expression and return its type
fn check_expr(chk: *Checker, node_idx: i64) i64 {
    if node_idx < 0 { return 0; }  // 0 = 0

    let node: *Node = node_get(chk.ast_pool, node_idx);

    // IntLit -> i64
    if node.kind == NodeKind.IntLit {
        return 5;  // 5 = 5
    }

    // Ident -> lookup in scope
    if node.kind == NodeKind.Ident {
        let name_start: i64 = node.field0;
        let name_len: i64 = node.field1;

        let type_idx: i64 = scope_lookup_type(chk.scope_pool, chk.current_scope,
                                               chk.source, name_start, name_len);

        // Check if symbol was found (-1 means not found)
        if type_idx < 0 {
            chk.error_count = chk.error_count + 1;
            return 0;  // TYPE_INVALID
        }

        return type_idx;
    }

    // BinaryExpr -> check both operands
    if node.kind == NodeKind.BinaryExpr {
        let left: i64 = node.field0;
        let right: i64 = node.field1;
        let op: i64 = node.field2;

        let left_type: i64 = check_expr(chk, left);
        let right_type: i64 = check_expr(chk, right);

        // For arithmetic ops, both must be numeric
        if op == 0 or op == 1 or op == 2 or op == 3 {  // Add, Sub, Mul, Div
            if not is_numeric(chk.type_pool, left_type) {
                chk.error_count = chk.error_count + 1;
                return 0;
            }
            if not is_numeric(chk.type_pool, right_type) {
                chk.error_count = chk.error_count + 1;
                return 0;
            }
            // Result is the same type (simplified - assume i64)
            return left_type;
        }

        return 0;
    }

    // CallExpr -> check callee is function, check args
    if node.kind == NodeKind.CallExpr {
        let callee: i64 = node.field0;
        let args_start: i64 = node.field1;
        let args_count: i64 = node.field2;

        let callee_type: i64 = check_expr(chk, callee);
        if not is_func(chk.type_pool, callee_type) {
            chk.error_count = chk.error_count + 1;
            return 0;
        }

        // Get return type of function
        return type_ret(chk.type_pool, callee_type);
    }

    return 0;
}

// ============================================================================
// Type Checking - Statements
// ============================================================================

// Check a statement, return true if control always returns
fn check_stmt(chk: *Checker, node_idx: i64) bool {
    if node_idx < 0 { return false; }

    let node: *Node = node_get(chk.ast_pool, node_idx);

    // ReturnStmt -> check value matches return type
    if node.kind == NodeKind.ReturnStmt {
        let value: i64 = node.field0;

        if value >= 0 {
            let value_type: i64 = check_expr(chk, value);
            if not is_assignable(chk.type_pool, value_type, chk.return_type) {
                chk.error_count = chk.error_count + 1;
            }
        } else {
            // No value - must be void return
            if chk.return_type != 12 {
                chk.error_count = chk.error_count + 1;
            }
        }

        return true;  // Always returns
    }

    // ExprStmt -> just check the expression
    if node.kind == NodeKind.ExprStmt {
        let expr: i64 = node.field0;
        check_expr(chk, expr);
        return false;
    }

    // BlockStmt -> check each statement
    if node.kind == NodeKind.BlockStmt {
        let stmts_start: i64 = node.field0;
        let stmts_count: i64 = node.field1;

        var i: i64 = 0;
        var has_return: bool = false;
        while i < stmts_count {
            let stmt_idx: i64 = node_child(chk.ast_pool, stmts_start, i);
            if check_stmt(chk, stmt_idx) {
                has_return = true;
            }
            i = i + 1;
        }

        return has_return;
    }

    return false;
}

// ============================================================================
// Type Checking - Declarations
// ============================================================================

// Check a function declaration
fn check_fn_decl(chk: *Checker, node_idx: i64) {
    let node: *Node = node_get(chk.ast_pool, node_idx);
    if node.kind != NodeKind.FnDecl { return; }

    let name_start: i64 = node.field0;
    let name_len: i64 = node.field1;
    let params_start: i64 = node.field2;
    let params_count: i64 = node.field3;

    // Create new scope for function body
    let fn_scope: i64 = scope_new(chk.scope_pool, chk.current_scope);
    let old_scope: i64 = chk.current_scope;
    chk.current_scope = fn_scope;

    // TODO: Add parameters to function scope
    // TODO: Get return type from function declaration
    // For now, assume i64 return type
    let old_return: i64 = chk.return_type;
    chk.return_type = 5;

    // TODO: Check function body

    // Restore scope
    chk.current_scope = old_scope;
    chk.return_type = old_return;
}

// ============================================================================
// Helper Functions
// ============================================================================

// Check if result is valid (no errors)
fn checker_ok(chk: *Checker) bool {
    return chk.error_count == 0;
}

// Get error count
fn checker_errors(chk: *Checker) i64 {
    return chk.error_count;
}

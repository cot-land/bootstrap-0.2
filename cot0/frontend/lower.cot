// AST-to-IR Lowering Pass
// Transforms parsed AST into flat IR suitable for SSA construction.
//
// Reference: src/frontend/lower.zig (Zig bootstrap)
// Reference: ~/learning/go/src/cmd/compile/internal/ssagen/ssa.go
//
// Design (following Go's walk patterns):
// 1. Walk AST in dependency order (declarations first, then expressions)
// 2. Emit IR nodes using FuncBuilder
// 3. Track loop context for break/continue
// 4. Handle control flow with explicit blocks

import "ast.cot"
import "ir.cot"
import "types.cot"

// ============================================================================
// Lowerer Context
// ============================================================================

// Compile-time constant entry
struct ConstEntry {
    name_start: i64,
    name_len: i64,
    value: i64,
}

const MAX_CONSTANTS: i64 = 500;

struct Lowerer {
    // AST to lower (pointer to Node array + count)
    nodes: *Node,
    nodes_count: i64,

    // Children array for lists (args, stmts, params)
    children: *i64,
    children_count: i64,

    // Source text for name extraction
    source: *u8,
    source_len: i64,

    // Current function being lowered
    current_func: *FuncBuilder,

    // IR output storage (externally allocated)
    ir_nodes: *IRNode,
    ir_nodes_cap: i64,
    ir_nodes_count: i64,

    ir_locals: *IRLocal,
    ir_locals_cap: i64,
    ir_locals_count: i64,

    // Function metadata (externally allocated)
    ir_funcs: *IRFunc,
    ir_funcs_cap: i64,
    ir_funcs_count: i64,

    // Compile-time constants
    constants: *ConstEntry,
    constants_count: i64,
    constants_cap: i64,
}

fn lowerer_init(l: *Lowerer,
                nodes: *Node, nodes_count: i64,
                children: *i64, children_count: i64,
                source: *u8, source_len: i64,
                ir_nodes: *IRNode, ir_nodes_cap: i64,
                ir_locals: *IRLocal, ir_locals_cap: i64,
                ir_funcs: *IRFunc, ir_funcs_cap: i64,
                constants: *ConstEntry, constants_cap: i64) {
    l.nodes = nodes;
    l.nodes_count = nodes_count;
    l.children = children;
    l.children_count = children_count;
    l.source = source;
    l.source_len = source_len;
    l.current_func = null;
    l.ir_nodes = ir_nodes;
    l.ir_nodes_cap = ir_nodes_cap;
    l.ir_nodes_count = 0;
    l.ir_locals = ir_locals;
    l.ir_locals_cap = ir_locals_cap;
    l.ir_locals_count = 0;
    l.ir_funcs = ir_funcs;
    l.ir_funcs_cap = ir_funcs_cap;
    l.ir_funcs_count = 0;
    l.constants = constants;
    l.constants_count = 0;
    l.constants_cap = constants_cap;
}

// ============================================================================
// Main Entry Point
// ============================================================================

// Look up a constant by name, return its value or -1 if not found
fn lowerer_lookup_const(l: *Lowerer, name_start: i64, name_len: i64) i64 {
    var i: i64 = 0;
    while i < l.constants_count {
        let c: *ConstEntry = l.constants + i;
        if names_equal(l.source, c.name_start, c.name_len, name_start, name_len) {
            return c.value;
        }
        i = i + 1;
    }
    return -1;  // Not found (note: this limits const values to non-negative!)
}

// Check if a constant exists
fn lowerer_has_const(l: *Lowerer, name_start: i64, name_len: i64) bool {
    var i: i64 = 0;
    while i < l.constants_count {
        let c: *ConstEntry = l.constants + i;
        if names_equal(l.source, c.name_start, c.name_len, name_start, name_len) {
            return true;
        }
        i = i + 1;
    }
    return false;
}

// Add a constant to the table
fn lowerer_add_const(l: *Lowerer, name_start: i64, name_len: i64, value: i64) {
    if l.constants_count >= l.constants_cap {
        return;
    }
    let c: *ConstEntry = l.constants + l.constants_count;
    c.name_start = name_start;
    c.name_len = name_len;
    c.value = value;
    l.constants_count = l.constants_count + 1;
}

// Process a const declaration
fn lower_const_decl(l: *Lowerer, node: *Node) {
    // ConstDecl fields:
    // field0 = name_start
    // field1 = name_len
    // field2 = type_handle (-1 if inferred)
    // field3 = init_expr node index

    let name_start: i64 = node.field0;
    let name_len: i64 = node.field1;
    let init_expr_idx: i64 = node.field3;

    // Evaluate the initializer (must be a constant expression)
    if init_expr_idx >= 0 {
        let init_node: *Node = l.nodes + init_expr_idx;
        if init_node.kind == NodeKind.IntLit {
            // Simple integer literal
            lowerer_add_const(l, name_start, name_len, init_node.field0);
        }
        // TODO: Support more complex constant expressions
    }
}

// Lower all declarations in the AST
fn lowerer_lower_all(l: *Lowerer) i64 {
    // First pass: process const declarations
    var i: i64 = 0;
    while i < l.nodes_count {
        let node: *Node = l.nodes + i;
        if node.kind == NodeKind.ConstDecl {
            lower_const_decl(l, node);
        }
        i = i + 1;
    }

    // Second pass: process function declarations
    i = 0;
    while i < l.nodes_count {
        let node: *Node = l.nodes + i;
        if node.kind == NodeKind.FnDecl {
            lower_fn_decl(l, node);
        }
        i = i + 1;
    }
    return l.ir_nodes_count;
}

// ============================================================================
// Declaration Lowering
// ============================================================================

fn lower_fn_decl(l: *Lowerer, node: *Node) {
    // FnDecl fields:
    // field0 = name_start
    // field1 = name_len
    // field2 = params_start
    // field3 = params_count
    // field4 = ret_type
    // field5 = body (block node index)

    // Record starting positions for this function
    let nodes_start: i64 = l.ir_nodes_count;
    let locals_start: i64 = l.ir_locals_count;

    // Create function builder
    var fb: FuncBuilder = undefined;
    func_builder_init(&fb,
                      node.field0, node.field1,  // name_start, name_len
                      TYPE_I64,                   // return type (simplified for now)
                      l.ir_locals + l.ir_locals_count,
                      l.ir_locals_cap - l.ir_locals_count,
                      l.ir_nodes + l.ir_nodes_count,
                      l.ir_nodes_cap - l.ir_nodes_count);

    l.current_func = &fb;

    // Add function parameters as locals (before lowering body so they're available)
    let params_start: i64 = node.field2;
    let params_count: i64 = node.field3;
    var param_idx: i64 = 0;
    while param_idx < params_count {
        // Get param node index from children array
        let child_ptr: *i64 = l.children + params_start + param_idx;
        let param_node_idx: i64 = child_ptr.*;
        let param_node: *Node = l.nodes + param_node_idx;

        // ParamDecl: field0=name_start, field1=name_len, field2=type_start, field3=type_len
        func_builder_add_param(&fb,
                               param_node.field0, param_node.field1,
                               TYPE_I64, param_idx);
        param_idx = param_idx + 1;
    }

    // Lower the function body (field5 is the body block node index)
    let body_idx: i64 = node.field5;
    if body_idx >= 0 {
        let body_node: *Node = l.nodes + body_idx;
        lower_block(l, body_node);
    }

    // Update counts from function builder
    l.ir_nodes_count = l.ir_nodes_count + fb.nodes_count;
    l.ir_locals_count = l.ir_locals_count + fb.locals_count;

    // Record function metadata
    if l.ir_funcs_count < l.ir_funcs_cap {
        let func_ptr: *IRFunc = l.ir_funcs + l.ir_funcs_count;
        func_ptr.name_start = node.field0;
        func_ptr.name_len = node.field1;
        func_ptr.return_type = TYPE_I64;
        func_ptr.nodes_start = nodes_start;
        func_ptr.nodes_count = fb.nodes_count;
        func_ptr.locals_start = locals_start;
        func_ptr.locals_count = fb.locals_count;
        func_ptr.code_offset = 0;
        l.ir_funcs_count = l.ir_funcs_count + 1;
    }

    l.current_func = null;
}

// ============================================================================
// Statement Lowering
// ============================================================================

fn lower_block(l: *Lowerer, node: *Node) {
    lower_block_check_terminated(l, node);
}

// Lower a block and return whether it ends with a terminator (return/branch)
fn lower_block_check_terminated(l: *Lowerer, node: *Node) bool {
    // BlockStmt fields:
    // field0 = stmts_start (index in children array)
    // field1 = stmts_count

    let stmts_start: i64 = node.field0;
    let stmts_count: i64 = node.field1;

    var terminated: bool = false;

    // Iterate over statements in the block
    var i: i64 = 0;
    while i < stmts_count {
        // Get statement node index from children array
        let child_ptr: *i64 = l.children + stmts_start + i;
        let stmt_idx: i64 = child_ptr.*;
        let stmt_node: *Node = l.nodes + stmt_idx;

        // Check if this is a terminator
        if stmt_node.kind == NodeKind.ReturnStmt {
            terminated = true;
        }

        // Lower the statement
        lower_stmt(l, stmt_node);

        i = i + 1;
    }

    return terminated;
}

fn lower_stmt(l: *Lowerer, node: *Node) {
    if node.kind == NodeKind.ReturnStmt {
        lower_return(l, node);
    } else if node.kind == NodeKind.VarDecl {
        lower_var_decl(l, node);
    } else if node.kind == NodeKind.IfStmt {
        lower_if(l, node);
    } else if node.kind == NodeKind.WhileStmt {
        lower_while(l, node);
    } else if node.kind == NodeKind.ExprStmt {
        lower_expr_stmt(l, node);
    }
}

fn lower_expr_stmt(l: *Lowerer, node: *Node) {
    // ExprStmt fields:
    // field0 = expression node index
    if node.field0 >= 0 {
        let expr_node: *Node = l.nodes + node.field0;
        lower_expr(l, expr_node);
    }
}

fn lower_return(l: *Lowerer, node: *Node) {
    // ReturnStmt fields:
    // field0 = value (node index, -1 if void)

    let fb: *FuncBuilder = l.current_func;
    if fb == null {
        return;
    }

    // Lower return value expression
    var value_idx: i64 = NULL_NODE;
    if node.field0 >= 0 {
        let expr: *Node = l.nodes + node.field0;
        value_idx = lower_expr(l, expr);
    }

    // Emit return node
    var ret_node: IRNode = ir_node_new(IRNodeKind.Return, TYPE_VOID);
    ret_node.left = value_idx;
    func_builder_emit(fb, ret_node);
}

fn lower_var_decl(l: *Lowerer, node: *Node) {
    // VarDecl fields:
    // field0 = is_let (1 = let/immutable, 0 = var/mutable)
    // field1 = name_start
    // field2 = name_len
    // field3 = init_expr node index

    let fb: *FuncBuilder = l.current_func;
    if fb == null {
        return;
    }

    // is_mutable = NOT is_let (var = mutable, let = immutable)
    let is_mutable: bool = node.field0 == 0;
    let local_idx: i64 = func_builder_add_local(fb, node.field1, node.field2, TYPE_I64, is_mutable);

    // If there's an initializer, emit store
    if node.field3 >= 0 {
        let init_expr: *Node = l.nodes + node.field3;
        let value_idx: i64 = lower_expr(l, init_expr);
        func_builder_emit_store_local(fb, local_idx, value_idx);
    }
}

fn lower_if(l: *Lowerer, node: *Node) {
    // IfStmt fields:
    // field0 = condition expr node index
    // field1 = then body node index
    // field2 = else body node index (-1 if none)

    let fb: *FuncBuilder = l.current_func;
    if fb == null { return; }

    // Create blocks
    let then_block: i64 = func_builder_new_block(fb);
    var else_block: i64 = -1;
    if node.field2 >= 0 {
        else_block = func_builder_new_block(fb);
    }
    let merge_block: i64 = func_builder_new_block(fb);

    // Lower condition
    let cond_node: *Node = l.nodes + node.field0;
    let cond_idx: i64 = lower_expr(l, cond_node);

    // Emit branch
    var target_else: i64 = merge_block;
    if else_block >= 0 {
        target_else = else_block;
    }
    func_builder_emit_branch(fb, cond_idx, then_block, target_else);

    // Lower then body
    func_builder_set_block(fb, then_block);
    let then_node: *Node = l.nodes + node.field1;
    let then_terminated: bool = lower_block_check_terminated(l, then_node);
    if not then_terminated {
        func_builder_emit_jump(fb, merge_block);
    }

    // Lower else body if present
    if else_block >= 0 {
        func_builder_set_block(fb, else_block);
        let else_node: *Node = l.nodes + node.field2;
        let else_terminated: bool = lower_block_check_terminated(l, else_node);
        if not else_terminated {
            func_builder_emit_jump(fb, merge_block);
        }
    }

    // Continue in merge block
    func_builder_set_block(fb, merge_block);
}

fn lower_while(l: *Lowerer, node: *Node) {
    // WhileStmt fields:
    // field0 = condition expr
    // field1 = body

    let fb: *FuncBuilder = l.current_func;
    if fb == null { return; }

    // Create blocks: header (condition), body, exit
    let header_block: i64 = func_builder_new_block(fb);
    let body_block: i64 = func_builder_new_block(fb);
    let exit_block: i64 = func_builder_new_block(fb);

    // Jump from current block to header
    func_builder_emit_jump(fb, header_block);

    // Header block: evaluate condition, branch to body or exit
    func_builder_set_block(fb, header_block);
    let cond_node: *Node = l.nodes + node.field0;
    let cond_idx: i64 = lower_expr(l, cond_node);
    func_builder_emit_branch(fb, cond_idx, body_block, exit_block);

    // Body block: execute body, jump back to header
    func_builder_set_block(fb, body_block);
    let body_node: *Node = l.nodes + node.field1;
    let body_terminated: bool = lower_block_check_terminated(l, body_node);
    if not body_terminated {
        func_builder_emit_jump(fb, header_block);
    }

    // Continue in exit block
    func_builder_set_block(fb, exit_block);
}

// ============================================================================
// Expression Lowering
// ============================================================================

fn lower_expr(l: *Lowerer, node: *Node) i64 {
    let fb: *FuncBuilder = l.current_func;
    if fb == null {
        return NULL_NODE;
    }

    if node.kind == NodeKind.IntLit {
        return lower_int_lit(l, node);
    } else if node.kind == NodeKind.StringLit {
        return lower_string_lit(l, node);
    } else if node.kind == NodeKind.Ident {
        return lower_ident(l, node);
    } else if node.kind == NodeKind.BinaryExpr {
        return lower_binary(l, node);
    } else if node.kind == NodeKind.UnaryExpr {
        return lower_unary(l, node);
    } else if node.kind == NodeKind.CallExpr {
        return lower_call(l, node);
    } else if node.kind == NodeKind.AssignExpr {
        return lower_assign(l, node);
    } else if node.kind == NodeKind.AddressOf {
        return lower_address_of(l, node);
    } else if node.kind == NodeKind.DerefExpr {
        return lower_deref(l, node);
    }

    return NULL_NODE;
}

fn lower_int_lit(l: *Lowerer, node: *Node) i64 {
    // IntLit fields:
    // field0 = value (the integer value)

    let fb: *FuncBuilder = l.current_func;
    return func_builder_emit_const_int(fb, node.field0);
}

fn lower_string_lit(l: *Lowerer, node: *Node) i64 {
    // StringLit fields:
    // field0 = string_start (offset in source, after opening quote)
    // field1 = string_len (length of string content, excluding quotes)

    let fb: *FuncBuilder = l.current_func;
    return func_builder_emit_const_string(fb, node.field0, node.field1);
}

// Compare two strings in source by their positions
fn names_equal(source: *u8, start1: i64, len1: i64, start2: i64, len2: i64) bool {
    if len1 != len2 { return false; }
    var i: i64 = 0;
    while i < len1 {
        let p1: *u8 = source + start1 + i;
        let p2: *u8 = source + start2 + i;
        if p1.* != p2.* { return false; }
        i = i + 1;
    }
    return true;
}

fn lower_ident(l: *Lowerer, node: *Node) i64 {
    // Ident fields:
    // field0 = name_start
    // field1 = name_len

    let fb: *FuncBuilder = l.current_func;

    // First check if this is a constant
    if lowerer_has_const(l, node.field0, node.field1) {
        let const_value: i64 = lowerer_lookup_const(l, node.field0, node.field1);
        return func_builder_emit_const_int(fb, const_value);
    }

    // Look up local variable by name - compare actual source content
    var i: i64 = 0;
    while i < fb.locals_count {
        let local: *IRLocal = fb.locals + i;
        if names_equal(l.source, local.name_start, local.name_len, node.field0, node.field1) {
            return func_builder_emit_load_local(fb, i);
        }
        i = i + 1;
    }

    // Not found - return null node
    return NULL_NODE;
}

fn lower_binary(l: *Lowerer, node: *Node) i64 {
    // BinaryExpr fields:
    // field0 = left operand (node index)
    // field1 = right operand (node index)
    // field2 = op (BinaryOp as integer)

    let fb: *FuncBuilder = l.current_func;

    // Lower left and right operands
    let left_node: *Node = l.nodes + node.field0;
    let right_node: *Node = l.nodes + node.field1;

    let left_idx: i64 = lower_expr(l, left_node);
    let right_idx: i64 = lower_expr(l, right_node);

    // Convert AST operator to IR operator
    let ir_op: i64 = ast_op_to_ir_op(node.field2);

    // Determine result type
    let result_type: i64 = TYPE_I64;
    if is_comparison_op(node.field2) {
        result_type = TYPE_BOOL;
    }

    return func_builder_emit_binary(fb, ir_op, left_idx, right_idx, result_type);
}

fn lower_unary(l: *Lowerer, node: *Node) i64 {
    // UnaryExpr fields:
    // field0 = operand (node index)
    // field1 = op (UnaryOp as integer)

    let fb: *FuncBuilder = l.current_func;

    let operand_node: *Node = l.nodes + node.field0;
    let operand_idx: i64 = lower_expr(l, operand_node);

    // Convert AST operator to IR operator
    let ir_op: i64 = ast_unary_op_to_ir_op(node.field1);

    return func_builder_emit_unary(fb, ir_op, operand_idx, TYPE_I64);
}

fn lower_call(l: *Lowerer, node: *Node) i64 {
    // CallExpr fields:
    // field0 = callee (node index)
    // field1 = args_start (index in children array)
    // field2 = args_count

    let fb: *FuncBuilder = l.current_func;
    if fb == null { return NULL_NODE; }

    // Get callee - must be an identifier for now
    let callee_node: *Node = l.nodes + node.field0;
    if callee_node.kind != NodeKind.Ident {
        return NULL_NODE;  // Only simple function calls supported
    }

    let func_name_start: i64 = callee_node.field0;
    let func_name_len: i64 = callee_node.field1;
    let args_start: i64 = node.field1;
    let args_count: i64 = node.field2;

    // Lower each argument and store IR indices
    // For simplicity, we store the first arg index and expect args to be consecutive
    var first_arg_idx: i64 = -1;
    var i: i64 = 0;
    while i < args_count {
        let arg_child_ptr: *i64 = l.children + args_start + i;
        let arg_node_idx: i64 = arg_child_ptr.*;
        let arg_node: *Node = l.nodes + arg_node_idx;
        let arg_ir_idx: i64 = lower_expr(l, arg_node);
        if i == 0 {
            first_arg_idx = arg_ir_idx;
        }
        i = i + 1;
    }

    // Emit Call IR node
    var call_node: IRNode = ir_node_new(IRNodeKind.Call, TYPE_I64);
    call_node.func_name_start = func_name_start;
    call_node.func_name_len = func_name_len;
    call_node.args_start = first_arg_idx;
    call_node.args_count = args_count;
    return func_builder_emit(fb, call_node);
}

fn lower_assign(l: *Lowerer, node: *Node) i64 {
    // AssignExpr fields:
    // field0 = target (identifier node or deref expr)
    // field1 = value (expression)

    let fb: *FuncBuilder = l.current_func;
    if fb == null { return NULL_NODE; }

    let target_node: *Node = l.nodes + node.field0;

    // Lower the value expression first
    let value_node: *Node = l.nodes + node.field1;
    let value_idx: i64 = lower_expr(l, value_node);

    // Handle assignment to dereferenced pointer: ptr.* = value
    if target_node.kind == NodeKind.DerefExpr {
        // Lower the pointer expression
        let ptr_operand: *Node = l.nodes + target_node.field0;
        let ptr_idx: i64 = lower_expr(l, ptr_operand);

        // Emit store through pointer
        func_builder_emit_store(fb, ptr_idx, value_idx);
        return value_idx;
    }

    // Handle simple variable assignment: x = value
    if target_node.kind == NodeKind.Ident {
        // Look up local variable by name
        var local_idx: i64 = -1;
        var i: i64 = 0;
        while i < fb.locals_count {
            let local: *IRLocal = fb.locals + i;
            if names_equal(l.source, local.name_start, local.name_len, target_node.field0, target_node.field1) {
                local_idx = i;
            }
            i = i + 1;
        }

        if local_idx < 0 {
            return NULL_NODE;  // Variable not found
        }

        // Emit store to local
        func_builder_emit_store_local(fb, local_idx, value_idx);
        return value_idx;
    }

    return NULL_NODE;  // Unsupported assignment target
}

fn lower_address_of(l: *Lowerer, node: *Node) i64 {
    // AddressOf fields:
    // field0 = operand (the expression to take address of)

    let fb: *FuncBuilder = l.current_func;
    if fb == null { return NULL_NODE; }

    let operand_node: *Node = l.nodes + node.field0;

    // For now, only support address of identifiers (local variables)
    if operand_node.kind == NodeKind.Ident {
        // Look up local variable by name
        var i: i64 = 0;
        while i < fb.locals_count {
            let local: *IRLocal = fb.locals + i;
            if names_equal(l.source, local.name_start, local.name_len,
                          operand_node.field0, operand_node.field1) {
                // Emit address of local - type is *i64 for now (TYPE_I64 + some offset for ptr)
                return func_builder_emit_addr_local(fb, i, TYPE_I64);
            }
            i = i + 1;
        }
    }

    return NULL_NODE;
}

fn lower_deref(l: *Lowerer, node: *Node) i64 {
    // DerefExpr fields:
    // field0 = operand (the pointer expression)

    let fb: *FuncBuilder = l.current_func;
    if fb == null { return NULL_NODE; }

    // Lower the pointer expression
    let operand_node: *Node = l.nodes + node.field0;
    let ptr_idx: i64 = lower_expr(l, operand_node);

    // Emit load from pointer - result type is i64 for now
    return func_builder_emit_load(fb, ptr_idx, TYPE_I64);
}

// ============================================================================
// Operator Conversion
// ============================================================================

// AST BinaryOp values (from ast.cot node_binary):
// Add=0, Sub=1, Mul=2, Div=3, Mod=4
// Equal=5, NotEqual=6, Less=7, LessEq=8, Greater=9, GreaterEq=10
// And=11, Or=12

fn ast_op_to_ir_op(ast_op: i64) i64 {
    // Map AST operators to IR operator codes
    // Arithmetic
    if ast_op == 0 { return IR_OP_ADD; }
    if ast_op == 1 { return IR_OP_SUB; }
    if ast_op == 2 { return IR_OP_MUL; }
    if ast_op == 3 { return IR_OP_DIV; }
    if ast_op == 4 { return IR_OP_MOD; }

    // Comparison
    if ast_op == 5 { return IR_OP_EQ; }
    if ast_op == 6 { return IR_OP_NE; }
    if ast_op == 7 { return IR_OP_LT; }
    if ast_op == 8 { return IR_OP_LE; }
    if ast_op == 9 { return IR_OP_GT; }
    if ast_op == 10 { return IR_OP_GE; }

    // Logical
    if ast_op == 11 { return IR_OP_AND; }
    if ast_op == 12 { return IR_OP_OR; }

    return 0;
}

// AST UnaryOp values (from ast.cot node_unary):
// Neg=0, Not=1, BitNot=2

fn ast_unary_op_to_ir_op(ast_op: i64) i64 {
    if ast_op == 0 { return IR_OP_NEG; }
    if ast_op == 1 { return IR_OP_NOT; }
    if ast_op == 2 { return IR_OP_BIT_NOT; }
    return 0;
}

// IR operator codes - must match IRBinaryOp enum in ir.cot
const IR_OP_ADD: i64 = 0;
const IR_OP_SUB: i64 = 1;
const IR_OP_MUL: i64 = 2;
const IR_OP_DIV: i64 = 3;
const IR_OP_MOD: i64 = 4;
const IR_OP_EQ: i64 = 5;
const IR_OP_NE: i64 = 6;
const IR_OP_LT: i64 = 7;
const IR_OP_LE: i64 = 8;
const IR_OP_GT: i64 = 9;
const IR_OP_GE: i64 = 10;
const IR_OP_AND: i64 = 11;
const IR_OP_OR: i64 = 12;
const IR_OP_BIT_AND: i64 = 13;
const IR_OP_BIT_OR: i64 = 14;
const IR_OP_BIT_XOR: i64 = 15;
const IR_OP_SHL: i64 = 16;
const IR_OP_SHR: i64 = 17;
const IR_OP_NEG: i64 = 18;
const IR_OP_NOT: i64 = 19;
const IR_OP_BIT_NOT: i64 = 20;

fn is_comparison_op(ast_op: i64) bool {
    // Comparison ops are 5-10 (Equal through GreaterEq)
    if ast_op >= 5 and ast_op <= 10 { return true; }
    return false;
}

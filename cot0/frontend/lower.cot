// AST-to-IR Lowering Pass
// Transforms parsed AST into flat IR suitable for SSA construction.
//
// Reference: src/frontend/lower.zig (Zig bootstrap)
// Reference: ~/learning/go/src/cmd/compile/internal/ssagen/ssa.go
//
// Design (following Go's walk patterns):
// 1. Walk AST in dependency order (declarations first, then expressions)
// 2. Emit IR nodes using FuncBuilder
// 3. Track loop context for break/continue
// 4. Handle control flow with explicit blocks

import "ast.cot"
import "ir.cot"
import "types.cot"
import "parser.cot"  // For parse_* functions

// ============================================================================
// Type Resolution
// ============================================================================
// PTYPE_* constants are defined in types.cot

// Resolve parser type handle to TypePool type index
fn resolve_type_handle(pool: *TypePool, source: *u8, type_handle: i64) i64 {
    // Basic types
    if type_handle == PTYPE_I64 { return TYPE_I64; }
    if type_handle == PTYPE_I32 { return TYPE_I32; }
    if type_handle == PTYPE_U8 { return TYPE_U8; }
    if type_handle == PTYPE_BOOL { return TYPE_BOOL; }
    if type_handle == PTYPE_VOID { return TYPE_VOID; }
    if type_handle == PTYPE_STRING { return TYPE_STRING; }

    // Pointer types: PTYPE_PTR_BASE + pointee_handle
    if type_handle >= PTYPE_PTR_BASE and type_handle < PTYPE_USER_BASE {
        let pointee_handle: i64 = type_handle - PTYPE_PTR_BASE;
        let pointee_type: i64 = resolve_type_handle(pool, source, pointee_handle);
        return TypePool_makePointer(pool, pointee_type);
    }

    // User types: PTYPE_USER_BASE + source_offset
    if type_handle >= PTYPE_USER_BASE {
        let name_start: i64 = type_handle - PTYPE_USER_BASE;
        // Calculate name length by finding end of identifier
        var name_len: i64 = 0;
        var pos: i64 = name_start;
        while true {
            let c: u8 = (source + pos).*;
            // Check if still identifier char: a-z, A-Z, 0-9, _
            if (c >= 97 and c <= 122) or (c >= 65 and c <= 90) or
               (c >= 48 and c <= 57) or c == 95 {
                name_len = name_len + 1;
                pos = pos + 1;
            } else {
                break;
            }
        }
        // Look up the struct type by name in the TypePool
        return TypePool_findByName(pool, name_start, name_len);
    }

    return TYPE_INVALID;
}

// ============================================================================
// Lowerer Context
// ============================================================================

// Compile-time constant entry
struct ConstEntry {
    name_start: i64,
    name_len: i64,
    value: i64,
}

const MAX_CONSTANTS: i64 = 2000;

// Struct field info for name-based lookup
struct StructFieldLookup {
    offset: i64,
    found: bool,
}

struct Lowerer {
    // AST to lower (pointer to Node array + count)
    nodes: *Node,
    nodes_count: i64,

    // Children array for lists (args, stmts, params)
    children: *i64,
    children_count: i64,

    // Source text for name extraction
    source: *u8,
    source_len: i64,

    // Type information for field access
    type_pool: *TypePool,

    // Current function being lowered
    current_func: *FuncBuilder,

    // IR output storage (externally allocated)
    ir_nodes: *IRNode,
    ir_nodes_cap: i64,
    ir_nodes_count: i64,

    ir_locals: *IRLocal,
    ir_locals_cap: i64,
    ir_locals_count: i64,

    // Function metadata (externally allocated)
    ir_funcs: *IRFunc,
    ir_funcs_cap: i64,
    ir_funcs_count: i64,

    // Compile-time constants
    constants: *ConstEntry,
    constants_count: i64,
    constants_cap: i64,

    // Loop context for break/continue (block indices, -1 if not in loop)
    loop_continue_block: i64,
    loop_break_block: i64,

    // Call argument indices (for non-consecutive args)
    call_args: *i64,
    call_args_count: i64,
    call_args_cap: i64,
}

fn Lowerer_init(l: *Lowerer,
                nodes: *Node, nodes_count: i64,
                children: *i64, children_count: i64,
                source: *u8, source_len: i64,
                type_pool: *TypePool,
                ir_nodes: *IRNode, ir_nodes_cap: i64,
                ir_locals: *IRLocal, ir_locals_cap: i64,
                ir_funcs: *IRFunc, ir_funcs_cap: i64,
                constants: *ConstEntry, constants_cap: i64,
                call_args: *i64, call_args_cap: i64) {
    l.nodes = nodes;
    l.nodes_count = nodes_count;
    l.children = children;
    l.children_count = children_count;
    l.source = source;
    l.source_len = source_len;
    l.type_pool = type_pool;
    l.current_func = null;
    l.ir_nodes = ir_nodes;
    l.ir_nodes_cap = ir_nodes_cap;
    l.ir_nodes_count = 0;
    l.ir_locals = ir_locals;
    l.ir_locals_cap = ir_locals_cap;
    l.ir_locals_count = 0;
    l.ir_funcs = ir_funcs;
    l.ir_funcs_cap = ir_funcs_cap;
    l.ir_funcs_count = 0;
    l.constants = constants;
    l.constants_count = 0;
    l.constants_cap = constants_cap;
    l.loop_continue_block = 0 - 1;  // -1 means not in a loop
    l.loop_break_block = 0 - 1;
    l.call_args = call_args;
    l.call_args_count = 0;
    l.call_args_cap = call_args_cap;
}

// ============================================================================
// Main Entry Point
// ============================================================================

// Look up a constant by name, return its value or -1 if not found
fn Lowerer_lookupConst(l: *Lowerer, name_start: i64, name_len: i64) i64 {
    var i: i64 = 0;
    while i < l.constants_count {
        let c: *ConstEntry = l.constants + i;
        if names_equal(l.source, c.name_start, c.name_len, name_start, name_len) {
            return c.value;
        }
        i = i + 1;
    }
    return -1;  // Not found (note: this limits const values to non-negative!)
}

// Check if a constant exists
fn Lowerer_hasConst(l: *Lowerer, name_start: i64, name_len: i64) bool {
    var i: i64 = 0;
    while i < l.constants_count {
        let c: *ConstEntry = l.constants + i;
        if names_equal(l.source, c.name_start, c.name_len, name_start, name_len) {
            return true;
        }
        i = i + 1;
    }
    return false;
}

// Add a constant to the table
fn Lowerer_addConst(l: *Lowerer, name_start: i64, name_len: i64, value: i64) {
    if l.constants_count >= l.constants_cap {
        return;
    }
    let c: *ConstEntry = l.constants + l.constants_count;
    c.name_start = name_start;
    c.name_len = name_len;
    c.value = value;
    l.constants_count = l.constants_count + 1;
}

// Find a function's return type by name
// Returns the parser type handle (PTYPE_*), or -1 if not found
// Following src/frontend/lower.zig inferExprType pattern
fn Lowerer_findFuncRetType(l: *Lowerer, name_start: i64, name_len: i64) i64 {
    var i: i64 = 0;
    while i < l.nodes_count {
        let node: *Node = l.nodes + i;
        // FnDecl: field0=name_start, field1=name_len, field4=ret_type_handle
        if node.kind == NodeKind.FnDecl {
            if names_equal(l.source, node.field0, node.field1, name_start, name_len) {
                return node.field4;  // ret_type_handle
            }
        }
        // ExternFnDecl: same field layout
        if node.kind == NodeKind.ExternFnDecl {
            if names_equal(l.source, node.field0, node.field1, name_start, name_len) {
                return node.field4;  // ret_type_handle
            }
        }
        i = i + 1;
    }
    return -1;  // Not found
}

// Check if an expression returns a slice type
// For CallExpr: looks up the function and checks its return type
fn Lowerer_exprReturnsSlice(l: *Lowerer, node: *Node) bool {
    if node.kind == NodeKind.CallExpr {
        // Get callee (must be Ident for now)
        let callee_node: *Node = l.nodes + node.field0;
        if callee_node.kind == NodeKind.Ident {
            let ret_type: i64 = Lowerer_findFuncRetType(l, callee_node.field0, callee_node.field1);
            // Check if slice type: PTYPE_SLICE_BASE = 100000
            if ret_type >= PTYPE_SLICE_BASE {
                return true;
            }
        }
    }
    return false;
}

// Process a const declaration
fn Lowerer_lowerConstDecl(l: *Lowerer, node: *Node) {
    // ConstDecl fields:
    // field0 = name_start
    // field1 = name_len
    // field2 = type_handle (-1 if inferred)
    // field3 = init_expr node index

    let name_start: i64 = node.field0;
    let name_len: i64 = node.field1;
    let init_expr_idx: i64 = node.field3;

    // Evaluate the initializer (must be a constant expression)
    if init_expr_idx >= 0 {
        let init_node: *Node = l.nodes + init_expr_idx;
        if init_node.kind == NodeKind.IntLit {
            // Simple integer literal
            Lowerer_addConst(l, name_start, name_len, init_node.field0);
        }
        // TODO: Support more complex constant expressions
    }
}

// Lower all declarations in the AST
fn Lowerer_lowerAll(l: *Lowerer) i64 {
    // First pass: process const declarations
    var i: i64 = 0;
    while i < l.nodes_count {
        let node: *Node = l.nodes + i;
        if node.kind == NodeKind.ConstDecl {
            Lowerer_lowerConstDecl(l, node);
        }
        i = i + 1;
    }

    // Second pass: process function declarations
    // Note: ExternFnDecl nodes are skipped - they don't need IR,
    // the linker will resolve external symbols
    i = 0;
    while i < l.nodes_count {
        let node: *Node = l.nodes + i;
        if node.kind == NodeKind.FnDecl {
            Lowerer_lowerFnDecl(l, node);
        }
        // ExternFnDecl - skip, no IR needed (linker resolves external symbols)
        i = i + 1;
    }
    return l.ir_nodes_count;
}

// ============================================================================
// Declaration Lowering
// ============================================================================

fn Lowerer_lowerFnDecl(l: *Lowerer, node: *Node) {
    // FnDecl fields:
    // field0 = name_start
    // field1 = name_len
    // field2 = params_start
    // field3 = params_count
    // field4 = ret_type
    // field5 = body (block node index)

    // Record starting positions for this function
    let nodes_start: i64 = l.ir_nodes_count;
    let locals_start: i64 = l.ir_locals_count;

    // Create function builder
    var fb: FuncBuilder = undefined;
    func_builder_init(&fb,
                      node.field0, node.field1,  // name_start, name_len
                      TYPE_I64,                   // return type (simplified for now)
                      l.ir_locals + l.ir_locals_count,
                      l.ir_locals_cap - l.ir_locals_count,
                      l.ir_nodes + l.ir_nodes_count,
                      l.ir_nodes_cap - l.ir_nodes_count);

    l.current_func = &fb;

    // Add function parameters as locals (before lowering body so they're available)
    let params_start: i64 = node.field2;
    let params_count: i64 = node.field3;
    var param_idx: i64 = 0;
    while param_idx < params_count {
        // Get param node index from children array
        let child_ptr: *i64 = l.children + params_start + param_idx;
        let param_node_idx: i64 = child_ptr.*;
        let param_node: *Node = l.nodes + param_node_idx;

        // ParamDecl: field0=name_start, field1=name_len, field2=type_start, field3=type_handle
        let param_type: i64 = resolve_type_handle(l.type_pool, l.source, param_node.field3);
        func_builder_add_param(&fb,
                               param_node.field0, param_node.field1,
                               param_type, param_idx);
        param_idx = param_idx + 1;
    }

    // Lower the function body (field5 is the body block node index)
    let body_idx: i64 = node.field5;
    var body_terminated: bool = false;
    if body_idx >= 0 {
        let body_node: *Node = l.nodes + body_idx;
        body_terminated = Lowerer_lowerBlockCheckTerminated(l, body_node);
    }

    // If function body doesn't end with a return, emit implicit void return
    if not body_terminated {
        func_builder_emit_return_void(&fb);
    }

    // Update counts from function builder
    l.ir_nodes_count = l.ir_nodes_count + fb.nodes_count;
    l.ir_locals_count = l.ir_locals_count + fb.locals_count;

    // Record function metadata
    if l.ir_funcs_count < l.ir_funcs_cap {
        let func_ptr: *IRFunc = l.ir_funcs + l.ir_funcs_count;
        func_ptr.name_start = node.field0;
        func_ptr.name_len = node.field1;
        func_ptr.return_type = TYPE_I64;
        func_ptr.nodes_start = nodes_start;
        func_ptr.nodes_count = fb.nodes_count;
        func_ptr.locals_start = locals_start;
        func_ptr.locals_count = fb.locals_count;
        func_ptr.code_offset = 0;
        l.ir_funcs_count = l.ir_funcs_count + 1;
    }

    l.current_func = null;
}

// ============================================================================
// Statement Lowering
// ============================================================================

fn Lowerer_lowerBlock(l: *Lowerer, node: *Node) {
    Lowerer_lowerBlockCheckTerminated(l, node);
}

// Lower a block and return whether it ends with a terminator (return/branch)
fn Lowerer_lowerBlockCheckTerminated(l: *Lowerer, node: *Node) bool {
    // BlockStmt fields:
    // field0 = stmts_start (index in children array)
    // field1 = stmts_count

    let stmts_start: i64 = node.field0;
    let stmts_count: i64 = node.field1;

    var terminated: bool = false;

    // Iterate over statements in the block
    var i: i64 = 0;
    while i < stmts_count {
        // Get statement node index from children array
        let child_ptr: *i64 = l.children + stmts_start + i;
        let stmt_idx: i64 = child_ptr.*;
        let stmt_node: *Node = l.nodes + stmt_idx;

        // Check if this is a terminator
        if stmt_node.kind == NodeKind.ReturnStmt {
            terminated = true;
        }

        // Lower the statement
        Lowerer_lowerStmt(l, stmt_node);

        i = i + 1;
    }

    return terminated;
}

fn Lowerer_lowerStmt(l: *Lowerer, node: *Node) {
    if node.kind == NodeKind.ReturnStmt {
        Lowerer_lowerReturn(l, node);
    } else if node.kind == NodeKind.VarDecl {
        Lowerer_lowerVarDecl(l, node);
    } else if node.kind == NodeKind.IfStmt {
        Lowerer_lowerIf(l, node);
    } else if node.kind == NodeKind.WhileStmt {
        Lowerer_lowerWhile(l, node);
    } else if node.kind == NodeKind.ForStmt {
        Lowerer_lowerFor(l, node);
    } else if node.kind == NodeKind.BreakStmt {
        Lowerer_lowerBreak(l);
    } else if node.kind == NodeKind.ContinueStmt {
        Lowerer_lowerContinue(l);
    } else if node.kind == NodeKind.ExprStmt {
        Lowerer_lowerExprStmt(l, node);
    }
}

fn Lowerer_lowerExprStmt(l: *Lowerer, node: *Node) {
    // ExprStmt fields:
    // field0 = expression node index
    if node.field0 >= 0 {
        let expr_node: *Node = l.nodes + node.field0;
        Lowerer_lowerExpr(l, expr_node);
    }
}

fn Lowerer_lowerReturn(l: *Lowerer, node: *Node) {
    // ReturnStmt fields:
    // field0 = value (node index, -1 if void)

    let fb: *FuncBuilder = l.current_func;
    if fb == null {
        return;
    }

    // Lower return value expression
    var value_idx: i64 = NULL_NODE;
    if node.field0 >= 0 {
        let expr: *Node = l.nodes + node.field0;
        value_idx = Lowerer_lowerExpr(l, expr);
    }

    // Emit return node
    var ret_node: IRNode = IRNode_new(IRNodeKind.Return, TYPE_VOID);
    ret_node.left = value_idx;
    func_builder_emit(fb, ret_node);
}

fn Lowerer_lowerVarDecl(l: *Lowerer, node: *Node) {
    // VarDecl fields:
    // field0 = is_let (1 = let/immutable, 0 = var/mutable)
    // field1 = name_start
    // field2 = name_len
    // field3 = init_expr node index
    // field4 = type_handle (PTYPE_USER_BASE + source_offset for struct types, 0 otherwise)

    let fb: *FuncBuilder = l.current_func;
    if fb == null {
        return;
    }

    // is_mutable = NOT is_let (var = mutable, let = immutable)
    let is_mutable: bool = node.field0 == 0;
    let type_handle: i64 = node.field4;

    // Determine local type based on type_handle
    // PTYPE_SLICE_BASE = 100000, PTYPE_ARRAY_BASE = 10000, PTYPE_USER_BASE = 100
    var local_type: i64 = TYPE_I64;
    if type_handle >= PTYPE_SLICE_BASE {
        local_type = TYPE_SLICE;  // Mark as slice for special indexing handling
    }

    let local_idx: i64 = func_builder_add_local(fb, node.field1, node.field2, local_type, is_mutable);

    // Set slice local size to 16 bytes (ptr + len)
    if local_type == TYPE_SLICE {
        func_builder_set_local_size(fb, local_idx, 16);
    }

    // Check for type annotation indicating a struct type
    // Handles both direct struct (Point) and pointer-to-struct (*Point)
    // PTYPE encoding: direct = 100+offset, pointer = 110+offset (overlaps at high offsets)
    // Disambiguate by checking if there's a '*' before the struct name position
    var struct_name_start: i64 = -1;
    var TypeInfo_isPointer_to_struct: bool = false;

    if type_handle >= PTYPE_USER_BASE and type_handle < PTYPE_ARRAY_BASE {
        let direct_offset: i64 = type_handle - PTYPE_USER_BASE;
        let ptr_offset: i64 = type_handle - PTYPE_PTR_BASE - PTYPE_USER_BASE;

        // Check for pointer-to-struct: look for '*' before ptr_offset position
        var found_star: bool = false;
        if ptr_offset > 0 {
            var scan_pos: i64 = ptr_offset - 1;
            while scan_pos >= 0 {
                let c: u8 = (l.source + scan_pos).*;
                // Skip whitespace (space=32, tab=9, newline=10, cr=13)
                if c == 32 or c == 9 or c == 10 or c == 13 {
                    scan_pos = scan_pos - 1;
                } else if c == 42 {  // '*'
                    found_star = true;
                    break;
                } else {
                    break;
                }
            }
        }

        if found_star and ptr_offset >= 0 {
            // Pointer-to-struct: store the pointee struct's position
            struct_name_start = ptr_offset;
            TypeInfo_isPointer_to_struct = true;
        } else {
            // Direct struct type
            struct_name_start = direct_offset;
        }
    }

    // If we found a struct type, scan for its name and store
    if struct_name_start >= 0 {
        // Scan for identifier length
        var type_name_len: i64 = 0;
        var pos: i64 = struct_name_start;
        while pos < l.source_len {
            let c: u8 = (l.source + pos).*;
            // Check if alphanumeric or underscore (a-z: 97-122, A-Z: 65-90, 0-9: 48-57, _: 95)
            let is_ident_char: bool = (c >= 97 and c <= 122) or (c >= 65 and c <= 90) or
                                       (c >= 48 and c <= 57) or c == 95;
            if not is_ident_char {
                break;
            }
            pos = pos + 1;
        }
        type_name_len = pos - struct_name_start;

        // Set struct type info on the local (for both struct and ptr-to-struct)
        let local: *IRLocal = fb.locals + local_idx;
        local.struct_type_start = struct_name_start;
        local.struct_type_len = type_name_len;

        // For direct struct types (not pointers), compute and set the struct size
        // so that the local gets enough stack space allocated
        if not TypeInfo_isPointer_to_struct {
            let struct_size: i64 = get_TypeInfo_size_from_ast(l, struct_name_start, type_name_len);
            if struct_size > 8 {
                func_builder_set_local_size(fb, local_idx, struct_size);
            }
        }
    }

    // If there's an initializer, emit store
    if node.field3 >= 0 {
        let init_expr: *Node = l.nodes + node.field3;

        // Special case for struct literal initialization
        if init_expr.kind == NodeKind.StructLit {
            // Record struct type on the local for field access later
            let local: *IRLocal = fb.locals + local_idx;
            local.struct_type_start = init_expr.field0;  // type_name_start
            local.struct_type_len = init_expr.field1;    // type_name_len

            Lowerer_lowerStructLitToLocal(l, init_expr, local_idx);
        } else if init_expr.kind == NodeKind.ArrayLit {
            // Array literal initialization: [elem1, elem2, ...]
            Lowerer_lowerArrayLitToLocal(l, init_expr, local_idx);
        } else if init_expr.kind == NodeKind.SliceExpr {
            // Slice expression: arr[start:end] - store ptr and len separately
            Lowerer_lowerSliceExprToLocal(l, init_expr, local_idx);
        } else {
            let value_idx: i64 = Lowerer_lowerExpr(l, init_expr);
            func_builder_emit_store_local(fb, local_idx, value_idx);
        }
    }
}

// Lower struct literal initializer to a local variable
fn Lowerer_lowerStructLitToLocal(l: *Lowerer, node: *Node, local_idx: i64) {
    // StructLit fields:
    // field0 = type_name_start
    // field1 = type_name_len
    // field2 = fields_start (index in children array)
    // field3 = fields_count

    let fb: *FuncBuilder = l.current_func;
    if fb == null { return; }

    let struct_name_start: i64 = node.field0;
    let struct_name_len: i64 = node.field1;
    let fields_start: i64 = node.field2;
    let fields_count: i64 = node.field3;

    // For each field initializer, emit a store to the local's field
    var i: i64 = 0;
    while i < fields_count {
        // Get field init node from children array
        let child_ptr: *i64 = l.children + fields_start + i;
        let field_init_idx: i64 = child_ptr.*;
        let field_init: *Node = l.nodes + field_init_idx;

        // FieldInit fields:
        // field0 = field_name_start
        // field1 = field_name_len
        // field2 = value (node index)

        let fname_start: i64 = field_init.field0;
        let fname_len: i64 = field_init.field1;
        let value_node_idx: i64 = field_init.field2;
        let value_node: *Node = l.nodes + value_node_idx;

        // Lower the value expression
        let value_ir: i64 = Lowerer_lowerExpr(l, value_node);

        // Look up field offset from struct declaration
        var field_offset: i64 = lookup_struct_field_offset(l, struct_name_start, struct_name_len,
                                                            fname_start, fname_len);
        // Fallback to index-based offset if lookup fails
        if field_offset < 0 {
            field_offset = i * 8;
        }

        // Emit store to local's field using StoreFieldLocal
        func_builder_emit_store_field_local(fb, local_idx, field_offset, value_ir);

        i = i + 1;
    }
}

// Lower array literal initializer to a local variable: [elem1, elem2, ...]
fn Lowerer_lowerArrayLitToLocal(l: *Lowerer, node: *Node, local_idx: i64) {
    // ArrayLit fields:
    // field0 = elements_start (index in children array)
    // field1 = elements_count

    let fb: *FuncBuilder = l.current_func;
    if fb == null { return; }

    let elements_start: i64 = node.field0;
    let elements_count: i64 = node.field1;

    // Set the local's size to fit all elements (8 bytes per element for i64)
    let array_size: i64 = elements_count * 8;
    func_builder_set_local_size(fb, local_idx, array_size);

    // For each element, store to the local at the appropriate offset
    var i: i64 = 0;
    while i < elements_count {
        // Get element node from children array
        let child_ptr: *i64 = l.children + elements_start + i;
        let elem_idx: i64 = child_ptr.*;
        let elem_node: *Node = l.nodes + elem_idx;

        // Lower the element expression
        let value_ir: i64 = Lowerer_lowerExpr(l, elem_node);

        // Calculate element offset (assuming 8 bytes per element for i64)
        let elem_offset: i64 = i * 8;

        // Emit store to local's element using StoreFieldLocal
        func_builder_emit_store_field_local(fb, local_idx, elem_offset, value_ir);

        i = i + 1;
    }
}

// Lower slice expression to a local variable: store ptr at offset 0, len at offset 8
// This is needed because slices are 16-byte values (ptr, len)
fn Lowerer_lowerSliceExprToLocal(l: *Lowerer, node: *Node, local_idx: i64) {
    // SliceExpr fields:
    // field0 = base expression (node index)
    // field1 = start index (-1 if omitted)
    // field2 = end index (-1 if omitted)

    let fb: *FuncBuilder = l.current_func;
    if fb == null { return; }

    let base_node: *Node = l.nodes + node.field0;
    let start_node_idx: i64 = node.field1;
    let end_node_idx: i64 = node.field2;

    // For cot0, assume element type is i64 (8 bytes)
    let elem_size: i64 = 8;

    // Default start to 0 if not specified
    var start_ir: i64;
    if start_node_idx < 0 {
        start_ir = func_builder_emit_const_int(fb, 0);
    } else {
        let start_node: *Node = l.nodes + start_node_idx;
        start_ir = Lowerer_lowerExpr(l, start_node);
    }

    // Lower end index
    var end_ir: i64;
    if end_node_idx < 0 {
        end_ir = func_builder_emit_const_int(fb, 0);
    } else {
        let end_node: *Node = l.nodes + end_node_idx;
        end_ir = Lowerer_lowerExpr(l, end_node);
    }

    // Calculate length: end - start
    let len_ir: i64 = func_builder_emit_binary(fb, IR_OP_SUB, end_ir, start_ir, TYPE_I64);

    // Get pointer to base[start]
    var ptr_ir: i64 = func_builder_emit_const_int(fb, 0);
    if base_node.kind == NodeKind.Ident {
        // Look up the local variable
        var base_local_idx: i64 = -1;
        var i: i64 = 0;
        while i < fb.locals_count {
            let local: *IRLocal = fb.locals + i;
            if names_equal(l.source, local.name_start, local.name_len,
                          base_node.field0, base_node.field1) {
                base_local_idx = i;
            }
            i = i + 1;
        }

        if base_local_idx >= 0 {
            // Get address of local array
            let base_ptr: i64 = func_builder_emit_addr_local(fb, base_local_idx, TYPE_I64);
            // Calculate offset: start * elem_size
            let elem_size_ir: i64 = func_builder_emit_const_int(fb, elem_size);
            let offset_ir: i64 = func_builder_emit_binary(fb, IR_OP_MUL, start_ir, elem_size_ir, TYPE_I64);
            // Add offset to base pointer
            ptr_ir = func_builder_emit_binary(fb, IR_OP_ADD, base_ptr, offset_ir, TYPE_I64);
        }
    }

    // Store ptr at offset 0 of slice local
    func_builder_emit_store_field_local(fb, local_idx, 0, ptr_ir);
    // Store len at offset 8 of slice local
    func_builder_emit_store_field_local(fb, local_idx, 8, len_ir);
}

fn Lowerer_lowerIf(l: *Lowerer, node: *Node) {
    // IfStmt fields:
    // field0 = condition expr node index
    // field1 = then body node index
    // field2 = else body node index (-1 if none)

    let fb: *FuncBuilder = l.current_func;
    if fb == null { return; }

    // Create blocks
    let then_block: i64 = func_builder_new_block(fb);
    var else_block: i64 = -1;
    if node.field2 >= 0 {
        else_block = func_builder_new_block(fb);
    }
    let merge_block: i64 = func_builder_new_block(fb);

    // Lower condition
    let cond_node: *Node = l.nodes + node.field0;
    let cond_idx: i64 = Lowerer_lowerExpr(l, cond_node);

    // Emit branch
    var target_else: i64 = merge_block;
    if else_block >= 0 {
        target_else = else_block;
    }
    func_builder_emit_branch(fb, cond_idx, then_block, target_else);

    // Lower then body
    func_builder_set_block(fb, then_block);
    let then_node: *Node = l.nodes + node.field1;
    let then_terminated: bool = Lowerer_lowerBlockCheckTerminated(l, then_node);
    if not then_terminated {
        func_builder_emit_jump(fb, merge_block);
    }

    // Lower else body if present
    if else_block >= 0 {
        func_builder_set_block(fb, else_block);
        let else_node: *Node = l.nodes + node.field2;
        let else_terminated: bool = Lowerer_lowerBlockCheckTerminated(l, else_node);
        if not else_terminated {
            func_builder_emit_jump(fb, merge_block);
        }
    }

    // Continue in merge block
    func_builder_set_block(fb, merge_block);
}

fn Lowerer_lowerWhile(l: *Lowerer, node: *Node) {
    // WhileStmt fields:
    // field0 = condition expr
    // field1 = body

    let fb: *FuncBuilder = l.current_func;
    if fb == null { return; }

    // Create blocks: header (condition), body, exit
    let header_block: i64 = func_builder_new_block(fb);
    let body_block: i64 = func_builder_new_block(fb);
    let exit_block: i64 = func_builder_new_block(fb);

    // Save outer loop context and set new one
    let saved_continue: i64 = l.loop_continue_block;
    let saved_break: i64 = l.loop_break_block;
    l.loop_continue_block = header_block;
    l.loop_break_block = exit_block;

    // Jump from current block to header
    func_builder_emit_jump(fb, header_block);

    // Header block: evaluate condition, branch to body or exit
    func_builder_set_block(fb, header_block);
    let cond_node: *Node = l.nodes + node.field0;
    let cond_idx: i64 = Lowerer_lowerExpr(l, cond_node);
    func_builder_emit_branch(fb, cond_idx, body_block, exit_block);

    // Body block: execute body, jump back to header
    func_builder_set_block(fb, body_block);
    let body_node: *Node = l.nodes + node.field1;
    let body_terminated: bool = Lowerer_lowerBlockCheckTerminated(l, body_node);
    if not body_terminated {
        func_builder_emit_jump(fb, header_block);
    }

    // Restore outer loop context
    l.loop_continue_block = saved_continue;
    l.loop_break_block = saved_break;

    // Continue in exit block
    func_builder_set_block(fb, exit_block);
}

// Lower for-in loop: for item in array { body }
// Following Zig compiler pattern from src/frontend/lower.zig:lowerFor
//
// Desugars to:
//   var __idx: i64 = 0;
//   var __len: i64 = <array_length>;
//   while __idx < __len {
//       let item = array[__idx];
//       body
//       __idx = __idx + 1;
//   }
fn Lowerer_lowerFor(l: *Lowerer, node: *Node) {
    // ForStmt fields:
    // field0 = binding name_start
    // field1 = binding name_len
    // field2 = iterable expression (node index)
    // field3 = body (block node index)

    let fb: *FuncBuilder = l.current_func;
    if fb == null { return; }

    let binding_start: i64 = node.field0;
    let binding_len: i64 = node.field1;
    let iter_node_idx: i64 = node.field2;
    let body_node_idx: i64 = node.field3;

    // Get the iterable node
    let iter_node: *Node = l.nodes + iter_node_idx;

    // Determine array length from iterable
    // For now, we need the iterable to be an identifier to look up its type
    var array_len: i64 = 0;
    var iter_local_idx: i64 = -1;
    var TypeInfo_isSlice: bool = false;
    if iter_node.kind == NodeKind.Ident {
        // Look up the local variable
        var i: i64 = 0;
        while i < fb.locals_count {
            let local: *IRLocal = fb.locals + i;
            if names_equal(l.source, local.name_start, local.name_len,
                          iter_node.field0, iter_node.field1) {
                iter_local_idx = i;
                if local.type_idx == TYPE_SLICE {
                    // Slice: length stored at offset 8 (loaded at runtime)
                    TypeInfo_isSlice = true;
                } else {
                    // Array: get length from local size (assuming 8 bytes per element)
                    array_len = local.size / 8;
                    if array_len < 1 {
                        array_len = 1;  // Default to at least 1
                    }
                }
            }
            i = i + 1;
        }
    }

    // Create index variable: var __idx: i64 = 0
    let idx_local: i64 = func_builder_add_local(fb, 0, 0, TYPE_I64, true);  // unnamed temp local
    let zero: i64 = func_builder_emit_const_int(fb, 0);
    func_builder_emit_store_local(fb, idx_local, zero);

    // Create length variable: var __len: i64 = <length>
    let len_local: i64 = func_builder_add_local(fb, 0, 0, TYPE_I64, false);
    if TypeInfo_isSlice {
        // For slices: load length from slice local (offset 8)
        let len_val: i64 = func_builder_emit_field_local(fb, iter_local_idx, 8, TYPE_I64);
        func_builder_emit_store_local(fb, len_local, len_val);
    } else {
        // For arrays: use compile-time constant
        let len_val: i64 = func_builder_emit_const_int(fb, array_len);
        func_builder_emit_store_local(fb, len_local, len_val);
    }

    // Create loop blocks: header (condition), body, incr, exit
    let header_block: i64 = func_builder_new_block(fb);
    let body_block: i64 = func_builder_new_block(fb);
    let incr_block: i64 = func_builder_new_block(fb);
    let exit_block: i64 = func_builder_new_block(fb);

    // Save outer loop context and set new one
    // Note: continue goes to incr_block (increment then check), break goes to exit_block
    let saved_continue: i64 = l.loop_continue_block;
    let saved_break: i64 = l.loop_break_block;
    l.loop_continue_block = incr_block;
    l.loop_break_block = exit_block;

    // Jump to header
    func_builder_emit_jump(fb, header_block);

    // Header block: __idx < __len
    func_builder_set_block(fb, header_block);
    let idx_val: i64 = func_builder_emit_load_local(fb, idx_local);
    let len_cond: i64 = func_builder_emit_load_local(fb, len_local);
    let cond: i64 = func_builder_emit_binary(fb, IR_OP_LT, idx_val, len_cond, TYPE_BOOL);
    func_builder_emit_branch(fb, cond, body_block, exit_block);

    // Body block: let item = array[__idx]; body
    func_builder_set_block(fb, body_block);

    // Create binding variable: let item = array[__idx]
    let binding_local: i64 = func_builder_add_local(fb, binding_start, binding_len, TYPE_I64, false);

    // Load current index
    let cur_idx: i64 = func_builder_emit_load_local(fb, idx_local);

    // Get element at index
    if iter_local_idx >= 0 {
        let elem_size: i64 = 8;  // Assume i64 elements
        if TypeInfo_isSlice {
            // For slices: load ptr from offset 0, then index through it
            let ptr_val: i64 = func_builder_emit_field_local(fb, iter_local_idx, 0, TYPE_I64);
            let elem_val: i64 = func_builder_emit_index_value(fb, ptr_val, cur_idx, elem_size, TYPE_I64);
            func_builder_emit_store_local(fb, binding_local, elem_val);
        } else {
            // For arrays: arr[__idx]
            let elem_val: i64 = func_builder_emit_index_local(fb, iter_local_idx, cur_idx, elem_size, TYPE_I64);
            func_builder_emit_store_local(fb, binding_local, elem_val);
        }
    }

    // Lower body
    let body_node: *Node = l.nodes + body_node_idx;
    let body_terminated: bool = Lowerer_lowerBlockCheckTerminated(l, body_node);
    if not body_terminated {
        func_builder_emit_jump(fb, incr_block);
    }

    // Increment block: __idx = __idx + 1
    func_builder_set_block(fb, incr_block);
    let idx_before_incr: i64 = func_builder_emit_load_local(fb, idx_local);
    let one: i64 = func_builder_emit_const_int(fb, 1);
    let idx_after_incr: i64 = func_builder_emit_binary(fb, IR_OP_ADD, idx_before_incr, one, TYPE_I64);
    func_builder_emit_store_local(fb, idx_local, idx_after_incr);
    func_builder_emit_jump(fb, header_block);

    // Restore outer loop context
    l.loop_continue_block = saved_continue;
    l.loop_break_block = saved_break;

    // Continue in exit block
    func_builder_set_block(fb, exit_block);
}

fn Lowerer_lowerBreak(l: *Lowerer) {
    let fb: *FuncBuilder = l.current_func;
    if fb == null { return; }
    if l.loop_break_block < 0 { return; }  // Not in a loop
    func_builder_emit_jump(fb, l.loop_break_block);
}

fn Lowerer_lowerContinue(l: *Lowerer) {
    let fb: *FuncBuilder = l.current_func;
    if fb == null { return; }
    if l.loop_continue_block < 0 { return; }  // Not in a loop
    func_builder_emit_jump(fb, l.loop_continue_block);
}

// ============================================================================
// Expression Lowering
// ============================================================================

fn Lowerer_lowerExpr(l: *Lowerer, node: *Node) i64 {
    let fb: *FuncBuilder = l.current_func;
    if fb == null {
        return NULL_NODE;
    }

    if node.kind == NodeKind.IntLit {
        return Lowerer_lowerIntLit(l, node);
    } else if node.kind == NodeKind.StringLit {
        return Lowerer_lowerStringLit(l, node);
    } else if node.kind == NodeKind.Ident {
        return Lowerer_lowerIdent(l, node);
    } else if node.kind == NodeKind.BinaryExpr {
        return Lowerer_lowerBinary(l, node);
    } else if node.kind == NodeKind.UnaryExpr {
        return Lowerer_lowerUnary(l, node);
    } else if node.kind == NodeKind.CallExpr {
        return Lowerer_lowerCall(l, node);
    } else if node.kind == NodeKind.AssignExpr {
        return Lowerer_lowerAssign(l, node);
    } else if node.kind == NodeKind.AddressOf {
        return Lowerer_lowerAddressOf(l, node);
    } else if node.kind == NodeKind.DerefExpr {
        return Lowerer_lowerDeref(l, node);
    } else if node.kind == NodeKind.FieldAccess {
        return Lowerer_lowerFieldAccess(l, node);
    } else if node.kind == NodeKind.IndexExpr {
        return Lowerer_lowerIndex(l, node);
    } else if node.kind == NodeKind.SliceExpr {
        return Lowerer_lowerSliceExpr(l, node);
    } else if node.kind == NodeKind.BuiltinCall {
        return Lowerer_lowerBuiltinCall(l, node);
    } else if node.kind == NodeKind.SwitchExpr {
        return Lowerer_lowerSwitchExpr(l, node);
    }

    return NULL_NODE;
}

fn Lowerer_lowerIntLit(l: *Lowerer, node: *Node) i64 {
    // IntLit fields:
    // field0 = value (the integer value)

    let fb: *FuncBuilder = l.current_func;
    return func_builder_emit_const_int(fb, node.field0);
}

fn Lowerer_lowerStringLit(l: *Lowerer, node: *Node) i64 {
    // StringLit fields:
    // field0 = string_start (offset in source, after opening quote)
    // field1 = string_len (length of string content, excluding quotes)

    let fb: *FuncBuilder = l.current_func;
    return func_builder_emit_const_string(fb, node.field0, node.field1);
}

// Compare two strings in source by their positions
fn names_equal(source: *u8, start1: i64, len1: i64, start2: i64, len2: i64) bool {
    if len1 != len2 { return false; }
    var i: i64 = 0;
    while i < len1 {
        let p1: *u8 = source + start1 + i;
        let p2: *u8 = source + start2 + i;
        if p1.* != p2.* { return false; }
        i = i + 1;
    }
    return true;
}

// Check if name in source equals "len" (3 chars)
// Following Zig pattern: src/frontend/lower.zig:1848
fn name_is_len(source: *u8, start: i64, len: i64) bool {
    if len != 3 { return false; }
    let c0: u8 = (source + start).*;
    let c1: u8 = (source + start + 1).*;
    let c2: u8 = (source + start + 2).*;
    return c0 == 108 and c1 == 101 and c2 == 110;  // 'l', 'e', 'n'
}

// Check if name in source equals "print" (5 chars)
fn name_is_print(source: *u8, start: i64, len: i64) bool {
    if len != 5 { return false; }
    let c0: u8 = (source + start).*;
    let c1: u8 = (source + start + 1).*;
    let c2: u8 = (source + start + 2).*;
    let c3: u8 = (source + start + 3).*;
    let c4: u8 = (source + start + 4).*;
    return c0 == 112 and c1 == 114 and c2 == 105 and c3 == 110 and c4 == 116;  // 'p', 'r', 'i', 'n', 't'
}

// Check if name in source equals "println" (7 chars)
fn name_is_println(source: *u8, start: i64, len: i64) bool {
    if len != 7 { return false; }
    let c0: u8 = (source + start).*;
    let c1: u8 = (source + start + 1).*;
    let c2: u8 = (source + start + 2).*;
    let c3: u8 = (source + start + 3).*;
    let c4: u8 = (source + start + 4).*;
    let c5: u8 = (source + start + 5).*;
    let c6: u8 = (source + start + 6).*;
    // 'p', 'r', 'i', 'n', 't', 'l', 'n'
    return c0 == 112 and c1 == 114 and c2 == 105 and c3 == 110 and c4 == 116 and c5 == 108 and c6 == 110;
}

// Find "write" in source text (for builtin print/println lowering)
// Returns the start offset of "write" or -1 if not found
fn find_write_in_source(source: *u8, source_len: i64) i64 {
    var i: i64 = 0;
    while i < source_len - 4 {  // Need at least 5 chars for "write"
        let c0: u8 = (source + i).*;
        if c0 == 119 {  // 'w'
            let c1: u8 = (source + i + 1).*;
            let c2: u8 = (source + i + 2).*;
            let c3: u8 = (source + i + 3).*;
            let c4: u8 = (source + i + 4).*;
            // 'w', 'r', 'i', 't', 'e'
            if c1 == 114 and c2 == 105 and c3 == 116 and c4 == 101 {
                return i;
            }
        }
        i = i + 1;
    }
    return -1;  // Not found
}

// Get size of a type by name from AST
// Returns 8 for primitives (i64, bool, etc), or struct size for struct types
fn get_TypeInfo_size_from_ast(l: *Lowerer, type_start: i64, type_len: i64) i64 {
    // Check for primitive types
    // i64, i32, u64, u32, bool, *T (pointers)
    if type_len <= 0 { return 8; }

    let c0: u8 = (l.source + type_start).*;

    // Check for pointer type (starts with *)
    if c0 == 42 { return 8; }  // '*'

    // Check for i64, i32 (start with 'i')
    if c0 == 105 { return 8; }  // 'i'

    // Check for u64, u32 (start with 'u')
    if c0 == 117 { return 8; }  // 'u'

    // Check for bool (starts with 'b')
    if c0 == 98 { return 8; }  // 'b' - treat bool as 8 bytes for alignment

    // Otherwise, look up struct by name and compute its size
    var n: i64 = 0;
    while n < l.nodes_count {
        let node: *Node = l.nodes + n;
        if node.kind == NodeKind.StructDecl {
            if names_equal(l.source, node.field0, node.field1, type_start, type_len) {
                // Found the struct - compute its size by summing field sizes
                let fields_start: i64 = node.field2;
                let fields_count: i64 = node.field3;
                var size: i64 = 0;

                var f: i64 = 0;
                while f < fields_count {
                    let child_ptr: *i64 = l.children + fields_start + f;
                    let field_idx: i64 = child_ptr.*;
                    let field_node: *Node = l.nodes + field_idx;

                    if field_node.kind == NodeKind.FieldDecl {
                        // Get field type and its size
                        let ftype_start: i64 = field_node.field2;
                        // Scan for type name length
                        var pos: i64 = ftype_start;
                        while pos < l.source_len {
                            let c: u8 = (l.source + pos).*;
                            let is_ident: bool = (c >= 97 and c <= 122) or (c >= 65 and c <= 90) or
                                                 (c >= 48 and c <= 57) or c == 95;
                            if not is_ident { break; }
                            pos = pos + 1;
                        }
                        let ftype_len: i64 = pos - ftype_start;
                        size = size + get_TypeInfo_size_from_ast(l, ftype_start, ftype_len);
                    }
                    f = f + 1;
                }
                return size;
            }
        }
        n = n + 1;
    }

    // Unknown type, assume 8 bytes
    return 8;
}

// FieldLookupResult stores both offset and type info for a field lookup
struct FieldLookupResult {
    offset: i64,           // Field offset in bytes (-1 if not found)
    type_start: i64,       // Start of field's type name in source (-1 if not found)
    type_len: i64,         // Length of field's type name
}

// Look up field info by searching struct declarations in the AST
// Returns FieldLookupResult with offset and type info
// Computes proper offset by summing sizes of preceding fields (following Zig pattern)
fn lookup_struct_field_info(l: *Lowerer, struct_name_start: i64, struct_name_len: i64,
                             field_name_start: i64, field_name_len: i64) FieldLookupResult {
    var result: FieldLookupResult = undefined;
    result.offset = -1;
    result.type_start = -1;
    result.type_len = 0;

    // Search through all AST nodes for StructDecl with matching name
    var n: i64 = 0;
    while n < l.nodes_count {
        let node: *Node = l.nodes + n;
        if node.kind == NodeKind.StructDecl {
            // StructDecl: field0=name_start, field1=name_len, field2=fields_start, field3=fields_count
            if names_equal(l.source, node.field0, node.field1, struct_name_start, struct_name_len) {
                // Found the struct, now search for the field
                let fields_start: i64 = node.field2;
                let fields_count: i64 = node.field3;

                // Compute offset by summing sizes of preceding fields
                var offset: i64 = 0;
                var f: i64 = 0;
                while f < fields_count {
                    let child_ptr: *i64 = l.children + fields_start + f;
                    let field_idx: i64 = child_ptr.*;
                    let field_node: *Node = l.nodes + field_idx;

                    // FieldDecl: field0=name_start, field1=name_len, field2=type_start, field3=type_handle
                    if field_node.kind == NodeKind.FieldDecl {
                        // Get this field's type info
                        let ftype_start: i64 = field_node.field2;
                        var pos: i64 = ftype_start;
                        while pos < l.source_len {
                            let c: u8 = (l.source + pos).*;
                            let is_ident: bool = (c >= 97 and c <= 122) or (c >= 65 and c <= 90) or
                                                 (c >= 48 and c <= 57) or c == 95;
                            if not is_ident { break; }
                            pos = pos + 1;
                        }
                        let ftype_len: i64 = pos - ftype_start;

                        if names_equal(l.source, field_node.field0, field_node.field1,
                                       field_name_start, field_name_len) {
                            // Found the field - use accumulated offset
                            result.offset = offset;
                            result.type_start = ftype_start;
                            result.type_len = ftype_len;
                            return result;
                        }

                        // Accumulate size for next field's offset
                        let field_size: i64 = get_TypeInfo_size_from_ast(l, ftype_start, ftype_len);
                        offset = offset + field_size;
                    }
                    f = f + 1;
                }
                // Struct found but field not found
                return result;
            }
        }
        n = n + 1;
    }
    // Struct not found
    return result;
}

// Look up field offset by searching struct declarations in the AST
// Returns field offset by summing sizes of preceding fields, or -1 if not found
fn lookup_struct_field_offset(l: *Lowerer, struct_name_start: i64, struct_name_len: i64,
                               field_name_start: i64, field_name_len: i64) i64 {
    // Use lookup_struct_field_info which computes proper offsets
    let info: FieldLookupResult = lookup_struct_field_info(l, struct_name_start, struct_name_len,
                                                            field_name_start, field_name_len);
    return info.offset;
}

fn Lowerer_lowerIdent(l: *Lowerer, node: *Node) i64 {
    // Ident fields:
    // field0 = name_start
    // field1 = name_len

    let fb: *FuncBuilder = l.current_func;

    // First check if this is a constant
    if Lowerer_hasConst(l, node.field0, node.field1) {
        let const_value: i64 = Lowerer_lookupConst(l, node.field0, node.field1);
        return func_builder_emit_const_int(fb, const_value);
    }

    // Look up local variable by name - compare actual source content
    var i: i64 = 0;
    while i < fb.locals_count {
        let local: *IRLocal = fb.locals + i;
        if names_equal(l.source, local.name_start, local.name_len, node.field0, node.field1) {
            return func_builder_emit_load_local(fb, i);
        }
        i = i + 1;
    }

    // Not found - return null node
    return NULL_NODE;
}

fn Lowerer_lowerBinary(l: *Lowerer, node: *Node) i64 {
    // BinaryExpr fields:
    // field0 = left operand (node index)
    // field1 = right operand (node index)
    // field2 = op (BinaryOp as integer)

    let fb: *FuncBuilder = l.current_func;

    // Lower left and right operands
    let left_node: *Node = l.nodes + node.field0;
    let right_node: *Node = l.nodes + node.field1;

    // BUG-049 FIX: If right operand is a call, the left operand must be spilled
    // to stack before the call and loaded after. This is because function calls
    // clobber caller-saved registers (X0-X18), so any value in those registers
    // would be lost after the call returns.
    //
    // Pattern: for "n * factorial(n-1)":
    // 1. Lower left (n) into a register
    // 2. Spill n to temp local (survives across call)
    // 3. Lower right (factorial call)
    // 4. Load n back from temp local
    // 5. Emit binary operation with (loaded_n, call_result)
    let right_is_call: bool = right_node.kind == NodeKind.CallExpr;

    var final_left_idx: i64 = 0;
    var right_idx: i64 = 0;

    if right_is_call {
        // Lower left operand first
        let left_idx: i64 = Lowerer_lowerExpr(l, left_node);

        // Spill to temp local
        let temp_local: i64 = func_builder_add_local(fb, 0, 0, TYPE_I64, true);
        func_builder_emit_store_local(fb, temp_local, left_idx);

        // Now lower right operand (the call)
        right_idx = Lowerer_lowerExpr(l, right_node);

        // Load left operand back from temp local
        final_left_idx = func_builder_emit_load_local(fb, temp_local);
    } else {
        // No call on right side, no spilling needed
        final_left_idx = Lowerer_lowerExpr(l, left_node);
        right_idx = Lowerer_lowerExpr(l, right_node);
    }

    // Convert AST operator to IR operator
    let ir_op: i64 = ast_op_to_ir_op(node.field2);

    // Determine result type
    let result_type: i64 = TYPE_I64;
    if is_comparison_op(node.field2) {
        result_type = TYPE_BOOL;
    }

    return func_builder_emit_binary(fb, ir_op, final_left_idx, right_idx, result_type);
}

fn Lowerer_lowerUnary(l: *Lowerer, node: *Node) i64 {
    // UnaryExpr fields:
    // field0 = operand (node index)
    // field1 = op (UnaryOp as integer)

    let fb: *FuncBuilder = l.current_func;

    let operand_node: *Node = l.nodes + node.field0;
    let operand_idx: i64 = Lowerer_lowerExpr(l, operand_node);

    // Convert AST operator to IR operator
    let ir_op: i64 = ast_unary_op_to_ir_op(node.field1);

    return func_builder_emit_unary(fb, ir_op, operand_idx, TYPE_I64);
}

// ============================================================================
// Builtin len/print/println
// Following Zig pattern: src/frontend/lower.zig:2014-2145
// ============================================================================

// Lower len(arg) builtin
// - String literal: return parsed length as const
// - String variable: access length field (offset 8 in string struct)
fn Lowerer_lowerBuiltinLen(l: *Lowerer, node: *Node) i64 {
    let fb: *FuncBuilder = l.current_func;
    if fb == null { return NULL_NODE; }

    // CallExpr: field1 = args_start, field2 = args_count
    let args_start: i64 = node.field1;
    let args_count: i64 = node.field2;
    if args_count != 1 { return NULL_NODE; }

    // Get the argument node
    let arg_child_ptr: *i64 = l.children + args_start;
    let arg_node_idx: i64 = arg_child_ptr.*;
    let arg_node: *Node = l.nodes + arg_node_idx;

    // String literal: len("hello") -> const 5
    if arg_node.kind == NodeKind.StringLit {
        // StringLiteral: field0 = str_start, field1 = str_len (source positions)
        // The str_len is the length of the content EXCLUDING quotes
        // But we need to handle escape sequences...
        // For now, just use the source length (TODO: handle escapes properly)
        let str_len: i64 = arg_node.field1;
        return func_builder_emit_const_int(fb, str_len);
    }

    // String variable: len(s) -> access length field at offset 8
    // String struct layout: [ptr: *u8, len: i64]
    if arg_node.kind == NodeKind.Ident {
        // Look up local variable
        var local_idx: i64 = -1;
        var i: i64 = 0;
        while i < fb.locals_count {
            let local: *IRLocal = fb.locals + i;
            if names_equal(l.source, local.name_start, local.name_len,
                          arg_node.field0, arg_node.field1) {
                local_idx = i;
            }
            i = i + 1;
        }

        if local_idx >= 0 {
            // Access length field at offset 8 (field index 1)
            return func_builder_emit_field_local(fb, local_idx, 8, TYPE_I64);
        }
    }

    return NULL_NODE;
}

// Lower print(s) or println(s) to write syscall
// Following Zig pattern: transforms to write(1, s.ptr, s.len)
fn Lowerer_lowerBuiltinPrint(l: *Lowerer, node: *Node, is_println: bool) i64 {
    let fb: *FuncBuilder = l.current_func;
    if fb == null { return NULL_NODE; }

    // Find "write" in source - it must be declared as extern fn write(...)
    let write_pos: i64 = find_write_in_source(l.source, l.source_len);
    if write_pos < 0 {
        // write not found in source, fall through to regular call handling
        return NULL_NODE;
    }

    // CallExpr: field1 = args_start, field2 = args_count
    let args_start: i64 = node.field1;
    let args_count: i64 = node.field2;
    if args_count != 1 { return NULL_NODE; }

    // Get the argument node
    let arg_child_ptr: *i64 = l.children + args_start;
    let arg_node_idx: i64 = arg_child_ptr.*;
    let arg_node: *Node = l.nodes + arg_node_idx;

    // Lower the string argument
    let str_val: i64 = Lowerer_lowerExpr(l, arg_node);

    // Create fd=1 (stdout) constant
    let fd_val: i64 = func_builder_emit_const_int(fb, 1);

    // Store args for write call: write(fd, str)
    // Note: For now we pass the string directly, codegen needs to handle extracting ptr/len
    let write_args_start: i64 = l.call_args_count;

    // arg0: fd
    if l.call_args_count < l.call_args_cap {
        let slot: *i64 = l.call_args + l.call_args_count;
        slot.* = fd_val;
        l.call_args_count = l.call_args_count + 1;
    }

    // arg1: string value (codegen will handle extracting ptr/len)
    if l.call_args_count < l.call_args_cap {
        let slot: *i64 = l.call_args + l.call_args_count;
        slot.* = str_val;
        l.call_args_count = l.call_args_count + 1;
    }

    // Emit write call using the found position of "write" in source
    var call_node: IRNode = IRNode_new(IRNodeKind.Call, TYPE_I64);
    call_node.func_name_start = write_pos;  // Actual position of "write" in source
    call_node.func_name_len = 5;            // "write" is 5 chars
    call_node.args_start = write_args_start;
    call_node.args_count = 2;  // fd and string
    let write_result: i64 = func_builder_emit(fb, call_node);

    // TODO: For println, also write a newline
    // For now, print and println behave the same (no trailing newline)

    return NULL_NODE;  // print/println returns void
}

fn Lowerer_lowerCall(l: *Lowerer, node: *Node) i64 {
    // CallExpr fields:
    // field0 = callee (node index)
    // field1 = args_start (index in children array)
    // field2 = args_count

    let fb: *FuncBuilder = l.current_func;
    if fb == null { return NULL_NODE; }

    // Get callee - must be an identifier for now
    let callee_node: *Node = l.nodes + node.field0;
    if callee_node.kind != NodeKind.Ident {
        return NULL_NODE;  // Only simple function calls supported
    }

    let func_name_start: i64 = callee_node.field0;
    let func_name_len: i64 = callee_node.field1;
    let args_start: i64 = node.field1;
    let args_count: i64 = node.field2;

    // Handle builtin functions
    // Following Zig pattern: src/frontend/lower.zig:1848-1856
    if name_is_len(l.source, func_name_start, func_name_len) {
        return Lowerer_lowerBuiltinLen(l, node);
    }
    if name_is_print(l.source, func_name_start, func_name_len) {
        let result: i64 = Lowerer_lowerBuiltinPrint(l, node, false);
        if result != NULL_NODE or find_write_in_source(l.source, l.source_len) >= 0 {
            return result;  // Successfully handled or write found
        }
        // Fall through to regular call if write not in source
    }
    if name_is_println(l.source, func_name_start, func_name_len) {
        let result: i64 = Lowerer_lowerBuiltinPrint(l, node, true);
        if result != NULL_NODE or find_write_in_source(l.source, l.source_len) >= 0 {
            return result;  // Successfully handled or write found
        }
        // Fall through to regular call if write not in source
    }

    // NOTE: Do NOT capture call_args_start here! Inner calls will modify l.call_args_count.
    // We capture it AFTER Pass 1, just before Pass 2.

    // Two-pass approach to handle nested calls:
    // Pass 1: Lower all arguments and STORE nested call results to temp locals
    //         (but don't load yet - the load would get clobbered by subsequent calls)
    // Pass 2: Load from temp locals for nested calls, then emit the main call
    //
    // This ensures loads happen AFTER all nested calls have completed.
    // Following the Zig compiler pattern (src/ssa/regalloc.zig): values need to
    // survive across calls by being spilled to stack, not held in caller-saved regs.

    // Track state for up to 8 args using individual variables
    // (arrays with undefined might not work reliably in cot0)
    var arg0_ir: i64 = -1;
    var arg1_ir: i64 = -1;
    var arg2_ir: i64 = -1;
    var arg3_ir: i64 = -1;
    var arg0_local: i64 = -1;
    var arg1_local: i64 = -1;
    var arg2_local: i64 = -1;
    var arg3_local: i64 = -1;
    var arg0_is_call: bool = false;
    var arg1_is_call: bool = false;
    var arg2_is_call: bool = false;
    var arg3_is_call: bool = false;

    // Pass 1: Lower all arguments and store nested call results
    var i: i64 = 0;
    while i < args_count and i < 4 {
        let arg_child_ptr: *i64 = l.children + args_start + i;
        let arg_node_idx: i64 = arg_child_ptr.*;
        let arg_node: *Node = l.nodes + arg_node_idx;
        let arg_ir_idx: i64 = Lowerer_lowerExpr(l, arg_node);
        let is_call: bool = arg_node.kind == NodeKind.CallExpr;

        // Store in the right variable based on index
        if i == 0 {
            arg0_ir = arg_ir_idx;
            arg0_is_call = is_call;
            if is_call {
                arg0_local = func_builder_add_local(fb, 0, 0, TYPE_I64, true);
                func_builder_emit_store_local(fb, arg0_local, arg_ir_idx);
            }
        } else if i == 1 {
            arg1_ir = arg_ir_idx;
            arg1_is_call = is_call;
            if is_call {
                arg1_local = func_builder_add_local(fb, 0, 0, TYPE_I64, true);
                func_builder_emit_store_local(fb, arg1_local, arg_ir_idx);
            }
        } else if i == 2 {
            arg2_ir = arg_ir_idx;
            arg2_is_call = is_call;
            if is_call {
                arg2_local = func_builder_add_local(fb, 0, 0, TYPE_I64, true);
                func_builder_emit_store_local(fb, arg2_local, arg_ir_idx);
            }
        } else if i == 3 {
            arg3_ir = arg_ir_idx;
            arg3_is_call = is_call;
            if is_call {
                arg3_local = func_builder_add_local(fb, 0, 0, TYPE_I64, true);
                func_builder_emit_store_local(fb, arg3_local, arg_ir_idx);
            }
        }

        i = i + 1;
    }

    // NOW capture call_args_start - AFTER all nested calls have run
    // Inner calls have already added their args to l.call_args
    let call_args_start: i64 = l.call_args_count;

    // Pass 2: Load from temp locals for nested calls, build final call_args
    i = 0;
    while i < args_count and i < 4 {
        var final_arg_idx: i64 = -1;

        if i == 0 {
            final_arg_idx = arg0_ir;
            if arg0_is_call and arg0_local >= 0 {
                final_arg_idx = func_builder_emit_load_local(fb, arg0_local);
            }
        } else if i == 1 {
            final_arg_idx = arg1_ir;
            if arg1_is_call and arg1_local >= 0 {
                final_arg_idx = func_builder_emit_load_local(fb, arg1_local);
            }
        } else if i == 2 {
            final_arg_idx = arg2_ir;
            if arg2_is_call and arg2_local >= 0 {
                final_arg_idx = func_builder_emit_load_local(fb, arg2_local);
            }
        } else if i == 3 {
            final_arg_idx = arg3_ir;
            if arg3_is_call and arg3_local >= 0 {
                final_arg_idx = func_builder_emit_load_local(fb, arg3_local);
            }
        }

        // Store the final IR index in call_args array
        if l.call_args_count < l.call_args_cap {
            let slot: *i64 = l.call_args + l.call_args_count;
            slot.* = final_arg_idx;
            l.call_args_count = l.call_args_count + 1;
        }

        i = i + 1;
    }

    // Emit Call IR node
    // args_start now points to offset in call_args array, not IR nodes
    var call_node: IRNode = IRNode_new(IRNodeKind.Call, TYPE_I64);
    call_node.func_name_start = func_name_start;
    call_node.func_name_len = func_name_len;
    call_node.args_start = call_args_start;
    call_node.args_count = args_count;
    return func_builder_emit(fb, call_node);
}

fn Lowerer_lowerAssign(l: *Lowerer, node: *Node) i64 {
    // AssignExpr fields:
    // field0 = target (identifier node or deref expr)
    // field1 = value (expression)

    let fb: *FuncBuilder = l.current_func;
    if fb == null { return NULL_NODE; }

    let target_node: *Node = l.nodes + node.field0;

    // Lower the value expression first
    let value_node: *Node = l.nodes + node.field1;
    let value_idx: i64 = Lowerer_lowerExpr(l, value_node);

    // Handle assignment to dereferenced pointer: ptr.* = value
    if target_node.kind == NodeKind.DerefExpr {
        // Lower the pointer expression
        let ptr_operand: *Node = l.nodes + target_node.field0;
        let ptr_idx: i64 = Lowerer_lowerExpr(l, ptr_operand);

        // Emit store through pointer
        func_builder_emit_store(fb, ptr_idx, value_idx);
        return value_idx;
    }

    // Handle field assignment: s.x = value or ptr.*.x = value
    if target_node.kind == NodeKind.FieldAccess {
        return Lowerer_lowerFieldAssign(l, target_node, value_idx);
    }

    // Handle array element assignment: arr[i] = value
    if target_node.kind == NodeKind.IndexExpr {
        return Lowerer_lowerIndexAssign(l, target_node, value_idx);
    }

    // Handle simple variable assignment: x = value
    if target_node.kind == NodeKind.Ident {
        // Look up local variable by name
        var local_idx: i64 = -1;
        var i: i64 = 0;
        while i < fb.locals_count {
            let local: *IRLocal = fb.locals + i;
            if names_equal(l.source, local.name_start, local.name_len, target_node.field0, target_node.field1) {
                local_idx = i;
            }
            i = i + 1;
        }

        if local_idx < 0 {
            return NULL_NODE;  // Variable not found
        }

        // Emit store to local
        func_builder_emit_store_local(fb, local_idx, value_idx);
        return value_idx;
    }

    return NULL_NODE;  // Unsupported assignment target
}

fn Lowerer_lowerAddressOf(l: *Lowerer, node: *Node) i64 {
    // AddressOf fields:
    // field0 = operand (the expression to take address of)

    let fb: *FuncBuilder = l.current_func;
    if fb == null { return NULL_NODE; }

    let operand_node: *Node = l.nodes + node.field0;

    // For now, only support address of identifiers (local variables)
    if operand_node.kind == NodeKind.Ident {
        // Look up local variable by name
        var i: i64 = 0;
        while i < fb.locals_count {
            let local: *IRLocal = fb.locals + i;
            if names_equal(l.source, local.name_start, local.name_len,
                          operand_node.field0, operand_node.field1) {
                // Emit address of local - type is *i64 for now (TYPE_I64 + some offset for ptr)
                return func_builder_emit_addr_local(fb, i, TYPE_I64);
            }
            i = i + 1;
        }
    }

    return NULL_NODE;
}

fn Lowerer_lowerDeref(l: *Lowerer, node: *Node) i64 {
    // DerefExpr fields:
    // field0 = operand (the pointer expression)

    let fb: *FuncBuilder = l.current_func;
    if fb == null { return NULL_NODE; }

    // Lower the pointer expression
    let operand_node: *Node = l.nodes + node.field0;
    let ptr_idx: i64 = Lowerer_lowerExpr(l, operand_node);

    // Emit load from pointer - result type is i64 for now
    return func_builder_emit_load(fb, ptr_idx, TYPE_I64);
}

fn Lowerer_lowerFieldAccess(l: *Lowerer, node: *Node) i64 {
    // FieldAccess fields:
    // field0 = base expression (node index)
    // field1 = field_name_start (offset in source)
    // field2 = field_name_len

    let fb: *FuncBuilder = l.current_func;
    if fb == null { return NULL_NODE; }

    let base_node: *Node = l.nodes + node.field0;
    let field_name_start: i64 = node.field1;
    let field_name_len: i64 = node.field2;

    // Case 1: Base is an identifier (local variable or parameter)
    if base_node.kind == NodeKind.Ident {
        // Look up the local variable
        var local_idx: i64 = -1;
        var local_type_idx: i64 = TYPE_I64;
        var i: i64 = 0;
        while i < fb.locals_count {
            let local: *IRLocal = fb.locals + i;
            if names_equal(l.source, local.name_start, local.name_len,
                          base_node.field0, base_node.field1) {
                local_idx = i;
                local_type_idx = local.type_idx;
            }
            i = i + 1;
        }

        if local_idx < 0 {
            return NULL_NODE;  // Variable not found
        }

        // Check if local is a pointer to struct (auto-dereference)
        let local_type: *Type = TypePool_get(l.type_pool, local_type_idx);
        var struct_type_idx: i64 = local_type_idx;

        if local_type.kind == TypeKind.Pointer {
            // Pointer to struct - need to load the pointer first
            struct_type_idx = local_type.elem;

            // Look up field in the pointee struct
            let field_info: *FieldInfo = TypePool_lookupField(l.type_pool, struct_type_idx,
                                                           field_name_start, field_name_len);
            if field_info == null {
                return NULL_NODE;  // Field not found
            }

            // Load the pointer value
            let ptr_val: i64 = func_builder_emit_load_local(fb, local_idx);
            // Access field through the pointer
            return func_builder_emit_field_value(fb, ptr_val, field_info.offset, field_info.type_idx);
        }

        // Direct struct access
        let field_info: *FieldInfo = TypePool_lookupField(l.type_pool, struct_type_idx,
                                                       field_name_start, field_name_len);
        if field_info != null {
            return func_builder_emit_field_local(fb, local_idx, field_info.offset, field_info.type_idx);
        }

        // Fallback: use struct type info from the local variable if available
        let local: *IRLocal = fb.locals + local_idx;
        if local.struct_type_start >= 0 {
            // Look up field offset from struct declaration
            let field_offset: i64 = lookup_struct_field_offset(l, local.struct_type_start, local.struct_type_len,
                                                                field_name_start, field_name_len);
            if field_offset >= 0 {
                return func_builder_emit_field_local(fb, local_idx, field_offset, TYPE_I64);
            }
        }
        // Last resort fallback: offset 0 (should rarely happen now)
        return func_builder_emit_field_local(fb, local_idx, 0, TYPE_I64);
    }

    // Case 2: Base is a dereference expression (ptr.*.field)
    // Following Go's ODOTPTR and Zig's lower.zig pattern:
    // Get pointer value, look up field offset in pointee struct, emit FieldValue
    if base_node.kind == NodeKind.DerefExpr {
        // Get the pointer value without loading the struct
        let ptr_operand: *Node = l.nodes + base_node.field0;
        let ptr_val: i64 = Lowerer_lowerExpr(l, ptr_operand);

        // Try to find struct type from the pointer local's info
        var field_offset: i64 = 0;
        if ptr_operand.kind == NodeKind.Ident {
            // Look up the pointer local to get its struct type info
            var i: i64 = 0;
            while i < fb.locals_count {
                let local: *IRLocal = fb.locals + i;
                if names_equal(l.source, local.name_start, local.name_len,
                              ptr_operand.field0, ptr_operand.field1) {
                    // Found the pointer local - check if it has struct type info
                    if local.struct_type_start >= 0 {
                        // Use AST-based lookup to find field offset
                        let info: FieldLookupResult = lookup_struct_field_info(l,
                            local.struct_type_start, local.struct_type_len,
                            field_name_start, field_name_len);
                        if info.offset >= 0 {
                            field_offset = info.offset;
                        }
                    }
                    break;
                }
                i = i + 1;
            }
        }

        return func_builder_emit_field_value(fb, ptr_val, field_offset, TYPE_I64);
    }

    // Case 3: Base is another field access (chained: a.b.c)
    // BUG-051 FIX: Use AST-based lookup (no checker/type pool dependency)
    // For o.inner.a: base_node is o.inner, field_name is "a"
    if base_node.kind == NodeKind.FieldAccess {
        var total_offset: i64 = 0;
        var root_local_idx: i64 = -1;

        // Walk up the field access chain to find root local
        var walk_node: *Node = base_node;
        var depth: i64 = 0;
        while walk_node.kind == NodeKind.FieldAccess and depth < 10 {
            walk_node = l.nodes + walk_node.field0;
            depth = depth + 1;
        }

        // Check if root is a local variable identifier
        if walk_node.kind == NodeKind.Ident {
            var i: i64 = 0;
            while i < fb.locals_count {
                let local: *IRLocal = fb.locals + i;
                if names_equal(l.source, local.name_start, local.name_len,
                              walk_node.field0, walk_node.field1) {
                    root_local_idx = i;

                    // Use AST-based lookup with struct_type_start/len
                    if local.struct_type_start >= 0 {
                        // Get base field info (e.g., "inner" in o.inner)
                        let base_field_name_start: i64 = base_node.field1;
                        let base_field_name_len: i64 = base_node.field2;

                        // Look up base field in root's struct type (AST-based)
                        let base_info: FieldLookupResult = lookup_struct_field_info(l,
                            local.struct_type_start, local.struct_type_len,
                            base_field_name_start, base_field_name_len);

                        if base_info.offset >= 0 and base_info.type_start >= 0 {
                            total_offset = base_info.offset;

                            // Look up final field in nested struct type (AST-based)
                            let final_info: FieldLookupResult = lookup_struct_field_info(l,
                                base_info.type_start, base_info.type_len,
                                field_name_start, field_name_len);

                            if final_info.offset >= 0 {
                                total_offset = total_offset + final_info.offset;
                                return func_builder_emit_field_local(fb, root_local_idx, total_offset, TYPE_I64);
                            }
                        }
                    }
                }
                i = i + 1;
            }
        }

        // Fallback: lower base and use offset 0 (original behavior)
        let base_val: i64 = Lowerer_lowerFieldAccess(l, base_node);
        return func_builder_emit_field_value(fb, base_val, 0, TYPE_I64);
    }

    // Case 4: Other expressions - lower them and access field
    let base_val: i64 = Lowerer_lowerExpr(l, base_node);
    return func_builder_emit_field_value(fb, base_val, 0, TYPE_I64);
}

fn Lowerer_lowerIndex(l: *Lowerer, node: *Node) i64 {
    // IndexExpr fields:
    // field0 = base expression (array/pointer)
    // field1 = index expression

    let fb: *FuncBuilder = l.current_func;
    if fb == null { return NULL_NODE; }

    let base_node: *Node = l.nodes + node.field0;
    let index_node_idx: i64 = node.field1;

    // For cot0, assume element type is i64 (8 bytes) for simplicity
    let elem_size: i64 = 8;
    let elem_type: i64 = TYPE_I64;

    // Lower the index expression
    let index_node: *Node = l.nodes + index_node_idx;
    let index_ir: i64 = Lowerer_lowerExpr(l, index_node);

    // Case 1: Base is an identifier (local array or slice variable)
    if base_node.kind == NodeKind.Ident {
        // Look up the local variable
        var local_idx: i64 = -1;
        var local_type_idx: i64 = TYPE_I64;
        var i: i64 = 0;
        while i < fb.locals_count {
            let local: *IRLocal = fb.locals + i;
            if names_equal(l.source, local.name_start, local.name_len,
                          base_node.field0, base_node.field1) {
                local_idx = i;
                local_type_idx = local.type_idx;
            }
            i = i + 1;
        }

        if local_idx >= 0 {
            // Check if local is a slice - slices store a pointer, not data
            if local_type_idx == TYPE_SLICE {
                // For slices: load the pointer first, then index from it
                let ptr_val: i64 = func_builder_emit_load_local(fb, local_idx);
                return func_builder_emit_index_value(fb, ptr_val, index_ir, elem_size, elem_type);
            } else {
                // For arrays: index directly into local storage
                return func_builder_emit_index_local(fb, local_idx, index_ir, elem_size, elem_type);
            }
        }
    }

    // Case 2: Base is any other expression - lower it and emit IndexValue
    // Following src/frontend/lower.zig:1625-1662 pattern
    let base_val: i64 = Lowerer_lowerExpr(l, base_node);

    // Check if base returns a slice (e.g., get_slice_from_ptr()[0])
    // For slices, we need to extract the pointer first using SlicePtr
    if Lowerer_exprReturnsSlice(l, base_node) {
        // Emit SlicePtr to extract pointer from slice value
        let ptr_val: i64 = func_builder_emit_slice_ptr(fb, base_val, TYPE_I64);
        return func_builder_emit_index_value(fb, ptr_val, index_ir, elem_size, elem_type);
    }

    return func_builder_emit_index_value(fb, base_val, index_ir, elem_size, elem_type);
}

// Lower slice expression: arr[start:end]
// SliceExpr fields:
// field0 = base expression (node index)
// field1 = start index (-1 if omitted)
// field2 = end index (-1 if omitted)
fn Lowerer_lowerSliceExpr(l: *Lowerer, node: *Node) i64 {
    let fb: *FuncBuilder = l.current_func;
    if fb == null { return NULL_NODE; }

    let base_node: *Node = l.nodes + node.field0;
    let start_node_idx: i64 = node.field1;
    let end_node_idx: i64 = node.field2;

    // For cot0, assume element type is i64 (8 bytes)
    let elem_size: i64 = 8;

    // Default start to 0 if not specified
    var start_ir: i64;
    if start_node_idx < 0 {
        start_ir = func_builder_emit_const_int(fb, 0);
    } else {
        let start_node: *Node = l.nodes + start_node_idx;
        start_ir = Lowerer_lowerExpr(l, start_node);
    }

    // Lower base and get end index
    // For arrays, we need the array length if end is not specified
    var end_ir: i64;
    if end_node_idx < 0 {
        // End not specified - would need array length
        // For now, default to a placeholder (should come from type info)
        end_ir = func_builder_emit_const_int(fb, 0);
    } else {
        let end_node: *Node = l.nodes + end_node_idx;
        end_ir = Lowerer_lowerExpr(l, end_node);
    }

    // Calculate length: end - start
    let len_ir: i64 = func_builder_emit_binary(fb, IR_OP_SUB, end_ir, start_ir, TYPE_I64);

    // Get pointer to base[start]
    // If base is a local array, get address of element at start index
    if base_node.kind == NodeKind.Ident {
        // Look up the local variable
        var local_idx: i64 = -1;
        var local_type_idx: i64 = TYPE_I64;
        var i: i64 = 0;
        while i < fb.locals_count {
            let local: *IRLocal = fb.locals + i;
            if names_equal(l.source, local.name_start, local.name_len,
                          base_node.field0, base_node.field1) {
                local_idx = i;
                local_type_idx = local.type_idx;
            }
            i = i + 1;
        }

        if local_idx >= 0 {
            // Check if local is a pointer (like ptr: *[3]i64)
            let local_type: *Type = TypePool_get(l.type_pool, local_type_idx);
            var base_ptr: i64;
            if local_type.kind == TypeKind.Pointer {
                // Pointer variable: load its value (the address it points to)
                base_ptr = func_builder_emit_load_local(fb, local_idx);
            } else {
                // Array local: get address of the local storage
                base_ptr = func_builder_emit_addr_local(fb, local_idx, TYPE_I64);
            }
            // Calculate offset: start * elem_size
            let elem_size_ir: i64 = func_builder_emit_const_int(fb, elem_size);
            let offset_ir: i64 = func_builder_emit_binary(fb, IR_OP_MUL, start_ir, elem_size_ir, TYPE_I64);
            // Add offset to base pointer
            let ptr_ir: i64 = func_builder_emit_binary(fb, IR_OP_ADD, base_ptr, offset_ir, TYPE_I64);
            // Make slice (ptr, len)
            return func_builder_emit_make_slice(fb, ptr_ir, len_ir, TYPE_I64);
        }
    }

    // Fallback: lower base expression and treat as pointer
    let base_val: i64 = Lowerer_lowerExpr(l, base_node);
    let elem_size_ir: i64 = func_builder_emit_const_int(fb, elem_size);
    let offset_ir: i64 = func_builder_emit_binary(fb, IR_OP_MUL, start_ir, elem_size_ir, TYPE_I64);
    let ptr_ir: i64 = func_builder_emit_binary(fb, IR_OP_ADD, base_val, offset_ir, TYPE_I64);
    return func_builder_emit_make_slice(fb, ptr_ir, len_ir, TYPE_I64);
}

fn Lowerer_lowerFieldAssign(l: *Lowerer, target: *Node, value_idx: i64) i64 {
    // FieldAccess fields:
    // field0 = base expression (node index)
    // field1 = field_name_start
    // field2 = field_name_len

    let fb: *FuncBuilder = l.current_func;
    if fb == null { return NULL_NODE; }

    let base_node: *Node = l.nodes + target.field0;
    let field_name_start: i64 = target.field1;
    let field_name_len: i64 = target.field2;

    // Case 1: Base is an identifier (local struct variable)
    if base_node.kind == NodeKind.Ident {
        // Look up the local variable
        var local_idx: i64 = -1;
        var local_type_idx: i64 = TYPE_I64;
        var i: i64 = 0;
        while i < fb.locals_count {
            let local: *IRLocal = fb.locals + i;
            if names_equal(l.source, local.name_start, local.name_len,
                          base_node.field0, base_node.field1) {
                local_idx = i;
                local_type_idx = local.type_idx;
            }
            i = i + 1;
        }

        if local_idx < 0 {
            return NULL_NODE;  // Variable not found
        }

        // Check if local is a pointer to struct (auto-dereference for assignment)
        let local_type: *Type = TypePool_get(l.type_pool, local_type_idx);
        var struct_type_idx: i64 = local_type_idx;

        if local_type.kind == TypeKind.Pointer {
            // Pointer to struct - need to load the pointer first
            struct_type_idx = local_type.elem;

            // Look up field in the pointee struct
            let field_info: *FieldInfo = TypePool_lookupField(l.type_pool, struct_type_idx,
                                                           field_name_start, field_name_len);
            if field_info == null {
                return NULL_NODE;  // Field not found
            }

            // Load the pointer value
            let ptr_val: i64 = func_builder_emit_load_local(fb, local_idx);
            // Store value through the pointer at field offset
            return func_builder_emit_store_field(fb, ptr_val, field_info.offset, value_idx);
        }

        // Direct struct assignment
        let field_info: *FieldInfo = TypePool_lookupField(l.type_pool, struct_type_idx,
                                                       field_name_start, field_name_len);
        if field_info != null {
            return func_builder_emit_store_field_local(fb, local_idx, field_info.offset, value_idx);
        }

        // Fallback: check if local has struct_type_start set (for struct literals)
        let local: *IRLocal = fb.locals + local_idx;
        if local.struct_type_start >= 0 {
            let field_offset: i64 = lookup_struct_field_offset(l, local.struct_type_start, local.struct_type_len,
                                                                field_name_start, field_name_len);
            if field_offset >= 0 {
                return func_builder_emit_store_field_local(fb, local_idx, field_offset, value_idx);
            }
        }

        // If local is a parameter, assume it might be a pointer to struct
        // Load the pointer value and store through it
        if local.is_param {
            // Try to find struct by looking through all StructDecl nodes
            var field_offset: i64 = -1;
            var n: i64 = 0;
            while n < l.nodes_count and field_offset < 0 {
                let snode: *Node = l.nodes + n;
                if snode.kind == NodeKind.StructDecl {
                    let found_offset: i64 = lookup_struct_field_offset(l, snode.field0, snode.field1,
                                                                        field_name_start, field_name_len);
                    if found_offset >= 0 {
                        field_offset = found_offset;
                    }
                }
                n = n + 1;
            }
            if field_offset < 0 {
                field_offset = 0;  // Default to offset 0 if not found
            }
            let ptr_val: i64 = func_builder_emit_load_local(fb, local_idx);
            return func_builder_emit_store_field(fb, ptr_val, field_offset, value_idx);
        }

        // Last fallback: use offset 0 (for untyped cases)
        return func_builder_emit_store_field_local(fb, local_idx, 0, value_idx);
    }

    // Case 2: Base is a dereference expression (ptr.*.field = value)
    // Following Go's ODOTPTR and Zig's lower.zig pattern:
    // Get pointer value, look up field offset in pointee struct, emit StoreField
    if base_node.kind == NodeKind.DerefExpr {
        let ptr_operand: *Node = l.nodes + base_node.field0;
        let ptr_val: i64 = Lowerer_lowerExpr(l, ptr_operand);

        // Try to find struct type from the pointer local's info
        var field_offset: i64 = 0;
        if ptr_operand.kind == NodeKind.Ident {
            // Look up the pointer local to get its struct type info
            var i: i64 = 0;
            while i < fb.locals_count {
                let local: *IRLocal = fb.locals + i;
                if names_equal(l.source, local.name_start, local.name_len,
                              ptr_operand.field0, ptr_operand.field1) {
                    // Found the pointer local - check if it has struct type info
                    if local.struct_type_start >= 0 {
                        // Use AST-based lookup to find field offset
                        let info: FieldLookupResult = lookup_struct_field_info(l,
                            local.struct_type_start, local.struct_type_len,
                            field_name_start, field_name_len);
                        if info.offset >= 0 {
                            field_offset = info.offset;
                        }
                    }
                    break;
                }
                i = i + 1;
            }
        }

        return func_builder_emit_store_field(fb, ptr_val, field_offset, value_idx);
    }

    // Case 3: Base is another field access (chained: a.b.c = value)
    // BUG-051 FIX: Use AST-based lookup (no checker/type pool dependency)
    // For o.inner.a: base_node is o.inner, field_name is "a"
    if base_node.kind == NodeKind.FieldAccess {
        var total_offset: i64 = 0;
        var root_local_idx: i64 = -1;

        // Walk up the field access chain to find root local
        var walk_node: *Node = base_node;
        var depth: i64 = 0;
        while walk_node.kind == NodeKind.FieldAccess and depth < 10 {
            walk_node = l.nodes + walk_node.field0;
            depth = depth + 1;
        }

        // Check if root is a local variable identifier
        if walk_node.kind == NodeKind.Ident {
            var i: i64 = 0;
            while i < fb.locals_count {
                let local: *IRLocal = fb.locals + i;
                if names_equal(l.source, local.name_start, local.name_len,
                              walk_node.field0, walk_node.field1) {
                    root_local_idx = i;

                    // Use AST-based lookup with struct_type_start/len
                    if local.struct_type_start >= 0 {
                        // Get base field info (e.g., "inner" in o.inner)
                        let base_field_name_start: i64 = base_node.field1;
                        let base_field_name_len: i64 = base_node.field2;

                        // Look up base field in root's struct type (AST-based)
                        let base_info: FieldLookupResult = lookup_struct_field_info(l,
                            local.struct_type_start, local.struct_type_len,
                            base_field_name_start, base_field_name_len);

                        if base_info.offset >= 0 and base_info.type_start >= 0 {
                            total_offset = base_info.offset;

                            // Look up final field in nested struct type (AST-based)
                            let final_info: FieldLookupResult = lookup_struct_field_info(l,
                                base_info.type_start, base_info.type_len,
                                field_name_start, field_name_len);

                            if final_info.offset >= 0 {
                                total_offset = total_offset + final_info.offset;
                                return func_builder_emit_store_field_local(fb, root_local_idx, total_offset, value_idx);
                            }
                        }
                    }
                }
                i = i + 1;
            }
        }

        // Fallback: lower base and store at offset 0 (original behavior)
        let base_val: i64 = Lowerer_lowerFieldAccess(l, base_node);
        return func_builder_emit_store_field(fb, base_val, 0, value_idx);
    }

    // Case 4: Other expressions - lower and store
    let base_val: i64 = Lowerer_lowerExpr(l, base_node);
    return func_builder_emit_store_field(fb, base_val, 0, value_idx);
}

fn Lowerer_lowerIndexAssign(l: *Lowerer, target: *Node, value_idx: i64) i64 {
    // IndexExpr fields:
    // field0 = base expression (array/pointer)
    // field1 = index expression

    let fb: *FuncBuilder = l.current_func;
    if fb == null { return NULL_NODE; }

    let base_node: *Node = l.nodes + target.field0;
    let index_node_idx: i64 = target.field1;

    // For cot0, assume element type is i64 (8 bytes) for simplicity
    let elem_size: i64 = 8;

    // Lower the index expression
    let index_node: *Node = l.nodes + index_node_idx;
    let index_ir: i64 = Lowerer_lowerExpr(l, index_node);

    // Case 1: Base is an identifier (local array or slice variable)
    if base_node.kind == NodeKind.Ident {
        // Look up the local variable
        var local_idx: i64 = -1;
        var local_type_idx: i64 = TYPE_I64;
        var i: i64 = 0;
        while i < fb.locals_count {
            let local: *IRLocal = fb.locals + i;
            if names_equal(l.source, local.name_start, local.name_len,
                          base_node.field0, base_node.field1) {
                local_idx = i;
                local_type_idx = local.type_idx;
            }
            i = i + 1;
        }

        if local_idx >= 0 {
            // Check if local is a slice - slices store a pointer, not data
            // Following src/frontend/lower.zig:815-825 slice handling
            if local_type_idx == TYPE_SLICE {
                // For slices: load the pointer first, then store through it
                let ptr_val: i64 = func_builder_emit_load_local(fb, local_idx);
                return func_builder_emit_store_index_value(fb, ptr_val, index_ir, value_idx, elem_size);
            } else {
                // For arrays: store directly into local storage
                return func_builder_emit_store_index_local(fb, local_idx, index_ir, value_idx, elem_size);
            }
        }
    }

    // Case 2: Base is any other expression - lower it and emit StoreIndexValue
    // Following src/frontend/lower.zig:849-857 slice handling pattern
    let base_val: i64 = Lowerer_lowerExpr(l, base_node);

    // Check if base returns a slice (e.g., get_slice_from_ptr()[0] = x)
    // For slices, we need to extract the pointer first using SlicePtr
    if Lowerer_exprReturnsSlice(l, base_node) {
        // Emit SlicePtr to extract pointer from slice value
        let ptr_val: i64 = func_builder_emit_slice_ptr(fb, base_val, TYPE_I64);
        return func_builder_emit_store_index_value(fb, ptr_val, index_ir, value_idx, elem_size);
    }

    return func_builder_emit_store_index_value(fb, base_val, index_ir, value_idx, elem_size);
}

// ============================================================================
// Builtin Lowering
// ============================================================================

fn Lowerer_lowerBuiltinCall(l: *Lowerer, node: *Node) i64 {
    // BuiltinCall fields:
    // field0 = name_start (offset in source after @)
    // field1 = name_len
    // field2 = type_arg (for @intCast, @sizeOf, @alignOf; -1 if none)
    // field3 = arg1 (first value argument node index)
    // field4 = arg2 (second value argument node index; -1 if none)

    let fb: *FuncBuilder = l.current_func;
    if fb == null { return NULL_NODE; }

    let name_start: i64 = node.field0;
    let name_len: i64 = node.field1;
    let arg1_idx: i64 = node.field3;
    let arg2_idx: i64 = node.field4;

    // Check builtin name by first character (using pointer arithmetic)
    // @string starts with 's', @intCast/@sizeOf with 'i'/'s', @alignOf with 'a'
    let first_char: u8 = (l.source + name_start).*;

    // @string(ptr, len)
    if first_char == 115 and name_len == 6 {  // 's' and length 6
        // Verify it's "string" by checking second char
        let second_char: u8 = (l.source + name_start + 1).*;
        if second_char == 116 {  // 't'
            // Lower both arguments
            let ptr_node: *Node = l.nodes + arg1_idx;
            let len_node: *Node = l.nodes + arg2_idx;
            let ptr_ir: i64 = Lowerer_lowerExpr(l, ptr_node);
            let len_ir: i64 = Lowerer_lowerExpr(l, len_node);
            return func_builder_emit_make_string(fb, ptr_ir, len_ir);
        }
    }

    // @intCast(type, val) - for now, just pass through the value
    if first_char == 105 and name_len == 7 {  // 'i' and length 7
        // Lower the value argument (arg1 is the value for @intCast)
        if arg1_idx >= 0 {
            let val_node: *Node = l.nodes + arg1_idx;
            return Lowerer_lowerExpr(l, val_node);
        }
    }

    // @sizeOf(type) - return type size (simplified: assume 8 for now)
    if first_char == 115 and name_len == 6 {  // 's' and length 6
        let second_char: u8 = (l.source + name_start + 1).*;
        if second_char == 105 {  // 'i' for "sizeOf"
            // For now, return 8 (size of i64)
            return func_builder_emit_const_int(fb, 8);
        }
    }

    // @alignOf(type) - return type alignment (simplified: assume 8 for now)
    if first_char == 97 and name_len == 7 {  // 'a' and length 7
        // For now, return 8 (alignment of i64)
        return func_builder_emit_const_int(fb, 8);
    }

    return NULL_NODE;
}

// ============================================================================
// Switch Expression Lowering
// Following Zig compiler pattern: lower as nested selects
// ============================================================================

fn Lowerer_lowerSwitchExpr(l: *Lowerer, node: *Node) i64 {
    // SwitchExpr fields:
    // field0 = subject (expression node index)
    // field1 = cases_start (index in children array)
    // field2 = cases_count
    // field3 = else_body (node index, -1 if no else)

    let fb: *FuncBuilder = l.current_func;
    if fb == null { return NULL_NODE; }

    // Lower the subject expression once
    let subject_node: *Node = l.nodes + node.field0;
    let subject: i64 = Lowerer_lowerExpr(l, subject_node);

    // Start with else value (or 0 if no else)
    var current_result: i64 = NULL_NODE;
    if node.field3 >= 0 {
        let else_node: *Node = l.nodes + node.field3;
        current_result = Lowerer_lowerExpr(l, else_node);
    } else {
        current_result = func_builder_emit_const_int(fb, 0);
    }

    // Process cases in reverse order to build nested selects
    let cases_start: i64 = node.field1;
    let cases_count: i64 = node.field2;

    var case_idx: i64 = cases_count - 1;
    while case_idx >= 0 {
        // Get case node from children array using pointer arithmetic
        let case_child_ptr: *i64 = l.children + cases_start + case_idx;
        let case_child_idx: i64 = case_child_ptr.*;
        let case_node: *Node = l.nodes + case_child_idx;

        // SwitchCase fields:
        // field0 = patterns_start (index in children array)
        // field1 = patterns_count
        // field2 = body (expression node index)

        let patterns_start: i64 = case_node.field0;
        let patterns_count: i64 = case_node.field1;
        let body_node_idx: i64 = case_node.field2;

        // Build condition: OR together all patterns compared for equality
        var case_cond: i64 = NULL_NODE;
        var pat_idx: i64 = 0;
        while pat_idx < patterns_count {
            // Get pattern node from children array using pointer arithmetic
            let pattern_child_ptr: *i64 = l.children + patterns_start + pat_idx;
            let pattern_child_idx: i64 = pattern_child_ptr.*;
            let pattern_node: *Node = l.nodes + pattern_child_idx;
            let pattern_val: i64 = Lowerer_lowerExpr(l, pattern_node);

            // Emit: subject == pattern
            let pattern_cond: i64 = func_builder_emit_binary(fb, IR_OP_EQ, subject, pattern_val, TYPE_BOOL);

            if case_cond == NULL_NODE {
                case_cond = pattern_cond;
            } else {
                // OR together: case_cond || pattern_cond
                case_cond = func_builder_emit_binary(fb, IR_OP_OR, case_cond, pattern_cond, TYPE_BOOL);
            }

            pat_idx = pat_idx + 1;
        }

        // Lower the case body
        let body_node: *Node = l.nodes + body_node_idx;
        let case_body: i64 = Lowerer_lowerExpr(l, body_node);

        // Emit select: if case_cond then case_body else current_result
        if case_cond != NULL_NODE {
            current_result = func_builder_emit_select(fb, case_cond, case_body, current_result, TYPE_I64);
        }

        case_idx = case_idx - 1;
    }

    return current_result;
}

// ============================================================================
// Operator Conversion
// ============================================================================

// AST BinaryOp values (from ast.cot node_binary):
// Add=0, Sub=1, Mul=2, Div=3, Mod=4
// Equal=5, NotEqual=6, Less=7, LessEq=8, Greater=9, GreaterEq=10
// And=11, Or=12

fn ast_op_to_ir_op(ast_op: i64) i64 {
    // Map AST operators to IR operator codes
    // Arithmetic
    if ast_op == 0 { return IR_OP_ADD; }
    if ast_op == 1 { return IR_OP_SUB; }
    if ast_op == 2 { return IR_OP_MUL; }
    if ast_op == 3 { return IR_OP_DIV; }
    if ast_op == 4 { return IR_OP_MOD; }

    // Comparison
    if ast_op == 5 { return IR_OP_EQ; }
    if ast_op == 6 { return IR_OP_NE; }
    if ast_op == 7 { return IR_OP_LT; }
    if ast_op == 8 { return IR_OP_LE; }
    if ast_op == 9 { return IR_OP_GT; }
    if ast_op == 10 { return IR_OP_GE; }

    // Logical
    if ast_op == 11 { return IR_OP_AND; }
    if ast_op == 12 { return IR_OP_OR; }

    // Bitwise
    if ast_op == 13 { return IR_OP_BIT_AND; }
    if ast_op == 14 { return IR_OP_BIT_OR; }
    if ast_op == 15 { return IR_OP_BIT_XOR; }
    if ast_op == 16 { return IR_OP_SHL; }
    if ast_op == 17 { return IR_OP_SHR; }

    return 0;
}

// AST UnaryOp values (from ast.cot node_unary):
// Neg=0, Not=1, BitNot=2

fn ast_unary_op_to_ir_op(ast_op: i64) i64 {
    if ast_op == 0 { return IR_OP_NEG; }
    if ast_op == 1 { return IR_OP_NOT; }
    if ast_op == 2 { return IR_OP_BIT_NOT; }
    return 0;
}

// IR operator codes - must match IRBinaryOp enum in ir.cot
const IR_OP_ADD: i64 = 0;
const IR_OP_SUB: i64 = 1;
const IR_OP_MUL: i64 = 2;
const IR_OP_DIV: i64 = 3;
const IR_OP_MOD: i64 = 4;
const IR_OP_EQ: i64 = 5;
const IR_OP_NE: i64 = 6;
const IR_OP_LT: i64 = 7;
const IR_OP_LE: i64 = 8;
const IR_OP_GT: i64 = 9;
const IR_OP_GE: i64 = 10;
const IR_OP_AND: i64 = 11;
const IR_OP_OR: i64 = 12;
const IR_OP_BIT_AND: i64 = 13;
const IR_OP_BIT_OR: i64 = 14;
const IR_OP_BIT_XOR: i64 = 15;
const IR_OP_SHL: i64 = 16;
const IR_OP_SHR: i64 = 17;
const IR_OP_NEG: i64 = 18;
const IR_OP_NOT: i64 = 19;
const IR_OP_BIT_NOT: i64 = 20;

fn is_comparison_op(ast_op: i64) bool {
    // Comparison ops are 5-10 (Equal through GreaterEq)
    if ast_op >= 5 and ast_op <= 10 { return true; }
    return false;
}

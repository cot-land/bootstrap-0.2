// Cot0 Parser
// Recursive descent parser with precedence climbing for expressions
//
// Design follows Go's cmd/compile/internal/syntax/parser.go patterns:
// - Parser struct embeds scanner state
// - Precedence climbing for binary expressions
// - Helper functions got() and want() for token consumption
//
// Reference: ~/learning/go/src/cmd/compile/internal/syntax/parser.go

import "token.cot"
import "scanner.cot"
import "ast.cot"
import "types.cot"

// ============================================================================
// Parser Structure
// ============================================================================

struct Parser {
    source: string,      // Source code being parsed
    scanner: Scanner,    // Embedded scanner
    current: Token,      // Current token
    pool: *NodePool,     // AST node pool for allocation
    had_error: bool,     // Error flag
}

// ============================================================================
// Parser Initialization
// ============================================================================

fn parser_new(source: string, pool: *NodePool) Parser {
    var p: Parser;
    p.source = source;
    p.scanner = scanner_new(source);
    p.pool = pool;
    p.had_error = false;
    // Prime the parser with first token
    p.current = scanner_next(&p.scanner);
    return p;
}

// ============================================================================
// Token Consumption Helpers (following Go's pattern)
// ============================================================================

// Advance to next token
fn parser_advance(p: *Parser) {
    p.current = scanner_next(&p.scanner);
}

// Check if current token matches expected type (don't consume)
fn parser_check(p: *Parser, expected: TokenType) bool {
    return p.current.kind == expected;
}

// Consume current token if it matches (returns true if consumed)
fn parser_got(p: *Parser, expected: TokenType) bool {
    if parser_check(p, expected) {
        parser_advance(p);
        return true;
    }
    return false;
}

// Require current token to match (error if not)
fn parser_want(p: *Parser, expected: TokenType) bool {
    if parser_got(p, expected) {
        return true;
    }
    p.had_error = true;
    return false;
}

// Check for end of file
fn parser_at_end(p: *Parser) bool {
    return p.current.kind == TokenType.Eof;
}

// Peek ahead to check if token AFTER current is a dot (for struct literal detection)
// This temporarily advances and restores scanner state
fn parser_peek_next_is_dot(p: *Parser) bool {
    // Save scanner position and token fields individually (avoid struct copy issues)
    let saved_pos: i64 = p.scanner.pos;
    let saved_kind: TokenType = p.current.kind;
    let saved_start: i64 = p.current.start;
    let saved_end: i64 = p.current.end;

    // Advance to next token
    parser_advance(p);
    let is_dot: bool = p.current.kind == TokenType.Dot;

    // Restore scanner position and token fields
    p.scanner.pos = saved_pos;
    p.current.kind = saved_kind;
    p.current.start = saved_start;
    p.current.end = saved_end;

    return is_dot;
}

// ============================================================================
// Operator Helpers (using precedence from ast.cot)
// ============================================================================

// Get precedence of current token using ast.cot's token_precedence
fn parser_prec(p: *Parser) i64 {
    return token_precedence(p.current.kind);
}

// Get BinaryOp as i64 from current token using ast.cot's token_to_binop
fn parser_binop_int(p: *Parser) i64 {
    return token_to_binop(p.current.kind);
}

// ============================================================================
// Type Parsing
// ============================================================================

// Type representation: we store type as start/length in source + a type_kind
// For cot0 simplicity, we return a type "handle" that encodes the type kind
// Parse a type: i64 | i32 | u8 | bool | void | string | *T | TypeName
// Type handles (PTYPE_*) are defined in types.cot
// Returns type handle (encoded as i64)
fn parse_type(p: *Parser) i64 {
    let kind: TokenType = p.current.kind;

    // Built-in types
    if kind == TokenType.I64 {
        parser_advance(p);
        return PTYPE_I64;
    }
    if kind == TokenType.I32 {
        parser_advance(p);
        return PTYPE_I32;
    }
    if kind == TokenType.U8 {
        parser_advance(p);
        return PTYPE_U8;
    }
    if kind == TokenType.Bool {
        parser_advance(p);
        return PTYPE_BOOL;
    }
    if kind == TokenType.Void {
        parser_advance(p);
        return PTYPE_VOID;
    }
    if kind == TokenType.String {
        parser_advance(p);
        return PTYPE_STRING;
    }

    // Pointer type: *T
    if kind == TokenType.Star {
        parser_advance(p);
        let pointee: i64 = parse_type(p);
        return PTYPE_PTR_BASE + pointee;
    }

    // Array type: [size]T
    if kind == TokenType.LBracket {
        parser_advance(p);  // consume '['
        // Parse array size (must be integer literal)
        var array_size: i64 = 0;
        if parser_check(p, TokenType.Int) {
            // Extract value using same pattern as parse_int_lit
            let arr_start: i64 = p.current.start;
            let arr_end: i64 = p.current.end;
            var arr_i: i64 = arr_start;
            while arr_i < arr_start + arr_end {
                let arr_c: u8 = p.source[arr_i];
                if arr_c >= 48 and arr_c <= 57 {
                    array_size = array_size * 10 + (arr_c - 48);
                }
                arr_i = arr_i + 1;
            }
            parser_advance(p);
        } else {
            p.had_error = true;
        }
        parser_want(p, TokenType.RBracket);  // consume ']'
        let elem_type: i64 = parse_type(p);
        return ptype_register_array(elem_type, array_size);
    }

    // User-defined type (struct/enum name) - store source offset
    if kind == TokenType.Ident {
        let offset: i64 = p.current.start;
        parser_advance(p);
        return PTYPE_USER_BASE + offset;
    }

    // Function type: fn(params) -> ret
    // Following Zig compiler pattern from src/frontend/parser.zig:parseType
    if kind == TokenType.Fn {
        parser_advance(p);  // consume 'fn'
        parser_want(p, TokenType.LParen);  // consume '('

        // Parse parameter types (comma-separated)
        while not parser_check(p, TokenType.RParen) and not parser_check(p, TokenType.Eof) {
            let param_type: i64 = parse_type(p);
            // We don't store param types for now - just skip them
            if not parser_check(p, TokenType.Comma) {
                break;
            }
            parser_advance(p);  // consume ','
        }

        parser_want(p, TokenType.RParen);  // consume ')'

        // Parse return type after '->'
        if parser_check(p, TokenType.Arrow) {
            parser_advance(p);  // consume '->'
            let ret_type: i64 = parse_type(p);
        }

        // Return I64 as placeholder - function types not fully implemented
        // This allows type checking to pass for function pointer declarations
        return PTYPE_I64;
    }

    // Error - unexpected token
    p.had_error = true;
    return PTYPE_I64;  // Default
}

// Helper to check if type is a pointer type
fn type_is_pointer(type_handle: i64) bool {
    return type_handle >= PTYPE_PTR_BASE and type_handle < PTYPE_USER_BASE;
}

// Helper to get pointee type from pointer type
fn type_pointee(type_handle: i64) i64 {
    return type_handle - PTYPE_PTR_BASE;
}

// ============================================================================
// Primitive Expression Parsing
// ============================================================================

// Parse integer literal: 42
fn parse_int_lit(p: *Parser) i64 {
    let start: i64 = p.current.start;
    let end: i64 = p.current.end;

    // Parse the integer value from source
    var value: i64 = 0;
    var i: i64 = start;
    while i < start + end {
        let c: u8 = p.source[i];
        if c >= 48 and c <= 57 {  // '0' - '9'
            value = value * 10 + (c - 48);
        }
        i = i + 1;
    }

    parser_advance(p);
    return node_int_lit(p.pool, value, start, start + end);
}

// Parse identifier: foo (not including call - that's handled separately)
fn parse_ident_only(p: *Parser) i64 {
    let start: i64 = p.current.start;
    let length: i64 = p.current.end;
    parser_advance(p);
    return node_ident(p.pool, start, length, start, start + length);
}

// ============================================================================
// Primary Expression Parsing (no recursion)
// ============================================================================

// Parse atom: int_lit | bool_lit | ident (without call or parens)
fn parse_atom(p: *Parser) i64 {
    let kind: TokenType = p.current.kind;

    // Integer literal
    if kind == TokenType.Int {
        return parse_int_lit(p);
    }

    // String literal: "hello"
    if kind == TokenType.StringLit {
        let start: i64 = p.current.start;
        let length: i64 = p.current.end;
        // String content starts after opening quote
        let str_start: i64 = start + 1;
        // String content length is length - 2 (for both quotes)
        let str_len: i64 = length - 2;
        parser_advance(p);
        return node_string_lit(p.pool, str_start, str_len, start, start + length);
    }

    // Character literal: 'A' or '\n'
    if kind == TokenType.CharLit {
        let start: i64 = p.current.start;
        let length: i64 = p.current.end;
        // Get the character value (skip opening quote)
        let char_offset: i64 = start + 1;
        let first_char: u8 = p.source[char_offset];
        var char_value: i64 = 0;
        if first_char == 92 {  // backslash - escape sequence
            let escaped: u8 = p.source[char_offset + 1];
            if escaped == 110 { char_value = 10; }       // \n -> newline
            else if escaped == 116 { char_value = 9; }   // \t -> tab
            else if escaped == 114 { char_value = 13; }  // \r -> carriage return
            else if escaped == 48 { char_value = 0; }    // \0 -> null
            else if escaped == 92 { char_value = 92; }   // \\ -> backslash
            else if escaped == 39 { char_value = 39; }   // \' -> single quote
            else { char_value = @intCast(i64, escaped); }
        } else {
            char_value = @intCast(i64, first_char);
        }
        parser_advance(p);
        return node_int_lit(p.pool, char_value, start, start + length);
    }

    // Boolean literal: true
    if kind == TokenType.True {
        let start: i64 = p.current.start;
        let end: i64 = p.current.start + p.current.end;
        parser_advance(p);
        return node_int_lit(p.pool, 1, start, end);  // true = 1
    }

    // Boolean literal: false
    if kind == TokenType.False {
        let start: i64 = p.current.start;
        let end: i64 = p.current.start + p.current.end;
        parser_advance(p);
        return node_int_lit(p.pool, 0, start, end);  // false = 0
    }

    // Null literal: null
    // Following Zig compiler pattern: null is a zero-valued pointer
    if kind == TokenType.Null {
        let start: i64 = p.current.start;
        let end: i64 = p.current.start + p.current.end;
        parser_advance(p);
        return node_int_lit(p.pool, 0, start, end);  // null = 0 (null pointer)
    }

    // Array literal: [elem1, elem2, ...]
    if kind == TokenType.LBracket {
        let start: i64 = p.current.start;
        parser_advance(p);  // consume '['

        // Parse elements
        let elements_start: i64 = p.pool.children_count;
        var elements_count: i64 = 0;

        // Check for empty array []
        if not parser_check(p, TokenType.RBracket) {
            // Parse first element
            let first: i64 = parse_expr(p);
            node_add_child(p.pool, first);
            elements_count = elements_count + 1;

            // Parse remaining elements
            while parser_check(p, TokenType.Comma) {
                parser_advance(p);  // consume ','
                if parser_check(p, TokenType.RBracket) {
                    break;  // Allow trailing comma
                }
                let elem: i64 = parse_expr(p);
                node_add_child(p.pool, elem);
                elements_count = elements_count + 1;
            }
        }

        let end_pos: i64 = p.current.start + p.current.end;
        parser_want(p, TokenType.RBracket);  // consume ']'

        return node_array_lit(p.pool, elements_start, elements_count, start, end_pos);
    }

    // Identifier
    if kind == TokenType.Ident {
        return parse_ident_only(p);
    }

    // Error - unexpected token - advance to prevent infinite loop
    p.had_error = true;
    parser_advance(p);  // CRITICAL: advance past bad token for error recovery
    return node_int_lit(p.pool, 0, 0, 0);  // Return dummy node
}

// ============================================================================
// Helper to create binary node with int op
// ============================================================================

fn make_binary_node(p: *Parser, op_int: i64, left: i64, right: i64) i64 {
    let left_node: *Node = node_get(p.pool, left);
    let right_node: *Node = node_get(p.pool, right);
    // Use direct enum values to avoid potential compiler issues with enum variables
    // Arithmetic
    if op_int == 0 { return node_binary(p.pool, BinaryOp.Add, left, right, left_node.start, right_node.end); }
    if op_int == 1 { return node_binary(p.pool, BinaryOp.Sub, left, right, left_node.start, right_node.end); }
    if op_int == 2 { return node_binary(p.pool, BinaryOp.Mul, left, right, left_node.start, right_node.end); }
    if op_int == 3 { return node_binary(p.pool, BinaryOp.Div, left, right, left_node.start, right_node.end); }
    if op_int == 4 { return node_binary(p.pool, BinaryOp.Mod, left, right, left_node.start, right_node.end); }
    // Comparison
    if op_int == 5 { return node_binary(p.pool, BinaryOp.Equal, left, right, left_node.start, right_node.end); }
    if op_int == 6 { return node_binary(p.pool, BinaryOp.NotEqual, left, right, left_node.start, right_node.end); }
    if op_int == 7 { return node_binary(p.pool, BinaryOp.Less, left, right, left_node.start, right_node.end); }
    if op_int == 8 { return node_binary(p.pool, BinaryOp.LessEq, left, right, left_node.start, right_node.end); }
    if op_int == 9 { return node_binary(p.pool, BinaryOp.Greater, left, right, left_node.start, right_node.end); }
    if op_int == 10 { return node_binary(p.pool, BinaryOp.GreaterEq, left, right, left_node.start, right_node.end); }
    // Logical
    if op_int == 11 { return node_binary(p.pool, BinaryOp.And, left, right, left_node.start, right_node.end); }
    if op_int == 12 { return node_binary(p.pool, BinaryOp.Or, left, right, left_node.start, right_node.end); }
    // Bitwise
    if op_int == 13 { return node_binary(p.pool, BinaryOp.BitAnd, left, right, left_node.start, right_node.end); }
    if op_int == 14 { return node_binary(p.pool, BinaryOp.BitOr, left, right, left_node.start, right_node.end); }
    if op_int == 15 { return node_binary(p.pool, BinaryOp.BitXor, left, right, left_node.start, right_node.end); }
    if op_int == 16 { return node_binary(p.pool, BinaryOp.Shl, left, right, left_node.start, right_node.end); }
    if op_int == 17 { return node_binary(p.pool, BinaryOp.Shr, left, right, left_node.start, right_node.end); }

    return node_binary(p.pool, BinaryOp.Add, left, right, left_node.start, right_node.end);
}

// ============================================================================
// Expression Parsing (with precedence climbing)
// ============================================================================

// Parse expression inside parens (inline to avoid recursion issues)
fn parse_paren_inner(p: *Parser) i64 {
    var inner: i64 = parse_atom(p);
    var cur_prec: i64 = parser_prec(p);

    // Continue with binary operators inside parens
    while cur_prec > 0 {
        var op1_int: i64 = parser_binop_int(p);
        var op1_prec: i64 = cur_prec;
        parser_advance(p);
        var right1: i64 = parse_atom(p);

        // Handle higher precedence on right
        var right_prec: i64 = parser_prec(p);
        while right_prec > op1_prec {
            var op2_int: i64 = parser_binop_int(p);
            parser_advance(p);
            var right2: i64 = parse_atom(p);
            right1 = make_binary_node(p, op2_int, right1, right2);
            right_prec = parser_prec(p);
        }

        inner = make_binary_node(p, op1_int, inner, right1);
        cur_prec = parser_prec(p);
    }

    return inner;
}

// Parse a single argument expression (inline)
// NOTE: Uses parse_unary (not parse_atom) to handle field access, calls, etc.
fn parse_arg_expr(p: *Parser) i64 {
    var arg: i64 = parse_unary(p);
    var arg_cur_prec: i64 = parser_prec(p);

    while arg_cur_prec > 0 {
        var arg_op_int: i64 = parser_binop_int(p);
        var arg_op_prec: i64 = arg_cur_prec;
        parser_advance(p);
        var arg_right: i64 = parse_unary(p);

        var arg_right_prec: i64 = parser_prec(p);
        while arg_right_prec > arg_op_prec {
            var arg_op2_int: i64 = parser_binop_int(p);
            parser_advance(p);
            var arg_right2: i64 = parse_unary(p);
            arg_right = make_binary_node(p, arg_op2_int, arg_right, arg_right2);
            arg_right_prec = parser_prec(p);
        }

        arg = make_binary_node(p, arg_op_int, arg, arg_right);
        arg_cur_prec = parser_prec(p);
    }

    return arg;
}

// Parse unary/primary expression including calls, parens, and unary ops
fn parse_unary(p: *Parser) i64 {
    let kind: TokenType = p.current.kind;

    // Unary negation: -expr
    if kind == TokenType.Minus {
        let start: i64 = p.current.start;
        parser_advance(p);
        let operand: i64 = parse_unary(p);  // Recursive for chained unary
        return node_unary(p.pool, UnaryOp.Neg, operand, start, p.current.start);
    }

    // Logical NOT: !expr or not expr
    if kind == TokenType.Bang or kind == TokenType.Not {
        let start: i64 = p.current.start;
        parser_advance(p);
        let operand: i64 = parse_unary(p);
        return node_unary(p.pool, UnaryOp.Not, operand, start, p.current.start);
    }

    // Bitwise NOT: ~expr
    if kind == TokenType.Tilde {
        let start: i64 = p.current.start;
        parser_advance(p);
        let operand: i64 = parse_unary(p);
        return node_unary(p.pool, UnaryOp.BitNot, operand, start, p.current.start);
    }

    // Address-of: &expr
    if kind == TokenType.Amp {
        let start: i64 = p.current.start;
        parser_advance(p);
        let operand: i64 = parse_unary(p);
        return node_address_of(p.pool, operand, start, p.current.start);
    }

    // Builtin call: @string(ptr, len), @intCast(type, val), @sizeOf(type)
    if kind == TokenType.At {
        let start: i64 = p.current.start;
        parser_advance(p);  // Consume '@'

        // Parse builtin name (must be an identifier)
        let name_start: i64 = p.current.start;
        let name_len: i64 = p.current.end;
        parser_want(p, TokenType.Ident);

        parser_want(p, TokenType.LParen);

        // Determine which builtin based on name length and characters
        var type_arg: i64 = 0 - 1;
        var arg1: i64 = 0 - 1;
        var arg2: i64 = 0 - 1;

        // @string(ptr, len) - two expression args
        if name_len == 6 and p.source[name_start] == 115 and p.source[name_start + 1] == 116 and
           p.source[name_start + 2] == 114 and p.source[name_start + 3] == 105 and
           p.source[name_start + 4] == 110 and p.source[name_start + 5] == 103 {
            // "string" - parse two expr args
            arg1 = parse_expr(p);
            parser_want(p, TokenType.Comma);
            arg2 = parse_expr(p);
        }
        // @intCast(type, val) - type arg + expr arg
        else if name_len == 7 and p.source[name_start] == 105 and p.source[name_start + 1] == 110 and
                p.source[name_start + 2] == 116 and p.source[name_start + 3] == 67 and
                p.source[name_start + 4] == 97 and p.source[name_start + 5] == 115 and
                p.source[name_start + 6] == 116 {
            // "intCast" - parse type then expr
            type_arg = parse_type(p);
            parser_want(p, TokenType.Comma);
            arg1 = parse_expr(p);
        }
        // @sizeOf(type) - just type arg
        else if name_len == 6 and p.source[name_start] == 115 and p.source[name_start + 1] == 105 and
                p.source[name_start + 2] == 122 and p.source[name_start + 3] == 101 and
                p.source[name_start + 4] == 79 and p.source[name_start + 5] == 102 {
            // "sizeOf" - parse just type
            type_arg = parse_type(p);
        }
        // @alignOf(type) - just type arg
        else if name_len == 7 and p.source[name_start] == 97 and p.source[name_start + 1] == 108 and
                p.source[name_start + 2] == 105 and p.source[name_start + 3] == 103 and
                p.source[name_start + 4] == 110 and p.source[name_start + 5] == 79 and
                p.source[name_start + 6] == 102 {
            // "alignOf" - parse just type
            type_arg = parse_type(p);
        }
        // Unknown builtin - just parse args generically (2 expressions)
        else {
            arg1 = parse_expr(p);
            if parser_check(p, TokenType.Comma) {
                parser_advance(p);
                arg2 = parse_expr(p);
            }
        }

        parser_want(p, TokenType.RParen);

        return node_builtin_call(p.pool, name_start, name_len, type_arg, arg1, arg2, start, p.current.start);
    }

    // Parenthesized expression
    if kind == TokenType.LParen {
        parser_advance(p);
        let inner: i64 = parse_paren_inner(p);
        parser_want(p, TokenType.RParen);
        return inner;
    }

    // Identifier - check for call or field access
    if kind == TokenType.Ident {
        var result: i64 = parse_ident_only(p);

        // Loop to handle chained postfix operations: foo.bar.baz, Type.Variant, foo()
        var done: bool = false;
        while not done {
            // Check for field access or dereference: expr.field or expr.*
            if parser_check(p, TokenType.Dot) {
                parser_advance(p);  // Consume '.'

                // Check for dereference: expr.*
                if parser_check(p, TokenType.Star) {
                    let result_node: *Node = node_get(p.pool, result);
                    parser_advance(p);  // Consume '*'
                    result = node_deref(p.pool, result, result_node.start, p.current.start);
                } else {
                    // Field/variant name
                    let field_start: i64 = p.current.start;
                    let field_len: i64 = p.current.end;
                    parser_want(p, TokenType.Ident);

                    let result_node: *Node = node_get(p.pool, result);
                    result = node_field_access(p.pool, result, field_start, field_len,
                                              result_node.start, p.current.start);
                }
            }
            // Check for function call
            else if parser_check(p, TokenType.LParen) {
                let call_start: i64 = p.current.start;
                parser_advance(p);  // Consume '('

                // Record start of arguments in children array
                let args_start: i64 = p.pool.children_count;
                var args_count: i64 = 0;

                // Parse argument list
                if not parser_check(p, TokenType.RParen) {
                    // First argument
                    let first_arg: i64 = parse_arg_expr(p);
                    node_add_child(p.pool, first_arg);
                    args_count = args_count + 1;

                    // Additional arguments
                    while parser_got(p, TokenType.Comma) {
                        let next_arg: i64 = parse_arg_expr(p);
                        node_add_child(p.pool, next_arg);
                        args_count = args_count + 1;
                    }
                }

                let end: i64 = p.current.start + p.current.end;
                parser_want(p, TokenType.RParen);

                result = node_call(p.pool, result, args_start, args_count, call_start, end);
            }
            // Check for array indexing: expr[index]
            else if parser_check(p, TokenType.LBracket) {
                let result_node: *Node = node_get(p.pool, result);
                let start: i64 = result_node.start;
                parser_advance(p);  // Consume '['

                // Parse index expression
                let index: i64 = parse_expr(p);

                let end: i64 = p.current.start + p.current.end;
                parser_want(p, TokenType.RBracket);

                result = node_index(p.pool, result, index, start, end);
            }
            // Check for struct literal: TypeName{ .field = value, ... }
            // IMPORTANT: Only if next token after '{' is '.' (to distinguish from blocks)
            else if parser_check(p, TokenType.LBrace) and parser_peek_next_is_dot(p) {
                // result should be an Ident node (the type name)
                let result_node: *Node = node_get(p.pool, result);
                if result_node.kind == NodeKind.Ident {
                    let type_name_start: i64 = result_node.field0;
                    let type_name_len: i64 = result_node.field1;
                    let lit_start: i64 = result_node.start;

                    parser_advance(p);  // Consume '{'

                    // Record start of field initializers in children array
                    let fields_start: i64 = p.pool.children_count;
                    var fields_count: i64 = 0;

                    // Parse field initializers: .field = value, ...
                    while not parser_check(p, TokenType.RBrace) {
                        let field_start: i64 = p.current.start;

                        // Expect '.'
                        parser_want(p, TokenType.Dot);

                        // Field name
                        let fname_start: i64 = p.current.start;
                        let fname_len: i64 = p.current.end;  // Token.end is the length
                        parser_want(p, TokenType.Ident);

                        // Expect '='
                        parser_want(p, TokenType.Eq);

                        // Field value expression
                        let fvalue: i64 = parse_expr(p);

                        let field_end: i64 = p.current.start;
                        let finit: i64 = node_field_init(p.pool, fname_start, fname_len,
                                                         fvalue, field_start, field_end);
                        node_add_child(p.pool, finit);
                        fields_count = fields_count + 1;

                        // Optional trailing comma
                        if not parser_check(p, TokenType.RBrace) {
                            parser_want(p, TokenType.Comma);
                        }
                    }

                    let lit_end: i64 = p.current.start + p.current.end;
                    parser_want(p, TokenType.RBrace);

                    result = node_struct_lit(p.pool, type_name_start, type_name_len,
                                            fields_start, fields_count, lit_start, lit_end);
                } else {
                    // Not an identifier, can't be struct literal
                    done = true;
                }
            }
            else {
                done = true;
            }
        }
        return result;
    }

    // Other atoms
    return parse_atom(p);
}

// Parse binary expression with precedence climbing
// Following Go's binaryExpr pattern from parser.go:865-882
fn parse_binary_expr(p: *Parser, left: i64, min_prec: i64) i64 {
    var x: i64 = left;
    var bin_cur_prec: i64 = parser_prec(p);

    // While current operator has higher precedence than minimum
    while bin_cur_prec > min_prec {
        var bin_op_int: i64 = parser_binop_int(p);
        var bin_op_prec: i64 = bin_cur_prec;

        parser_advance(p);  // Consume operator

        // Parse right operand
        var right: i64 = parse_unary(p);

        // Handle higher-precedence operators on the right
        right = parse_binary_expr(p, right, bin_op_prec);

        // Create binary node
        x = make_binary_node(p, bin_op_int, x, right);
        bin_cur_prec = parser_prec(p);
    }

    return x;
}

// Parse any expression
fn parse_expr(p: *Parser) i64 {
    let start: i64 = p.current.start;
    let left: i64 = parse_unary(p);
    let expr: i64 = parse_binary_expr(p, left, 0);

    // Check for assignment: expr = value
    if parser_got(p, TokenType.Eq) {
        let value: i64 = parse_expr(p);  // Right-associative
        let end: i64 = p.current.start;
        return node_assign(p.pool, expr, value, start, end);
    }

    return expr;
}

// ============================================================================
// Statement Parsing
// ============================================================================

// Parse return statement: return expr;
fn parse_return_stmt(p: *Parser) i64 {
    let start: i64 = p.current.start;
    parser_want(p, TokenType.Return);

    // Optional return value - check if next token looks like no value
    // (semicolon, closing brace, or statement-starting keywords)
    var value: i64 = -1;
    let k: TokenType = p.current.kind;
    let no_value: bool = k == TokenType.Semi or k == TokenType.RBrace or
                         k == TokenType.Return or k == TokenType.Let or
                         k == TokenType.Var or k == TokenType.If or
                         k == TokenType.While or k == TokenType.For or
                         k == TokenType.Break or k == TokenType.Continue;
    if not no_value {
        value = parse_expr(p);
    }

    let end: i64 = p.current.start + p.current.end;
    parser_got(p, TokenType.Semi);  // Optional semicolon

    return node_return(p.pool, value, start, end);
}

// Parse variable declaration: let name: type = expr; OR var name: type = expr;
fn parse_var_decl(p: *Parser) i64 {
    let start: i64 = p.current.start;

    // Check if 'let', 'const', or 'var'
    // is_let: 0 = var (mutable), 1 = let (immutable), 2 = const (compile-time const)
    var is_let: i64 = 0;
    if parser_check(p, TokenType.Let) {
        is_let = 1;
        parser_advance(p);
    } else if parser_check(p, TokenType.Const) {
        is_let = 2;  // const treated as immutable like let
        parser_advance(p);
    } else {
        parser_want(p, TokenType.Var);
    }

    // Variable name
    let name_start: i64 = p.current.start;
    let name_len: i64 = p.current.end;
    parser_want(p, TokenType.Ident);

    // Type annotation (required for now)
    var type_start: i64 = 0;
    var type_handle: i64 = PTYPE_I64;  // Default to i64
    if parser_got(p, TokenType.Colon) {
        type_start = p.current.start;
        type_handle = parse_type(p);
    }

    // Optional initializer
    var init_expr: i64 = -1;
    if parser_got(p, TokenType.Eq) {
        init_expr = parse_expr(p);
    }

    let end: i64 = p.current.start + p.current.end;
    parser_got(p, TokenType.Semi);  // Optional semicolon

    return node_var_decl(p.pool, is_let, name_start, name_len, type_start, type_handle, init_expr, start, end);
}

// Parse if statement: if expr { body } [else { body }]
fn parse_if_stmt(p: *Parser) i64 {
    let start: i64 = p.current.start;
    parser_want(p, TokenType.If);

    // Condition expression (no parens required like Go/Cot)
    let cond: i64 = parse_expr(p);

    // Then body (block required)
    let then_body: i64 = parse_block(p);

    // Optional else clause
    var else_body: i64 = -1;
    if parser_got(p, TokenType.Else) {
        // Check for 'else if' (chain)
        if parser_check(p, TokenType.If) {
            // Recursively parse if-else-if chain
            else_body = parse_if_stmt(p);
        } else {
            // Plain else block
            else_body = parse_block(p);
        }
    }

    let end: i64 = p.current.start;
    return node_if_stmt(p.pool, cond, then_body, else_body, start, end);
}

// Parse while statement: while expr { body }
fn parse_while_stmt(p: *Parser) i64 {
    let start: i64 = p.current.start;
    parser_want(p, TokenType.While);

    // Condition expression
    let cond: i64 = parse_expr(p);

    // Body block
    let body: i64 = parse_block(p);

    let end: i64 = p.current.start;
    return node_while_stmt(p.pool, cond, body, start, end);
}

// Parse expression statement: expr;
fn parse_expr_stmt(p: *Parser) i64 {
    let start: i64 = p.current.start;
    let expr: i64 = parse_expr(p);
    let end: i64 = p.current.start + p.current.end;
    parser_got(p, TokenType.Semi);  // Optional semicolon
    return node_expr_stmt(p.pool, expr, start, end);
}

// Parse a statement (dispatch based on token)
fn parse_stmt(p: *Parser) i64 {
    let kind: TokenType = p.current.kind;

    // Return statement
    if kind == TokenType.Return {
        return parse_return_stmt(p);
    }

    // Variable declarations (let, var, const)
    if kind == TokenType.Let or kind == TokenType.Var or kind == TokenType.Const {
        return parse_var_decl(p);
    }

    // Control flow statements
    if kind == TokenType.If {
        return parse_if_stmt(p);
    }

    if kind == TokenType.While {
        return parse_while_stmt(p);
    }

    // Break statement
    if kind == TokenType.Break {
        let start: i64 = p.current.start;
        parser_advance(p);
        parser_got(p, TokenType.Semi);  // Optional semicolon
        return node_break_stmt(p.pool, start, p.current.start);
    }

    // Continue statement
    if kind == TokenType.Continue {
        let start: i64 = p.current.start;
        parser_advance(p);
        parser_got(p, TokenType.Semi);  // Optional semicolon
        return node_continue_stmt(p.pool, start, p.current.start);
    }

    // Default: expression statement
    return parse_expr_stmt(p);
}

// Parse block: { stmt* }
// NOTE: We must collect statement indices first, THEN add them to children.
// This is because nested blocks (e.g., if body) add their children during parsing,
// which would interleave with our children if we add them as we go.
fn parse_block(p: *Parser) i64 {
    let start: i64 = p.current.start;
    parser_want(p, TokenType.LBrace);

    // Temporary storage for statement indices (parse first, add children later)
    var stmt_indices: [128]i64 = undefined;
    var stmts_count: i64 = 0;

    // Parse statements until '}'
    while not parser_check(p, TokenType.RBrace) and not parser_at_end(p) {
        let stmt: i64 = parse_stmt(p);
        stmt_indices[stmts_count] = stmt;
        stmts_count = stmts_count + 1;
    }

    let end: i64 = p.current.start + p.current.end;
    parser_want(p, TokenType.RBrace);

    // NOW add children - this ensures stmts_start is correct even with nested blocks
    let stmts_start: i64 = p.pool.children_count;
    var i: i64 = 0;
    while i < stmts_count {
        node_add_child(p.pool, stmt_indices[i]);
        i = i + 1;
    }

    return node_block(p.pool, stmts_start, stmts_count, start, end);
}

// ============================================================================
// Declaration Parsing
// ============================================================================

// Parse parameter: name: type
fn parse_param(p: *Parser) i64 {
    let start: i64 = p.current.start;

    // Parameter name
    let name_start: i64 = p.current.start;
    let name_len: i64 = p.current.end;
    parser_want(p, TokenType.Ident);

    // Colon
    parser_want(p, TokenType.Colon);

    // Type (use parse_type for all types)
    let type_start: i64 = p.current.start;
    let type_handle: i64 = parse_type(p);
    let type_len: i64 = p.current.start - type_start;  // Calculate length from position

    let end: i64 = p.current.start;
    // Note: we store type_handle in type_len field for now (type_start is unused for built-in types)
    return node_param(p.pool, name_start, name_len, type_start, type_handle, start, end);
}

// Parse extern function declaration: extern fn name(params) ret_type;
fn parse_extern_fn_decl(p: *Parser) i64 {
    let start: i64 = p.current.start;
    parser_want(p, TokenType.Extern);
    parser_want(p, TokenType.Fn);

    // Function name
    let name_start: i64 = p.current.start;
    let name_len: i64 = p.current.end;
    parser_want(p, TokenType.Ident);

    // Parameters
    parser_want(p, TokenType.LParen);
    let params_start: i64 = p.pool.children_count;
    var params_count: i64 = 0;

    if not parser_check(p, TokenType.RParen) {
        // First parameter
        let param: i64 = parse_param(p);
        node_add_child(p.pool, param);
        params_count = params_count + 1;

        // Additional parameters
        while parser_got(p, TokenType.Comma) {
            let next_param: i64 = parse_param(p);
            node_add_child(p.pool, next_param);
            params_count = params_count + 1;
        }
    }
    parser_want(p, TokenType.RParen);

    // Return type
    let ret_type_start: i64 = p.current.start;
    let ret_type_handle: i64 = parse_type(p);

    // Optional semicolon (extern fn has no body)
    parser_got(p, TokenType.Semi);

    let end: i64 = p.current.start;

    // Create extern function declaration node
    return node_extern_fn_decl(p.pool, name_start, name_len, params_start, params_count, ret_type_start, ret_type_handle, start, end);
}

// Parse function declaration: fn name(params) ret_type { body }
fn parse_fn_decl(p: *Parser) i64 {
    let start: i64 = p.current.start;
    parser_want(p, TokenType.Fn);

    // Function name
    let name_start: i64 = p.current.start;
    let name_len: i64 = p.current.end;
    parser_want(p, TokenType.Ident);

    // Parameters
    parser_want(p, TokenType.LParen);
    let params_start: i64 = p.pool.children_count;
    var params_count: i64 = 0;

    if not parser_check(p, TokenType.RParen) {
        // First parameter
        let param: i64 = parse_param(p);
        node_add_child(p.pool, param);
        params_count = params_count + 1;

        // Additional parameters
        while parser_got(p, TokenType.Comma) {
            let next_param: i64 = parse_param(p);
            node_add_child(p.pool, next_param);
            params_count = params_count + 1;
        }
    }
    parser_want(p, TokenType.RParen);

    // Return type - optional, defaults to void if { follows immediately
    let ret_type_start: i64 = p.current.start;
    var ret_type_handle: i64 = PTYPE_VOID;  // Default to void
    if not parser_check(p, TokenType.LBrace) {
        ret_type_handle = parse_type(p);
    }

    // Body
    let body: i64 = parse_block(p);

    let end: i64 = p.current.start;

    // Create function declaration node
    // Note: we store ret_type_handle in ret_type_len field (ret_type_start for user types)
    let fn_idx: i64 = node_fn_decl(p.pool, name_start, name_len, params_start, params_count, ret_type_start, ret_type_handle, body, start, end);

    return fn_idx;
}

// ============================================================================
// Sprint B: Struct/Enum Declaration Parsing
// Following Go's cmd/compile/internal/syntax/parser.go patterns
// ============================================================================

// Parse struct field: name: type,
fn parse_struct_field(p: *Parser) i64 {
    let start: i64 = p.current.start;

    // Field name
    let name_start: i64 = p.current.start;
    let name_len: i64 = p.current.end;  // Token.end is the length
    parser_want(p, TokenType.Ident);

    // Colon
    parser_want(p, TokenType.Colon);

    // Type
    let type_start: i64 = p.current.start;
    let type_handle: i64 = parse_type(p);

    let end: i64 = p.current.start;

    // Comma is optional (handled by caller)
    return node_field_decl(p.pool, name_start, name_len, type_start, type_handle, start, end);
}

// Parse struct declaration: struct Name { fields }
fn parse_struct_decl(p: *Parser) i64 {
    let start: i64 = p.current.start;
    parser_want(p, TokenType.Struct);

    // Struct name
    let name_start: i64 = p.current.start;
    let name_len: i64 = p.current.end;
    parser_want(p, TokenType.Ident);

    // Opening brace
    parser_want(p, TokenType.LBrace);

    // Parse fields
    let fields_start: i64 = p.pool.children_count;
    var fields_count: i64 = 0;

    while not parser_check(p, TokenType.RBrace) and not parser_at_end(p) {
        let field: i64 = parse_struct_field(p);
        node_add_child(p.pool, field);
        fields_count = fields_count + 1;

        // Optional comma between fields
        parser_got(p, TokenType.Comma);
    }

    let end: i64 = p.current.start + p.current.end;
    parser_want(p, TokenType.RBrace);

    return node_struct_decl(p.pool, name_start, name_len, fields_start, fields_count, start, end);
}

// Parse enum variant: just an identifier
// Stores as an Ident node (variant_start, variant_len)
fn parse_enum_variant(p: *Parser) i64 {
    let start: i64 = p.current.start;
    let name_len: i64 = p.current.end;  // Token.end is the length
    parser_want(p, TokenType.Ident);
    return node_ident(p.pool, start, name_len, start, start + name_len);
}

// Parse enum declaration: enum Name { variants }
fn parse_enum_decl(p: *Parser) i64 {
    let start: i64 = p.current.start;
    parser_want(p, TokenType.Enum);

    // Enum name
    let name_start: i64 = p.current.start;
    let name_len: i64 = p.current.end;
    parser_want(p, TokenType.Ident);

    // Opening brace
    parser_want(p, TokenType.LBrace);

    // Parse variants
    let variants_start: i64 = p.pool.children_count;
    var variants_count: i64 = 0;

    while not parser_check(p, TokenType.RBrace) and not parser_at_end(p) {
        let variant: i64 = parse_enum_variant(p);
        node_add_child(p.pool, variant);
        variants_count = variants_count + 1;

        // Optional comma between variants
        parser_got(p, TokenType.Comma);
    }

    let end: i64 = p.current.start + p.current.end;
    parser_want(p, TokenType.RBrace);

    return node_enum_decl(p.pool, name_start, name_len, variants_start, variants_count, start, end);
}

// ============================================================================
// Sprint D: Import and Const Declarations
// ============================================================================

// Parse import declaration: import "path";
fn parse_import(p: *Parser) i64 {
    let start: i64 = p.current.start;
    parser_want(p, TokenType.Import);

    // Expect string literal for path
    if not parser_check(p, TokenType.StringLit) {
        p.had_error = true;
        return -1;
    }

    let path_token_start: i64 = p.current.start;
    let path_token_len: i64 = p.current.end;
    // Path content starts after opening quote
    let path_start: i64 = path_token_start + 1;
    // Path length is token length - 2 (for both quotes)
    let path_len: i64 = path_token_len - 2;
    parser_advance(p);

    // Optional semicolon
    parser_got(p, TokenType.Semi);

    let end: i64 = p.current.start;
    return node_import_decl(p.pool, path_start, path_len, start, end);
}

// Parse const declaration: const NAME = expr; or const NAME: type = expr;
fn parse_const_decl(p: *Parser) i64 {
    let start: i64 = p.current.start;
    parser_want(p, TokenType.Const);

    // Constant name
    let name_start: i64 = p.current.start;
    let name_len: i64 = p.current.end;
    parser_want(p, TokenType.Ident);

    // Optional type annotation
    var type_handle: i64 = -1;
    if parser_got(p, TokenType.Colon) {
        type_handle = parse_type(p);
    }

    // Required initializer
    parser_want(p, TokenType.Eq);
    let init_expr: i64 = parse_expr(p);

    let end: i64 = p.current.start + p.current.end;
    parser_got(p, TokenType.Semi);  // Optional semicolon

    return node_const_decl(p.pool, name_start, name_len, type_handle, init_expr, start, end);
}

// Parse var declaration at top level: var NAME: type = expr;
// Following Zig parser's pattern for parseVarDecl
fn parse_global_var_decl(p: *Parser) i64 {
    let start: i64 = p.current.start;
    parser_want(p, TokenType.Var);

    // Variable name
    let name_start: i64 = p.current.start;
    let name_len: i64 = p.current.end;
    parser_want(p, TokenType.Ident);

    // Type annotation (required for globals)
    var type_handle: i64 = -1;
    var type_start: i64 = 0;
    if parser_got(p, TokenType.Colon) {
        type_start = p.current.start;
        type_handle = parse_type(p);
    }

    // Optional initializer
    var init_expr: i64 = -1;
    if parser_got(p, TokenType.Eq) {
        init_expr = parse_expr(p);
    }

    let end: i64 = p.current.start + p.current.end;
    parser_got(p, TokenType.Semi);  // Optional semicolon

    // Use node_var_decl with is_let=0 (indicating var, not let)
    return node_var_decl(p.pool, 0, name_start, name_len, type_start, type_handle, init_expr, start, end);
}

// ============================================================================
// Top-Level Parsing
// ============================================================================

// Parse a single top-level declaration
fn parse_decl(p: *Parser) i64 {
    // Import must come first
    if parser_check(p, TokenType.Import) {
        return parse_import(p);
    }

    // Extern function declaration
    if parser_check(p, TokenType.Extern) {
        return parse_extern_fn_decl(p);
    }

    // Const declaration
    if parser_check(p, TokenType.Const) {
        return parse_const_decl(p);
    }

    // Var declaration (global variable)
    if parser_check(p, TokenType.Var) {
        return parse_global_var_decl(p);
    }

    if parser_check(p, TokenType.Fn) {
        return parse_fn_decl(p);
    }

    if parser_check(p, TokenType.Struct) {
        return parse_struct_decl(p);
    }

    if parser_check(p, TokenType.Enum) {
        return parse_enum_decl(p);
    }

    // Error - unexpected token at top level
    p.had_error = true;
    parser_advance(p);  // Skip bad token
    return -1;
}

// Parse entire file (list of declarations)
fn parse_file(p: *Parser) i64 {
    // Store declarations in children array
    let decls_start: i64 = p.pool.children_count;
    var decls_count: i64 = 0;

    while not parser_at_end(p) {
        let decl: i64 = parse_decl(p);
        if decl != -1 {
            node_add_child(p.pool, decl);
            decls_count = decls_count + 1;
        }
    }

    // Return a block node representing the file
    return node_block(p.pool, decls_start, decls_count, 0, p.scanner.pos);
}

// ============================================================================
// Utility Functions
// ============================================================================

// Get source text for a node (name, etc.)
fn get_source_text(p: *Parser, start: i64, length: i64) string {
    return @string(p.source.ptr + start, length);
}

// Check if parser encountered errors
fn parser_had_error(p: *Parser) bool {
    return p.had_error;
}

// Cot0 Intermediate Representation
// Strongly typed IR following Go's cmd/compile/internal/ir patterns.
//
// Design principles (from Go + bootstrap-0.2):
// 1. Op discriminator drives type switching
// 2. Every operation has explicit fields
// 3. Uses pointers for arrays (like ast.cot)
//
// Reference: ~/learning/go/src/cmd/compile/internal/ir/
// Reference: bootstrap-0.2/src/frontend/ir.zig

import "types.cot"

// ============================================================================
// Index Types - Distinct to prevent mixing
// NOTE: NULL_NODE is defined in ast.cot to avoid redefinition
// ============================================================================

const NULL_IR_NODE: i64 = -1;
const NULL_LOCAL: i64 = -1;
const NULL_BLOCK: i64 = -1;

// ============================================================================
// Binary Operation Kinds (Go's OADD, OSUB, OEQ, etc.)
// ============================================================================

enum IRBinaryOp {
    // Arithmetic
    Add,
    Sub,
    Mul,
    Div,
    Mod,

    // Comparison
    Eq,
    Ne,
    Lt,
    Le,
    Gt,
    Ge,

    // Logical
    And,
    Or,

    // Bitwise
    BitAnd,
    BitOr,
    BitXor,
    Shl,
    Shr,
}

// Check if this is a comparison operation (returns bool)
fn ir_is_comparison(op: IRBinaryOp) bool {
    if op == IRBinaryOp.Eq { return true; }
    if op == IRBinaryOp.Ne { return true; }
    if op == IRBinaryOp.Lt { return true; }
    if op == IRBinaryOp.Le { return true; }
    if op == IRBinaryOp.Gt { return true; }
    if op == IRBinaryOp.Ge { return true; }
    return false;
}

// Check if this is an arithmetic operation
fn ir_is_arithmetic(op: IRBinaryOp) bool {
    if op == IRBinaryOp.Add { return true; }
    if op == IRBinaryOp.Sub { return true; }
    if op == IRBinaryOp.Mul { return true; }
    if op == IRBinaryOp.Div { return true; }
    if op == IRBinaryOp.Mod { return true; }
    return false;
}

// Check if this is a logical operation
fn ir_is_logical(op: IRBinaryOp) bool {
    if op == IRBinaryOp.And { return true; }
    if op == IRBinaryOp.Or { return true; }
    return false;
}

// Check if this is a bitwise operation
fn ir_is_bitwise(op: IRBinaryOp) bool {
    if op == IRBinaryOp.BitAnd { return true; }
    if op == IRBinaryOp.BitOr { return true; }
    if op == IRBinaryOp.BitXor { return true; }
    if op == IRBinaryOp.Shl { return true; }
    if op == IRBinaryOp.Shr { return true; }
    return false;
}

// ============================================================================
// Unary Operation Kinds (Go's ONEG, ONOT, etc.)
// ============================================================================

enum IRUnaryOp {
    Neg,      // Arithmetic negation: -x
    Not,      // Logical not: !x
    BitNot,   // Bitwise not: ~x
}

// ============================================================================
// IR Node Kinds (Go's Op enum)
// ============================================================================

enum IRNodeKind {
    // Constants
    ConstInt,
    ConstBool,
    ConstNull,
    ConstString,  // String literal: str_start, str_len in source

    // Variable access
    LoadLocal,
    StoreLocal,
    AddrLocal,

    // Pointer operations
    Load,         // Load from pointer: left = ptr_expr
    Store,        // Store to pointer: left = ptr_expr, right = value

    // Field access (struct fields)
    FieldLocal,   // Access field of local struct: left = local_idx, right = offset
    FieldValue,   // Access field via pointer: left = base_expr, right = offset
    StoreFieldLocal,  // Store to field of local struct: left = local_idx, right = offset, value = stored_expr
    StoreField,   // Store to field via pointer: left = base_expr, right = offset, value = stored_expr

    // Operations
    Binary,
    Unary,

    // Control flow
    Call,
    Return,
    Jump,
    Branch,

    // Phi (SSA)
    Phi,

    // Misc
    Nop,
}

// ============================================================================
// IR Node - A single operation
// ============================================================================

struct IRNode {
    kind: IRNodeKind,
    type_idx: i64,        // Result type
    block_id: i64,        // Block this node belongs to

    // Fields used depending on kind:
    // ConstInt: value
    // ConstString: left (str_start), right (str_len)
    // Binary: op, left, right
    // Unary: op, left (operand)
    // LoadLocal/StoreLocal/AddrLocal: left (local_idx)
    // StoreLocal: right (value)
    // Load: left (ptr_expr)
    // Store: left (ptr_expr), right (value_expr)
    // FieldLocal: left (local_idx), right (offset)
    // FieldValue: left (base_expr), right (offset)
    // StoreFieldLocal: left (local_idx), right (offset), value (stored_expr)
    // StoreField: left (base_expr), right (offset), value (stored_expr)
    // Call: func_name_start, func_name_len, args_start, args_count
    // Return: left (value), or -1 for void
    // Jump: left (target_block)
    // Branch: left (condition), right (then_block), value (else_block)

    value: i64,           // ConstInt value, or else_block for Branch
    left: i64,            // Left operand, local_idx, condition, etc.
    right: i64,           // Right operand, value for store, etc.
    op: i64,              // Operator code (BinaryOp or UnaryOp cast to i64)

    // For Call nodes
    func_name_start: i64,
    func_name_len: i64,
    args_start: i64,
    args_count: i64,
}

fn ir_node_new(kind: IRNodeKind, type_idx: i64) IRNode {
    return IRNode{
        .kind = kind,
        .type_idx = type_idx,
        .block_id = 0,
        .value = 0,
        .left = NULL_IR_NODE,
        .right = NULL_IR_NODE,
        .op = 0,
        .func_name_start = 0,
        .func_name_len = 0,
        .args_start = 0,
        .args_count = 0,
    };
}

// Check if node is a terminator (ends a basic block)
fn ir_node_is_terminator(node: *IRNode) bool {
    if node.kind == IRNodeKind.Return { return true; }
    if node.kind == IRNodeKind.Jump { return true; }
    if node.kind == IRNodeKind.Branch { return true; }
    return false;
}

// Check if node is a constant
fn ir_node_is_constant(node: *IRNode) bool {
    if node.kind == IRNodeKind.ConstInt { return true; }
    if node.kind == IRNodeKind.ConstBool { return true; }
    if node.kind == IRNodeKind.ConstNull { return true; }
    return false;
}

// ============================================================================
// IR Node Pool - Arena for IR nodes (pointer-based like ast.cot)
// NOTE: Named IRNodePool to avoid conflict with ast.cot's NodePool
// ============================================================================

struct IRNodePool {
    nodes: *IRNode,       // Externally allocated array
    nodes_count: i64,
    nodes_cap: i64,
}

fn ir_node_pool_init(pool: *IRNodePool, nodes: *IRNode, cap: i64) {
    pool.nodes = nodes;
    pool.nodes_count = 0;
    pool.nodes_cap = cap;
}

fn ir_node_pool_add(pool: *IRNodePool, node: IRNode) i64 {
    if pool.nodes_count >= pool.nodes_cap {
        return NULL_IR_NODE;
    }
    let idx: i64 = pool.nodes_count;
    let ptr: *IRNode = pool.nodes + idx;
    ptr.* = node;
    pool.nodes_count = pool.nodes_count + 1;
    return idx;
}

fn ir_node_pool_get(pool: *IRNodePool, idx: i64) *IRNode {
    return pool.nodes + idx;
}

fn ir_node_pool_add_const_int(pool: *IRNodePool, value: i64, type_idx: i64) i64 {
    var node: IRNode = ir_node_new(IRNodeKind.ConstInt, type_idx);
    node.value = value;
    return ir_node_pool_add(pool, node);
}

fn ir_node_pool_add_binary(pool: *IRNodePool, op: i64, left: i64, right: i64, type_idx: i64) i64 {
    var node: IRNode = ir_node_new(IRNodeKind.Binary, type_idx);
    node.op = op;
    node.left = left;
    node.right = right;
    return ir_node_pool_add(pool, node);
}

// ============================================================================
// Local Variable
// ============================================================================

struct IRLocal {
    name_start: i64,      // Offset into source for name
    name_len: i64,        // Length of name
    type_idx: i64,        // Type index
    is_mutable: bool,     // Can be modified?
    is_param: bool,       // Is this a parameter?
    param_idx: i64,       // Parameter index (if is_param)
    size: i64,            // Size in bytes
    offset: i64,          // Stack frame offset
}

fn ir_local_new(name_start: i64, name_len: i64, type_idx: i64, is_mutable: bool) IRLocal {
    return IRLocal{
        .name_start = name_start,
        .name_len = name_len,
        .type_idx = type_idx,
        .is_mutable = is_mutable,
        .is_param = false,
        .param_idx = 0,
        .size = 8,
        .offset = 0,
    };
}

fn ir_local_new_param(name_start: i64, name_len: i64, type_idx: i64, param_idx: i64) IRLocal {
    return IRLocal{
        .name_start = name_start,
        .name_len = name_len,
        .type_idx = type_idx,
        .is_mutable = false,
        .is_param = true,
        .param_idx = param_idx,
        .size = 8,
        .offset = 0,
    };
}

// ============================================================================
// IR Function Metadata - Tracks function boundaries in IR
// ============================================================================

struct IRFunc {
    name_start: i64,      // Offset into source for name
    name_len: i64,        // Length of name
    return_type: i64,     // Return type index

    nodes_start: i64,     // Start index in IR nodes array
    nodes_count: i64,     // Number of IR nodes

    locals_start: i64,    // Start index in locals array
    locals_count: i64,    // Number of locals

    code_offset: i64,     // Offset in generated code (set during codegen)
}

fn ir_func_new(name_start: i64, name_len: i64, return_type: i64,
               nodes_start: i64, nodes_count: i64,
               locals_start: i64, locals_count: i64) IRFunc {
    return IRFunc{
        .name_start = name_start,
        .name_len = name_len,
        .return_type = return_type,
        .nodes_start = nodes_start,
        .nodes_count = nodes_count,
        .locals_start = locals_start,
        .locals_count = locals_count,
        .code_offset = 0,
    };
}

// ============================================================================
// Function Builder - Constructs IR functions (pointer-based)
// ============================================================================

struct FuncBuilder {
    name_start: i64,
    name_len: i64,
    return_type: i64,

    locals: *IRLocal,         // Externally allocated
    locals_count: i64,
    locals_cap: i64,

    nodes: *IRNode,           // Externally allocated
    nodes_count: i64,
    nodes_cap: i64,

    // Block tracking
    current_block: i64,       // Currently active block ID
    next_block_id: i64,       // Next block ID to allocate
}

fn func_builder_init(fb: *FuncBuilder, name_start: i64, name_len: i64, return_type: i64,
                     locals: *IRLocal, locals_cap: i64,
                     nodes: *IRNode, nodes_cap: i64) {
    fb.name_start = name_start;
    fb.name_len = name_len;
    fb.return_type = return_type;
    fb.locals = locals;
    fb.locals_count = 0;
    fb.locals_cap = locals_cap;
    fb.nodes = nodes;
    fb.nodes_count = 0;
    fb.nodes_cap = nodes_cap;
    fb.current_block = 0;
    fb.next_block_id = 1;  // Block 0 is the entry block
}

// Create a new block and return its ID
fn func_builder_new_block(fb: *FuncBuilder) i64 {
    let id: i64 = fb.next_block_id;
    fb.next_block_id = fb.next_block_id + 1;
    return id;
}

// Set the current block for subsequent nodes
fn func_builder_set_block(fb: *FuncBuilder, block_id: i64) {
    fb.current_block = block_id;
}

fn func_builder_add_local(fb: *FuncBuilder, name_start: i64, name_len: i64,
                          type_idx: i64, is_mutable: bool) i64 {
    if fb.locals_count >= fb.locals_cap {
        return NULL_LOCAL;
    }
    let idx: i64 = fb.locals_count;
    let ptr: *IRLocal = fb.locals + idx;
    ptr.* = ir_local_new(name_start, name_len, type_idx, is_mutable);
    fb.locals_count = fb.locals_count + 1;
    return idx;
}

fn func_builder_add_param(fb: *FuncBuilder, name_start: i64, name_len: i64,
                          type_idx: i64, param_idx: i64) i64 {
    if fb.locals_count >= fb.locals_cap {
        return NULL_LOCAL;
    }
    let idx: i64 = fb.locals_count;
    let ptr: *IRLocal = fb.locals + idx;
    ptr.* = ir_local_new_param(name_start, name_len, type_idx, param_idx);
    fb.locals_count = fb.locals_count + 1;
    return idx;
}

fn func_builder_emit(fb: *FuncBuilder, node: IRNode) i64 {
    if fb.nodes_count >= fb.nodes_cap {
        return NULL_IR_NODE;
    }
    let idx: i64 = fb.nodes_count;
    let ptr: *IRNode = fb.nodes + idx;
    ptr.* = node;
    ptr.block_id = fb.current_block;  // Tag node with current block
    fb.nodes_count = fb.nodes_count + 1;
    return idx;
}

fn func_builder_emit_const_int(fb: *FuncBuilder, value: i64) i64 {
    var node: IRNode = ir_node_new(IRNodeKind.ConstInt, TYPE_I64);
    node.value = value;
    return func_builder_emit(fb, node);
}

fn func_builder_emit_const_bool(fb: *FuncBuilder, value: bool) i64 {
    var node: IRNode = ir_node_new(IRNodeKind.ConstBool, TYPE_BOOL);
    if value {
        node.value = 1;
    } else {
        node.value = 0;
    }
    return func_builder_emit(fb, node);
}

fn func_builder_emit_const_string(fb: *FuncBuilder, str_start: i64, str_len: i64) i64 {
    var node: IRNode = ir_node_new(IRNodeKind.ConstString, TYPE_STRING);
    node.left = str_start;   // Offset in source text
    node.right = str_len;    // Length of string content
    return func_builder_emit(fb, node);
}

fn func_builder_emit_load_local(fb: *FuncBuilder, local_idx: i64) i64 {
    let local: *IRLocal = fb.locals + local_idx;
    var node: IRNode = ir_node_new(IRNodeKind.LoadLocal, local.type_idx);
    node.left = local_idx;
    return func_builder_emit(fb, node);
}

fn func_builder_emit_store_local(fb: *FuncBuilder, local_idx: i64, value: i64) i64 {
    let local: *IRLocal = fb.locals + local_idx;
    var node: IRNode = ir_node_new(IRNodeKind.StoreLocal, local.type_idx);
    node.left = local_idx;
    node.right = value;
    return func_builder_emit(fb, node);
}

fn func_builder_emit_binary(fb: *FuncBuilder, op: i64, left: i64, right: i64, type_idx: i64) i64 {
    var node: IRNode = ir_node_new(IRNodeKind.Binary, type_idx);
    node.op = op;
    node.left = left;
    node.right = right;
    return func_builder_emit(fb, node);
}

fn func_builder_emit_unary(fb: *FuncBuilder, op: i64, operand: i64, type_idx: i64) i64 {
    var node: IRNode = ir_node_new(IRNodeKind.Unary, type_idx);
    node.op = op;
    node.left = operand;
    return func_builder_emit(fb, node);
}

fn func_builder_emit_return(fb: *FuncBuilder, value: i64) i64 {
    var node: IRNode = ir_node_new(IRNodeKind.Return, TYPE_VOID);
    node.left = value;
    return func_builder_emit(fb, node);
}

fn func_builder_emit_return_void(fb: *FuncBuilder) i64 {
    var node: IRNode = ir_node_new(IRNodeKind.Return, TYPE_VOID);
    node.left = NULL_IR_NODE;
    return func_builder_emit(fb, node);
}

// Emit a conditional branch
// cond = condition IR node index
// then_block, else_block = target block IDs
fn func_builder_emit_branch(fb: *FuncBuilder, cond: i64, then_block: i64, else_block: i64) i64 {
    var node: IRNode = ir_node_new(IRNodeKind.Branch, TYPE_VOID);
    node.left = cond;
    node.right = then_block;
    node.value = else_block;
    return func_builder_emit(fb, node);
}

// Emit an unconditional jump
fn func_builder_emit_jump(fb: *FuncBuilder, target_block: i64) i64 {
    var node: IRNode = ir_node_new(IRNodeKind.Jump, TYPE_VOID);
    node.left = target_block;
    return func_builder_emit(fb, node);
}

// Emit a load from pointer (dereference)
// ptr_expr = IR node index of pointer expression
// result_type = type of the pointed-to value
fn func_builder_emit_load(fb: *FuncBuilder, ptr_expr: i64, result_type: i64) i64 {
    var node: IRNode = ir_node_new(IRNodeKind.Load, result_type);
    node.left = ptr_expr;
    return func_builder_emit(fb, node);
}

// Emit a store through pointer (dereference assignment)
// ptr_expr = IR node index of pointer expression
// value_expr = IR node index of value to store
fn func_builder_emit_store(fb: *FuncBuilder, ptr_expr: i64, value_expr: i64) i64 {
    var node: IRNode = ir_node_new(IRNodeKind.Store, TYPE_VOID);
    node.left = ptr_expr;
    node.right = value_expr;
    return func_builder_emit(fb, node);
}

// Emit address of local variable
fn func_builder_emit_addr_local(fb: *FuncBuilder, local_idx: i64, ptr_type: i64) i64 {
    var node: IRNode = ir_node_new(IRNodeKind.AddrLocal, ptr_type);
    node.left = local_idx;
    return func_builder_emit(fb, node);
}

// Emit field access from local struct
// local_idx = index of the local struct variable
// offset = byte offset of field within struct
// field_type = type of the field
fn func_builder_emit_field_local(fb: *FuncBuilder, local_idx: i64, offset: i64, field_type: i64) i64 {
    var node: IRNode = ir_node_new(IRNodeKind.FieldLocal, field_type);
    node.left = local_idx;
    node.right = offset;
    return func_builder_emit(fb, node);
}

// Emit field access from computed address (pointer to struct)
// base_expr = IR node index of base address expression
// offset = byte offset of field within struct
// field_type = type of the field
fn func_builder_emit_field_value(fb: *FuncBuilder, base_expr: i64, offset: i64, field_type: i64) i64 {
    var node: IRNode = ir_node_new(IRNodeKind.FieldValue, field_type);
    node.left = base_expr;
    node.right = offset;
    return func_builder_emit(fb, node);
}

// Emit store to field of local struct
// local_idx = index of the local struct variable
// offset = byte offset of field within struct
// value_expr = IR node index of value to store
fn func_builder_emit_store_field_local(fb: *FuncBuilder, local_idx: i64, offset: i64, value_expr: i64) i64 {
    var node: IRNode = ir_node_new(IRNodeKind.StoreFieldLocal, TYPE_VOID);
    node.left = local_idx;
    node.right = offset;
    node.value = value_expr;
    return func_builder_emit(fb, node);
}

// Emit store to field via pointer
// base_expr = IR node index of base address expression
// offset = byte offset of field within struct
// value_expr = IR node index of value to store
fn func_builder_emit_store_field(fb: *FuncBuilder, base_expr: i64, offset: i64, value_expr: i64) i64 {
    var node: IRNode = ir_node_new(IRNodeKind.StoreField, TYPE_VOID);
    node.left = base_expr;
    node.right = offset;
    node.value = value_expr;
    return func_builder_emit(fb, node);
}

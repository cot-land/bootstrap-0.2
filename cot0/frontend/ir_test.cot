// IR Test - Tests for ir.cot
// Run with: ./zig-out/bin/cot cot0/frontend/ir_test.cot -o /tmp/ir_test && /tmp/ir_test
//
// Tests the intermediate representation data structures.

import "ir.cot"

// Storage arrays for tests (global to avoid stack issues)
var g_nodes: [100]IRNode;
var g_locals: [50]IRLocal;

fn main() i64 {
    let result: i64 = 0;

    result = result + test_binary_op();
    result = result + test_node_pool();
    result = result + test_func_builder();

    return result;
}

// ============================================================================
// Test: BinaryOp enum and predicates
// ============================================================================

fn test_binary_op() i64 {
    // Test ir_is_comparison
    if not ir_is_comparison(IRBinaryOp.Eq) { return 1; }
    if not ir_is_comparison(IRBinaryOp.Ne) { return 2; }
    if not ir_is_comparison(IRBinaryOp.Lt) { return 3; }
    if ir_is_comparison(IRBinaryOp.Add) { return 4; }
    if ir_is_comparison(IRBinaryOp.Sub) { return 5; }

    // Test ir_is_arithmetic
    if not ir_is_arithmetic(IRBinaryOp.Add) { return 10; }
    if not ir_is_arithmetic(IRBinaryOp.Sub) { return 11; }
    if not ir_is_arithmetic(IRBinaryOp.Mul) { return 12; }
    if ir_is_arithmetic(IRBinaryOp.Eq) { return 13; }

    return 0;
}

// ============================================================================
// Test: NodePool basic operations
// ============================================================================

fn test_node_pool() i64 {
    // Create a node pool with global storage
    var pool: IRNodePool = IRNodePool{
        .nodes = &g_nodes[0],
        .nodes_count = 0,
        .nodes_cap = 100,
    };

    // Add a const_int node
    let n0: i64 = ir_node_pool_add_const_int(&pool, 42, TYPE_I64);
    if n0 != 0 { return 20; }
    if pool.nodes_count != 1 { return 21; }

    // Add another node
    let n1: i64 = ir_node_pool_add_const_int(&pool, 100, TYPE_I64);
    if n1 != 1 { return 22; }
    if pool.nodes_count != 2 { return 23; }

    // Get node and verify
    let node: *IRNode = ir_node_pool_get(&pool, n0);
    if node.kind != IRNodeKind.ConstInt { return 24; }
    if node.value != 42 { return 25; }

    return 0;
}

// ============================================================================
// Test: FuncBuilder basic operations
// ============================================================================

fn test_func_builder() i64 {
    // Create a function builder with global storage
    var fb: FuncBuilder = FuncBuilder{
        .name_start = 0,
        .name_len = 4,
        .return_type = TYPE_I64,
        .locals = &g_locals[0],
        .locals_count = 0,
        .locals_cap = 50,
        .nodes = &g_nodes[0],
        .nodes_count = 0,
        .nodes_cap = 100,
        .current_block = 0,
    };

    // Add a local variable
    let local_idx: i64 = func_builder_add_local(&fb, 0, 1, TYPE_I64, true);
    if local_idx != 0 { return 30; }
    if fb.locals_count != 1 { return 31; }

    // Add a const_int node
    let n0: i64 = func_builder_emit_const_int(&fb, 42);
    if n0 < 0 { return 32; }

    // Add a store to the local
    let n1: i64 = func_builder_emit_store_local(&fb, local_idx, n0);
    if n1 < 0 { return 33; }

    return 0;
}

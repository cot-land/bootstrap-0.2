// Cot0 Parser Tests
// Tests for parsing expressions, statements, and declarations

import "ast.cot"
import "parser.cot"

// Global test pool - avoid malloc complexity
var g_nodes: [200]Node;
var g_children: [1000]i64;
var g_pool: NodePool;

fn init_test_pool() *NodePool {
    g_pool.nodes = &g_nodes[0];
    g_pool.count = 0;
    g_pool.children = &g_children[0];
    g_pool.children_count = 0;
    return &g_pool;
}

fn reset_pool(pool: *NodePool) {
    pool.count = 0;
    pool.children_count = 0;
}

// Test 1: Parse integer literal
fn test_parse_int() i64 {
    let pool: *NodePool = init_test_pool();
    var p: Parser = parser_new("42", pool);

    let expr: i64 = parse_expr(&p);

    let n: *Node = node_get(pool, expr);
    if n.kind != NodeKind.IntLit { return 1; }
    if n.field0 != 42 { return 2; }

    return 0;
}

// Test 2: Parse identifier
fn test_parse_ident() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = parser_new("foo", pool);

    let expr: i64 = parse_expr(&p);

    let n: *Node = node_get(pool, expr);
    if n.kind != NodeKind.Ident { return 1; }
    if n.field0 != 0 { return 2; }   // name_start
    if n.field1 != 3 { return 3; }   // name_len

    return 0;
}

// Test 3: Parse binary add
fn test_parse_add() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = parser_new("1 + 2", pool);

    let expr: i64 = parse_expr(&p);

    let n: *Node = node_get(pool, expr);
    if n.kind != NodeKind.BinaryExpr { return 1; }

    // Check left operand (1)
    let left: *Node = node_get(pool, n.field0);
    if left.kind != NodeKind.IntLit { return 2; }
    if left.field0 != 1 { return 3; }

    // Check right operand (2)
    let right: *Node = node_get(pool, n.field1);
    if right.kind != NodeKind.IntLit { return 4; }
    if right.field0 != 2 { return 5; }

    // Check operator (Add = 0)
    if n.field2 != 0 { return 6; }

    return 0;
}

// Test 4: Parse operator precedence (mul before add)
fn test_parse_precedence() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = parser_new("1 + 2 * 3", pool);

    let expr: i64 = parse_expr(&p);

    // Should parse as: 1 + (2 * 3)
    let add: *Node = node_get(pool, expr);
    if add.kind != NodeKind.BinaryExpr { return 1; }
    if add.field2 != 0 { return 2; }  // Add = 0

    // Left should be 1
    let left: *Node = node_get(pool, add.field0);
    if left.kind != NodeKind.IntLit { return 3; }
    if left.field0 != 1 { return 4; }

    // Right should be (2 * 3)
    let mul: *Node = node_get(pool, add.field1);
    if mul.kind != NodeKind.BinaryExpr { return 5; }
    if mul.field2 != 2 { return 6; }  // Mul = 2

    // Check 2 and 3
    let two: *Node = node_get(pool, mul.field0);
    let three: *Node = node_get(pool, mul.field1);
    if two.field0 != 2 { return 7; }
    if three.field0 != 3 { return 8; }

    return 0;
}

// Test 5: Parse function call
fn test_parse_call() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = parser_new("add(1, 2)", pool);

    let expr: i64 = parse_expr(&p);

    let call: *Node = node_get(pool, expr);
    if call.kind != NodeKind.CallExpr { return 1; }

    // Check callee is identifier
    let callee: *Node = node_get(pool, call.field0);
    if callee.kind != NodeKind.Ident { return 2; }

    // Check argument count
    if call.field2 != 2 { return 3; }  // args_count

    // Check arguments
    let args_start: i64 = call.field1;
    let arg0: i64 = node_child(pool, args_start, 0);
    let arg1: i64 = node_child(pool, args_start, 1);

    let a0: *Node = node_get(pool, arg0);
    let a1: *Node = node_get(pool, arg1);
    if a0.field0 != 1 { return 4; }  // First arg = 1
    if a1.field0 != 2 { return 5; }  // Second arg = 2

    return 0;
}

// Test 6: Parse return statement
fn test_parse_return() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = parser_new("return 42;", pool);

    let stmt: i64 = parse_stmt(&p);

    let ret: *Node = node_get(pool, stmt);
    if ret.kind != NodeKind.ReturnStmt { return 1; }

    // Check return value
    let val: *Node = node_get(pool, ret.field0);
    if val.kind != NodeKind.IntLit { return 2; }
    if val.field0 != 42 { return 3; }

    return 0;
}

// Test 7: Parse block
fn test_parse_block() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = parser_new("{ return 1; return 2; }", pool);

    let block: i64 = parse_block(&p);

    let blk: *Node = node_get(pool, block);
    if blk.kind != NodeKind.BlockStmt { return 1; }
    if blk.field1 != 2 { return 2; }  // 2 statements

    return 0;
}

// Test 8: Parse function declaration
fn test_parse_fn_decl() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = parser_new("fn main() i64 { return 42; }", pool);

    let decl: i64 = parse_decl(&p);

    let fn_node: *Node = node_get(pool, decl);
    if fn_node.kind != NodeKind.FnDecl { return 1; }

    // Check name (start=3, len=4 for "main")
    if fn_node.field0 != 3 { return 2; }   // name_start
    if fn_node.field1 != 4 { return 3; }   // name_len

    // Check no parameters
    if fn_node.field3 != 0 { return 4; }   // params_count

    return 0;
}

// Test 9: Parse function with parameters
fn test_parse_fn_params() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = parser_new("fn add(a: i64, b: i64) i64 { return 42; }", pool);

    let decl: i64 = parse_decl(&p);

    let fn_node: *Node = node_get(pool, decl);
    if fn_node.kind != NodeKind.FnDecl { return 1; }

    // Check 2 parameters
    if fn_node.field3 != 2 { return 2; }   // params_count

    // Check first parameter
    let params_start: i64 = fn_node.field2;
    let p0_idx: i64 = node_child(pool, params_start, 0);
    let p0: *Node = node_get(pool, p0_idx);
    if p0.kind != NodeKind.ParamDecl { return 3; }

    return 0;
}

// Test 10: Parse expression in return
fn test_parse_return_expr() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = parser_new("return 1 + 2;", pool);

    let stmt: i64 = parse_stmt(&p);

    let ret: *Node = node_get(pool, stmt);
    if ret.kind != NodeKind.ReturnStmt { return 1; }

    // Return value should be binary expr
    let val: *Node = node_get(pool, ret.field0);
    if val.kind != NodeKind.BinaryExpr { return 2; }

    return 0;
}

fn main() i64 {
    var failed: i64 = 0;

    if test_parse_int() != 0 {
        println("FAIL: test_parse_int");
        failed = failed + 1;
    }

    if test_parse_ident() != 0 {
        println("FAIL: test_parse_ident");
        failed = failed + 1;
    }

    if test_parse_add() != 0 {
        println("FAIL: test_parse_add");
        failed = failed + 1;
    }

    if test_parse_precedence() != 0 {
        println("FAIL: test_parse_precedence");
        failed = failed + 1;
    }

    if test_parse_call() != 0 {
        println("FAIL: test_parse_call");
        failed = failed + 1;
    }

    if test_parse_return() != 0 {
        println("FAIL: test_parse_return");
        failed = failed + 1;
    }

    if test_parse_block() != 0 {
        println("FAIL: test_parse_block");
        failed = failed + 1;
    }

    if test_parse_fn_decl() != 0 {
        println("FAIL: test_parse_fn_decl");
        failed = failed + 1;
    }

    if test_parse_fn_params() != 0 {
        println("FAIL: test_parse_fn_params");
        failed = failed + 1;
    }

    if test_parse_return_expr() != 0 {
        println("FAIL: test_parse_return_expr");
        failed = failed + 1;
    }

    if failed == 0 {
        println("All 10 parser tests passed!");
    }

    return failed;
}

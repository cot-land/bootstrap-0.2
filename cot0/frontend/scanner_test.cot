// Cot0 Scanner Tests
// Tests for the minimal lexer

import "token.cot"
import "scanner.cot"

// Test scanning a single integer
fn test_scan_int() i64 {
    var s: Scanner = scanner_new("42");
    let tok: Token = scanner_next(&s);
    if tok.kind != TokenType.Int { return 1; }
    if tok.start != 0 { return 2; }
    if tok.end != 2 { return 3; }  // length is 2
    return 0;
}

// Test scanning an identifier
fn test_scan_ident() i64 {
    var s: Scanner = scanner_new("foo");
    let tok: Token = scanner_next(&s);
    if tok.kind != TokenType.Ident { return 1; }
    if tok.start != 0 { return 2; }
    if tok.end != 3 { return 3; }
    return 0;
}

// Test scanning keyword 'fn'
fn test_scan_fn() i64 {
    var s: Scanner = scanner_new("fn");
    let tok: Token = scanner_next(&s);
    if tok.kind != TokenType.Fn { return 1; }
    return 0;
}

// Test scanning keyword 'return'
fn test_scan_return() i64 {
    var s: Scanner = scanner_new("return");
    let tok: Token = scanner_next(&s);
    if tok.kind != TokenType.Return { return 1; }
    return 0;
}

// Test scanning keyword 'i64'
fn test_scan_i64() i64 {
    var s: Scanner = scanner_new("i64");
    let tok: Token = scanner_next(&s);
    if tok.kind != TokenType.I64 { return 1; }
    return 0;
}

// Test scanning punctuation
fn test_scan_punct() i64 {
    var s: Scanner = scanner_new("(){},:;");

    let t1: Token = scanner_next(&s);
    if t1.kind != TokenType.LParen { return 1; }

    let t2: Token = scanner_next(&s);
    if t2.kind != TokenType.RParen { return 2; }

    let t3: Token = scanner_next(&s);
    if t3.kind != TokenType.LBrace { return 3; }

    let t4: Token = scanner_next(&s);
    if t4.kind != TokenType.RBrace { return 4; }

    let t5: Token = scanner_next(&s);
    if t5.kind != TokenType.Comma { return 5; }

    let t6: Token = scanner_next(&s);
    if t6.kind != TokenType.Colon { return 6; }

    let t7: Token = scanner_next(&s);
    if t7.kind != TokenType.Semi { return 7; }

    return 0;
}

// Test scanning operators
fn test_scan_ops() i64 {
    var s: Scanner = scanner_new("+-*/");

    let t1: Token = scanner_next(&s);
    if t1.kind != TokenType.Plus { return 1; }

    let t2: Token = scanner_next(&s);
    if t2.kind != TokenType.Minus { return 2; }

    let t3: Token = scanner_next(&s);
    if t3.kind != TokenType.Star { return 3; }

    let t4: Token = scanner_next(&s);
    if t4.kind != TokenType.Slash { return 4; }

    return 0;
}

// Test whitespace is skipped
fn test_skip_whitespace() i64 {
    var s: Scanner = scanner_new("  42  ");
    let tok: Token = scanner_next(&s);
    if tok.kind != TokenType.Int { return 1; }
    if tok.start != 2 { return 2; }  // after 2 spaces
    return 0;
}

// Test EOF token
fn test_eof() i64 {
    var s: Scanner = scanner_new("");
    let tok: Token = scanner_next(&s);
    if tok.kind != TokenType.Eof { return 1; }
    return 0;
}

// Test multiple tokens with whitespace
fn test_multi_tokens() i64 {
    var s: Scanner = scanner_new("fn main");

    let t1: Token = scanner_next(&s);
    if t1.kind != TokenType.Fn { return 1; }

    let t2: Token = scanner_next(&s);
    if t2.kind != TokenType.Ident { return 2; }

    let t3: Token = scanner_next(&s);
    if t3.kind != TokenType.Eof { return 3; }

    return 0;
}

// Test full simple function tokenization
fn test_full_fn() i64 {
    var s: Scanner = scanner_new("fn main() i64 { return 42; }");

    // fn
    let t1: Token = scanner_next(&s);
    if t1.kind != TokenType.Fn { return 1; }

    // main
    let t2: Token = scanner_next(&s);
    if t2.kind != TokenType.Ident { return 2; }

    // (
    let t3: Token = scanner_next(&s);
    if t3.kind != TokenType.LParen { return 3; }

    // )
    let t4: Token = scanner_next(&s);
    if t4.kind != TokenType.RParen { return 4; }

    // i64
    let t5: Token = scanner_next(&s);
    if t5.kind != TokenType.I64 { return 5; }

    // {
    let t6: Token = scanner_next(&s);
    if t6.kind != TokenType.LBrace { return 6; }

    // return
    let t7: Token = scanner_next(&s);
    if t7.kind != TokenType.Return { return 7; }

    // 42
    let t8: Token = scanner_next(&s);
    if t8.kind != TokenType.Int { return 8; }

    // ;
    let t9: Token = scanner_next(&s);
    if t9.kind != TokenType.Semi { return 9; }

    // }
    let t10: Token = scanner_next(&s);
    if t10.kind != TokenType.RBrace { return 10; }

    // EOF
    let t11: Token = scanner_next(&s);
    if t11.kind != TokenType.Eof { return 11; }

    return 0;
}

fn main() i64 {
    var failed: i64 = 0;

    if test_scan_int() != 0 {
        println("FAIL: test_scan_int");
        failed = failed + 1;
    }
    if test_scan_ident() != 0 {
        println("FAIL: test_scan_ident");
        failed = failed + 1;
    }
    if test_scan_fn() != 0 {
        println("FAIL: test_scan_fn");
        failed = failed + 1;
    }
    if test_scan_return() != 0 {
        println("FAIL: test_scan_return");
        failed = failed + 1;
    }
    if test_scan_i64() != 0 {
        println("FAIL: test_scan_i64");
        failed = failed + 1;
    }
    if test_scan_punct() != 0 {
        println("FAIL: test_scan_punct");
        failed = failed + 1;
    }
    if test_scan_ops() != 0 {
        println("FAIL: test_scan_ops");
        failed = failed + 1;
    }
    if test_skip_whitespace() != 0 {
        println("FAIL: test_skip_whitespace");
        failed = failed + 1;
    }
    if test_eof() != 0 {
        println("FAIL: test_eof");
        failed = failed + 1;
    }
    if test_multi_tokens() != 0 {
        println("FAIL: test_multi_tokens");
        failed = failed + 1;
    }
    if test_full_fn() != 0 {
        println("FAIL: test_full_fn");
        failed = failed + 1;
    }

    if failed == 0 {
        println("All 11 scanner tests passed!");
    }

    return failed;
}

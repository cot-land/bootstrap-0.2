// Mach-O Object File Format
// Defines constants and structures for generating Mach-O object files.
//
// Reference: src/obj/macho.zig (our Zig bootstrap)
// Reference: Apple Mach-O file format documentation
//
// Mach-O Structure:
// +------------------+
// | Mach-O Header    |  32 bytes (64-bit)
// +------------------+
// | Load Commands    |  Variable size
// +------------------+
// | __TEXT Segment   |
// |   __text section |  Code
// +------------------+
// | __DATA Segment   |
// |   __data section |  Initialized data
// +------------------+
// | Symbol Table     |
// +------------------+
// | String Table     |
// +------------------+

// ============================================================================
// Magic Numbers
// ============================================================================

// Mach-O 64-bit magic (little-endian)
const MH_MAGIC_64: i64 = 0xFEEDFACF;
// Big-endian version (reversed)
const MH_CIGAM_64: i64 = 0xCFFAEDFE;

// ============================================================================
// CPU Types
// ============================================================================

// CPU type for ARM64
const CPU_TYPE_ARM64: i64 = 0x0100000C;
// CPU subtype for all ARM64 variants
const CPU_SUBTYPE_ARM64_ALL: i64 = 0x00000000;

// ============================================================================
// File Types
// ============================================================================

// Relocatable object file
const MH_OBJECT: i64 = 0x1;
// Executable file
const MH_EXECUTE: i64 = 0x2;
// Dynamic library
const MH_DYLIB: i64 = 0x6;

// ============================================================================
// Header Flags
// ============================================================================

// Object file may be safely divided into subsections
const MH_SUBSECTIONS_VIA_SYMBOLS: i64 = 0x2000;

// ============================================================================
// Load Command Types
// ============================================================================

// 64-bit segment load command
const LC_SEGMENT_64: i64 = 0x19;
// Symbol table load command
const LC_SYMTAB: i64 = 0x02;
// Dynamic symbol table load command
const LC_DYSYMTAB: i64 = 0x0B;
// Build version load command
const LC_BUILD_VERSION: i64 = 0x32;

// ============================================================================
// Section Types
// ============================================================================

// Regular section
const S_REGULAR: i64 = 0x0;
// Zero-filled section (BSS)
const S_ZEROFILL: i64 = 0x1;
// C string literals section
const S_CSTRING_LITERALS: i64 = 0x2;

// ============================================================================
// Section Attributes
// ============================================================================

// Section contains only executable machine instructions
const S_ATTR_PURE_INSTRUCTIONS: i64 = 0x80000000;
// Section contains some machine instructions
const S_ATTR_SOME_INSTRUCTIONS: i64 = 0x00000400;

// ============================================================================
// Symbol Types
// ============================================================================

// Undefined symbol
const N_UNDF: i64 = 0x0;
// External symbol
const N_EXT: i64 = 0x1;
// Symbol defined in section
const N_SECT: i64 = 0xE;

// ============================================================================
// ARM64 Relocation Types
// ============================================================================

// Absolute address relocation
const ARM64_RELOC_UNSIGNED: i64 = 0;
// Subtractor for computing differences
const ARM64_RELOC_SUBTRACTOR: i64 = 1;
// 26-bit branch instruction (B, BL)
const ARM64_RELOC_BRANCH26: i64 = 2;
// ADRP instruction (page address, bits 12-32)
const ARM64_RELOC_PAGE21: i64 = 3;
// ADD/LDR instruction (page offset, bits 0-11)
const ARM64_RELOC_PAGEOFF12: i64 = 4;
// GOT page address
const ARM64_RELOC_GOT_LOAD_PAGE21: i64 = 5;
// GOT page offset
const ARM64_RELOC_GOT_LOAD_PAGEOFF12: i64 = 6;

// ============================================================================
// Structure Sizes (in bytes)
// ============================================================================

// Mach-O 64-bit header size
const MACH_HEADER_64_SIZE: i64 = 32;
// Segment command 64 size (without sections)
const SEGMENT_COMMAND_64_SIZE: i64 = 72;
// Section 64 size
const SECTION_64_SIZE: i64 = 80;
// Symbol table command size
const SYMTAB_COMMAND_SIZE: i64 = 24;
// Nlist64 entry size (symbol table entry)
const NLIST64_SIZE: i64 = 16;
// Relocation entry size
const RELOCATION_SIZE: i64 = 8;

// ============================================================================
// Relocation Info Encoding
// ============================================================================

// Create relocation info word
// Format: symbolnum (24 bits) | pcrel (1) | length (2) | extern (1) | type (4)
fn make_reloc_info(symbolnum: i64, pcrel: bool, length: i64, external: bool, reloc_type: i64) i64 {
    var result: i64 = symbolnum & 0xFFFFFF;
    if pcrel { result = result | (1 << 24); }
    result = result | ((length & 3) << 25);
    if external { result = result | (1 << 27); }
    result = result | ((reloc_type & 15) << 28);
    return result;
}

// ============================================================================
// Section Numbers (1-indexed for Mach-O)
// ============================================================================

const SECT_TEXT: i64 = 1;
const SECT_DATA: i64 = 2;
const SECT_BSS: i64 = 3;
const SECT_CSTRING: i64 = 4;

// ============================================================================
// Memory Protection Flags
// ============================================================================

const VM_PROT_READ: i64 = 0x1;
const VM_PROT_WRITE: i64 = 0x2;
const VM_PROT_EXECUTE: i64 = 0x4;
const VM_PROT_ALL: i64 = 0x7;  // rwx

// ============================================================================
// Alignment (log2)
// ============================================================================

// Text section typically aligned to 4 bytes (2^2) for ARM64
const TEXT_ALIGN: i64 = 2;
// Data section aligned to 8 bytes (2^3) for 64-bit values
const DATA_ALIGN: i64 = 3;
// Page alignment (2^14 = 16384 for ARM64 macOS)
const PAGE_ALIGN: i64 = 14;

// ============================================================================
// Helper Functions
// ============================================================================

// Check if value is a valid Mach-O magic number
fn is_macho_magic(magic: i64) bool {
    return magic == MH_MAGIC_64 or magic == MH_CIGAM_64;
}

// Check if file type is valid
fn is_valid_file_type(filetype: i64) bool {
    return filetype == MH_OBJECT or filetype == MH_EXECUTE or filetype == MH_DYLIB;
}

// Calculate padding needed for alignment
fn padding_for_align(offset: i64, align_pow2: i64) i64 {
    let alignment: i64 = 1 << align_pow2;
    let remainder: i64 = offset & (alignment - 1);
    if remainder == 0 { return 0; }
    return alignment - remainder;
}

// Round up offset to alignment
fn align_up(offset: i64, align_pow2: i64) i64 {
    return offset + padding_for_align(offset, align_pow2);
}

// ============================================================================
// Symbol Entry (for symbol table)
// ============================================================================

struct Symbol {
    name_offset: i64,     // Offset in string table
    value: i64,           // Value/address
    section: i64,         // Section number (0=undef, 1=text, 2=data)
    is_external: bool,    // External symbol?
}

// ============================================================================
// Relocation Entry (for branch relocations)
// ============================================================================

struct Reloc {
    offset: i64,          // Offset in text section
    symbol_idx: i64,      // Target symbol index
    reloc_type: i64,      // ARM64_RELOC_* type
    is_pcrel: bool,       // PC-relative?
}

// ============================================================================
// Mach-O Writer State
// Uses external buffers (no dynamic allocation)
// ============================================================================

struct MachOWriter {
    // Code section (text)
    code: *u8,
    code_count: i64,
    code_cap: i64,

    // Data section
    data: *u8,
    data_count: i64,
    data_cap: i64,

    // Symbol table
    symbols: *Symbol,
    symbols_count: i64,
    symbols_cap: i64,

    // String table
    strings: *u8,
    strings_count: i64,
    strings_cap: i64,

    // Relocations
    relocs: *Reloc,
    relocs_count: i64,
    relocs_cap: i64,

    // Output buffer
    output: *u8,
    output_count: i64,
    output_cap: i64,
}

// ============================================================================
// Writer Initialization
// ============================================================================

fn macho_writer_init(w: *MachOWriter,
                     code: *u8, code_cap: i64,
                     data: *u8, data_cap: i64,
                     symbols: *Symbol, symbols_cap: i64,
                     strings: *u8, strings_cap: i64,
                     relocs: *Reloc, relocs_cap: i64,
                     output: *u8, output_cap: i64) {
    w.code = code;
    w.code_count = 0;
    w.code_cap = code_cap;

    w.data = data;
    w.data_count = 0;
    w.data_cap = data_cap;

    w.symbols = symbols;
    w.symbols_count = 0;
    w.symbols_cap = symbols_cap;

    // String table starts with null byte
    w.strings = strings;
    w.strings_count = 1;  // Reserve byte 0 as null
    w.strings_cap = strings_cap;
    if strings_cap > 0 {
        strings.* = 0;
    }

    w.relocs = relocs;
    w.relocs_count = 0;
    w.relocs_cap = relocs_cap;

    w.output = output;
    w.output_count = 0;
    w.output_cap = output_cap;
}

// ============================================================================
// Add Functions
// ============================================================================

// Add code bytes to text section
fn macho_add_code(w: *MachOWriter, bytes: *u8, len: i64) {
    var i: i64 = 0;
    while i < len and w.code_count < w.code_cap {
        let src: *u8 = bytes + i;
        let dst: *u8 = w.code + w.code_count;
        dst.* = src.*;
        w.code_count = w.code_count + 1;
        i = i + 1;
    }
}

// Add a string to the string table, return its offset
fn macho_add_string(w: *MachOWriter, s: *u8, len: i64) i64 {
    let offset: i64 = w.strings_count;

    var i: i64 = 0;
    while i < len and w.strings_count < w.strings_cap {
        let src: *u8 = s + i;
        let dst: *u8 = w.strings + w.strings_count;
        dst.* = src.*;
        w.strings_count = w.strings_count + 1;
        i = i + 1;
    }

    // Add null terminator
    if w.strings_count < w.strings_cap {
        let null_ptr: *u8 = w.strings + w.strings_count;
        null_ptr.* = 0;
        w.strings_count = w.strings_count + 1;
    }

    return offset;
}

// Add a symbol
fn macho_add_symbol(w: *MachOWriter, name: *u8, name_len: i64,
                    value: i64, section: i64, is_external: bool) i64 {
    if w.symbols_count >= w.symbols_cap {
        return 0 - 1;  // Error
    }

    let name_offset: i64 = macho_add_string(w, name, name_len);

    let sym: *Symbol = w.symbols + w.symbols_count;
    sym.name_offset = name_offset;
    sym.value = value;
    sym.section = section;
    sym.is_external = is_external;

    let idx: i64 = w.symbols_count;
    w.symbols_count = w.symbols_count + 1;
    return idx;
}

// Add a relocation
fn macho_add_reloc(w: *MachOWriter, offset: i64, symbol_idx: i64,
                   reloc_type: i64, is_pcrel: bool) {
    if w.relocs_count >= w.relocs_cap {
        return;
    }

    let r: *Reloc = w.relocs + w.relocs_count;
    r.offset = offset;
    r.symbol_idx = symbol_idx;
    r.reloc_type = reloc_type;
    r.is_pcrel = is_pcrel;

    w.relocs_count = w.relocs_count + 1;
}

// ============================================================================
// Output Helpers
// ============================================================================

// Write a single byte to output
fn out_byte(w: *MachOWriter, b: i64) {
    if w.output_count < w.output_cap {
        let p: *u8 = w.output + w.output_count;
        p.* = @intCast(u8, b & 255);
        w.output_count = w.output_count + 1;
    }
}

// Write a 32-bit value (little-endian)
fn out_u32(w: *MachOWriter, val: i64) {
    out_byte(w, val & 255);
    out_byte(w, (val >> 8) & 255);
    out_byte(w, (val >> 16) & 255);
    out_byte(w, (val >> 24) & 255);
}

// Write a 64-bit value (little-endian)
fn out_u64(w: *MachOWriter, val: i64) {
    out_u32(w, val & 0xFFFFFFFF);
    out_u32(w, (val >> 32) & 0xFFFFFFFF);
}

// Write n zero bytes
fn out_zeros(w: *MachOWriter, n: i64) {
    var i: i64 = 0;
    while i < n {
        out_byte(w, 0);
        i = i + 1;
    }
}

// Write bytes from buffer
fn out_bytes(w: *MachOWriter, src: *u8, len: i64) {
    var i: i64 = 0;
    while i < len {
        let p: *u8 = src + i;
        out_byte(w, @intCast(i64, p.*));
        i = i + 1;
    }
}

// ============================================================================
// Mach-O Header Writer
// ============================================================================

fn write_mach_header(w: *MachOWriter, ncmds: i64, sizeofcmds: i64) {
    out_u32(w, MH_MAGIC_64);           // magic
    out_u32(w, CPU_TYPE_ARM64);        // cputype
    out_u32(w, CPU_SUBTYPE_ARM64_ALL); // cpusubtype
    out_u32(w, MH_OBJECT);             // filetype
    out_u32(w, ncmds);                 // ncmds
    out_u32(w, sizeofcmds);            // sizeofcmds
    out_u32(w, MH_SUBSECTIONS_VIA_SYMBOLS); // flags
    out_u32(w, 0);                     // reserved
}

// ============================================================================
// Segment Command Writer
// ============================================================================

fn write_segment_cmd(w: *MachOWriter, vmsize: i64, fileoff: i64,
                     filesize: i64, nsects: i64) {
    let cmdsize: i64 = SEGMENT_COMMAND_64_SIZE + nsects * SECTION_64_SIZE;

    out_u32(w, LC_SEGMENT_64);  // cmd
    out_u32(w, cmdsize);        // cmdsize
    out_zeros(w, 16);           // segname (empty)
    out_u64(w, 0);              // vmaddr
    out_u64(w, vmsize);         // vmsize
    out_u64(w, fileoff);        // fileoff
    out_u64(w, filesize);       // filesize
    out_u32(w, VM_PROT_ALL);    // maxprot (rwx)
    out_u32(w, VM_PROT_ALL);    // initprot
    out_u32(w, nsects);         // nsects
    out_u32(w, 0);              // flags
}

// ============================================================================
// Section Writer
// ============================================================================

fn write_section(w: *MachOWriter,
                 sectname: *u8, segname: *u8,
                 size: i64, offset: i64,
                 sect_align: i64, flags: i64,
                 reloff: i64, nreloc: i64) {
    // Write 16-byte section name (pad with zeros)
    var i: i64 = 0;
    while i < 16 {
        if i < 6 {
            let p: *u8 = sectname + i;
            out_byte(w, @intCast(i64, p.*));
        } else {
            out_byte(w, 0);
        }
        i = i + 1;
    }

    // Write 16-byte segment name (pad with zeros)
    i = 0;
    while i < 16 {
        if i < 6 {
            let p: *u8 = segname + i;
            out_byte(w, @intCast(i64, p.*));
        } else {
            out_byte(w, 0);
        }
        i = i + 1;
    }

    out_u64(w, 0);          // addr (0 for object file)
    out_u64(w, size);       // size
    out_u32(w, offset);     // offset
    out_u32(w, sect_align); // align (log2)
    out_u32(w, reloff);     // reloff
    out_u32(w, nreloc);     // nreloc
    out_u32(w, flags);      // flags
    out_u32(w, 0);          // reserved1
    out_u32(w, 0);          // reserved2
    out_u32(w, 0);          // reserved3
}

// ============================================================================
// Symbol Table Command Writer
// ============================================================================

fn write_symtab_cmd(w: *MachOWriter, symoff: i64, nsyms: i64,
                    stroff: i64, strsize: i64) {
    out_u32(w, LC_SYMTAB);       // cmd
    out_u32(w, SYMTAB_COMMAND_SIZE);  // cmdsize
    out_u32(w, symoff);          // symoff
    out_u32(w, nsyms);           // nsyms
    out_u32(w, stroff);          // stroff
    out_u32(w, strsize);         // strsize
}

// ============================================================================
// Relocation Entry Writer
// ============================================================================

fn write_reloc(w: *MachOWriter, r: *Reloc) {
    out_u32(w, r.offset);  // r_address

    // Build r_info: symbolnum (24) | pcrel (1) | length (2) | extern (1) | type (4)
    let info: i64 = make_reloc_info(r.symbol_idx, r.is_pcrel, 2, true, r.reloc_type);
    out_u32(w, info);
}

// ============================================================================
// Symbol Entry Writer (nlist64)
// ============================================================================

fn write_nlist64(w: *MachOWriter, sym: *Symbol) {
    out_u32(w, sym.name_offset);  // n_strx

    // n_type: N_SECT | N_EXT for defined external, N_EXT for undefined
    let n_type: i64 = 0;
    if sym.section == 0 {
        // Undefined external symbol
        n_type = N_EXT;
    } else {
        // Defined in section
        n_type = N_SECT;
        if sym.is_external {
            n_type = n_type | N_EXT;
        }
    }
    out_byte(w, n_type);  // n_type

    out_byte(w, sym.section);  // n_sect
    out_byte(w, 0);  // n_desc low byte
    out_byte(w, 0);  // n_desc high byte
    out_u64(w, sym.value);  // n_value
}

// ============================================================================
// Main Write Function
// Writes complete Mach-O object file to output buffer
// Returns bytes written, or negative on error
// ============================================================================

fn write_macho(w: *MachOWriter) i64 {
    // Calculate layout
    let num_sections: i64 = 2;  // __text and __data
    let load_cmds_size: i64 = SEGMENT_COMMAND_64_SIZE +
                              num_sections * SECTION_64_SIZE +
                              SYMTAB_COMMAND_SIZE;

    let text_offset: i64 = MACH_HEADER_64_SIZE + load_cmds_size;
    let text_size: i64 = w.code_count;

    let data_offset: i64 = align_up(text_offset + text_size, 3);  // 8-byte align
    let data_size: i64 = w.data_count;

    let reloc_offset: i64 = align_up(data_offset + data_size, 2);  // 4-byte align
    let reloc_size: i64 = w.relocs_count * RELOCATION_SIZE;

    let symtab_offset: i64 = align_up(reloc_offset + reloc_size, 3);  // 8-byte align
    let symtab_size: i64 = w.symbols_count * NLIST64_SIZE;

    let strtab_offset: i64 = symtab_offset + symtab_size;
    let strtab_size: i64 = w.strings_count;

    let segment_filesize: i64 = data_offset + data_size - text_offset;

    // Write header
    write_mach_header(w, 2, load_cmds_size);

    // Write segment command
    write_segment_cmd(w, segment_filesize, text_offset, segment_filesize, num_sections);

    // Write __text section
    // Note: Using string literals requires passing pointers
    // For now, we use hard-coded values
    let text_flags: i64 = S_ATTR_PURE_INSTRUCTIONS | S_ATTR_SOME_INSTRUCTIONS;
    var text_name: [16]u8;
    text_name[0] = 95;  // '_'
    text_name[1] = 95;  // '_'
    text_name[2] = 116; // 't'
    text_name[3] = 101; // 'e'
    text_name[4] = 120; // 'x'
    text_name[5] = 116; // 't'

    var text_seg: [16]u8;
    text_seg[0] = 95;   // '_'
    text_seg[1] = 95;   // '_'
    text_seg[2] = 84;   // 'T'
    text_seg[3] = 69;   // 'E'
    text_seg[4] = 88;   // 'X'
    text_seg[5] = 84;   // 'T'

    write_section(w, &text_name[0], &text_seg[0],
                  text_size, text_offset,
                  TEXT_ALIGN, text_flags,
                  reloc_offset, w.relocs_count);

    // Write __data section
    var data_name: [16]u8;
    data_name[0] = 95;  // '_'
    data_name[1] = 95;  // '_'
    data_name[2] = 100; // 'd'
    data_name[3] = 97;  // 'a'
    data_name[4] = 116; // 't'
    data_name[5] = 97;  // 'a'

    var data_seg: [16]u8;
    data_seg[0] = 95;   // '_'
    data_seg[1] = 95;   // '_'
    data_seg[2] = 68;   // 'D'
    data_seg[3] = 65;   // 'A'
    data_seg[4] = 84;   // 'T'
    data_seg[5] = 65;   // 'A'

    write_section(w, &data_name[0], &data_seg[0],
                  data_size, data_offset,
                  DATA_ALIGN, S_REGULAR,
                  0, 0);

    // Write symtab command
    write_symtab_cmd(w, symtab_offset, w.symbols_count,
                     strtab_offset, strtab_size);

    // Write text section content
    out_bytes(w, w.code, w.code_count);

    // Pad to data section
    let pad1: i64 = data_offset - (text_offset + text_size);
    out_zeros(w, pad1);

    // Write data section content
    out_bytes(w, w.data, w.data_count);

    // Pad to relocation table
    let pad2: i64 = reloc_offset - (data_offset + data_size);
    out_zeros(w, pad2);

    // Write relocations
    var i: i64 = 0;
    while i < w.relocs_count {
        let r: *Reloc = w.relocs + i;
        write_reloc(w, r);
        i = i + 1;
    }

    // Pad to symbol table
    let pad3: i64 = symtab_offset - (reloc_offset + reloc_size);
    out_zeros(w, pad3);

    // Write symbol table
    i = 0;
    while i < w.symbols_count {
        let sym: *Symbol = w.symbols + i;
        write_nlist64(w, sym);
        i = i + 1;
    }

    // Write string table
    out_bytes(w, w.strings, w.strings_count);

    return w.output_count;
}

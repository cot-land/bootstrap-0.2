// macho_writer_test.cot - Tests for MachO writer
// Run with: ./zig-out/bin/cot cot0/obj/macho_writer_test.cot -o /tmp/macho_writer_test && /tmp/macho_writer_test

import "macho.cot"
import "../codegen/arm64.cot"

extern fn write(fd: i32, buf: *u8, count: i64) i64;

fn print_str(s: string) {
    write(1, s.ptr, len(s));
}

fn print_num(n: i64) {
    var ch: u8 = 48;
    if n == 0 {
        write(1, &ch, 1);
        return;
    }

    var val: i64 = n;
    if val < 0 {
        print_str("-");
        val = 0 - val;
    }

    var digits: [20]u8;
    var count: i64 = 0;

    while val > 0 and count < 20 {
        let digit: i64 = val - (val / 10) * 10;
        digits[count] = @intCast(u8, 48 + digit);
        val = val / 10;
        count = count + 1;
    }

    while count > 0 {
        count = count - 1;
        write(1, &digits[count], 1);
    }
}

fn print_hex(n: i64) {
    print_str("0x");
    var digits: [16]u8;
    var count: i64 = 0;
    var val: i64 = n;

    if val == 0 {
        print_str("0");
        return;
    }

    while val > 0 and count < 16 {
        let digit: i64 = val & 15;
        if digit < 10 {
            digits[count] = @intCast(u8, 48 + digit);
        } else {
            digits[count] = @intCast(u8, 97 + digit - 10);
        }
        val = val >> 4;
        count = count + 1;
    }

    while count > 0 {
        count = count - 1;
        write(1, &digits[count], 1);
    }
}

// Storage buffers for MachOWriter
var g_code: [4096]u8;
var g_data: [4096]u8;
var g_symbols: [100]Symbol;
var g_strings: [4096]u8;
var g_relocs: [100]Reloc;
var g_output: [65536]u8;

fn main() i64 {
    print_str("MachO Writer Test\n");
    print_str("=================\n\n");

    let r1: i64 = test_writer_init();
    if r1 != 0 { return r1; }

    let r2: i64 = test_add_code();
    if r2 != 0 { return r2; }

    let r3: i64 = test_add_symbol();
    if r3 != 0 { return r3; }

    let r4: i64 = test_write_macho();
    if r4 != 0 { return r4; }

    print_str("\nAll MachO writer tests passed!\n");
    return 0;
}

fn test_writer_init() i64 {
    print_str("Test: writer_init - ");

    var w: MachOWriter = undefined;
    macho_writer_init(&w,
                      &g_code[0], 4096,
                      &g_data[0], 4096,
                      &g_symbols[0], 100,
                      &g_strings[0], 4096,
                      &g_relocs[0], 100,
                      &g_output[0], 65536);

    if w.code_count != 0 { print_str("FAIL (code_count)\n"); return 1; }
    if w.symbols_count != 0 { print_str("FAIL (symbols_count)\n"); return 2; }
    if w.strings_count != 1 { print_str("FAIL (strings_count should be 1)\n"); return 3; }
    if w.output_count != 0 { print_str("FAIL (output_count)\n"); return 4; }

    print_str("PASS\n");
    return 0;
}

fn test_add_code() i64 {
    print_str("Test: add_code - ");

    var w: MachOWriter = undefined;
    macho_writer_init(&w,
                      &g_code[0], 4096,
                      &g_data[0], 4096,
                      &g_symbols[0], 100,
                      &g_strings[0], 4096,
                      &g_relocs[0], 100,
                      &g_output[0], 65536);

    // Create a NOP instruction (0xd503201f)
    var nop: [4]u8;
    nop[0] = 31;   // 0x1f
    nop[1] = 32;   // 0x20
    nop[2] = 3;    // 0x03
    nop[3] = 213;  // 0xd5

    macho_add_code(&w, &nop[0], 4);

    if w.code_count != 4 { print_str("FAIL (code_count)\n"); return 10; }

    // Check first byte
    if g_code[0] != 31 { print_str("FAIL (byte 0)\n"); return 11; }
    if g_code[1] != 32 { print_str("FAIL (byte 1)\n"); return 12; }
    if g_code[2] != 3 { print_str("FAIL (byte 2)\n"); return 13; }
    if g_code[3] != 213 { print_str("FAIL (byte 3)\n"); return 14; }

    print_str("PASS\n");
    return 0;
}

fn test_add_symbol() i64 {
    print_str("Test: add_symbol - ");

    var w: MachOWriter = undefined;
    macho_writer_init(&w,
                      &g_code[0], 4096,
                      &g_data[0], 4096,
                      &g_symbols[0], 100,
                      &g_strings[0], 4096,
                      &g_relocs[0], 100,
                      &g_output[0], 65536);

    // Add a symbol "_main"
    var name: [5]u8;
    name[0] = 95;   // '_'
    name[1] = 109;  // 'm'
    name[2] = 97;   // 'a'
    name[3] = 105;  // 'i'
    name[4] = 110;  // 'n'

    let idx: i64 = macho_add_symbol(&w, &name[0], 5, 0, SECT_TEXT, true);

    if idx != 0 { print_str("FAIL (index should be 0)\n"); return 20; }
    if w.symbols_count != 1 { print_str("FAIL (symbols_count)\n"); return 21; }

    // String table should have: [0]=null, [1-5]="_main", [6]=null
    if w.strings_count != 7 { print_str("FAIL (strings_count)\n"); return 22; }

    print_str("PASS\n");
    return 0;
}

fn test_write_macho() i64 {
    print_str("Test: write_macho - ");

    var w: MachOWriter = undefined;
    macho_writer_init(&w,
                      &g_code[0], 4096,
                      &g_data[0], 4096,
                      &g_symbols[0], 100,
                      &g_strings[0], 4096,
                      &g_relocs[0], 100,
                      &g_output[0], 65536);

    // Add a simple return 42 function
    // MOV X0, #42
    var mov_inst: [4]u8;
    let mov: i64 = encode_mov_imm(X0, 42);
    mov_inst[0] = @intCast(u8, mov & 255);
    mov_inst[1] = @intCast(u8, (mov >> 8) & 255);
    mov_inst[2] = @intCast(u8, (mov >> 16) & 255);
    mov_inst[3] = @intCast(u8, (mov >> 24) & 255);
    macho_add_code(&w, &mov_inst[0], 4);

    // RET
    var ret_inst: [4]u8;
    let ret: i64 = codegen_return();
    ret_inst[0] = @intCast(u8, ret & 255);
    ret_inst[1] = @intCast(u8, (ret >> 8) & 255);
    ret_inst[2] = @intCast(u8, (ret >> 16) & 255);
    ret_inst[3] = @intCast(u8, (ret >> 24) & 255);
    macho_add_code(&w, &ret_inst[0], 4);

    // Add _main symbol
    var name: [5]u8;
    name[0] = 95;   // '_'
    name[1] = 109;  // 'm'
    name[2] = 97;   // 'a'
    name[3] = 105;  // 'i'
    name[4] = 110;  // 'n'
    let main_idx: i64 = macho_add_symbol(&w, &name[0], 5, 0, SECT_TEXT, true);

    // Write the Mach-O file
    let bytes_written: i64 = write_macho(&w);

    if bytes_written <= 0 {
        print_str("FAIL (no output)\n");
        return 30;
    }

    // Check magic number (first 4 bytes)
    // MH_MAGIC_64 = 0xFEEDFACF (little-endian: CF FA ED FE)
    if g_output[0] != 207 { print_str("FAIL (magic[0])\n"); return 31; }  // 0xCF
    if g_output[1] != 250 { print_str("FAIL (magic[1])\n"); return 32; }  // 0xFA
    if g_output[2] != 237 { print_str("FAIL (magic[2])\n"); return 33; }  // 0xED
    if g_output[3] != 254 { print_str("FAIL (magic[3])\n"); return 34; }  // 0xFE

    print_str("PASS (");
    print_num(bytes_written);
    print_str(" bytes)\n");
    return 0;
}

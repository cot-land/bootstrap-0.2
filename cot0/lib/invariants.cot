// =============================================================================
// Compiler-Specific Invariant Checks
// =============================================================================
//
// Provides deep invariant checking for all major compiler structures:
// 1. Scanner invariants
// 2. Parser invariants
// 3. Lowerer invariants
// 4. SSABuilder invariants
// 5. GenState invariants
// 6. Func (SSA function) invariants
//
// Each checker validates:
// - Null pointers that should be non-null
// - Array bounds (count <= capacity)
// - Index ranges
// - Consistency between related fields
//
// =============================================================================

import "error.cot"

// =============================================================================
// Scanner Invariants
// =============================================================================

// Note: Scanner uses string type which has ptr and len
// struct Scanner {
//     source: string,
//     pos: i64,
// }

fn Scanner_checkInvariants(source_ptr: *u8, source_len: i64, pos: i64, context: *u8) {
    // Source must not be null
    if source_ptr == null {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("SCANNER INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  source.ptr is null\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    // Source length must be non-negative
    if source_len < 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("SCANNER INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  source.len is negative: ");
        stderr_int(source_len);
        stderr_newline();
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    // Position must be in valid range [0, source_len]
    if pos < 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("SCANNER INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  pos is negative: ");
        stderr_int(pos);
        stderr_newline();
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    if pos > source_len {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("SCANNER INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  pos (");
        stderr_int(pos);
        stderr_str(") > source_len (");
        stderr_int(source_len);
        stderr_str(")\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }
}

// =============================================================================
// Parser Invariants
// =============================================================================

// struct Parser {
//     source: string,
//     scanner: Scanner,
//     current: Token,
//     pool: *NodePool,
//     type_registry: *TypeRegistry,
//     had_error: bool,
// }

fn Parser_checkInvariants_pools(pool_nodes: *i64, pool_count: i64, pool_cap: i64, context: *u8) {
    // Node pool pointer must be valid
    if pool_nodes == null {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("PARSER INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  pool.nodes is null\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    // Count must be non-negative
    if pool_count < 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("PARSER INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  pool.count is negative: ");
        stderr_int(pool_count);
        stderr_newline();
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    // Count must not exceed capacity
    if pool_count > pool_cap {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("PARSER INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  pool.count (");
        stderr_int(pool_count);
        stderr_str(") > pool.cap (");
        stderr_int(pool_cap);
        stderr_str(")\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }
}

// =============================================================================
// Lowerer Invariants
// =============================================================================

// struct Lowerer fields we can check:
//   nodes: *Node, nodes_count: i64
//   children: *i64, children_count: i64
//   source: *u8, source_len: i64
//   current_func: *FuncBuilder
//   ir_nodes: *IRNode, ir_nodes_cap: i64, ir_nodes_count: i64
//   ir_locals: *IRLocal, ir_locals_cap: i64, ir_locals_count: i64
//   ir_funcs: *IRFunc, ir_funcs_cap: i64

fn Lowerer_checkInvariants(
    nodes: *i64, nodes_count: i64,
    source: *u8, source_len: i64,
    ir_nodes: *i64, ir_nodes_count: i64, ir_nodes_cap: i64,
    ir_locals: *i64, ir_locals_count: i64, ir_locals_cap: i64,
    context: *u8
) {
    // AST nodes must be valid
    if nodes == null and nodes_count > 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("LOWERER INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  nodes is null but nodes_count = ");
        stderr_int(nodes_count);
        stderr_newline();
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    // Source must be valid
    if source == null {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("LOWERER INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  source is null\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    if source_len <= 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("LOWERER INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  source_len is invalid: ");
        stderr_int(source_len);
        stderr_newline();
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    // IR nodes array
    if ir_nodes == null and ir_nodes_cap > 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("LOWERER INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  ir_nodes is null but cap = ");
        stderr_int(ir_nodes_cap);
        stderr_newline();
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    if ir_nodes_count < 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("LOWERER INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  ir_nodes_count is negative: ");
        stderr_int(ir_nodes_count);
        stderr_newline();
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    if ir_nodes_count > ir_nodes_cap {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("LOWERER INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  ir_nodes_count (");
        stderr_int(ir_nodes_count);
        stderr_str(") > ir_nodes_cap (");
        stderr_int(ir_nodes_cap);
        stderr_str(")\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    // IR locals array
    if ir_locals_count < 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("LOWERER INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  ir_locals_count is negative: ");
        stderr_int(ir_locals_count);
        stderr_newline();
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    if ir_locals_count > ir_locals_cap {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("LOWERER INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  ir_locals_count (");
        stderr_int(ir_locals_count);
        stderr_str(") > ir_locals_cap (");
        stderr_int(ir_locals_cap);
        stderr_str(")\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }
}

// =============================================================================
// SSABuilder Invariants
// =============================================================================

fn SSABuilder_checkInvariants(
    func: *i64,
    func_blocks_count: i64, func_blocks_cap: i64,
    func_values_count: i64, func_values_cap: i64,
    current_block: i64,
    context: *u8
) {
    // Func must be valid
    if func == null {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("SSA BUILDER INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  func is null\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    // Blocks count/cap
    if func_blocks_count < 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("SSA BUILDER INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  blocks_count is negative: ");
        stderr_int(func_blocks_count);
        stderr_newline();
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    if func_blocks_count > func_blocks_cap {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("SSA BUILDER INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  blocks_count (");
        stderr_int(func_blocks_count);
        stderr_str(") > blocks_cap (");
        stderr_int(func_blocks_cap);
        stderr_str(")\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    // Values count/cap
    if func_values_count < 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("SSA BUILDER INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  values_count is negative: ");
        stderr_int(func_values_count);
        stderr_newline();
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    if func_values_count > func_values_cap {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("SSA BUILDER INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  values_count (");
        stderr_int(func_values_count);
        stderr_str(") > values_cap (");
        stderr_int(func_values_cap);
        stderr_str(")\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    // Current block must be valid
    if current_block < 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("SSA BUILDER INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  current_block is negative: ");
        stderr_int(current_block);
        stderr_newline();
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    if current_block >= func_blocks_count and func_blocks_count > 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("SSA BUILDER INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  current_block (");
        stderr_int(current_block);
        stderr_str(") >= blocks_count (");
        stderr_int(func_blocks_count);
        stderr_str(")\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }
}

// =============================================================================
// GenState Invariants
// =============================================================================

fn GenState_checkInvariants(
    func: *i64,
    code: *u8, code_count: i64, code_cap: i64,
    branches_count: i64, branches_cap: i64,
    context: *u8
) {
    // Func must be valid
    if func == null {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("GENSTATE INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  func is null\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    // Code buffer must be valid
    if code == null and code_cap > 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("GENSTATE INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  code is null but cap = ");
        stderr_int(code_cap);
        stderr_newline();
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    // Code count/cap
    if code_count < 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("GENSTATE INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  code_count is negative: ");
        stderr_int(code_count);
        stderr_newline();
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    if code_count > code_cap {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("GENSTATE INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  code_count (");
        stderr_int(code_count);
        stderr_str(") > code_cap (");
        stderr_int(code_cap);
        stderr_str(")\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    // Branches count/cap
    if branches_count < 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("GENSTATE INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  branches_count is negative: ");
        stderr_int(branches_count);
        stderr_newline();
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    if branches_count > branches_cap {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("GENSTATE INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  branches_count (");
        stderr_int(branches_count);
        stderr_str(") > branches_cap (");
        stderr_int(branches_cap);
        stderr_str(")\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }
}

// =============================================================================
// Func (SSA Function) Invariants
// =============================================================================

fn Func_checkInvariants(
    blocks: *i64, blocks_count: i64, blocks_cap: i64,
    values: *i64, values_count: i64, values_cap: i64,
    context: *u8
) {
    // Blocks array
    if blocks == null and blocks_cap > 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("FUNC INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  blocks is null but cap = ");
        stderr_int(blocks_cap);
        stderr_newline();
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    if blocks_count < 0 or blocks_count > blocks_cap {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("FUNC INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  blocks_count (");
        stderr_int(blocks_count);
        stderr_str(") invalid for cap (");
        stderr_int(blocks_cap);
        stderr_str(")\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    // Values array
    if values == null and values_cap > 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("FUNC INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  values is null but cap = ");
        stderr_int(values_cap);
        stderr_newline();
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    if values_count < 0 or values_count > values_cap {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("FUNC INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  values_count (");
        stderr_int(values_count);
        stderr_str(") invalid for cap (");
        stderr_int(values_cap);
        stderr_str(")\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }
}

// =============================================================================
// Buffer Invariants (generic)
// =============================================================================

fn Buffer_checkInvariants(buf: *u8, count: i64, cap: i64, name: *u8, context: *u8) {
    if buf == null and cap > 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("BUFFER INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  ");
        stderr_str(name);
        stderr_str(" is null but cap = ");
        stderr_int(cap);
        stderr_newline();
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    if count < 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("BUFFER INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  ");
        stderr_str(name);
        stderr_str(".count is negative: ");
        stderr_int(count);
        stderr_newline();
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    if count > cap {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("BUFFER INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  ");
        stderr_str(name);
        stderr_str(": count (");
        stderr_int(count);
        stderr_str(") > cap (");
        stderr_int(cap);
        stderr_str(")\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }
}

// =============================================================================
// MachO Writer Invariants
// =============================================================================

fn MachOWriter_checkInvariants(
    output: *u8, output_len: i64, output_cap: i64,
    symbols_count: i64, symbols_cap: i64,
    relocs_count: i64, relocs_cap: i64,
    context: *u8
) {
    // Output buffer
    Buffer_checkInvariants(output, output_len, output_cap, "output", context);

    // Symbols array
    if symbols_count < 0 or symbols_count > symbols_cap {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("MACHO INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  symbols_count (");
        stderr_int(symbols_count);
        stderr_str(") invalid for cap (");
        stderr_int(symbols_cap);
        stderr_str(")\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    // Relocs array
    if relocs_count < 0 or relocs_count > relocs_cap {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("MACHO INVARIANT VIOLATION: ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  relocs_count (");
        stderr_int(relocs_count);
        stderr_str(") invalid for cap (");
        stderr_int(relocs_cap);
        stderr_str(")\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }
}


// Cot0 SSA Function
// Minimal SSA function for self-hosting.
//
// Reference: ~/learning/go/src/cmd/compile/internal/ssa/func.go
// Reference: bootstrap-0.2/src/ssa/func.zig

// Only import block.cot - it transitively imports value.cot â†’ op.cot
import "block.cot"

// ============================================================================
// Constants
// ============================================================================

const FUNC_MAX_PARAMS: i64 = 16;
const FUNC_MAX_LOCALS: i64 = 256;

// ============================================================================
// Local Variable
// ============================================================================

struct Local {
    name_start: i64,      // Name offset in source
    name_len: i64,        // Name length
    type_idx: i64,        // Type index
    is_mutable: bool,     // let vs var
    is_param: bool,       // Is function parameter
    param_idx: i64,       // Parameter index (if is_param)
    size: i64,            // Size in bytes
    align: i64,           // Alignment
    offset: i64,          // Stack frame offset (computed by stackalloc)
}

fn local_new(name_start: i64, name_len: i64, type_idx: i64, is_mutable: bool) Local {
    return Local{
        .name_start = name_start,
        .name_len = name_len,
        .type_idx = type_idx,
        .is_mutable = is_mutable,
        .is_param = false,
        .param_idx = 0,
        .size = 8,
        .align = 8,
        .offset = 0,
    };
}

fn local_new_param(name_start: i64, name_len: i64, type_idx: i64, param_idx: i64) Local {
    return Local{
        .name_start = name_start,
        .name_len = name_len,
        .type_idx = type_idx,
        .is_mutable = false,
        .is_param = true,
        .param_idx = param_idx,
        .size = 8,
        .align = 8,
        .offset = 0,
    };
}

// ============================================================================
// SSA Function
// ============================================================================

// Func represents a function in SSA form.
// Contains:
// - Entry block
// - All basic blocks
// - All values (instructions)
// - Local variables
// - Stack frame layout
struct Func {
    // Function metadata
    name_start: i64,      // Name offset in source
    name_len: i64,        // Name length
    return_type: i64,     // Return type index

    // Blocks
    blocks: *Block,       // Externally allocated block array
    blocks_count: i64,
    blocks_cap: i64,
    entry_block: i64,     // Entry block ID

    // Values
    values: *Value,       // Externally allocated value array
    values_count: i64,
    values_cap: i64,

    // Locals
    locals: *Local,       // Externally allocated local array
    locals_count: i64,
    locals_cap: i64,

    // Stack frame (computed by stackalloc)
    frame_size: i64,      // Total stack frame size
    spill_slots: i64,     // Number of spill slots used

    // Current building state
    current_block: i64,   // Block we're adding values to
}

// ============================================================================
// Function Initialization
// ============================================================================

fn func_init(f: *Func, name_start: i64, name_len: i64, return_type: i64,
             blocks: *Block, blocks_cap: i64,
             values: *Value, values_cap: i64,
             locals: *Local, locals_cap: i64) {
    f.name_start = name_start;
    f.name_len = name_len;
    f.return_type = return_type;

    f.blocks = blocks;
    f.blocks_count = 0;
    f.blocks_cap = blocks_cap;
    f.entry_block = INVALID_BLOCK;

    f.values = values;
    f.values_count = 0;
    f.values_cap = values_cap;

    f.locals = locals;
    f.locals_count = 0;
    f.locals_cap = locals_cap;

    f.frame_size = 0;
    f.spill_slots = 0;
    f.current_block = INVALID_BLOCK;
}

// ============================================================================
// Block Management
// ============================================================================

// Create a new block and add it to the function
fn func_new_block(f: *Func, kind: BlockKind) i64 {
    if f.blocks_count >= f.blocks_cap { return INVALID_BLOCK; }

    let id: i64 = f.blocks_count;
    let b: *Block = f.blocks + id;
    b.* = block_new(id, kind);
    f.blocks_count = f.blocks_count + 1;

    return id;
}

// Create entry block (call once at start)
fn func_new_entry_block(f: *Func) i64 {
    let id: i64 = func_new_block(f, BlockKind.Plain);
    f.entry_block = id;
    f.current_block = id;
    return id;
}

// Get block by ID
fn func_get_block(f: *Func, id: i64) *Block {
    if id < 0 or id >= f.blocks_count {
        return f.blocks;  // Return first as error placeholder
    }
    return f.blocks + id;
}

// Set current block (for value emission)
fn func_set_block(f: *Func, block_id: i64) {
    f.current_block = block_id;
}

// ============================================================================
// Value Management
// ============================================================================

// Create a new value in the current block
fn func_new_value(f: *Func, op: Op, type_idx: i64) *Value {
    if f.values_count >= f.values_cap {
        return f.values;  // Return first as error placeholder
    }
    if f.current_block == INVALID_BLOCK {
        return f.values;
    }

    let id: i64 = f.values_count;
    let v: *Value = f.values + id;
    v.* = value_new(id, op, type_idx, f.current_block);
    f.values_count = f.values_count + 1;

    // Update block's value range
    let b: *Block = func_get_block(f, f.current_block);
    if b.values_count == 0 {
        b.values_start = id;
    }
    b.values_count = b.values_count + 1;

    return v;
}

// Get value by ID
fn func_get_value(f: *Func, id: i64) *Value {
    if id < 0 or id >= f.values_count {
        return f.values;  // Return first as error placeholder
    }
    return f.values + id;
}

// ============================================================================
// Local Management
// ============================================================================

// Add a local variable
fn func_add_local(f: *Func, name_start: i64, name_len: i64, type_idx: i64, is_mutable: bool) i64 {
    if f.locals_count >= f.locals_cap { return -1; }

    let idx: i64 = f.locals_count;
    let local: *Local = f.locals + idx;
    local.* = local_new(name_start, name_len, type_idx, is_mutable);
    f.locals_count = f.locals_count + 1;

    return idx;
}

// Add a parameter (parameters come before other locals)
fn func_add_param(f: *Func, name_start: i64, name_len: i64, type_idx: i64) i64 {
    if f.locals_count >= f.locals_cap { return -1; }

    let param_idx: i64 = f.locals_count;
    let idx: i64 = f.locals_count;
    let local: *Local = f.locals + idx;
    local.* = local_new_param(name_start, name_len, type_idx, param_idx);
    f.locals_count = f.locals_count + 1;

    return idx;
}

// Get local by index
fn func_get_local(f: *Func, idx: i64) *Local {
    if idx < 0 or idx >= f.locals_count {
        return f.locals;  // Return first as error placeholder
    }
    return f.locals + idx;
}

// ============================================================================
// Value Emission Helpers
// ============================================================================

// Emit a constant integer
fn func_emit_const_int(f: *Func, value: i64, type_idx: i64) *Value {
    let v: *Value = func_new_value(f, Op.ConstInt, type_idx);
    v.aux_int = value;
    return v;
}

// Emit a constant boolean
fn func_emit_const_bool(f: *Func, value: bool) *Value {
    let v: *Value = func_new_value(f, Op.ConstBool, 1);  // TYPE_BOOL = 1
    if value {
        v.aux_int = 1;
    } else {
        v.aux_int = 0;
    }
    return v;
}

// Emit a constant string
fn func_emit_const_string(f: *Func, str_start: i64, str_len: i64) *Value {
    let v: *Value = func_new_value(f, Op.ConstString, 13);  // TYPE_STRING = 13
    v.aux_int = str_start;  // Offset in source text
    v.aux_ptr = str_len;    // Length of string
    return v;
}

// Emit a binary operation
fn func_emit_binary(f: *Func, op: Op, left: *Value, right: *Value, type_idx: i64) *Value {
    let v: *Value = func_new_value(f, op, type_idx);
    value_add_arg2(v, left, right);
    return v;
}

// Emit a unary operation
fn func_emit_unary(f: *Func, op: Op, operand: *Value, type_idx: i64) *Value {
    let v: *Value = func_new_value(f, op, type_idx);
    value_add_arg(v, operand);
    return v;
}

// Emit a select (conditional value): cond ? true_val : false_val
fn func_emit_select(f: *Func, cond: *Value, true_val: *Value, false_val: *Value, type_idx: i64) *Value {
    let v: *Value = func_new_value(f, Op.Select, type_idx);
    value_add_arg3(v, cond, true_val, false_val);
    return v;
}

// Emit a load from local
fn func_emit_load_local(f: *Func, local_idx: i64) *Value {
    let local: *Local = func_get_local(f, local_idx);
    let v: *Value = func_new_value(f, Op.LocalAddr, local.type_idx);
    v.aux_int = local_idx;

    let load: *Value = func_new_value(f, Op.Load, local.type_idx);
    value_add_arg(load, v);
    return load;
}

// Emit a store to local
fn func_emit_store_local(f: *Func, local_idx: i64, val: *Value) *Value {
    let local: *Local = func_get_local(f, local_idx);
    let addr: *Value = func_new_value(f, Op.LocalAddr, local.type_idx);
    addr.aux_int = local_idx;

    let store: *Value = func_new_value(f, Op.Store, 0);  // Store has no result type
    value_add_arg2(store, addr, val);
    return store;
}

// Emit a return
fn func_emit_return(f: *Func, val: *Value) *Value {
    let ret: *Value = func_new_value(f, Op.Return, 0);
    if val.id != INVALID_ID {
        value_add_arg(ret, val);
    }
    return ret;
}

// Emit a function call
// name_start/name_len refer to positions in source
fn func_emit_call(f: *Func, name_start: i64, name_len: i64, type_idx: i64) *Value {
    let v: *Value = func_new_value(f, Op.Call, type_idx);
    v.aux_int = name_start;
    v.aux_ptr = name_len;
    return v;
}

// ============================================================================
// Control Flow
// ============================================================================

// Set up a conditional branch
fn func_emit_if(f: *Func, cond: *Value, then_block: i64, else_block: i64) {
    let b: *Block = func_get_block(f, f.current_block);
    b.kind = BlockKind.If;
    b.control = cond.id;

    block_set_succ(b, 0, then_block);
    block_set_succ(b, 1, else_block);

    let then_b: *Block = func_get_block(f, then_block);
    let else_b: *Block = func_get_block(f, else_block);
    block_add_pred(then_b, f.current_block);
    block_add_pred(else_b, f.current_block);
}

// Set up an unconditional jump
fn func_emit_jump(f: *Func, target: i64) {
    let b: *Block = func_get_block(f, f.current_block);
    b.kind = BlockKind.Plain;
    block_add_succ(b, target);

    let target_b: *Block = func_get_block(f, target);
    block_add_pred(target_b, f.current_block);
}

// Mark current block as return block
fn func_emit_return_block(f: *Func) {
    let b: *Block = func_get_block(f, f.current_block);
    b.kind = BlockKind.Return;
}

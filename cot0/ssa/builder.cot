// Cot0 SSA Builder - IR to SSA Conversion
// Converts frontend IR to backend SSA form.
//
// Key concepts (from Go):
// - Convert IR nodes to SSA values
// - Track variable→value mapping per block
// - Handle control flow (if, while, return)
// - Create phi nodes at merge points
//
// Reference: ~/learning/go/src/cmd/compile/internal/ssagen/ssa.go
// Reference: bootstrap-0.2/src/frontend/ssa_builder.zig

// NOTE: This file depends on types from func.cot and ir.cot
// These are imported by main.cot via genssa.cot and lower.cot
// We don't import them here to avoid duplicate definitions
// This means builder.cot must be imported LAST in main.cot

// NOTE: Register constants (X0, etc.) are imported via genssa.cot -> arm64.cot -> ../arm64/regs.cot
// No imports needed here - all dependencies come from main.cot's earlier imports

// ============================================================================
// Constants
// ============================================================================

const MAX_VAR_DEFS: i64 = 1024;    // Max variable definitions per block
const MAX_BLOCK_DEFS: i64 = 500;   // Max blocks with definitions

// IR node indices (from lower.cot/ir.cot)
const IR_NULL_NODE: i64 = -1;

// ============================================================================
// IR to SSA Op Mapping (from main.cot)
// Reference: Zig's binaryOpToSSA() in ssa_builder.zig
// ============================================================================

// Map IR binary operation to SSA Op
fn ir_op_to_ssa_op(ir_op: i64) Op {
    // IRBinaryOp enum values (from ir.cot)
    if ir_op == 0 { return Op.Add64; }     // IRBinaryOp.Add
    if ir_op == 1 { return Op.Sub64; }     // IRBinaryOp.Sub
    if ir_op == 2 { return Op.Mul64; }     // IRBinaryOp.Mul
    if ir_op == 3 { return Op.Div64; }     // IRBinaryOp.Div
    if ir_op == 4 { return Op.Mod64; }     // IRBinaryOp.Mod
    if ir_op == 5 { return Op.Eq64; }      // IRBinaryOp.Eq
    if ir_op == 6 { return Op.Ne64; }      // IRBinaryOp.Ne
    if ir_op == 7 { return Op.Lt64; }      // IRBinaryOp.Lt
    if ir_op == 8 { return Op.Le64; }      // IRBinaryOp.Le
    if ir_op == 9 { return Op.Gt64; }      // IRBinaryOp.Gt
    if ir_op == 10 { return Op.Ge64; }     // IRBinaryOp.Ge
    if ir_op == 11 { return Op.And64; }    // IRBinaryOp.And (logical - use bitwise)
    if ir_op == 12 { return Op.Or64; }     // IRBinaryOp.Or (logical - use bitwise)
    if ir_op == 13 { return Op.And64; }    // IRBinaryOp.BitAnd
    if ir_op == 14 { return Op.Or64; }     // IRBinaryOp.BitOr
    if ir_op == 15 { return Op.Xor64; }    // IRBinaryOp.BitXor
    if ir_op == 16 { return Op.Shl64; }    // IRBinaryOp.Shl
    if ir_op == 17 { return Op.Shr64; }    // IRBinaryOp.Shr
    return Op.Add64;  // Default fallback
}

fn ir_unary_op_to_ssa_op(ir_op: i64) Op {
    // IR unary ops: Neg=0, Not=1, BitNot=2 (from ir.cot IRUnaryOp enum)
    if ir_op == 0 { return Op.Neg64; }     // IRUnaryOp.Neg
    if ir_op == 1 { return Op.Not64; }     // IRUnaryOp.Not
    if ir_op == 2 { return Op.Not64; }     // IRUnaryOp.BitNot (use Not64 for now)
    return Op.Neg64;  // Default fallback
}

// ============================================================================
// Variable Definition Tracking
// ============================================================================

// Single variable → value mapping
struct VarDef {
    var_idx: i64,         // Local variable index
    value_id: i64,        // SSA value ID
}

// Variable definitions for one block
struct BlockDefs {
    block_id: i64,
    defs: *VarDef,        // Array of VarDef
    defs_count: i64,
    defs_cap: i64,
}

fn BlockDefs_init(bd: *BlockDefs, block_id: i64, defs: *VarDef, cap: i64) {
    bd.block_id = block_id;
    bd.defs = defs;
    bd.defs_count = 0;
    bd.defs_cap = cap;
}

// Set variable value (add or update)
fn BlockDefs_set(bd: *BlockDefs, var_idx: i64, value_id: i64) {
    // Check if already exists
    var i: i64 = 0;
    while i < bd.defs_count {
        let def: *VarDef = bd.defs + i;
        if def.var_idx == var_idx {
            def.value_id = value_id;
            return;
        }
        i = i + 1;
    }

    // Add new
    if bd.defs_count >= bd.defs_cap { return; }
    let def: *VarDef = bd.defs + bd.defs_count;
    def.var_idx = var_idx;
    def.value_id = value_id;
    bd.defs_count = bd.defs_count + 1;
}

// Get variable value (or -1 if not found)
fn BlockDefs_get(bd: *BlockDefs, var_idx: i64) i64 {
    var i: i64 = 0;
    while i < bd.defs_count {
        let def: *VarDef = bd.defs + i;
        if def.var_idx == var_idx {
            return def.value_id;
        }
        i = i + 1;
    }
    return INVALID_ID;
}

// ============================================================================
// IR to SSA Block Mapping
// ============================================================================

struct BlockMapping {
    ir_block: i64,        // IR block index
    ssa_block: i64,       // SSA block ID
}

// ============================================================================
// SSA Builder
// ============================================================================

struct SSABuilder {
    // The SSA function being built
    func: *Func,

    // Current block
    current_block: i64,

    // Variable definitions for current block
    current_defs: *BlockDefs,

    // All block definitions (for phi insertion)
    all_defs: *BlockDefs,     // Array of BlockDefs
    all_defs_count: i64,
    all_defs_cap: i64,

    // IR to SSA block mapping
    block_map: *BlockMapping,
    block_map_count: i64,
    block_map_cap: i64,

    // IR node to SSA value mapping (prevents duplicate conversion)
    node_values: *VarDef,     // Reuse VarDef for node→value
    node_values_count: i64,
    node_values_cap: i64,

    // Storage for per-block VarDefs (external)
    var_storage: *VarDef,
    var_storage_used: i64,
    var_storage_cap: i64,

    // === IR References (set before build) ===
    ir_nodes: *IRNode,        // Global IR nodes array
    ir_nodes_start: i64,      // Start index for this function
    ir_nodes_end: i64,        // End index for this function
    ir_locals: *IRLocal,      // Global IR locals array
    ir_locals_start: i64,     // Start index for this function
    ir_locals_count: i64,     // Number of locals
    source: *u8,              // Source text for function names
    source_len: i64,
    call_args: *i64,          // Global call args array

    // === Register allocation state ===
    // Simple round-robin allocation matching original main.cot behavior
    next_reg: i64,            // Next register to assign (X1-X28)
    max_reg: i64,             // Maximum register (28 = X28)
}

// ============================================================================
// Builder Initialization
// ============================================================================

fn SSABuilder_init(b: *SSABuilder, f: *Func,
                all_defs: *BlockDefs, all_defs_cap: i64,
                block_map: *BlockMapping, block_map_cap: i64,
                node_values: *VarDef, node_values_cap: i64,
                var_storage: *VarDef, var_storage_cap: i64) {
    b.func = f;
    b.current_block = INVALID_BLOCK;
    b.current_defs = null;

    b.all_defs = all_defs;
    b.all_defs_count = 0;
    b.all_defs_cap = all_defs_cap;

    b.block_map = block_map;
    b.block_map_count = 0;
    b.block_map_cap = block_map_cap;

    b.node_values = node_values;
    b.node_values_count = 0;
    b.node_values_cap = node_values_cap;

    b.var_storage = var_storage;
    b.var_storage_used = 0;
    b.var_storage_cap = var_storage_cap;

    // IR references (set later via SSABuilder_setIR)
    b.ir_nodes = null;
    b.ir_nodes_start = 0;
    b.ir_nodes_end = 0;
    b.ir_locals = null;
    b.ir_locals_start = 0;
    b.ir_locals_count = 0;
    b.source = null;
    b.source_len = 0;
    b.call_args = null;

    // Register allocation - simple round-robin matching original main.cot
    b.next_reg = X1;          // Start at X1 (X0 is reserved for return value)
    b.max_reg = 28;           // Max is X28 (29=FP, 30=LR, 31=SP/XZR)
}

// Assign a register to a value and increment the counter
// Returns the assigned register
fn SSABuilder_assignReg(b: *SSABuilder, v: *Value) i64 {
    let reg: i64 = b.next_reg;
    v.reg = reg;
    b.next_reg = b.next_reg + 1;
    if b.next_reg > b.max_reg {
        b.next_reg = X1;  // Wrap around
    }
    return reg;
}

// Set IR references before calling build()
// Matches Zig's SSABuilder.init() which takes ir_func
fn SSABuilder_setIR(b: *SSABuilder,
                    ir_nodes: *IRNode, ir_nodes_start: i64, ir_nodes_count: i64,
                    ir_locals: *IRLocal, ir_locals_start: i64, ir_locals_count: i64,
                    source: *u8, source_len: i64,
                    call_args: *i64) {
    b.ir_nodes = ir_nodes;
    b.ir_nodes_start = ir_nodes_start;
    b.ir_nodes_end = ir_nodes_start + ir_nodes_count;
    b.ir_locals = ir_locals;
    b.ir_locals_start = ir_locals_start;
    b.ir_locals_count = ir_locals_count;
    b.source = source;
    b.source_len = source_len;
    b.call_args = call_args;
}

// Allocate storage for a block's VarDefs
fn SSABuilder_allocDefs(b: *SSABuilder, count: i64) *VarDef {
    if b.var_storage_used + count > b.var_storage_cap {
        return b.var_storage;  // Return start as fallback
    }
    let result: *VarDef = b.var_storage + b.var_storage_used;
    b.var_storage_used = b.var_storage_used + count;
    return result;
}

// ============================================================================
// Block Management
// ============================================================================

// Create a new SSA block and set it as current
fn SSABuilder_newBlock(b: *SSABuilder, kind: BlockKind) i64 {
    let block_id: i64 = Func_newBlock(b.func, kind);
    SSABuilder_setBlock(b, block_id);
    return block_id;
}

// Get current block being built
// Reference: Zig's SSABuilder.currentBlock()
fn SSABuilder_currentBlock(b: *SSABuilder) i64 {
    return b.current_block;
}

// Set current block
fn SSABuilder_setBlock(b: *SSABuilder, block_id: i64) {
    b.current_block = block_id;
    Func_setBlock(b.func, block_id);

    // Create BlockDefs for this block
    if b.all_defs_count < b.all_defs_cap {
        let bd: *BlockDefs = b.all_defs + b.all_defs_count;
        let storage: *VarDef = SSABuilder_allocDefs(b, MAX_VAR_DEFS);
        BlockDefs_init(bd, block_id, storage, MAX_VAR_DEFS);
        b.current_defs = bd;
        b.all_defs_count = b.all_defs_count + 1;
    }
}

// Map IR block to SSA block
fn SSABuilder_mapBlock(b: *SSABuilder, ir_block: i64, ssa_block: i64) {
    if b.block_map_count >= b.block_map_cap { return; }
    let m: *BlockMapping = b.block_map + b.block_map_count;
    m.ir_block = ir_block;
    m.ssa_block = ssa_block;
    b.block_map_count = b.block_map_count + 1;
}

// Get SSA block for IR block (or -1)
fn SSABuilder_getSSABlock(b: *SSABuilder, ir_block: i64) i64 {
    var i: i64 = 0;
    while i < b.block_map_count {
        let m: *BlockMapping = b.block_map + i;
        if m.ir_block == ir_block {
            return m.ssa_block;
        }
        i = i + 1;
    }
    return INVALID_BLOCK;
}

// ============================================================================
// Variable Tracking
// ============================================================================

// Set variable value in current block
fn SSABuilder_setVar(b: *SSABuilder, var_idx: i64, value_id: i64) {
    if b.current_defs != null {
        BlockDefs_set(b.current_defs, var_idx, value_id);
    }
}

// Get variable value from current block (or -1)
fn SSABuilder_getVar(b: *SSABuilder, var_idx: i64) i64 {
    if b.current_defs != null {
        return BlockDefs_get(b.current_defs, var_idx);
    }
    return INVALID_ID;
}

// ============================================================================
// Node Value Caching
// ============================================================================

// Cache IR node → SSA value mapping
fn SSABuilder_cacheNode(b: *SSABuilder, node_idx: i64, value_id: i64) {
    if b.node_values_count >= b.node_values_cap { return; }
    let nv: *VarDef = b.node_values + b.node_values_count;
    nv.var_idx = node_idx;
    nv.value_id = value_id;
    b.node_values_count = b.node_values_count + 1;
}

// Get cached SSA value for IR node (or -1)
fn SSABuilder_getCached(b: *SSABuilder, node_idx: i64) i64 {
    var i: i64 = 0;
    while i < b.node_values_count {
        let nv: *VarDef = b.node_values + i;
        if nv.var_idx == node_idx {
            return nv.value_id;
        }
        i = i + 1;
    }
    return INVALID_ID;
}

// ============================================================================
// Value Emission (wrappers around func_* functions)
// ============================================================================

// Emit constant integer
fn SSABuilder_emitConstInt(b: *SSABuilder, value: i64, type_idx: i64) *Value {
    return Func_emitConstInt(b.func, value, type_idx);
}

// Emit constant boolean
fn SSABuilder_emitConstBool(b: *SSABuilder, value: bool) *Value {
    return Func_emitConstBool(b.func, value);
}

// Emit binary operation
fn SSABuilder_emitBinary(b: *SSABuilder, op: Op, left: *Value, right: *Value, type_idx: i64) *Value {
    return Func_emitBinary(b.func, op, left, right, type_idx);
}

// Emit unary operation
fn SSABuilder_emitUnary(b: *SSABuilder, op: Op, operand: *Value, type_idx: i64) *Value {
    return Func_emitUnary(b.func, op, operand, type_idx);
}

// Emit load from local
fn SSABuilder_emitLoadLocal(b: *SSABuilder, local_idx: i64) *Value {
    return Func_emitLoadLocal(b.func, local_idx);
}

// Emit store to local
fn SSABuilder_emitStoreLocal(b: *SSABuilder, local_idx: i64, val: *Value) *Value {
    return Func_emitStoreLocal(b.func, local_idx, val);
}

// Emit return
fn SSABuilder_emitReturn(b: *SSABuilder, val: *Value) *Value {
    return Func_emitReturn(b.func, val);
}

// Emit stack allocation (alloca)
// Reference: Zig's SSABuilder.buildAlloca()
// Returns pointer to allocated stack space
fn SSABuilder_emitAlloca(b: *SSABuilder, size: i64, align: i64, type_idx: i64) *Value {
    // In cot0, we use LocalAddr to get address of a local variable
    // Add a new local to the function and return its address
    let local_idx: i64 = Func_addLocal(b.func, 0, 0, type_idx, true);
    let local: *Local = Func_getLocal(b.func, local_idx);
    local.size = size;
    local.align = align;

    let addr: *Value = Func_newValue(b.func, Op.LocalAddr, type_idx);
    addr.aux_int = local_idx;
    return addr;
}

// Emit type cast/conversion
// Reference: Zig's SSABuilder.buildCast()
// Selects appropriate conversion op based on source/dest size
fn SSABuilder_emitCast(b: *SSABuilder, val: *Value, src_size: i64, dst_size: i64, is_signed: bool, dst_type: i64) *Value {
    // Same size - no conversion needed
    if src_size == dst_size {
        return val;
    }

    // Extension (smaller to larger)
    if src_size < dst_size {
        var op: Op = Op.ZeroExt8to64;  // Default
        if is_signed {
            if src_size == 1 {
                op = Op.SignExt8to64;
            } else if src_size == 2 {
                op = Op.SignExt16to64;
            } else if src_size == 4 {
                op = Op.SignExt32to64;
            }
        } else {
            if src_size == 1 {
                op = Op.ZeroExt8to64;
            } else if src_size == 2 {
                op = Op.ZeroExt16to64;
            } else if src_size == 4 {
                op = Op.ZeroExt32to64;
            }
        }
        return Func_emitUnary(b.func, op, val, dst_type);
    }

    // Truncation (larger to smaller)
    var op: Op = Op.Trunc64to8;  // Default
    if dst_size == 1 {
        op = Op.Trunc64to8;
    } else if dst_size == 2 {
        op = Op.Trunc64to16;
    } else if dst_size == 4 {
        op = Op.Trunc64to32;
    }
    return Func_emitUnary(b.func, op, val, dst_type);
}

// ============================================================================
// Control Flow
// ============================================================================

// Emit conditional branch
fn SSABuilder_emitIf(b: *SSABuilder, cond: *Value, then_block: i64, else_block: i64) {
    Func_emitIf(b.func, cond, then_block, else_block);
}

// Emit unconditional jump
fn SSABuilder_emitJump(b: *SSABuilder, target: i64) {
    Func_emitJump(b.func, target);
}

// Mark current block as return
fn SSABuilder_emitReturn_block(b: *SSABuilder) {
    Func_emitReturnBlock(b.func);
}

// ============================================================================
// Phi Node Creation
// ============================================================================

// Create phi node for variable
fn SSABuilder_emitPhi(b: *SSABuilder, type_idx: i64) *Value {
    let v: *Value = Func_newValue(b.func, Op.Phi, type_idx);
    return v;
}

// Add argument to phi node from predecessor block
fn SSABuilder_phiAddArg(b: *SSABuilder, phi: *Value, val: *Value, pred_block: i64) {
    // For simplicity, store args directly
    // In full implementation, args are ordered by predecessor
    Value_addArg(phi, val);
}

// ============================================================================
// Complete IR to SSA Conversion
// Matches Zig's SSABuilder.build() in src/frontend/ssa_builder.zig
// ============================================================================

// Build SSA from IR function
// Returns 0 on success, error code otherwise
// Reference: Zig's SSABuilder.build() at line 383
fn SSABuilder_build(b: *SSABuilder) i64 {
    // Step 1: Find max block_id in IR nodes to know how many blocks we need
    var max_block_id: i64 = 0;
    var ir_idx: i64 = b.ir_nodes_start;
    while ir_idx < b.ir_nodes_end {
        let ir_node: *IRNode = b.ir_nodes + ir_idx;
        if ir_node.block_id > max_block_id {
            max_block_id = ir_node.block_id;
        }
        ir_idx = ir_idx + 1;
    }

    // Step 2: Create SSA blocks
    // Entry block (block 0)
    let entry: i64 = Func_newEntryBlock(b.func);
    SSABuilder_setBlock(b, entry);
    SSABuilder_mapBlock(b, 0, entry);

    // Create additional blocks (1 through max_block_id)
    var block_idx: i64 = 1;
    while block_idx <= max_block_id {
        let new_block: i64 = Func_newBlock(b.func, BlockKind.Plain);
        SSABuilder_mapBlock(b, block_idx, new_block);
        block_idx = block_idx + 1;
    }

    // Step 3: Register locals (params first, then regular locals)
    // Copy from IR locals to SSA locals
    var local_idx: i64 = b.ir_locals_start;
    let locals_end: i64 = b.ir_locals_start + b.ir_locals_count;
    var ssa_local_idx: i64 = 0;
    while local_idx < locals_end {
        let ir_local: *IRLocal = b.ir_locals + local_idx;
        if ir_local.is_param {
            Func_addParam(b.func, ir_local.name_start, ir_local.name_len,
                          ir_local.type_idx);
        } else {
            Func_addLocal(b.func, ir_local.name_start, ir_local.name_len,
                          ir_local.type_idx, ir_local.is_mutable);
        }
        // Copy size from IR local to SSA local
        let ssa_local: *Local = Func_getLocal(b.func, ssa_local_idx);
        ssa_local.size = ir_local.size;
        local_idx = local_idx + 1;
        ssa_local_idx = ssa_local_idx + 1;
    }

    // Step 4: Store parameters to stack (BUG-049 fix)
    // Following Zig's ssa_builder.zig Phase 3: parameters must be stored to
    // stack slots so they survive across function calls (X0-X7 are caller-saved)
    var param_local_idx: i64 = 0;
    while param_local_idx < b.func.locals_count {
        let param_local: *Local = Func_getLocal(b.func, param_local_idx);
        if param_local.is_param {
            // 1. Create Arg value for the parameter (captures value from X0/X1/etc.)
            let arg_val: *Value = Func_newValue(b.func, Op.Arg, TYPE_I64);
            arg_val.aux_int = param_local.param_idx;
            arg_val.reg = X0 + param_local.param_idx;

            // 2. Create LocalAddr value for the stack slot
            let addr_val: *Value = Func_newValue(b.func, Op.LocalAddr, TYPE_I64);
            addr_val.aux_int = param_local_idx;

            // 3. Store Arg to stack slot
            let store_val: *Value = Func_newValue(b.func, Op.Store, TYPE_VOID);
            Value_addArg2(store_val, addr_val, arg_val);
        }
        param_local_idx = param_local_idx + 1;
    }

    // Step 5: Convert IR nodes to SSA
    // Track current IR block for block transitions
    var current_ir_block: i64 = 0;
    ir_idx = b.ir_nodes_start;
    while ir_idx < b.ir_nodes_end {
        let ir_node: *IRNode = b.ir_nodes + ir_idx;

        // Handle block transitions
        if ir_node.block_id != current_ir_block {
            current_ir_block = ir_node.block_id;
            let ssa_block: i64 = SSABuilder_getSSABlock(b, current_ir_block);
            if ssa_block >= 0 {
                SSABuilder_setBlock(b, ssa_block);
            }
        }

        // Convert this node
        SSABuilder_convertNode(b, ir_node, ir_idx);

        ir_idx = ir_idx + 1;
    }

    // Step 6: Emit return block
    Func_emitReturnBlock(b.func);

    return 0;
}

// Convert a single IR node to SSA value(s)
// Matches Zig's SSABuilder.convertNode() at line 470
// Returns the SSA value ID, or -1 for control flow nodes
fn SSABuilder_convertNode(b: *SSABuilder, ir_node: *IRNode, ir_idx: i64) i64 {
    // Check if already converted (using node_values cache)
    let cached: i64 = SSABuilder_getCached(b, ir_idx);
    if cached != INVALID_ID {
        return cached;
    }

    // Dispatch based on node kind
    // This will be filled in by subsequent steps
    var result_id: i64 = INVALID_ID;

    if ir_node.kind == IRNodeKind.ConstInt {
        result_id = SSABuilder_convertConstInt(b, ir_node);
    } else if ir_node.kind == IRNodeKind.ConstString {
        result_id = SSABuilder_convertConstString(b, ir_node);
    } else if ir_node.kind == IRNodeKind.ConstBool {
        result_id = SSABuilder_convertConstBool(b, ir_node);
    } else if ir_node.kind == IRNodeKind.Binary {
        result_id = SSABuilder_convertBinary(b, ir_node);
    } else if ir_node.kind == IRNodeKind.Unary {
        result_id = SSABuilder_convertUnary(b, ir_node);
    } else if ir_node.kind == IRNodeKind.LoadLocal {
        result_id = SSABuilder_convertLoadLocal(b, ir_node);
    } else if ir_node.kind == IRNodeKind.StoreLocal {
        result_id = SSABuilder_convertStoreLocal(b, ir_node);
    } else if ir_node.kind == IRNodeKind.AddrLocal {
        result_id = SSABuilder_convertAddrLocal(b, ir_node);
    } else if ir_node.kind == IRNodeKind.Load {
        result_id = SSABuilder_convertLoad(b, ir_node);
    } else if ir_node.kind == IRNodeKind.Store {
        result_id = SSABuilder_convertStore(b, ir_node);
    } else if ir_node.kind == IRNodeKind.FieldLocal {
        result_id = SSABuilder_convertFieldLocal(b, ir_node);
    } else if ir_node.kind == IRNodeKind.FieldValue {
        result_id = SSABuilder_convertFieldValue(b, ir_node);
    } else if ir_node.kind == IRNodeKind.StoreFieldLocal {
        result_id = SSABuilder_convertStoreFieldLocal(b, ir_node);
    } else if ir_node.kind == IRNodeKind.StoreField {
        result_id = SSABuilder_convertStoreField(b, ir_node);
    } else if ir_node.kind == IRNodeKind.IndexLocal {
        result_id = SSABuilder_convertIndexLocal(b, ir_node);
    } else if ir_node.kind == IRNodeKind.IndexValue {
        result_id = SSABuilder_convertIndexValue(b, ir_node);
    } else if ir_node.kind == IRNodeKind.StoreIndexLocal {
        result_id = SSABuilder_convertStoreIndexLocal(b, ir_node);
    } else if ir_node.kind == IRNodeKind.StoreIndexValue {
        result_id = SSABuilder_convertStoreIndexValue(b, ir_node);
    } else if ir_node.kind == IRNodeKind.MakeString {
        result_id = SSABuilder_convertMakeString(b, ir_node);
    } else if ir_node.kind == IRNodeKind.MakeSlice {
        result_id = SSABuilder_convertMakeSlice(b, ir_node);
    } else if ir_node.kind == IRNodeKind.SlicePtr {
        result_id = SSABuilder_convertSlicePtr(b, ir_node);
    } else if ir_node.kind == IRNodeKind.SliceLen {
        result_id = SSABuilder_convertSliceLen(b, ir_node);
    } else if ir_node.kind == IRNodeKind.Call {
        result_id = SSABuilder_convertCall(b, ir_node);
    } else if ir_node.kind == IRNodeKind.Select {
        result_id = SSABuilder_convertSelect(b, ir_node);
    } else if ir_node.kind == IRNodeKind.Branch {
        SSABuilder_convertBranch(b, ir_node);
        result_id = INVALID_ID;
    } else if ir_node.kind == IRNodeKind.Jump {
        SSABuilder_convertJump(b, ir_node);
        result_id = INVALID_ID;
    } else if ir_node.kind == IRNodeKind.Return {
        SSABuilder_convertReturn(b, ir_node);
        result_id = INVALID_ID;
    }

    // Cache the result
    if result_id != INVALID_ID {
        SSABuilder_cacheNode(b, ir_idx, result_id);
    }

    return result_id;
}

// ============================================================================
// IR Node Converters
// Each function converts a specific IR node kind to SSA values
// Reference: Zig's SSABuilder.convertNode() and main.cot's conversion loop
// ============================================================================

// Helper: Get SSA value by ID
fn SSABuilder_getValue(b: *SSABuilder, value_id: i64) *Value {
    return Func_getValue(b.func, value_id);
}

// Helper: Get cached SSA value ID for an IR node, computing absolute index
fn SSABuilder_getOperandValue(b: *SSABuilder, relative_ir_idx: i64) *Value {
    let abs_idx: i64 = b.ir_nodes_start + relative_ir_idx;
    let value_id: i64 = SSABuilder_getCached(b, abs_idx);
    return Func_getValue(b.func, value_id);
}

// --- Constants ---

fn SSABuilder_convertConstInt(b: *SSABuilder, ir_node: *IRNode) i64 {
    let val: *Value = Func_emitConstInt(b.func, ir_node.value, TYPE_I64);
    SSABuilder_assignReg(b, val);
    return val.id;
}

fn SSABuilder_convertConstString(b: *SSABuilder, ir_node: *IRNode) i64 {
    // String literal: left=str_start, right=str_len in source
    let val: *Value = Func_emitConstString(b.func, ir_node.left, ir_node.right);
    SSABuilder_assignReg(b, val);
    return val.id;
}

fn SSABuilder_convertConstBool(b: *SSABuilder, ir_node: *IRNode) i64 {
    let val: *Value = Func_emitConstBool(b.func, ir_node.value != 0);
    SSABuilder_assignReg(b, val);
    return val.id;
}

// --- Binary/Unary Operations ---

fn SSABuilder_convertBinary(b: *SSABuilder, ir_node: *IRNode) i64 {
    // left and right are relative IR indices
    let left_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let right_val: *Value = SSABuilder_getOperandValue(b, ir_node.right);
    let ssa_op: Op = ir_op_to_ssa_op(ir_node.op);
    let val: *Value = Func_emitBinary(b.func, ssa_op, left_val, right_val, TYPE_I64);
    SSABuilder_assignReg(b, val);
    return val.id;
}

fn SSABuilder_convertUnary(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Unary op: left is operand (relative IR index), op is the operator
    let operand_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let ssa_op: Op = ir_unary_op_to_ssa_op(ir_node.op);
    let val: *Value = Func_newValue(b.func, ssa_op, TYPE_I64);
    Value_addArg(val, operand_val);
    SSABuilder_assignReg(b, val);
    return val.id;
}

// --- Local Variable Access ---

fn SSABuilder_convertLoadLocal(b: *SSABuilder, ir_node: *IRNode) i64 {
    let loc_idx: i64 = ir_node.left;
    let load_val: *Value = Func_emitLoadLocal(b.func, loc_idx);
    SSABuilder_assignReg(b, load_val);
    return load_val.id;
}

fn SSABuilder_convertStoreLocal(b: *SSABuilder, ir_node: *IRNode) i64 {
    let loc_idx: i64 = ir_node.left;
    // right is relative IR index of value to store
    let value_val: *Value = SSABuilder_getOperandValue(b, ir_node.right);
    let store_val: *Value = Func_emitStoreLocal(b.func, loc_idx, value_val);
    // Stores don't need registers (they write to memory)
    return store_val.id;
}

fn SSABuilder_convertAddrLocal(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Address of local variable: left = local index
    let loc_idx: i64 = ir_node.left;
    let addr_val: *Value = Func_newValue(b.func, Op.LocalAddr, TYPE_I64);
    addr_val.aux_int = loc_idx;
    SSABuilder_assignReg(b, addr_val);
    return addr_val.id;
}

// --- Pointer Operations ---

fn SSABuilder_convertLoad(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Load from pointer: left = ptr expr (relative IR index)
    let ptr_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let load_val: *Value = Func_newValue(b.func, Op.Load, TYPE_I64);
    Value_addArg(load_val, ptr_val);
    SSABuilder_assignReg(b, load_val);
    return load_val.id;
}

fn SSABuilder_convertStore(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Store to pointer: left = ptr expr, right = value expr (relative)
    let ptr_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let val_val: *Value = SSABuilder_getOperandValue(b, ir_node.right);
    let store_val: *Value = Func_newValue(b.func, Op.Store, TYPE_VOID);
    Value_addArg2(store_val, ptr_val, val_val);
    // Stores don't need registers
    return store_val.id;
}

// --- Field Access ---

fn SSABuilder_convertFieldLocal(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Access field of local struct: left = local_idx, right = offset
    let loc_idx: i64 = ir_node.left;
    let offset: i64 = ir_node.right;

    // 1. Get address of local
    let addr_val: *Value = Func_newValue(b.func, Op.LocalAddr, TYPE_I64);
    addr_val.aux_int = loc_idx;

    // 2. Add offset to get field address
    let off_val: *Value = Func_newValue(b.func, Op.OffPtr, TYPE_I64);
    Value_addArg(off_val, addr_val);
    off_val.aux_int = offset;

    // 3. Load the field value
    let load_val: *Value = Func_newValue(b.func, Op.Load, ir_node.type_idx);
    Value_addArg(load_val, off_val);
    SSABuilder_assignReg(b, load_val);
    return load_val.id;
}

fn SSABuilder_convertFieldValue(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Access field via computed address: left = base_expr, right = offset
    let base_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let offset: i64 = ir_node.right;

    // 1. Add offset to base to get field address
    let off_val: *Value = Func_newValue(b.func, Op.OffPtr, TYPE_I64);
    Value_addArg(off_val, base_val);
    off_val.aux_int = offset;

    // 2. Load the field value
    let load_val: *Value = Func_newValue(b.func, Op.Load, ir_node.type_idx);
    Value_addArg(load_val, off_val);
    SSABuilder_assignReg(b, load_val);
    return load_val.id;
}

fn SSABuilder_convertStoreFieldLocal(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Store to field of local struct: left = local_idx, right = offset, value = stored_expr
    let loc_idx: i64 = ir_node.left;
    let offset: i64 = ir_node.right;
    let val_val: *Value = SSABuilder_getOperandValue(b, ir_node.value);

    // 1. Get address of local
    let addr_val: *Value = Func_newValue(b.func, Op.LocalAddr, TYPE_I64);
    addr_val.aux_int = loc_idx;
    SSABuilder_assignReg(b, addr_val);

    // 2. Add offset to get field address
    let off_val: *Value = Func_newValue(b.func, Op.OffPtr, TYPE_I64);
    Value_addArg(off_val, addr_val);
    off_val.aux_int = offset;
    SSABuilder_assignReg(b, off_val);

    // 3. Store the value
    let store_val: *Value = Func_newValue(b.func, Op.Store, TYPE_VOID);
    Value_addArg2(store_val, off_val, val_val);
    return store_val.id;
}

fn SSABuilder_convertStoreField(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Store to field via computed address: left = base_expr, right = offset, value = stored_expr
    let base_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let offset: i64 = ir_node.right;
    let val_val: *Value = SSABuilder_getOperandValue(b, ir_node.value);

    // 1. Add offset to base to get field address
    let off_val: *Value = Func_newValue(b.func, Op.OffPtr, TYPE_I64);
    Value_addArg(off_val, base_val);
    off_val.aux_int = offset;
    SSABuilder_assignReg(b, off_val);

    // 2. Store the value
    let store_val: *Value = Func_newValue(b.func, Op.Store, TYPE_VOID);
    Value_addArg2(store_val, off_val, val_val);
    return store_val.id;
}

// --- Array Indexing ---

fn SSABuilder_convertIndexLocal(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Index into local array: left = local_idx, right = index_expr, value = elem_size
    let loc_idx: i64 = ir_node.left;
    let idx_val: *Value = SSABuilder_getOperandValue(b, ir_node.right);
    let elem_size: i64 = ir_node.value;

    // 1. Get address of local array
    let addr_val: *Value = Func_newValue(b.func, Op.LocalAddr, TYPE_I64);
    addr_val.aux_int = loc_idx;
    SSABuilder_assignReg(b, addr_val);

    // 2. Compute byte offset: index * elem_size
    let size_val: *Value = Func_emitConstInt(b.func, elem_size, TYPE_I64);
    SSABuilder_assignReg(b, size_val);
    let offset_val: *Value = Func_emitBinary(b.func, Op.Mul64, idx_val, size_val, TYPE_I64);
    SSABuilder_assignReg(b, offset_val);

    // 3. Add offset to base address
    let ptr_val: *Value = Func_emitBinary(b.func, Op.AddPtr, addr_val, offset_val, TYPE_I64);
    SSABuilder_assignReg(b, ptr_val);

    // 4. Load the element value
    let load_val: *Value = Func_newValue(b.func, Op.Load, ir_node.type_idx);
    Value_addArg(load_val, ptr_val);
    SSABuilder_assignReg(b, load_val);
    return load_val.id;
}

fn SSABuilder_convertIndexValue(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Index via computed address: left = base_expr, right = index_expr, value = elem_size
    let base_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let idx_val: *Value = SSABuilder_getOperandValue(b, ir_node.right);
    let elem_size: i64 = ir_node.value;

    // 1. Compute byte offset: index * elem_size
    let size_val: *Value = Func_emitConstInt(b.func, elem_size, TYPE_I64);
    SSABuilder_assignReg(b, size_val);
    let offset_val: *Value = Func_emitBinary(b.func, Op.Mul64, idx_val, size_val, TYPE_I64);
    SSABuilder_assignReg(b, offset_val);

    // 2. Add offset to base address
    let ptr_val: *Value = Func_emitBinary(b.func, Op.AddPtr, base_val, offset_val, TYPE_I64);
    SSABuilder_assignReg(b, ptr_val);

    // 3. Load the element value
    let load_val: *Value = Func_newValue(b.func, Op.Load, ir_node.type_idx);
    Value_addArg(load_val, ptr_val);
    SSABuilder_assignReg(b, load_val);
    return load_val.id;
}

fn SSABuilder_convertStoreIndexLocal(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Store to local array element: left = local_idx, right = index_expr, value = stored_expr, op = elem_size
    let loc_idx: i64 = ir_node.left;
    let idx_val: *Value = SSABuilder_getOperandValue(b, ir_node.right);
    let val_val: *Value = SSABuilder_getOperandValue(b, ir_node.value);
    let elem_size: i64 = ir_node.op;

    // 1. Get address of local array
    let addr_val: *Value = Func_newValue(b.func, Op.LocalAddr, TYPE_I64);
    addr_val.aux_int = loc_idx;
    SSABuilder_assignReg(b, addr_val);

    // 2. Compute byte offset: index * elem_size
    let size_val: *Value = Func_emitConstInt(b.func, elem_size, TYPE_I64);
    SSABuilder_assignReg(b, size_val);
    let offset_val: *Value = Func_emitBinary(b.func, Op.Mul64, idx_val, size_val, TYPE_I64);
    SSABuilder_assignReg(b, offset_val);

    // 3. Add offset to base address
    let ptr_val: *Value = Func_emitBinary(b.func, Op.AddPtr, addr_val, offset_val, TYPE_I64);
    SSABuilder_assignReg(b, ptr_val);

    // 4. Store the value
    let store_val: *Value = Func_newValue(b.func, Op.Store, TYPE_VOID);
    Value_addArg2(store_val, ptr_val, val_val);
    return store_val.id;
}

fn SSABuilder_convertStoreIndexValue(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Store via indexed address: left = base_expr, right = index_expr, value = stored_expr, op = elem_size
    let base_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let idx_val: *Value = SSABuilder_getOperandValue(b, ir_node.right);
    let val_val: *Value = SSABuilder_getOperandValue(b, ir_node.value);
    let elem_size: i64 = ir_node.op;

    // 1. Compute byte offset: index * elem_size
    let size_val: *Value = Func_emitConstInt(b.func, elem_size, TYPE_I64);
    SSABuilder_assignReg(b, size_val);
    let offset_val: *Value = Func_emitBinary(b.func, Op.Mul64, idx_val, size_val, TYPE_I64);
    SSABuilder_assignReg(b, offset_val);

    // 2. Add offset to base address
    let ptr_val: *Value = Func_emitBinary(b.func, Op.AddPtr, base_val, offset_val, TYPE_I64);
    SSABuilder_assignReg(b, ptr_val);

    // 3. Store the value
    let store_val: *Value = Func_newValue(b.func, Op.Store, TYPE_VOID);
    Value_addArg2(store_val, ptr_val, val_val);
    return store_val.id;
}

// --- Slice/String Builtins ---

fn SSABuilder_convertMakeString(b: *SSABuilder, ir_node: *IRNode) i64 {
    // @string(ptr, len): left=ptr_expr, right=len_expr (relative IR indices)
    let ptr_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let len_val: *Value = SSABuilder_getOperandValue(b, ir_node.right);
    let make_val: *Value = Func_newValue(b.func, Op.StringMake, TYPE_STRING);
    Value_addArg2(make_val, ptr_val, len_val);
    SSABuilder_assignReg(b, make_val);
    return make_val.id;
}

fn SSABuilder_convertMakeSlice(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Slice creation: left=ptr_expr, right=len_expr (relative IR indices)
    let ptr_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let len_val: *Value = SSABuilder_getOperandValue(b, ir_node.right);
    let make_val: *Value = Func_newValue(b.func, Op.SliceMake, TYPE_I64);
    Value_addArg2(make_val, ptr_val, len_val);
    SSABuilder_assignReg(b, make_val);
    return make_val.id;
}

fn SSABuilder_convertSlicePtr(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Extract pointer from slice: left=slice_expr (relative IR index)
    let slice_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let ptr_val: *Value = Func_newValue(b.func, Op.SlicePtr, TYPE_I64);
    Value_addArg(ptr_val, slice_val);
    SSABuilder_assignReg(b, ptr_val);
    return ptr_val.id;
}

fn SSABuilder_convertSliceLen(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Extract length from slice: left=slice_expr (relative IR index)
    let slice_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let len_val: *Value = Func_newValue(b.func, Op.SliceLen, TYPE_I64);
    Value_addArg(len_val, slice_val);
    SSABuilder_assignReg(b, len_val);
    return len_val.id;
}

// --- Function Call ---

fn SSABuilder_convertCall(b: *SSABuilder, ir_node: *IRNode) i64 {
    let val: *Value = Func_emitCall(b.func,
                                     ir_node.func_name_start,
                                     ir_node.func_name_len,
                                     TYPE_I64);
    // Add arguments
    var arg_idx: i64 = 0;
    while arg_idx < ir_node.args_count {
        // args_start is an index into call_args array
        // call_args contains the actual IR node indices for each argument
        let call_args_slot: *i64 = b.call_args + ir_node.args_start + arg_idx;
        let arg_ir_rel: i64 = call_args_slot.*;  // Relative IR index within function
        let arg_val: *Value = SSABuilder_getOperandValue(b, arg_ir_rel);
        Value_addArg(val, arg_val);
        arg_idx = arg_idx + 1;
    }
    SSABuilder_assignReg(b, val);
    return val.id;
}

// --- Select (Ternary) ---

fn SSABuilder_convertSelect(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Select: left = cond, right = true_val, value = false_val
    let cond_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let true_val: *Value = SSABuilder_getOperandValue(b, ir_node.right);
    let false_val: *Value = SSABuilder_getOperandValue(b, ir_node.value);
    let val: *Value = Func_emitSelect(b.func, cond_val, true_val, false_val, TYPE_I64);
    SSABuilder_assignReg(b, val);
    return val.id;
}

// --- Control Flow ---

fn SSABuilder_convertBranch(b: *SSABuilder, ir_node: *IRNode) {
    // left is relative IR index of condition
    let cond_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let then_block: i64 = ir_node.right;
    let else_block: i64 = ir_node.value;
    Func_emitIf(b.func, cond_val, then_block, else_block);
}

fn SSABuilder_convertJump(b: *SSABuilder, ir_node: *IRNode) {
    let target_block: i64 = ir_node.left;
    Func_emitJump(b.func, target_block);
}

fn SSABuilder_convertReturn(b: *SSABuilder, ir_node: *IRNode) {
    if ir_node.left >= 0 {
        let ret_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
        Func_emitReturn(b.func, ret_val);
    } else {
        // Void return - emit return with no value
        let void_ret: *Value = Func_newValue(b.func, Op.Return, TYPE_VOID);
    }
}

// ============================================================================
// Block Definitions Lookup
// ============================================================================

// Get BlockDefs for a specific SSA block
fn SSABuilder_getBlockDefs(b: *SSABuilder, block_id: i64) *BlockDefs {
    var i: i64 = 0;
    while i < b.all_defs_count {
        let bd: *BlockDefs = b.all_defs + i;
        if bd.block_id == block_id {
            return bd;
        }
        i = i + 1;
    }
    return null;
}

// Copy definitions from one block to another (for control flow merge)
fn SSABuilder_copyDefs(b: *SSABuilder, from_block: i64, to_block: i64) {
    let from: *BlockDefs = SSABuilder_getBlockDefs(b, from_block);
    let to: *BlockDefs = SSABuilder_getBlockDefs(b, to_block);

    if from == null or to == null { return; }

    var i: i64 = 0;
    while i < from.defs_count {
        let def: *VarDef = from.defs + i;
        BlockDefs_set(to, def.var_idx, def.value_id);
        i = i + 1;
    }
}

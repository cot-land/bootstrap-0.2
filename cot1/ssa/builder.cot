// Cot0 SSA Builder - IR to SSA Conversion
// Converts frontend IR to backend SSA form.
//
// Key concepts (from Go):
// - Convert IR nodes to SSA values
// - Track variable→value mapping per block
// - Handle control flow (if, while, return)
// - Create phi nodes at merge points
//
// Reference: ~/learning/go/src/cmd/compile/internal/ssagen/ssa.go
// Reference: bootstrap-0.2/src/frontend/ssa_builder.zig

// NOTE: This file depends on types from func.cot and ir.cot
// These are imported by main.cot via genssa.cot and lower.cot
// We don't import them here to avoid duplicate definitions
// This means builder.cot must be imported LAST in main.cot

// NOTE: Register constants (X0, etc.) are imported via genssa.cot -> arm64.cot -> ../arm64/regs.cot
// No imports needed here - all dependencies come from main.cot's earlier imports

// ============================================================================
// Constants
// ============================================================================

const MAX_VAR_DEFS: i64 = 1024;    // Max variable definitions per block
const MAX_BLOCK_DEFS: i64 = 500;   // Max blocks with definitions

// IR node indices (from lower.cot/ir.cot)
const IR_NULL_NODE: i64 = -1;

// ============================================================================
// IR to SSA Op Mapping (from main.cot)
// Reference: Zig's binaryOpToSSA() in ssa_builder.zig
// ============================================================================

// Map IR binary operation to SSA Op
fn Op_fromIRBinaryOp(ir_op: i64) Op {
    // IRBinaryOp enum values (from ir.cot)
    if ir_op == 0 { return Op.Add64; }     // IRBinaryOp.Add
    if ir_op == 1 { return Op.Sub64; }     // IRBinaryOp.Sub
    if ir_op == 2 { return Op.Mul64; }     // IRBinaryOp.Mul
    if ir_op == 3 { return Op.Div64; }     // IRBinaryOp.Div
    if ir_op == 4 { return Op.Mod64; }     // IRBinaryOp.Mod
    if ir_op == 5 { return Op.Eq64; }      // IRBinaryOp.Eq
    if ir_op == 6 { return Op.Ne64; }      // IRBinaryOp.Ne
    if ir_op == 7 { return Op.Lt64; }      // IRBinaryOp.Lt
    if ir_op == 8 { return Op.Le64; }      // IRBinaryOp.Le
    if ir_op == 9 { return Op.Gt64; }      // IRBinaryOp.Gt
    if ir_op == 10 { return Op.Ge64; }     // IRBinaryOp.Ge
    if ir_op == 11 { return Op.And64; }    // IRBinaryOp.And (logical - use bitwise)
    if ir_op == 12 { return Op.Or64; }     // IRBinaryOp.Or (logical - use bitwise)
    if ir_op == 13 { return Op.And64; }    // IRBinaryOp.BitAnd
    if ir_op == 14 { return Op.Or64; }     // IRBinaryOp.BitOr
    if ir_op == 15 { return Op.Xor64; }    // IRBinaryOp.BitXor
    if ir_op == 16 { return Op.Shl64; }    // IRBinaryOp.Shl
    if ir_op == 17 { return Op.Shr64; }    // IRBinaryOp.Shr
    return Op.Add64;  // Default fallback
}

fn Op_fromIRUnaryOp(ir_op: i64) Op {
    // IR unary op constants from lower.cot: NEG=18, NOT=19, BIT_NOT=20
    if ir_op == 18 { return Op.Neg64; }    // IR_OP_NEG
    if ir_op == 19 { return Op.Not64; }    // IR_OP_NOT
    if ir_op == 20 { return Op.Not64; }    // IR_OP_BIT_NOT
    return Op.Neg64;  // Default fallback
}

// ============================================================================
// Variable Definition Tracking
// ============================================================================

// Single variable → value mapping
struct VarDef {
    var_idx: i64,         // Local variable index
    value_id: i64,        // SSA value ID
}

// Variable definitions for one block
struct BlockDefs {
    block_id: i64,
    defs: *VarDef,        // Array of VarDef
    defs_count: i64,
    defs_cap: i64,
}

fn BlockDefs_init(bd: *BlockDefs, block_id: i64, defs: *VarDef, cap: i64) {
    bd.block_id = block_id;
    bd.defs = defs;
    bd.defs_count = 0;
    bd.defs_cap = cap;
}

// Set variable value (add or update)
fn BlockDefs_set(bd: *BlockDefs, var_idx: i64, value_id: i64) {
    // Check if already exists
    var i: i64 = 0;
    while i < bd.defs_count {
        let def: *VarDef = bd.defs + i;
        if def.var_idx == var_idx {
            def.value_id = value_id;
            return;
        }
        i = i + 1;
    }

    // Add new
    if bd.defs_count >= bd.defs_cap { return; }
    let def: *VarDef = bd.defs + bd.defs_count;
    def.var_idx = var_idx;
    def.value_id = value_id;
    bd.defs_count = bd.defs_count + 1;
}

// Get variable value (or -1 if not found)
fn BlockDefs_get(bd: *BlockDefs, var_idx: i64) i64 {
    var i: i64 = 0;
    while i < bd.defs_count {
        let def: *VarDef = bd.defs + i;
        if def.var_idx == var_idx {
            return def.value_id;
        }
        i = i + 1;
    }
    return INVALID_ID;
}

// ============================================================================
// IR to SSA Block Mapping
// ============================================================================

struct BlockMapping {
    ir_block: i64,        // IR block index
    ssa_block: i64,       // SSA block ID
}

// ============================================================================
// SSA Builder
// ============================================================================

struct SSABuilder {
    // The SSA function being built
    func: *Func,

    // Current block
    current_block: i64,

    // Variable definitions for current block
    current_defs: *BlockDefs,

    // All block definitions (for phi insertion)
    all_defs: *BlockDefs,     // Array of BlockDefs
    all_defs_count: i64,
    all_defs_cap: i64,

    // IR to SSA block mapping
    block_map: *BlockMapping,
    block_map_count: i64,
    block_map_cap: i64,

    // IR node to SSA value mapping (prevents duplicate conversion)
    node_values: *VarDef,     // Reuse VarDef for node→value
    node_values_count: i64,
    node_values_cap: i64,

    // Storage for per-block VarDefs (external)
    var_storage: *VarDef,
    var_storage_used: i64,
    var_storage_cap: i64,

    // === FwdRef Pattern State ===
    // Following Zig ssa_builder.zig: fwd_vars and defvars
    fwd_vars: *VarDef,        // FwdRefs created in current block (var_idx→value_id)
    fwd_vars_count: i64,
    fwd_vars_cap: i64,

    // defvars: per-block variable→value mapping for phi insertion
    // Uses all_defs array (BlockDefs already tracks this)

    // === IR References (set before build) ===
    ir_nodes: *IRNode,        // Global IR nodes array
    ir_nodes_start: i64,      // Start index for this function
    ir_nodes_end: i64,        // End index for this function
    ir_locals: *IRLocal,      // Global IR locals array
    ir_locals_start: i64,     // Start index for this function
    ir_locals_count: i64,     // Number of locals
    source: *u8,              // Source text for function names
    source_len: i64,

    // === Type Registry (for struct checks) ===
    // Following Zig ssa_builder.zig line 49: type_registry: *TypeRegistry
    type_registry: *TypeRegistry,

    // === Register allocation state ===
    // Simple round-robin allocation matching original main.cot behavior
    next_reg: i64,            // Next register to assign (X1-X28)
    max_reg: i64,             // Maximum register (28 = X28)
}

// ============================================================================
// Builder Initialization
// ============================================================================

// Split into two functions to avoid >8 arguments (ARM64 ABI limitation)
fn SSABuilder_init(b: *SSABuilder, f: *Func,
                all_defs: *BlockDefs, all_defs_cap: i64,
                block_map: *BlockMapping, block_map_cap: i64,
                node_values: *VarDef, node_values_cap: i64) {
    b.func = f;
    b.current_block = INVALID_BLOCK;
    b.current_defs = null;

    b.all_defs = all_defs;
    b.all_defs_count = 0;
    b.all_defs_cap = all_defs_cap;

    b.block_map = block_map;
    b.block_map_count = 0;
    b.block_map_cap = block_map_cap;

    b.node_values = node_values;
    b.node_values_count = 0;
    b.node_values_cap = node_values_cap;

    // Initialize remaining fields to defaults
    b.var_storage = null;
    b.var_storage_used = 0;
    b.var_storage_cap = 0;

    // FwdRef pattern state - initialized later via SSABuilder_initFwdVars
    b.fwd_vars = null;
    b.fwd_vars_count = 0;
    b.fwd_vars_cap = 0;

    // IR references (set later via SSABuilder_setIRNodes/Locals/Source)
    b.ir_nodes = null;
    b.ir_nodes_start = 0;
    b.ir_nodes_end = 0;
    b.ir_locals = null;
    b.ir_locals_start = 0;
    b.ir_locals_count = 0;
    b.source = null;
    b.source_len = 0;
    b.type_registry = null;

    // Register allocation - simple round-robin matching original main.cot
    b.next_reg = X1;          // Start at X1 (X0 is reserved for return value)
    b.max_reg = 28;           // Max is X28 (29=FP, 30=LR, 31=SP/XZR)
}

// Second part of init - set var_storage (split for ARM64 ABI)
fn SSABuilder_initStorage(b: *SSABuilder, var_storage: *VarDef, var_storage_cap: i64) {
    b.var_storage = var_storage;
    b.var_storage_used = 0;
    b.var_storage_cap = var_storage_cap;
}

// Set type registry for struct type checks
// Following Zig ssa_builder.zig:49 - type_registry field
fn SSABuilder_setTypeRegistry(b: *SSABuilder, reg: *TypeRegistry) {
    b.type_registry = reg;
}

// Assign a register to a value and increment the counter
// Returns the assigned register
// Note: Skips X16-X18 which are reserved on ARM64 (linker scratch + platform)
fn SSABuilder_assignReg(b: *SSABuilder, v: *Value) i64 {
    // Skip X16, X17, X18 if we're in that range (reserved: linker scratch + platform)
    if b.next_reg >= 16 and b.next_reg <= 18 {
        b.next_reg = 19;  // Skip to X19
    }

    let reg: i64 = b.next_reg;
    v.reg = reg;

    // Advance to next allocatable register
    b.next_reg = b.next_reg + 1;
    // Skip X16, X17, X18 if we wrap into that range
    if b.next_reg == 16 {
        b.next_reg = 19;  // Skip to X19
    }
    if b.next_reg > b.max_reg {
        b.next_reg = X1;  // Wrap around
    }
    return reg;
}

// Set IR references before calling build()
// Matches Zig's SSABuilder.init() which takes ir_func
// Set IR nodes for the SSA builder
fn SSABuilder_setIRNodes(b: *SSABuilder,
                    ir_nodes: *IRNode, ir_nodes_start: i64, ir_nodes_count: i64) {
    b.ir_nodes = ir_nodes;
    b.ir_nodes_start = ir_nodes_start;
    b.ir_nodes_end = ir_nodes_start + ir_nodes_count;
}

// Set IR locals for the SSA builder
fn SSABuilder_setIRLocals(b: *SSABuilder,
                    ir_locals: *IRLocal, ir_locals_start: i64, ir_locals_count: i64) {
    b.ir_locals = ir_locals;
    b.ir_locals_start = ir_locals_start;
    b.ir_locals_count = ir_locals_count;
}

// Set source for the SSA builder
fn SSABuilder_setSource(b: *SSABuilder, source: *u8, source_len: i64) {
    b.source = source;
    b.source_len = source_len;
}

// Allocate storage for a block's VarDefs
fn SSABuilder_allocDefs(b: *SSABuilder, count: i64) *VarDef {
    if b.var_storage_used + count > b.var_storage_cap {
        return b.var_storage;  // Return start as fallback
    }
    let result: *VarDef = b.var_storage + b.var_storage_used;
    b.var_storage_used = b.var_storage_used + count;
    return result;
}

// ============================================================================
// Block Management
// ============================================================================

// Create a new SSA block and set it as current
fn SSABuilder_newBlock(b: *SSABuilder, kind: BlockKind) i64 {
    let block_id: i64 = Func_newBlock(b.func, kind);
    SSABuilder_setBlock(b, block_id);
    return block_id;
}

// Get current block being built
// Reference: Zig's SSABuilder.currentBlock()
fn SSABuilder_currentBlock(b: *SSABuilder) i64 {
    return b.current_block;
}

// Set current block
fn SSABuilder_setBlock(b: *SSABuilder, block_id: i64) {
    b.current_block = block_id;
    Func_setBlock(b.func, block_id);

    // Create BlockDefs for this block
    if b.all_defs_count < b.all_defs_cap {
        let bd: *BlockDefs = b.all_defs + b.all_defs_count;
        let storage: *VarDef = SSABuilder_allocDefs(b, MAX_VAR_DEFS);
        BlockDefs_init(bd, block_id, storage, MAX_VAR_DEFS);
        b.current_defs = bd;
        b.all_defs_count = b.all_defs_count + 1;
    }
}

// Map IR block to SSA block
fn SSABuilder_mapBlock(b: *SSABuilder, ir_block: i64, ssa_block: i64) {
    if b.block_map_count >= b.block_map_cap { return; }
    let m: *BlockMapping = b.block_map + b.block_map_count;
    m.ir_block = ir_block;
    m.ssa_block = ssa_block;
    b.block_map_count = b.block_map_count + 1;
}

// Get SSA block for IR block (or -1)
fn SSABuilder_getSSABlock(b: *SSABuilder, ir_block: i64) i64 {
    var i: i64 = 0;
    while i < b.block_map_count {
        let m: *BlockMapping = b.block_map + i;
        if m.ir_block == ir_block {
            return m.ssa_block;
        }
        i = i + 1;
    }
    return INVALID_BLOCK;
}

// ============================================================================
// Variable Tracking
// ============================================================================

// Set variable value in current block
fn SSABuilder_setVar(b: *SSABuilder, var_idx: i64, value_id: i64) {
    if b.current_defs != null {
        BlockDefs_set(b.current_defs, var_idx, value_id);
    }
}

// Get variable value from current block (or -1)
fn SSABuilder_getVar(b: *SSABuilder, var_idx: i64) i64 {
    if b.current_defs != null {
        return BlockDefs_get(b.current_defs, var_idx);
    }
    return INVALID_ID;
}

// ============================================================================
// FwdRef Pattern - Go's Iterative Phi Insertion
// Reference: Zig ssa_builder.zig:354-381 (variable) and 1642-1819 (insertPhis)
// ============================================================================

// Initialize fwd_vars storage
fn SSABuilder_initFwdVars(b: *SSABuilder, storage: *VarDef, cap: i64) {
    b.fwd_vars = storage;
    b.fwd_vars_count = 0;
    b.fwd_vars_cap = cap;
}

// Clear fwd_vars for a new block
fn SSABuilder_clearFwdVars(b: *SSABuilder) {
    b.fwd_vars_count = 0;
}

// Get cached FwdRef for variable in current block (or INVALID_ID)
fn SSABuilder_getFwdVar(b: *SSABuilder, var_idx: i64) i64 {
    var i: i64 = 0;
    while i < b.fwd_vars_count {
        let fv: *VarDef = b.fwd_vars + i;
        if fv.var_idx == var_idx {
            return fv.value_id;
        }
        i = i + 1;
    }
    return INVALID_ID;
}

// Cache FwdRef for variable in current block
fn SSABuilder_setFwdVar(b: *SSABuilder, var_idx: i64, value_id: i64) {
    if b.fwd_vars_count >= b.fwd_vars_cap { return; }
    let fv: *VarDef = b.fwd_vars + b.fwd_vars_count;
    fv.var_idx = var_idx;
    fv.value_id = value_id;
    b.fwd_vars_count = b.fwd_vars_count + 1;
}

// Read current value of a variable - creates FwdRef if needed.
// This is the KEY method that implements the FwdRef pattern.
// Reference: Zig ssa_builder.zig:354-381
fn SSABuilder_variable(b: *SSABuilder, local_idx: i64, type_idx: i64) *Value {
    // 1. Check current block's definitions
    let val_id: i64 = SSABuilder_getVar(b, local_idx);
    if val_id != INVALID_ID {
        return Func_getValue(b.func, val_id);
    }

    // 2. Check if we already created a FwdRef for this
    let fwd_id: i64 = SSABuilder_getFwdVar(b, local_idx);
    if fwd_id != INVALID_ID {
        return Func_getValue(b.func, fwd_id);
    }

    // 3. Create forward reference - will be resolved later by insertPhis
    let fwd_ref: *Value = Func_newValue(b.func, Op.FwdRef, type_idx);
    fwd_ref.aux_int = local_idx;  // Remember which variable

    // 4. Cache to coalesce multiple uses in same block
    SSABuilder_setFwdVar(b, local_idx, fwd_ref.id);

    return fwd_ref;
}

// Helper: ensure defvars[block_id][local_idx] = value
// Reference: Zig ssa_builder.zig:1759-1770
fn SSABuilder_ensureDefvar(b: *SSABuilder, block_id: i64, local_idx: i64, value_id: i64) {
    let bd: *BlockDefs = SSABuilder_getBlockDefs(b, block_id);
    if bd == null { return; }

    // Only set if not already defined (don't override real definitions with FwdRefs)
    let existing: i64 = BlockDefs_get(bd, local_idx);
    if existing == INVALID_ID {
        BlockDefs_set(bd, local_idx, value_id);
    }
}

// Look up the value of a variable at the end of a block.
// If not found and we hit a block with multiple predecessors, creates a new FwdRef.
// Reference: Zig ssa_builder.zig:1775-1819
// Returns value_id or creates a new FwdRef and returns its id
fn SSABuilder_lookupVarOutgoing(b: *SSABuilder, block_id: i64, local_idx: i64, type_idx: i64,
                                fwd_refs: *I64List) i64 {
    var cur_id: i64 = block_id;

    // Walk backwards through single-predecessor chains
    while true {
        // Check if block defines this variable
        let bd: *BlockDefs = SSABuilder_getBlockDefs(b, cur_id);
        if bd != null {
            let val_id: i64 = BlockDefs_get(bd, local_idx);
            if val_id != INVALID_ID {
                return val_id;
            }
        }

        // Get block to check predecessors
        let blk: *Block = Func_getBlock(b.func, cur_id);
        if blk == null { break; }

        // Single predecessor? Keep walking back
        if blk.preds.count == 1 {
            cur_id = Block_getPred(blk, 0);
            continue;
        }

        // Multiple predecessors or no predecessors (entry) - stop walking
        break;
    }

    // Create a new FwdRef for this variable in the current block
    let new_fwd: *Value = Func_newValue(b.func, Op.FwdRef, type_idx);
    new_fwd.aux_int = local_idx;

    // Store in defvars so we don't create duplicate
    SSABuilder_ensureDefvar(b, cur_id, local_idx, new_fwd.id);

    // CRITICAL: Add to work list so it gets processed
    i64list_append(fwd_refs, new_fwd.id);

    return new_fwd.id;
}

// Reorder values in each block to ensure phis come first.
// Reference: Zig ssa_builder.zig:1732-1757
fn SSABuilder_reorderPhis(b: *SSABuilder) {
    var block_idx: i64 = 0;
    while block_idx < b.func.blocks_count {
        let blk: *Block = Func_getBlock(b.func, block_idx);

        // Count phis and non-phis
        var phi_count: i64 = 0;
        var i: i64 = 0;
        while i < blk.values_count {
            let v: *Value = Func_getValue(b.func, blk.values_start + i);
            if v.op == Op.Phi {
                phi_count = phi_count + 1;
            }
            i = i + 1;
        }

        // If all values are phis or no phis, nothing to do
        if phi_count == 0 or phi_count == blk.values_count {
            block_idx = block_idx + 1;
            continue;
        }

        // Need to reorder: use dynamic list
        var temp_ids: I64List = undefined;
        i64list_init(&temp_ids);

        // First pass: collect phis
        i = 0;
        while i < blk.values_count {
            let v: *Value = Func_getValue(b.func, blk.values_start + i);
            if v.op == Op.Phi {
                i64list_append(&temp_ids, blk.values_start + i);
            }
            i = i + 1;
        }

        // Second pass: collect non-phis
        i = 0;
        while i < blk.values_count {
            let v: *Value = Func_getValue(b.func, blk.values_start + i);
            if v.op != Op.Phi {
                i64list_append(&temp_ids, blk.values_start + i);
            }
            i = i + 1;
        }

        // Note: The values themselves don't move, just their IDs
        // This is a simplification - real implementation would update the block's value list
        // For now, we rely on codegen handling phis first regardless of order

        i64list_deinit(&temp_ids);
        block_idx = block_idx + 1;
    }
}

// Insert phi nodes for all forward references using Go's iterative algorithm.
// Called after all blocks have been walked.
// Reference: Zig ssa_builder.zig:1642-1727
fn SSABuilder_insertPhis(b: *SSABuilder) {
    // Work list of FwdRef value IDs to process (dynamic list)
    var fwd_refs: I64List = undefined;
    i64list_init(&fwd_refs);

    // Collect initial FwdRef values and treat them as definitions
    var block_idx: i64 = 0;
    while block_idx < b.func.blocks_count {
        let blk: *Block = Func_getBlock(b.func, block_idx);
        var i: i64 = 0;
        while i < blk.values_count {
            let val_id: i64 = blk.values_start + i;
            let v: *Value = Func_getValue(b.func, val_id);
            if v.op == Op.FwdRef {
                // Add to work list
                i64list_append(&fwd_refs, val_id);
                // Treat FwdRefs as definitions in their block
                let local_idx: i64 = v.aux_int;
                SSABuilder_ensureDefvar(b, block_idx, local_idx, val_id);
            }
            i = i + 1;
        }
        block_idx = block_idx + 1;
    }

    // Temporary storage for incoming values (dynamic list)
    var args: I64List = undefined;
    i64list_init(&args);

    // Process FwdRefs iteratively until the work list is empty
    while fwd_refs.count > 0 {
        // Pop from work list
        let fwd_id: i64 = i64list_pop(&fwd_refs);
        let fwd: *Value = Func_getValue(b.func, fwd_id);

        // Find which block this FwdRef is in
        var fwd_block_id: i64 = -1;
        block_idx = 0;
        while block_idx < b.func.blocks_count {
            let blk: *Block = Func_getBlock(b.func, block_idx);
            var i: i64 = 0;
            while i < blk.values_count {
                if blk.values_start + i == fwd_id {
                    fwd_block_id = block_idx;
                    break;
                }
                i = i + 1;
            }
            if fwd_block_id >= 0 { break; }
            block_idx = block_idx + 1;
        }

        if fwd_block_id < 0 { continue; }

        let blk: *Block = Func_getBlock(b.func, fwd_block_id);

        // Entry block should never have FwdRef (variable used before defined)
        if fwd_block_id == 0 {
            continue;
        }

        // No predecessors? Skip (unreachable block)
        if blk.preds.count == 0 {
            continue;
        }

        let local_idx: i64 = fwd.aux_int;

        // Find variable value on each predecessor
        i64list_clear(&args);
        var pred_idx: i64 = 0;
        while pred_idx < blk.preds.count {
            let pred_block_id: i64 = Block_getPred(blk, pred_idx);
            let val_id: i64 = SSABuilder_lookupVarOutgoing(b, pred_block_id, local_idx, fwd.type_idx,
                                                           &fwd_refs);
            i64list_append(&args, val_id);
            pred_idx = pred_idx + 1;
        }

        // Decide if we need a phi or not
        // We need a phi if there are two different args (excluding self-references)
        var witness: i64 = INVALID_ID;
        var need_phi: bool = false;

        var ai: i64 = 0;
        while ai < args.count {
            let a: i64 = i64list_get(&args, ai);
            if a == fwd_id {
                ai = ai + 1;
                continue;  // Self-reference, skip
            }
            if witness == INVALID_ID {
                witness = a;  // First witness
            } else if a != witness {
                need_phi = true;  // Two different values, need phi
                break;
            }
            ai = ai + 1;
        }

        if need_phi {
            // Convert to Phi with all incoming values
            fwd.op = Op.Phi;
            ai = 0;
            while ai < args.count {
                let arg_val: *Value = Func_getValue(b.func, i64list_get(&args, ai));
                Value_addArg(fwd, arg_val);
                ai = ai + 1;
            }
        } else if witness != INVALID_ID {
            // One witness (excluding self). Make it a copy.
            fwd.op = Op.Copy;
            let witness_val: *Value = Func_getValue(b.func, witness);
            Value_addArg(fwd, witness_val);
        }
        // If no witness at all (all self-references), leave as FwdRef
        // This is an error but will be caught later
    }

    // Clean up dynamic lists
    i64list_deinit(&args);
    i64list_deinit(&fwd_refs);

    // Reorder all blocks to ensure phis are at the start
    SSABuilder_reorderPhis(b);
}

// ============================================================================
// Node Value Caching
// ============================================================================

// Cache IR node → SSA value mapping
fn SSABuilder_cacheNode(b: *SSABuilder, node_idx: i64, value_id: i64) {
    if b.node_values_count >= b.node_values_cap { return; }
    let nv: *VarDef = b.node_values + b.node_values_count;
    nv.var_idx = node_idx;
    nv.value_id = value_id;
    b.node_values_count = b.node_values_count + 1;
}

// Get cached SSA value for IR node (or -1)
fn SSABuilder_getCached(b: *SSABuilder, node_idx: i64) i64 {
    var i: i64 = 0;
    while i < b.node_values_count {
        let nv: *VarDef = b.node_values + i;
        if nv.var_idx == node_idx {
            return nv.value_id;
        }
        i = i + 1;
    }
    return INVALID_ID;
}

// ============================================================================
// Value Emission (wrappers around func_* functions)
// ============================================================================

// Emit constant integer
fn SSABuilder_emitConstInt(b: *SSABuilder, value: i64, type_idx: i64) *Value {
    return Func_emitConstInt(b.func, value, type_idx);
}

// Emit constant boolean
fn SSABuilder_emitConstBool(b: *SSABuilder, value: bool) *Value {
    return Func_emitConstBool(b.func, value);
}

// Emit binary operation
fn SSABuilder_emitBinary(b: *SSABuilder, op: Op, left: *Value, right: *Value, type_idx: i64) *Value {
    return Func_emitBinary(b.func, op, left, right, type_idx);
}

// Emit unary operation
fn SSABuilder_emitUnary(b: *SSABuilder, op: Op, operand: *Value, type_idx: i64) *Value {
    return Func_emitUnary(b.func, op, operand, type_idx);
}

// Emit load from local
fn SSABuilder_emitLoadLocal(b: *SSABuilder, local_idx: i64) *Value {
    return Func_emitLoadLocal(b.func, local_idx);
}

// Emit store to local
fn SSABuilder_emitStoreLocal(b: *SSABuilder, local_idx: i64, val: *Value) *Value {
    return Func_emitStoreLocal(b.func, local_idx, val);
}

// Emit return
fn SSABuilder_emitReturn(b: *SSABuilder, val: *Value) *Value {
    return Func_emitReturn(b.func, val);
}

// Emit stack allocation (alloca)
// Reference: Zig's SSABuilder.buildAlloca()
// Returns pointer to allocated stack space
fn SSABuilder_emitAlloca(b: *SSABuilder, size: i64, align: i64, type_idx: i64) *Value {
    // In cot0, we use LocalAddr to get address of a local variable
    // Add a new local to the function and return its address
    let local_idx: i64 = Func_addLocal(b.func, 0, 0, type_idx, true);
    let local: *Local = Func_getLocal(b.func, local_idx);
    local.size = size;
    local.align = align;

    let addr: *Value = Func_newValue(b.func, Op.LocalAddr, type_idx);
    addr.aux_int = local_idx;
    return addr;
}

// Emit type cast/conversion
// Reference: Zig's SSABuilder.buildCast()
// Selects appropriate conversion op based on source/dest size
fn SSABuilder_emitCast(b: *SSABuilder, val: *Value, src_size: i64, dst_size: i64, is_signed: bool, dst_type: i64) *Value {
    // Same size - no conversion needed
    if src_size == dst_size {
        return val;
    }

    // Extension (smaller to larger)
    if src_size < dst_size {
        var op: Op = Op.ZeroExt8to64;  // Default
        if is_signed {
            if src_size == 1 {
                op = Op.SignExt8to64;
            } else if src_size == 2 {
                op = Op.SignExt16to64;
            } else if src_size == 4 {
                op = Op.SignExt32to64;
            }
        } else {
            if src_size == 1 {
                op = Op.ZeroExt8to64;
            } else if src_size == 2 {
                op = Op.ZeroExt16to64;
            } else if src_size == 4 {
                op = Op.ZeroExt32to64;
            }
        }
        return Func_emitUnary(b.func, op, val, dst_type);
    }

    // Truncation (larger to smaller)
    var op: Op = Op.Trunc64to8;  // Default
    if dst_size == 1 {
        op = Op.Trunc64to8;
    } else if dst_size == 2 {
        op = Op.Trunc64to16;
    } else if dst_size == 4 {
        op = Op.Trunc64to32;
    }
    return Func_emitUnary(b.func, op, val, dst_type);
}

// ============================================================================
// Control Flow
// ============================================================================

// Emit conditional branch
fn SSABuilder_emitIf(b: *SSABuilder, cond: *Value, then_block: i64, else_block: i64) {
    Func_emitIf(b.func, cond, then_block, else_block);
}

// Emit unconditional jump
fn SSABuilder_emitJump(b: *SSABuilder, target: i64) {
    Func_emitJump(b.func, target);
}

// Mark current block as return
fn SSABuilder_emitReturn_block(b: *SSABuilder) {
    Func_emitReturnBlock(b.func);
}

// ============================================================================
// Phi Node Creation
// ============================================================================

// Create phi node for variable
fn SSABuilder_emitPhi(b: *SSABuilder, type_idx: i64) *Value {
    let v: *Value = Func_newValue(b.func, Op.Phi, type_idx);
    return v;
}

// Add argument to phi node from predecessor block
fn SSABuilder_phiAddArg(b: *SSABuilder, phi: *Value, val: *Value, pred_block: i64) {
    // For simplicity, store args directly
    // In full implementation, args are ordered by predecessor
    Value_addArg(phi, val);
}

// ============================================================================
// Complete IR to SSA Conversion
// Matches Zig's SSABuilder.build() in src/frontend/ssa_builder.zig
// ============================================================================

// Build SSA from IR function
// Returns 0 on success, error code otherwise
// Reference: Zig's SSABuilder.build() at line 383
fn SSABuilder_build(b: *SSABuilder) i64 {
    // Step 1: Find max block_id in IR nodes to know how many blocks we need
    var max_block_id: i64 = 0;
    var ir_idx: i64 = b.ir_nodes_start;
    while ir_idx < b.ir_nodes_end {
        let ir_node: *IRNode = b.ir_nodes + ir_idx;
        if ir_node.block_id > max_block_id {
            max_block_id = ir_node.block_id;
        }
        ir_idx = ir_idx + 1;
    }

    // Step 2: Create SSA blocks
    // Entry block (block 0)
    let entry: i64 = Func_newEntryBlock(b.func);
    SSABuilder_setBlock(b, entry);
    SSABuilder_mapBlock(b, 0, entry);

    // Create additional blocks (1 through max_block_id)
    var block_idx: i64 = 1;
    while block_idx <= max_block_id {
        let new_block: i64 = Func_newBlock(b.func, BlockKind.Plain);
        SSABuilder_mapBlock(b, block_idx, new_block);
        block_idx = block_idx + 1;
    }

    // Step 3: Register locals (params first, then regular locals)
    // Copy from IR locals to SSA locals
    var local_idx: i64 = b.ir_locals_start;
    let locals_end: i64 = b.ir_locals_start + b.ir_locals_count;
    var ssa_local_idx: i64 = 0;
    while local_idx < locals_end {
        let ir_local: *IRLocal = b.ir_locals + local_idx;
        if ir_local.is_param {
            Func_addParam(b.func, ir_local.name_start, ir_local.name_len,
                          ir_local.type_idx);
        } else {
            Func_addLocal(b.func, ir_local.name_start, ir_local.name_len,
                          ir_local.type_idx, ir_local.is_mutable);
        }
        // Copy size from IR local to SSA local
        let ssa_local: *Local = Func_getLocal(b.func, ssa_local_idx);
        ssa_local.size = ir_local.size;
        local_idx = local_idx + 1;
        ssa_local_idx = ssa_local_idx + 1;
    }
    // Step 4: Handle parameters with 3-phase approach (BUG-056 fix)
    // Following Zig's ssa_builder.zig lines 111-242
    //
    // CRITICAL: Emit ALL Arg ops FIRST, then stores.
    // This ensures ABI registers (x0-x7) aren't overwritten before being captured.
    //
    // Phase 1: Create ALL Arg ops (captures all ABI register values)
    // Phase 2: Create slice_make ops for string params (not yet implemented)
    // Phase 3: Store all params to stack slots
    //
    // String/slice params take TWO registers (ptr + len), so we track the
    // physical register index separately from the logical param index.

    // Dynamic lists to track params across phases (store value IDs, not pointers)
    var arg_value_ids: I64List = undefined;
    var arg_local_indices: I64List = undefined;
    i64list_init(&arg_value_ids);
    i64list_init(&arg_local_indices);

    // Phase 1: Create ALL Arg ops first
    // phys_reg_idx tracks the physical ABI register (x0, x1, ..., or stack slot)
    var phys_reg_idx: i64 = 0;
    var param_local_idx: i64 = 0;
    while param_local_idx < b.func.locals_count {
        let param_local: *Local = Func_getLocal(b.func, param_local_idx);
        if param_local.is_param {
            // Create Arg value for this parameter
            // ARM64 ABI: x0-x7 for first 8 args, stack for rest
            let arg_val: *Value = Func_newValue(b.func, Op.Arg, TYPE_I64);
            arg_val.aux_int = phys_reg_idx;  // Physical register index, not logical param index
            if phys_reg_idx < 8 {
                // Register argument - pre-assign to X0-X7
                arg_val.reg = X0 + phys_reg_idx;
            }
            // Stack arguments (phys_reg_idx >= 8) have reg=-1, will be assigned by regalloc

            // Save for Phase 3
            i64list_append(&arg_value_ids, arg_val.id);
            i64list_append(&arg_local_indices, param_local_idx);

            phys_reg_idx = phys_reg_idx + 1;
            // Note: For string params (future), increment phys_reg_idx twice
        }
        param_local_idx = param_local_idx + 1;
    }

    // Phase 2: Create slice_make ops for string params
    // (Not implemented yet - cot0 doesn't have string params)

    // Phase 3: Store all params to stack slots
    // This happens AFTER all Arg ops are created
    var i: i64 = 0;
    while i < arg_value_ids.count {
        let arg_val: *Value = Func_getValue(b.func, i64list_get(&arg_value_ids, i));
        let local_idx: i64 = i64list_get(&arg_local_indices, i);
        let param_local: *Local = Func_getLocal(b.func, local_idx);

        // Create LocalAddr value for the stack slot
        let addr_val: *Value = Func_newValue(b.func, Op.LocalAddr, TYPE_I64);
        addr_val.aux_int = local_idx;

        // BUG-019 FIX: >16B struct types are passed by reference
        // Following Zig ssa_builder.zig lines 222-238
        // param_val is a POINTER to source, use OpMove to copy
        var is_large_struct: bool = false;
        var type_size: i64 = 8;
        if b.type_registry != null {
            type_size = TypeRegistry_sizeof(b.type_registry, param_local.type_idx);
            let is_struct: bool = TypeInfo_isStruct(b.type_registry, param_local.type_idx);
            if is_struct and type_size > 16 {
                is_large_struct = true;
            }
        }

        if is_large_struct {
            // OpMove: copy from arg_val (source ptr) to addr_val (dest)
            let move_val: *Value = Func_newValue(b.func, Op.Move, TYPE_VOID);
            move_val.aux_int = type_size;
            Value_addArg2(move_val, addr_val, arg_val);
        } else {
            // Store Arg to stack slot
            let store_val: *Value = Func_newValue(b.func, Op.Store, TYPE_VOID);
            Value_addArg2(store_val, addr_val, arg_val);
        }

        i = i + 1;
    }
    i64list_deinit(&arg_value_ids);
    i64list_deinit(&arg_local_indices);

    // Step 5: Convert IR nodes to SSA
    // Track current IR block for block transitions
    var current_ir_block: i64 = 0;
    ir_idx = b.ir_nodes_start;
    while ir_idx < b.ir_nodes_end {
        let ir_node: *IRNode = b.ir_nodes + ir_idx;

        // Handle block transitions
        if ir_node.block_id != current_ir_block {
            current_ir_block = ir_node.block_id;
            let ssa_block: i64 = SSABuilder_getSSABlock(b, current_ir_block);
            if ssa_block >= 0 {
                SSABuilder_setBlock(b, ssa_block);
            }
        }

        // Convert this node
        SSABuilder_convertNode(b, ir_node, ir_idx);

        ir_idx = ir_idx + 1;
    }

    // Step 6: Insert phi nodes for forward references
    // Reference: Zig ssa_builder.zig:455
    SSABuilder_insertPhis(b);

    // Step 7: Emit return block
    Func_emitReturnBlock(b.func);

    return 0;
}

// Convert a single IR node to SSA value(s)
// Matches Zig's SSABuilder.convertNode() at line 470
// Returns the SSA value ID, or -1 for control flow nodes
fn SSABuilder_convertNode(b: *SSABuilder, ir_node: *IRNode, ir_idx: i64) i64 {
    // Check if already converted (using node_values cache)
    let cached: i64 = SSABuilder_getCached(b, ir_idx);
    if cached != INVALID_ID {
        return cached;
    }

    // Dispatch based on node kind
    var result_id: i64 = INVALID_ID;

    if ir_node.kind == IRNodeKind.ConstInt {
        result_id = SSABuilder_convertConstInt(b, ir_node);
    } else if ir_node.kind == IRNodeKind.ConstString {
        result_id = SSABuilder_convertConstString(b, ir_node);
    } else if ir_node.kind == IRNodeKind.ConstBool {
        result_id = SSABuilder_convertConstBool(b, ir_node);
    } else if ir_node.kind == IRNodeKind.Binary {
        result_id = SSABuilder_convertBinary(b, ir_node);
    } else if ir_node.kind == IRNodeKind.Unary {
        result_id = SSABuilder_convertUnary(b, ir_node);
    } else if ir_node.kind == IRNodeKind.LoadLocal {
        result_id = SSABuilder_convertLoadLocal(b, ir_node);
    } else if ir_node.kind == IRNodeKind.StoreLocal {
        result_id = SSABuilder_convertStoreLocal(b, ir_node);
    } else if ir_node.kind == IRNodeKind.AddrLocal {
        result_id = SSABuilder_convertAddrLocal(b, ir_node);
    } else if ir_node.kind == IRNodeKind.LoadGlobal {
        result_id = SSABuilder_convertLoadGlobal(b, ir_node);
    } else if ir_node.kind == IRNodeKind.StoreGlobal {
        result_id = SSABuilder_convertStoreGlobal(b, ir_node);
    } else if ir_node.kind == IRNodeKind.AddrGlobal {
        result_id = SSABuilder_convertAddrGlobal(b, ir_node);
    } else if ir_node.kind == IRNodeKind.FuncAddr {
        result_id = SSABuilder_convertFuncAddr(b, ir_node);
    } else if ir_node.kind == IRNodeKind.Load {
        result_id = SSABuilder_convertLoad(b, ir_node);
    } else if ir_node.kind == IRNodeKind.Store {
        result_id = SSABuilder_convertStore(b, ir_node);
    } else if ir_node.kind == IRNodeKind.FieldLocal {
        result_id = SSABuilder_convertFieldLocal(b, ir_node);
    } else if ir_node.kind == IRNodeKind.FieldValue {
        result_id = SSABuilder_convertFieldValue(b, ir_node);
    } else if ir_node.kind == IRNodeKind.StoreFieldLocal {
        result_id = SSABuilder_convertStoreFieldLocal(b, ir_node);
    } else if ir_node.kind == IRNodeKind.StoreField {
        result_id = SSABuilder_convertStoreField(b, ir_node);
    } else if ir_node.kind == IRNodeKind.IndexLocal {
        result_id = SSABuilder_convertIndexLocal(b, ir_node);
    } else if ir_node.kind == IRNodeKind.IndexValue {
        result_id = SSABuilder_convertIndexValue(b, ir_node);
    } else if ir_node.kind == IRNodeKind.StoreIndexLocal {
        result_id = SSABuilder_convertStoreIndexLocal(b, ir_node);
    } else if ir_node.kind == IRNodeKind.StoreIndexValue {
        result_id = SSABuilder_convertStoreIndexValue(b, ir_node);
    } else if ir_node.kind == IRNodeKind.MakeString {
        result_id = SSABuilder_convertMakeString(b, ir_node);
    } else if ir_node.kind == IRNodeKind.MakeSlice {
        result_id = SSABuilder_convertMakeSlice(b, ir_node);
    } else if ir_node.kind == IRNodeKind.SlicePtr {
        result_id = SSABuilder_convertSlicePtr(b, ir_node);
    } else if ir_node.kind == IRNodeKind.SliceLen {
        result_id = SSABuilder_convertSliceLen(b, ir_node);
    } else if ir_node.kind == IRNodeKind.Call {
        result_id = SSABuilder_convertCall(b, ir_node);
    } else if ir_node.kind == IRNodeKind.CallIndirect {
        result_id = SSABuilder_convertCallIndirect(b, ir_node);
    } else if ir_node.kind == IRNodeKind.StrConcat {
        result_id = SSABuilder_convertStrConcat(b, ir_node);
    } else if ir_node.kind == IRNodeKind.Select {
        result_id = SSABuilder_convertSelect(b, ir_node);
    } else if ir_node.kind == IRNodeKind.Branch {
        SSABuilder_convertBranch(b, ir_node);
        result_id = INVALID_ID;
    } else if ir_node.kind == IRNodeKind.Jump {
        SSABuilder_convertJump(b, ir_node);
        result_id = INVALID_ID;
    } else if ir_node.kind == IRNodeKind.Return {
        SSABuilder_convertReturn(b, ir_node);
        result_id = INVALID_ID;
    }

    // Cache the result and set source position for debug info
    if result_id != INVALID_ID {
        SSABuilder_cacheNode(b, ir_idx, result_id);
        // Copy source position from IR node to SSA value for DWARF line tables
        let result_val: *Value = Func_getValue(b.func, result_id);
        result_val.pos = ir_node.pos;
    }

    return result_id;
}

// ============================================================================
// IR Node Converters
// Each function converts a specific IR node kind to SSA values
// Reference: Zig's SSABuilder.convertNode() and main.cot's conversion loop
// ============================================================================

// Helper: Get SSA value by ID
fn SSABuilder_getValue(b: *SSABuilder, value_id: i64) *Value {
    return Func_getValue(b.func, value_id);
}

// Helper: Get cached SSA value ID for an IR node, computing absolute index
fn SSABuilder_getOperandValue(b: *SSABuilder, relative_ir_idx: i64) *Value {
    let abs_idx: i64 = b.ir_nodes_start + relative_ir_idx;
    let value_id: i64 = SSABuilder_getCached(b, abs_idx);
    return Func_getValue(b.func, value_id);
}

// --- Constants ---

fn SSABuilder_convertConstInt(b: *SSABuilder, ir_node: *IRNode) i64 {
    let val: *Value = Func_emitConstInt(b.func, ir_node.value, TYPE_I64);
    SSABuilder_assignReg(b, val);
    return val.id;
}

fn SSABuilder_convertConstString(b: *SSABuilder, ir_node: *IRNode) i64 {
    // String literal: left=str_start, right=str_len in source
    let val: *Value = Func_emitConstString(b.func, ir_node.left, ir_node.right);
    SSABuilder_assignReg(b, val);
    return val.id;
}

fn SSABuilder_convertConstBool(b: *SSABuilder, ir_node: *IRNode) i64 {
    let val: *Value = Func_emitConstBool(b.func, ir_node.value != 0);
    SSABuilder_assignReg(b, val);
    return val.id;
}

// --- Binary/Unary Operations ---

fn SSABuilder_convertBinary(b: *SSABuilder, ir_node: *IRNode) i64 {
    // left and right are relative IR indices
    let left_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let right_val: *Value = SSABuilder_getOperandValue(b, ir_node.right);
    let ssa_op: Op = Op_fromIRBinaryOp(ir_node.op);
    let val: *Value = Func_emitBinary(b.func, ssa_op, left_val, right_val, TYPE_I64);
    SSABuilder_assignReg(b, val);
    return val.id;
}

fn SSABuilder_convertUnary(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Unary op: left is operand (relative IR index), op is the operator
    let operand_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let ssa_op: Op = Op_fromIRUnaryOp(ir_node.op);
    let val: *Value = Func_newValue(b.func, ssa_op, TYPE_I64);
    Value_addArg(val, operand_val);
    SSABuilder_assignReg(b, val);
    return val.id;
}

// --- Local Variable Access ---

fn SSABuilder_convertLoadLocal(b: *SSABuilder, ir_node: *IRNode) i64 {
    let loc_idx: i64 = ir_node.left;
    let load_val: *Value = Func_emitLoadLocal(b.func, loc_idx);
    SSABuilder_assignReg(b, load_val);
    return load_val.id;
}

fn SSABuilder_convertStoreLocal(b: *SSABuilder, ir_node: *IRNode) i64 {
    let loc_idx: i64 = ir_node.left;
    // right is relative IR index of value to store
    let value_val: *Value = SSABuilder_getOperandValue(b, ir_node.right);

    // BUG-019 FIX: For struct types, use Op.Move to copy the data
    // Following Zig ssa_builder.zig:228-233:
    //   const is_large_struct = (local_type_info == .struct_type) and (type_size > 16);
    //   if (is_large_struct) { const move_val = try func.newValue(.move, ...); }
    //
    // When the value is an address of a struct (from index_value, field_value, etc.),
    // we need to copy the struct data to the local, not just store the address.
    let local: *Local = Func_getLocal(b.func, loc_idx);
    var is_struct: bool = false;
    var struct_size: i64 = 0;
    if b.type_registry != null and local.type_idx > 0 {
        let local_type: *Type = TypeRegistry_get(b.type_registry, local.type_idx);
        if local_type.kind == TypeKind.Struct {
            is_struct = true;
            struct_size = local.size;
        }
    }

    if is_struct and struct_size > 8 {
        // Struct type: emit Op.Move to copy data from source to dest
        // dest = address of local
        let dest_addr: *Value = Func_newValue(b.func, Op.LocalAddr, TYPE_I64);
        dest_addr.aux_int = loc_idx;
        SSABuilder_assignReg(b, dest_addr);

        // source = value_val (which should be an address for struct types)
        // Move: (dest, source) with aux_int = size
        let move_val: *Value = Func_newValue(b.func, Op.Move, TYPE_VOID);
        move_val.aux_int = struct_size;
        Value_addArg2(move_val, dest_addr, value_val);
        return move_val.id;
    }

    // Non-struct: use normal store
    let store_val: *Value = Func_emitStoreLocal(b.func, loc_idx, value_val);
    // Stores don't need registers (they write to memory)
    return store_val.id;
}

fn SSABuilder_convertAddrLocal(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Address of local variable: left = local index
    let loc_idx: i64 = ir_node.left;
    let addr_val: *Value = Func_newValue(b.func, Op.LocalAddr, TYPE_I64);
    addr_val.aux_int = loc_idx;
    SSABuilder_assignReg(b, addr_val);
    return addr_val.id;
}

// --- Global Variable Operations ---

fn SSABuilder_convertLoadGlobal(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Load global variable: left = global index
    let global_idx: i64 = ir_node.left;
    let load_val: *Value = Func_newValue(b.func, Op.GlobalLoad, ir_node.type_idx);
    load_val.aux_int = global_idx;
    SSABuilder_assignReg(b, load_val);
    return load_val.id;
}

fn SSABuilder_convertStoreGlobal(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Store to global variable: left = global index, right = value expr
    let global_idx: i64 = ir_node.left;
    let val: *Value = SSABuilder_getOperandValue(b, ir_node.right);
    let store_val: *Value = Func_newValue(b.func, Op.GlobalStore, TYPE_I64);
    store_val.aux_int = global_idx;
    Value_addArg(store_val, val);
    SSABuilder_assignReg(b, store_val);
    return store_val.id;
}

fn SSABuilder_convertAddrGlobal(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Address of global variable: left = global index
    let global_idx: i64 = ir_node.left;
    let addr_val: *Value = Func_newValue(b.func, Op.GlobalAddr, TYPE_I64);
    addr_val.aux_int = global_idx;
    SSABuilder_assignReg(b, addr_val);
    return addr_val.id;
}

// Convert function address (for function pointers)
// Following Zig: src/frontend/ssa_builder.zig (FuncAddr handling)
fn SSABuilder_convertFuncAddr(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Address of function: func_name_start, func_name_len
    let addr_val: *Value = Func_newValue(b.func, Op.Addr, TYPE_I64);
    // Store function name position in aux fields (same as Call)
    addr_val.aux_int = ir_node.func_name_start;
    addr_val.aux_ptr = ir_node.func_name_len;
    SSABuilder_assignReg(b, addr_val);
    return addr_val.id;
}

// --- Pointer Operations ---

fn SSABuilder_convertLoad(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Load from pointer: left = ptr expr (relative IR index)
    // Use the IR node's type_idx to preserve byte types (u8, i8)
    let ptr_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let load_val: *Value = Func_newValue(b.func, Op.Load, ir_node.type_idx);
    Value_addArg(load_val, ptr_val);
    SSABuilder_assignReg(b, load_val);
    return load_val.id;
}

fn SSABuilder_convertStore(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Store to pointer: left = ptr expr, right = value expr (relative)
    let ptr_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let val_val: *Value = SSABuilder_getOperandValue(b, ir_node.right);
    let store_val: *Value = Func_newValue(b.func, Op.Store, TYPE_VOID);
    Value_addArg2(store_val, ptr_val, val_val);
    // Stores don't need registers
    return store_val.id;
}

// --- Field Access ---

fn SSABuilder_convertFieldLocal(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Access field of local struct: left = local_idx, right = offset
    // Following Zig ssa_builder.zig:1027-1061
    let loc_idx: i64 = ir_node.left;
    let offset: i64 = ir_node.right;

    // 1. Get address of local
    let addr_val: *Value = Func_newValue(b.func, Op.LocalAddr, TYPE_I64);
    addr_val.aux_int = loc_idx;

    // 2. Add offset to get field address
    let off_val: *Value = Func_newValue(b.func, Op.OffPtr, TYPE_I64);
    Value_addArg(off_val, addr_val);
    off_val.aux_int = offset;

    // Check if result is a struct or array - if so, return address (no load)
    // Both structs and arrays are inline data, not pointers, so we return
    // the address for further field access or indexing.
    // Following Zig ssa_builder.zig:1042-1051
    if b.type_registry != null and ir_node.type_idx > 0 {
        let field_type: *Type = TypeRegistry_get(b.type_registry, ir_node.type_idx);
        if field_type != null {
            if field_type.kind == TypeKind.Struct or field_type.kind == TypeKind.Array {
                // Nested struct or array - return address for further access
                SSABuilder_assignReg(b, off_val);
                return off_val.id;
            }
        }
    }

    // 3. Primitive type - load the field value
    let load_val: *Value = Func_newValue(b.func, Op.Load, ir_node.type_idx);
    Value_addArg(load_val, off_val);
    SSABuilder_assignReg(b, load_val);
    return load_val.id;
}

fn SSABuilder_convertFieldValue(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Access field via computed address: left = base_expr, right = offset
    // Following Zig ssa_builder.zig:1108-1130
    let base_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let offset: i64 = ir_node.right;

    // 1. Add offset to base to get field address
    let off_val: *Value = Func_newValue(b.func, Op.OffPtr, TYPE_I64);
    Value_addArg(off_val, base_val);
    off_val.aux_int = offset;

    // Check if result is a struct or array - if so, return address (no load)
    // Both structs and arrays are inline data, not pointers, so we return
    // the address for further field access or indexing.
    // Following Zig ssa_builder.zig:1118-1126
    if b.type_registry != null and ir_node.type_idx > 0 {
        let field_type: *Type = TypeRegistry_get(b.type_registry, ir_node.type_idx);
        if field_type != null {
            if field_type.kind == TypeKind.Struct or field_type.kind == TypeKind.Array {
                // Nested struct or array - return address for further access
                SSABuilder_assignReg(b, off_val);
                return off_val.id;
            }
        }
    }

    // 2. Primitive type - load the field value
    let load_val: *Value = Func_newValue(b.func, Op.Load, ir_node.type_idx);
    Value_addArg(load_val, off_val);
    SSABuilder_assignReg(b, load_val);
    return load_val.id;
}

fn SSABuilder_convertStoreFieldLocal(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Store to field of local struct: left = local_idx, right = offset, value = stored_expr
    let loc_idx: i64 = ir_node.left;
    let offset: i64 = ir_node.right;
    let val_val: *Value = SSABuilder_getOperandValue(b, ir_node.value);

    // 1. Get address of local
    let addr_val: *Value = Func_newValue(b.func, Op.LocalAddr, TYPE_I64);
    addr_val.aux_int = loc_idx;
    SSABuilder_assignReg(b, addr_val);

    // 2. Add offset to get field address
    let off_val: *Value = Func_newValue(b.func, Op.OffPtr, TYPE_I64);
    Value_addArg(off_val, addr_val);
    off_val.aux_int = offset;
    SSABuilder_assignReg(b, off_val);

    // 3. Store the value
    let store_val: *Value = Func_newValue(b.func, Op.Store, TYPE_VOID);
    Value_addArg2(store_val, off_val, val_val);
    return store_val.id;
}

fn SSABuilder_convertStoreField(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Store to field via computed address: left = base_expr, right = offset, value = stored_expr
    let base_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let offset: i64 = ir_node.right;
    let val_val: *Value = SSABuilder_getOperandValue(b, ir_node.value);

    // 1. Add offset to base to get field address
    let off_val: *Value = Func_newValue(b.func, Op.OffPtr, TYPE_I64);
    Value_addArg(off_val, base_val);
    off_val.aux_int = offset;
    SSABuilder_assignReg(b, off_val);

    // 2. Store the value
    let store_val: *Value = Func_newValue(b.func, Op.Store, TYPE_VOID);
    Value_addArg2(store_val, off_val, val_val);
    return store_val.id;
}

// --- Array Indexing ---

fn SSABuilder_convertIndexLocal(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Index into local array: left = local_idx, right = index_expr, value = elem_size
    let loc_idx: i64 = ir_node.left;
    let idx_val: *Value = SSABuilder_getOperandValue(b, ir_node.right);
    let elem_size: i64 = ir_node.value;

    // 1. Get address of local array
    let addr_val: *Value = Func_newValue(b.func, Op.LocalAddr, TYPE_I64);
    addr_val.aux_int = loc_idx;
    SSABuilder_assignReg(b, addr_val);

    // 2. Compute byte offset: index * elem_size
    let size_val: *Value = Func_emitConstInt(b.func, elem_size, TYPE_I64);
    SSABuilder_assignReg(b, size_val);
    let offset_val: *Value = Func_emitBinary(b.func, Op.Mul64, idx_val, size_val, TYPE_I64);
    SSABuilder_assignReg(b, offset_val);

    // 3. Add offset to base address
    let ptr_val: *Value = Func_emitBinary(b.func, Op.AddPtr, addr_val, offset_val, TYPE_I64);
    SSABuilder_assignReg(b, ptr_val);

    // 4. Load the element value
    let load_val: *Value = Func_newValue(b.func, Op.Load, ir_node.type_idx);
    Value_addArg(load_val, ptr_val);
    SSABuilder_assignReg(b, load_val);
    return load_val.id;
}

fn SSABuilder_convertIndexValue(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Index via computed address: left = base_expr, right = index_expr, value = elem_size
    // Following Zig ssa_builder.zig:1308-1346
    let base_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let idx_val: *Value = SSABuilder_getOperandValue(b, ir_node.right);
    let elem_size: i64 = ir_node.value;

    // 1. Compute byte offset: index * elem_size
    let size_val: *Value = Func_emitConstInt(b.func, elem_size, TYPE_I64);
    SSABuilder_assignReg(b, size_val);
    let offset_val: *Value = Func_emitBinary(b.func, Op.Mul64, idx_val, size_val, TYPE_I64);
    SSABuilder_assignReg(b, offset_val);

    // 2. Add offset to base address
    let ptr_val: *Value = Func_emitBinary(b.func, Op.AddPtr, base_val, offset_val, TYPE_I64);
    SSABuilder_assignReg(b, ptr_val);

    // 3. For struct types, return address without loading
    // Following Zig ssa_builder.zig:1333-1337:
    //   const elem_type = self.type_registry.get(node.type_idx);
    //   if (elem_type == .struct_type) { break :blk elem_addr; }
    // Structs need address for field access, not loaded value
    if b.type_registry != null and ir_node.type_idx > 0 {
        let elem_type: *Type = TypeRegistry_get(b.type_registry, ir_node.type_idx);
        if elem_type.kind == TypeKind.Struct {
            return ptr_val.id;
        }
    }

    // 4. Load the element value for primitives
    let load_val: *Value = Func_newValue(b.func, Op.Load, ir_node.type_idx);
    Value_addArg(load_val, ptr_val);
    SSABuilder_assignReg(b, load_val);
    return load_val.id;
}

fn SSABuilder_convertStoreIndexLocal(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Store to local array element: left = local_idx, right = index_expr, value = stored_expr, op = elem_size
    let loc_idx: i64 = ir_node.left;
    let idx_val: *Value = SSABuilder_getOperandValue(b, ir_node.right);
    let val_val: *Value = SSABuilder_getOperandValue(b, ir_node.value);
    let elem_size: i64 = ir_node.op;

    // 1. Get address of local array
    let addr_val: *Value = Func_newValue(b.func, Op.LocalAddr, TYPE_I64);
    addr_val.aux_int = loc_idx;
    SSABuilder_assignReg(b, addr_val);

    // 2. Compute byte offset: index * elem_size
    let size_val: *Value = Func_emitConstInt(b.func, elem_size, TYPE_I64);
    SSABuilder_assignReg(b, size_val);
    let offset_val: *Value = Func_emitBinary(b.func, Op.Mul64, idx_val, size_val, TYPE_I64);
    SSABuilder_assignReg(b, offset_val);

    // 3. Add offset to base address
    let ptr_val: *Value = Func_emitBinary(b.func, Op.AddPtr, addr_val, offset_val, TYPE_I64);
    SSABuilder_assignReg(b, ptr_val);

    // 4. Store the value
    let store_val: *Value = Func_newValue(b.func, Op.Store, TYPE_VOID);
    Value_addArg2(store_val, ptr_val, val_val);
    return store_val.id;
}

fn SSABuilder_convertStoreIndexValue(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Store via indexed address: left = base_expr, right = index_expr, value = stored_expr, op = elem_size
    let base_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let idx_val: *Value = SSABuilder_getOperandValue(b, ir_node.right);
    let val_val: *Value = SSABuilder_getOperandValue(b, ir_node.value);
    let elem_size: i64 = ir_node.op;

    // 1. Compute byte offset: index * elem_size
    let size_val: *Value = Func_emitConstInt(b.func, elem_size, TYPE_I64);
    SSABuilder_assignReg(b, size_val);
    let offset_val: *Value = Func_emitBinary(b.func, Op.Mul64, idx_val, size_val, TYPE_I64);
    SSABuilder_assignReg(b, offset_val);

    // 2. Add offset to base address
    let ptr_val: *Value = Func_emitBinary(b.func, Op.AddPtr, base_val, offset_val, TYPE_I64);
    SSABuilder_assignReg(b, ptr_val);

    // 3. Store the value
    let store_val: *Value = Func_newValue(b.func, Op.Store, TYPE_VOID);
    Value_addArg2(store_val, ptr_val, val_val);
    return store_val.id;
}

// --- Slice/String Builtins ---

fn SSABuilder_convertMakeString(b: *SSABuilder, ir_node: *IRNode) i64 {
    // @string(ptr, len): left=ptr_expr, right=len_expr (relative IR indices)
    let ptr_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let len_val: *Value = SSABuilder_getOperandValue(b, ir_node.right);
    let make_val: *Value = Func_newValue(b.func, Op.StringMake, TYPE_STRING);
    Value_addArg2(make_val, ptr_val, len_val);
    SSABuilder_assignReg(b, make_val);
    return make_val.id;
}

fn SSABuilder_convertMakeSlice(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Slice creation: left=ptr_expr, right=len_expr (relative IR indices)
    let ptr_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let len_val: *Value = SSABuilder_getOperandValue(b, ir_node.right);
    let make_val: *Value = Func_newValue(b.func, Op.SliceMake, TYPE_I64);
    Value_addArg2(make_val, ptr_val, len_val);
    SSABuilder_assignReg(b, make_val);
    return make_val.id;
}

fn SSABuilder_convertSlicePtr(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Extract pointer from slice: left=slice_expr (relative IR index)
    let slice_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let ptr_val: *Value = Func_newValue(b.func, Op.SlicePtr, TYPE_I64);
    Value_addArg(ptr_val, slice_val);
    SSABuilder_assignReg(b, ptr_val);
    return ptr_val.id;
}

fn SSABuilder_convertSliceLen(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Extract length from slice: left=slice_expr (relative IR index)
    let slice_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let len_val: *Value = Func_newValue(b.func, Op.SliceLen, TYPE_I64);
    Value_addArg(len_val, slice_val);
    SSABuilder_assignReg(b, len_val);
    return len_val.id;
}

// --- Function Call ---

fn SSABuilder_convertCall(b: *SSABuilder, ir_node: *IRNode) i64 {
    let val: *Value = Func_emitCall(b.func,
                                     ir_node.func_name_start,
                                     ir_node.func_name_len,
                                     ir_node.type_idx);
    var arg_idx: i64 = 0;
    while arg_idx < ir_node.call_args.count {
        let arg_ir_rel: i64 = i64list_get(&ir_node.call_args, arg_idx);
        // Validate arg index
        if arg_ir_rel < 0 {
            io_print("SSA ERROR: Invalid arg ir_rel=");
            io_print_int(arg_ir_rel);
            io_print(" for call arg ");
            io_print_int(arg_idx);
            io_print(" in ");
            // Print current function name
            if b.source != null and b.func.name_start >= 0 and b.func.name_len > 0 {
                write(1, b.source + b.func.name_start, b.func.name_len);
            }
            io_print(" calling ");
            // Print callee name
            if b.source != null and ir_node.func_name_start >= 0 and ir_node.func_name_len > 0 {
                write(1, b.source + ir_node.func_name_start, ir_node.func_name_len);
            }
            io_print("\n");
            arg_idx = arg_idx + 1;
            continue;
        }
        let abs_idx: i64 = b.ir_nodes_start + arg_ir_rel;
        let arg_ir_node: *IRNode = b.ir_nodes + abs_idx;
        let arg_value_id: i64 = SSABuilder_convertNode(b, arg_ir_node, abs_idx);
        let arg_val: *Value = Func_getValue(b.func, arg_value_id);
        Value_addArg(val, arg_val);
        arg_idx = arg_idx + 1;
    }
    SSABuilder_assignReg(b, val);
    return val.id;
}

// Convert indirect call through function pointer (Go: ClosureCall)
// Following Zig pattern: src/frontend/ssa_builder.zig:930-945
fn SSABuilder_convertCallIndirect(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Create ClosureCall value
    let val: *Value = Func_emitCallIndirect(b.func, TYPE_I64);

    // First argument is the function pointer (ir_node.left)
    // Use convertNode pattern like Zig
    let fn_ptr_abs_idx: i64 = b.ir_nodes_start + ir_node.left;
    let fn_ptr_ir_node: *IRNode = b.ir_nodes + fn_ptr_abs_idx;
    let fn_ptr_value_id: i64 = SSABuilder_convertNode(b, fn_ptr_ir_node, fn_ptr_abs_idx);
    let fn_ptr_val: *Value = Func_getValue(b.func, fn_ptr_value_id);
    Value_addArg(val, fn_ptr_val);

    // Add remaining arguments - call convertNode for each arg (matches Zig)
    var arg_idx: i64 = 0;
    while arg_idx < ir_node.call_args.count {
        let arg_ir_rel: i64 = i64list_get(&ir_node.call_args, arg_idx);
        let abs_idx: i64 = b.ir_nodes_start + arg_ir_rel;
        let arg_ir_node: *IRNode = b.ir_nodes + abs_idx;
        let arg_value_id: i64 = SSABuilder_convertNode(b, arg_ir_node, abs_idx);
        let arg_val: *Value = Func_getValue(b.func, arg_value_id);
        Value_addArg(val, arg_val);
        arg_idx = arg_idx + 1;
    }
    SSABuilder_assignReg(b, val);
    return val.id;
}

// --- String Concatenation ---
// Following Zig pattern: src/frontend/ssa_builder.zig:851-859
// Creates StringConcat SSA value with 4 args: ptr1, len1, ptr2, len2

fn SSABuilder_convertStrConcat(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Create StringConcat value (returns string type)
    let val: *Value = Func_newValue(b.func, Op.StringConcat, TYPE_STRING);

    // Convert and add the 4 args: ptr1, len1, ptr2, len2
    var arg_idx: i64 = 0;
    while arg_idx < ir_node.call_args.count {
        let arg_ir_rel: i64 = i64list_get(&ir_node.call_args, arg_idx);
        if arg_ir_rel < 0 {
            arg_idx = arg_idx + 1;
            continue;
        }
        let abs_idx: i64 = b.ir_nodes_start + arg_ir_rel;
        let arg_ir_node: *IRNode = b.ir_nodes + abs_idx;
        let arg_value_id: i64 = SSABuilder_convertNode(b, arg_ir_node, abs_idx);
        let arg_val: *Value = Func_getValue(b.func, arg_value_id);
        Value_addArg(val, arg_val);
        arg_idx = arg_idx + 1;
    }

    SSABuilder_assignReg(b, val);
    return val.id;
}

// --- Select (Ternary) ---

fn SSABuilder_convertSelect(b: *SSABuilder, ir_node: *IRNode) i64 {
    // Select: left = cond, right = true_val, value = false_val
    let cond_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let true_val: *Value = SSABuilder_getOperandValue(b, ir_node.right);
    let false_val: *Value = SSABuilder_getOperandValue(b, ir_node.value);
    let val: *Value = Func_emitSelect(b.func, cond_val, true_val, false_val, TYPE_I64);
    SSABuilder_assignReg(b, val);
    return val.id;
}

// --- Control Flow ---

fn SSABuilder_convertBranch(b: *SSABuilder, ir_node: *IRNode) {
    // left is relative IR index of condition
    let cond_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
    let then_block: i64 = ir_node.right;
    let else_block: i64 = ir_node.value;
    Func_emitIf(b.func, cond_val, then_block, else_block);
}

fn SSABuilder_convertJump(b: *SSABuilder, ir_node: *IRNode) {
    let target_block: i64 = ir_node.left;
    Func_emitJump(b.func, target_block);
}

fn SSABuilder_convertReturn(b: *SSABuilder, ir_node: *IRNode) {
    if ir_node.left >= 0 {
        let ret_val: *Value = SSABuilder_getOperandValue(b, ir_node.left);
        Func_emitReturn(b.func, ret_val);
    } else {
        // Void return - emit return with no value
        let void_ret: *Value = Func_newValue(b.func, Op.Return, TYPE_VOID);
    }
}

// ============================================================================
// Block Definitions Lookup
// ============================================================================

// Get BlockDefs for a specific SSA block
fn SSABuilder_getBlockDefs(b: *SSABuilder, block_id: i64) *BlockDefs {
    var i: i64 = 0;
    while i < b.all_defs_count {
        let bd: *BlockDefs = b.all_defs + i;
        if bd.block_id == block_id {
            return bd;
        }
        i = i + 1;
    }
    return null;
}

// Copy definitions from one block to another (for control flow merge)
fn SSABuilder_copyDefs(b: *SSABuilder, from_block: i64, to_block: i64) {
    let from: *BlockDefs = SSABuilder_getBlockDefs(b, from_block);
    let to: *BlockDefs = SSABuilder_getBlockDefs(b, to_block);

    if from == null or to == null { return; }

    var i: i64 = 0;
    while i < from.defs_count {
        let def: *VarDef = from.defs + i;
        BlockDefs_set(to, def.var_idx, def.value_id);
        i = i + 1;
    }
}

// ============================================================================
// SSA Verification (following Zig ssa_builder.zig:1826-1875)
// ============================================================================

// Verify the SSA function is well-formed.
// Returns true if valid, false if errors found.
// Checks:
// 1. Phi placement - phis must be at start of block
// 2. Phi arg count - must match predecessor count
// 3. No unresolved FwdRefs
// 4. Block termination - ret has no successors, if has 2 successors and control
fn SSABuilder_verify(b: *SSABuilder) bool {
    let f: *Func = b.func;
    var errors_found: bool = false;

    var block_idx: i64 = 0;
    while block_idx < f.blocks_count {
        let block: *Block = f.blocks + block_idx;

        // Check values in this block
        var seen_non_phi: bool = false;
        var val_idx: i64 = block.values_start;
        while val_idx < block.values_start + block.values_count {
            let v: *Value = f.values + val_idx;

            // Check 1: Phi placement
            if v.op == Op.Phi {
                if seen_non_phi {
                    // Error: phi after non-phi value
                    errors_found = true;
                }
                // Check 2: Phi arg count matches predecessors
                if v.args.count != block.preds.count {
                    errors_found = true;
                }
            } else {
                seen_non_phi = true;
            }

            // Check 3: No unresolved FwdRefs
            if v.op == Op.FwdRef {
                errors_found = true;
            }

            val_idx = val_idx + 1;
        }

        // Check 4: Block termination
        if block.kind == BlockKind.Return {
            // Return blocks should have no successors
            if block.succs_count != 0 {
                errors_found = true;
            }
        } else if block.kind == BlockKind.If {
            // If blocks must have exactly 2 successors
            if block.succs_count != 2 {
                errors_found = true;
            }
            // Must have a control value (condition)
            if block.control < 0 {
                errors_found = true;
            }
        }
        // Plain blocks: allow 0 or 1 successors (single-block functions, etc.)

        block_idx = block_idx + 1;
    }

    return not errors_found;
}

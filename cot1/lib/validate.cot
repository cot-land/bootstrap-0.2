// =============================================================================
// Type/Kind Validation Helpers
// =============================================================================
//
// Provides validation functions for compiler-specific types:
// 1. AST NodeKind validation
// 2. IR IRNodeKind validation
// 3. SSA Op validation
// 4. Type index validation
// 5. Block/Value index validation
//
// Each validator provides clear error messages identifying:
// - What was expected
// - What was found
// - Where it happened (context)
//
// =============================================================================

import "error.cot"

// =============================================================================
// NodeKind Names (for error messages)
// =============================================================================

// Note: These must match the NodeKind enum in ast.cot
fn NodeKind_name(kind: i64) *u8 {
    // Expressions
    if kind == 0 { return "IntLit"; }
    if kind == 1 { return "StringLit"; }
    if kind == 2 { return "Ident"; }
    if kind == 3 { return "BinaryExpr"; }
    if kind == 4 { return "CallExpr"; }
    if kind == 5 { return "UnaryExpr"; }
    if kind == 6 { return "AddressOf"; }
    if kind == 7 { return "DerefExpr"; }
    if kind == 8 { return "AssignExpr"; }

    // Statements
    if kind == 9 { return "ReturnStmt"; }
    if kind == 10 { return "ExprStmt"; }
    if kind == 11 { return "BlockStmt"; }
    if kind == 12 { return "IfStmt"; }
    if kind == 13 { return "WhileStmt"; }
    if kind == 14 { return "ForStmt"; }
    if kind == 15 { return "BreakStmt"; }
    if kind == 16 { return "ContinueStmt"; }

    // Declarations
    if kind == 17 { return "FnDecl"; }
    if kind == 18 { return "ExternFnDecl"; }
    if kind == 19 { return "ParamDecl"; }
    if kind == 20 { return "VarDecl"; }
    if kind == 21 { return "GlobalVarDecl"; }
    if kind == 22 { return "ConstDecl"; }
    if kind == 23 { return "StructDecl"; }
    if kind == 24 { return "EnumDecl"; }
    if kind == 25 { return "FieldDecl"; }
    if kind == 26 { return "ImportDecl"; }

    // Member access
    if kind == 27 { return "FieldAccess"; }
    if kind == 28 { return "IndexExpr"; }
    if kind == 29 { return "SliceExpr"; }

    // Composite literals
    if kind == 30 { return "StructLit"; }
    if kind == 31 { return "FieldInit"; }
    if kind == 32 { return "ArrayLit"; }

    // Builtins
    if kind == 33 { return "BuiltinCall"; }

    // Switch
    if kind == 34 { return "SwitchExpr"; }
    if kind == 35 { return "SwitchCase"; }

    return "Unknown";
}

// =============================================================================
// IRNodeKind Names (for error messages)
// =============================================================================

// Note: These must match the IRNodeKind enum in ir.cot
fn IRNodeKind_name(kind: i64) *u8 {
    // Constants
    if kind == 0 { return "ConstInt"; }
    if kind == 1 { return "ConstBool"; }
    if kind == 2 { return "ConstNull"; }
    if kind == 3 { return "ConstString"; }

    // Builtins
    if kind == 4 { return "MakeString"; }
    if kind == 5 { return "MakeSlice"; }
    if kind == 6 { return "SlicePtr"; }
    if kind == 7 { return "SliceLen"; }

    // Local variable access
    if kind == 8 { return "LoadLocal"; }
    if kind == 9 { return "StoreLocal"; }
    if kind == 10 { return "AddrLocal"; }

    // Global variable access
    if kind == 11 { return "LoadGlobal"; }
    if kind == 12 { return "StoreGlobal"; }
    if kind == 13 { return "AddrGlobal"; }

    // Pointer operations
    if kind == 14 { return "Load"; }
    if kind == 15 { return "Store"; }

    // Field access
    if kind == 16 { return "FieldLocal"; }
    if kind == 17 { return "FieldValue"; }
    if kind == 18 { return "StoreFieldLocal"; }
    if kind == 19 { return "StoreField"; }

    // Array indexing
    if kind == 20 { return "IndexLocal"; }
    if kind == 21 { return "IndexValue"; }
    if kind == 22 { return "StoreIndexLocal"; }
    if kind == 23 { return "StoreIndexValue"; }

    // Operations
    if kind == 24 { return "Binary"; }
    if kind == 25 { return "Unary"; }

    // Control flow
    if kind == 26 { return "Call"; }
    if kind == 27 { return "Return"; }
    if kind == 28 { return "Jump"; }
    if kind == 29 { return "Branch"; }

    // Phi
    if kind == 30 { return "Phi"; }

    return "Unknown";
}

// =============================================================================
// Op Names (for error messages)
// =============================================================================

// Note: These must match the Op enum in ssa/op.cot
fn Op_name(op: i64) *u8 {
    if op == 0 { return "Invalid"; }
    if op == 1 { return "InitMem"; }

    // Constants
    if op == 2 { return "ConstBool"; }
    if op == 3 { return "ConstInt"; }
    if op == 4 { return "ConstNil"; }
    if op == 5 { return "ConstString"; }
    if op == 6 { return "ConstPtr"; }

    // Integer Arithmetic
    if op == 7 { return "Add64"; }
    if op == 8 { return "Sub64"; }
    if op == 9 { return "Mul64"; }
    if op == 10 { return "Div64"; }
    if op == 11 { return "Mod64"; }
    if op == 12 { return "Neg64"; }

    // Bitwise Operations
    if op == 13 { return "And64"; }
    if op == 14 { return "Or64"; }
    if op == 15 { return "Xor64"; }
    if op == 16 { return "Shl64"; }
    if op == 17 { return "Shr64"; }
    if op == 18 { return "Sar64"; }
    if op == 19 { return "Not64"; }

    // Comparisons
    if op == 20 { return "Eq64"; }
    if op == 21 { return "Ne64"; }
    if op == 22 { return "Lt64"; }
    if op == 23 { return "Le64"; }
    if op == 24 { return "Gt64"; }
    if op == 25 { return "Ge64"; }
    if op == 26 { return "Ltu64"; }
    if op == 27 { return "Leu64"; }

    // Type Conversions
    if op == 28 { return "SignExt8to64"; }
    if op == 29 { return "SignExt16to64"; }
    if op == 30 { return "SignExt32to64"; }
    if op == 31 { return "ZeroExt8to64"; }
    if op == 32 { return "ZeroExt16to64"; }
    if op == 33 { return "ZeroExt32to64"; }
    if op == 34 { return "Trunc64to8"; }
    if op == 35 { return "Trunc64to16"; }
    if op == 36 { return "Trunc64to32"; }

    // Memory Operations
    if op == 37 { return "Load"; }
    if op == 38 { return "Store"; }
    if op == 39 { return "Move"; }
    if op == 40 { return "Zero"; }

    // Address Operations
    if op == 41 { return "Addr"; }
    if op == 42 { return "LocalAddr"; }
    if op == 43 { return "GlobalAddr"; }
    if op == 44 { return "GlobalLoad"; }
    if op == 45 { return "GlobalStore"; }
    if op == 46 { return "OffPtr"; }
    if op == 47 { return "AddPtr"; }

    // Control Flow
    if op == 48 { return "Phi"; }
    if op == 49 { return "Copy"; }
    if op == 50 { return "Arg"; }

    // Function Calls
    if op == 51 { return "Call"; }
    if op == 52 { return "TailCall"; }
    if op == 53 { return "ClosureCall"; }

    // Return
    if op == 54 { return "Return"; }

    return "Unknown";
}

// =============================================================================
// NodeKind Validation
// =============================================================================

// Assert that a node has a specific kind
fn assert_node_kind(kind: i64, expected: i64, context: *u8) {
    if kind != expected {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("NODE KIND ERROR in ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  Expected: ");
        stderr_str(NodeKind_name(expected));
        stderr_str(" (");
        stderr_int(expected);
        stderr_str(")\n");
        stderr_str("  Got:      ");
        stderr_str(NodeKind_name(kind));
        stderr_str(" (");
        stderr_int(kind);
        stderr_str(")\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }
}

// Assert that a node kind is one of several expected kinds
fn assert_node_kind_in(kind: i64, kinds: *i64, count: i64, context: *u8) {
    var i: i64 = 0;
    while i < count {
        if kind == (kinds + i).* {
            return;  // Found a match
        }
        i = i + 1;
    }

    // No match found
    stderr_str("\n");
    stderr_str("================================================================================\n");
    stderr_str("NODE KIND ERROR in ");
    stderr_str(context);
    stderr_newline();
    stderr_str("  Got: ");
    stderr_str(NodeKind_name(kind));
    stderr_str(" (");
    stderr_int(kind);
    stderr_str(")\n");
    stderr_str("  Expected one of:\n");

    i = 0;
    while i < count {
        stderr_str("    - ");
        stderr_str(NodeKind_name((kinds + i).*));
        stderr_newline();
        i = i + 1;
    }
    stderr_str("================================================================================\n");
    print_error_context_stack();
    exit(1);
}

// Assert that a node kind is an expression
fn assert_is_expression(kind: i64, context: *u8) {
    // Expression kinds: 0-8 (IntLit through AssignExpr)
    // Plus FieldAccess, IndexExpr, SliceExpr, StructLit, ArrayLit, BuiltinCall, SwitchExpr
    if kind <= 8 { return; }
    if kind >= 27 and kind <= 29 { return; }  // FieldAccess, IndexExpr, SliceExpr
    if kind == 30 { return; }  // StructLit
    if kind == 32 { return; }  // ArrayLit
    if kind == 33 { return; }  // BuiltinCall
    if kind == 34 { return; }  // SwitchExpr

    stderr_str("\n");
    stderr_str("================================================================================\n");
    stderr_str("NODE KIND ERROR in ");
    stderr_str(context);
    stderr_newline();
    stderr_str("  Expected: an expression\n");
    stderr_str("  Got: ");
    stderr_str(NodeKind_name(kind));
    stderr_str(" (");
    stderr_int(kind);
    stderr_str(") which is not an expression\n");
    stderr_str("================================================================================\n");
    print_error_context_stack();
    exit(1);
}

// Assert that a node kind is a statement
fn assert_is_statement(kind: i64, context: *u8) {
    // Statement kinds: 9-16 (ReturnStmt through ContinueStmt)
    if kind >= 9 and kind <= 16 { return; }

    stderr_str("\n");
    stderr_str("================================================================================\n");
    stderr_str("NODE KIND ERROR in ");
    stderr_str(context);
    stderr_newline();
    stderr_str("  Expected: a statement\n");
    stderr_str("  Got: ");
    stderr_str(NodeKind_name(kind));
    stderr_str(" (");
    stderr_int(kind);
    stderr_str(") which is not a statement\n");
    stderr_str("================================================================================\n");
    print_error_context_stack();
    exit(1);
}

// Assert that a node kind is a declaration
fn assert_is_declaration(kind: i64, context: *u8) {
    // Declaration kinds: 17-26 (FnDecl through ImportDecl)
    if kind >= 17 and kind <= 26 { return; }

    stderr_str("\n");
    stderr_str("================================================================================\n");
    stderr_str("NODE KIND ERROR in ");
    stderr_str(context);
    stderr_newline();
    stderr_str("  Expected: a declaration\n");
    stderr_str("  Got: ");
    stderr_str(NodeKind_name(kind));
    stderr_str(" (");
    stderr_int(kind);
    stderr_str(") which is not a declaration\n");
    stderr_str("================================================================================\n");
    print_error_context_stack();
    exit(1);
}

// =============================================================================
// IRNodeKind Validation
// =============================================================================

// Assert that an IR node has a specific kind
fn assert_ir_kind(kind: i64, expected: i64, context: *u8) {
    if kind != expected {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("IR NODE KIND ERROR in ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  Expected: ");
        stderr_str(IRNodeKind_name(expected));
        stderr_str(" (");
        stderr_int(expected);
        stderr_str(")\n");
        stderr_str("  Got:      ");
        stderr_str(IRNodeKind_name(kind));
        stderr_str(" (");
        stderr_int(kind);
        stderr_str(")\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }
}

// Assert that an IR node kind is a constant
fn assert_ir_is_constant(kind: i64, context: *u8) {
    // Constant kinds: 0-3 (ConstInt through ConstString)
    if kind >= 0 and kind <= 3 { return; }

    stderr_str("\n");
    stderr_str("================================================================================\n");
    stderr_str("IR NODE KIND ERROR in ");
    stderr_str(context);
    stderr_newline();
    stderr_str("  Expected: a constant IR node\n");
    stderr_str("  Got: ");
    stderr_str(IRNodeKind_name(kind));
    stderr_str(" (");
    stderr_int(kind);
    stderr_str(")\n");
    stderr_str("================================================================================\n");
    print_error_context_stack();
    exit(1);
}

// =============================================================================
// SSA Op Validation
// =============================================================================

// Assert that an SSA value has a specific op
fn assert_op(op: i64, expected: i64, context: *u8) {
    if op != expected {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("SSA OP ERROR in ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  Expected: ");
        stderr_str(Op_name(expected));
        stderr_str(" (");
        stderr_int(expected);
        stderr_str(")\n");
        stderr_str("  Got:      ");
        stderr_str(Op_name(op));
        stderr_str(" (");
        stderr_int(op);
        stderr_str(")\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }
}

// Assert that an op is not Invalid
fn assert_op_valid(op: i64, context: *u8) {
    if op == 0 {  // Invalid
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("SSA OP ERROR in ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  Got Invalid op (uninitialized value?)\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }
}

// Assert that an op is a constant op
fn assert_op_is_constant(op: i64, context: *u8) {
    // Constant ops: 2-6 (ConstBool through ConstPtr)
    if op >= 2 and op <= 6 { return; }

    stderr_str("\n");
    stderr_str("================================================================================\n");
    stderr_str("SSA OP ERROR in ");
    stderr_str(context);
    stderr_newline();
    stderr_str("  Expected: a constant op\n");
    stderr_str("  Got: ");
    stderr_str(Op_name(op));
    stderr_str(" (");
    stderr_int(op);
    stderr_str(")\n");
    stderr_str("================================================================================\n");
    print_error_context_stack();
    exit(1);
}

// Assert that an op is an arithmetic op
fn assert_op_is_arithmetic(op: i64, context: *u8) {
    // Arithmetic ops: 7-12 (Add64 through Neg64)
    if op >= 7 and op <= 12 { return; }

    stderr_str("\n");
    stderr_str("================================================================================\n");
    stderr_str("SSA OP ERROR in ");
    stderr_str(context);
    stderr_newline();
    stderr_str("  Expected: an arithmetic op\n");
    stderr_str("  Got: ");
    stderr_str(Op_name(op));
    stderr_str(" (");
    stderr_int(op);
    stderr_str(")\n");
    stderr_str("================================================================================\n");
    print_error_context_stack();
    exit(1);
}

// Assert that an op is a comparison op
fn assert_op_is_comparison(op: i64, context: *u8) {
    // Comparison ops: 20-27 (Eq64 through Leu64)
    if op >= 20 and op <= 27 { return; }

    stderr_str("\n");
    stderr_str("================================================================================\n");
    stderr_str("SSA OP ERROR in ");
    stderr_str(context);
    stderr_newline();
    stderr_str("  Expected: a comparison op\n");
    stderr_str("  Got: ");
    stderr_str(Op_name(op));
    stderr_str(" (");
    stderr_int(op);
    stderr_str(")\n");
    stderr_str("================================================================================\n");
    print_error_context_stack();
    exit(1);
}

// =============================================================================
// Index Validation
// =============================================================================

// Validate a block index
fn assert_block_index(index: i64, count: i64, context: *u8) {
    if index < 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("BLOCK INDEX ERROR in ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  Block index is negative: ");
        stderr_int(index);
        stderr_newline();
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    if index >= count {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("BLOCK INDEX ERROR in ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  Block index out of range: ");
        stderr_int(index);
        stderr_str(" >= ");
        stderr_int(count);
        stderr_str(" (block count)\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }
}

// Validate a value index
fn assert_value_index(index: i64, count: i64, context: *u8) {
    if index < 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("VALUE INDEX ERROR in ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  Value index is negative: ");
        stderr_int(index);
        stderr_newline();
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    if index >= count {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("VALUE INDEX ERROR in ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  Value index out of range: ");
        stderr_int(index);
        stderr_str(" >= ");
        stderr_int(count);
        stderr_str(" (value count)\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }
}

// Validate a local variable index
fn assert_local_index(index: i64, count: i64, context: *u8) {
    if index < 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("LOCAL INDEX ERROR in ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  Local index is negative: ");
        stderr_int(index);
        stderr_newline();
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    if index >= count {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("LOCAL INDEX ERROR in ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  Local index out of range: ");
        stderr_int(index);
        stderr_str(" >= ");
        stderr_int(count);
        stderr_str(" (local count)\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }
}

// Validate an IR node index
fn assert_ir_node_index(index: i64, count: i64, context: *u8) {
    if index < 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("IR NODE INDEX ERROR in ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  IR node index is negative: ");
        stderr_int(index);
        stderr_newline();
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    if index >= count {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("IR NODE INDEX ERROR in ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  IR node index out of range: ");
        stderr_int(index);
        stderr_str(" >= ");
        stderr_int(count);
        stderr_str(" (IR node count)\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }
}

// Validate an AST node index
fn assert_ast_node_index(index: i64, count: i64, context: *u8) {
    if index < 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("AST NODE INDEX ERROR in ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  AST node index is negative: ");
        stderr_int(index);
        stderr_newline();
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }

    if index >= count {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("AST NODE INDEX ERROR in ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  AST node index out of range: ");
        stderr_int(index);
        stderr_str(" >= ");
        stderr_int(count);
        stderr_str(" (AST node count)\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }
}

// =============================================================================
// Range Validation
// =============================================================================

// Assert a value is within a range
fn assert_in_range(value: i64, min: i64, max: i64, name: *u8, context: *u8) {
    if value < min or value > max {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("RANGE ERROR in ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  ");
        stderr_str(name);
        stderr_str(" = ");
        stderr_int(value);
        stderr_str(" is outside valid range [");
        stderr_int(min);
        stderr_str(", ");
        stderr_int(max);
        stderr_str("]\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }
}

// Assert a value is positive (> 0)
fn assert_positive(value: i64, name: *u8, context: *u8) {
    if value <= 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("VALUE ERROR in ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  ");
        stderr_str(name);
        stderr_str(" = ");
        stderr_int(value);
        stderr_str(" (expected positive)\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }
}

// Assert a value is non-negative (>= 0)
fn assert_non_negative(value: i64, name: *u8, context: *u8) {
    if value < 0 {
        stderr_str("\n");
        stderr_str("================================================================================\n");
        stderr_str("VALUE ERROR in ");
        stderr_str(context);
        stderr_newline();
        stderr_str("  ");
        stderr_str(name);
        stderr_str(" = ");
        stderr_int(value);
        stderr_str(" (expected non-negative)\n");
        stderr_str("================================================================================\n");
        print_error_context_stack();
        exit(1);
    }
}


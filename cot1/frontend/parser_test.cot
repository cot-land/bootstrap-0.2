// Cot0 Parser Tests
// Tests for parsing expressions, statements, and declarations

import "ast.cot"
import "parser.cot"
import "types.cot"

// Global test pool - avoid malloc complexity
var g_nodes: [200]Node;
var g_children: [1000]i64;
var g_pool: NodePool;

// Global type registry for tests
var g_types: [100]Type;
var g_type_params: [100]i64;
var g_type_fields: [100]FieldInfo;
var g_type_registry: TypeRegistry;

fn init_test_pool() *NodePool {
    g_pool.nodes = &g_nodes[0];
    g_pool.count = 0;
    g_pool.children = &g_children[0];
    g_pool.children_count = 0;
    // Initialize type registry
    g_type_registry.types = &g_types[0];
    g_type_registry.params = &g_type_params[0];
    g_type_registry.fields = &g_type_fields[0];
    TypeRegistry_init(&g_type_registry);
    return &g_pool;
}

fn reset_pool(pool: *NodePool) {
    pool.count = 0;
    pool.children_count = 0;
}

// Test 1: Parse integer literal
fn test_parse_int() i64 {
    let pool: *NodePool = init_test_pool();
    var p: Parser = Parser_init("42", pool, &g_type_registry);

    let expr: i64 = Parser_parseExpr(&p);

    let n: *Node = node_get(pool, expr);
    if n.kind != NodeKind.IntLit { return 1; }
    if n.field0 != 42 { return 2; }

    return 0;
}

// Test 2: Parse identifier
fn test_parse_ident() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = Parser_init("foo", pool, &g_type_registry);

    let expr: i64 = Parser_parseExpr(&p);

    let n: *Node = node_get(pool, expr);
    if n.kind != NodeKind.Ident { return 1; }
    if n.field0 != 0 { return 2; }   // name_start
    if n.field1 != 3 { return 3; }   // name_len

    return 0;
}

// Test 3: Parse binary add
fn test_parse_add() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = Parser_init("1 + 2", pool, &g_type_registry);

    let expr: i64 = Parser_parseExpr(&p);

    let n: *Node = node_get(pool, expr);
    if n.kind != NodeKind.BinaryExpr { return 1; }

    // Check left operand (1)
    let left: *Node = node_get(pool, n.field0);
    if left.kind != NodeKind.IntLit { return 2; }
    if left.field0 != 1 { return 3; }

    // Check right operand (2)
    let right: *Node = node_get(pool, n.field1);
    if right.kind != NodeKind.IntLit { return 4; }
    if right.field0 != 2 { return 5; }

    // Check operator (Add = 0)
    if n.field2 != 0 { return 6; }

    return 0;
}

// Test 4: Parse operator precedence (mul before add)
fn test_parse_precedence() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = Parser_init("1 + 2 * 3", pool, &g_type_registry);

    let expr: i64 = Parser_parseExpr(&p);

    // Should parse as: 1 + (2 * 3)
    let add: *Node = node_get(pool, expr);
    if add.kind != NodeKind.BinaryExpr { return 1; }
    if add.field2 != 0 { return 2; }  // Add = 0

    // Left should be 1
    let left: *Node = node_get(pool, add.field0);
    if left.kind != NodeKind.IntLit { return 3; }
    if left.field0 != 1 { return 4; }

    // Right should be (2 * 3)
    let mul: *Node = node_get(pool, add.field1);
    if mul.kind != NodeKind.BinaryExpr { return 5; }
    if mul.field2 != 2 { return 6; }  // Mul = 2

    // Check 2 and 3
    let two: *Node = node_get(pool, mul.field0);
    let three: *Node = node_get(pool, mul.field1);
    if two.field0 != 2 { return 7; }
    if three.field0 != 3 { return 8; }

    return 0;
}

// Test 5: Parse function call
fn test_parse_call() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = Parser_init("add(1, 2)", pool);

    let expr: i64 = Parser_parseExpr(&p);

    let call: *Node = node_get(pool, expr);
    if call.kind != NodeKind.CallExpr { return 1; }

    // Check callee is identifier
    let callee: *Node = node_get(pool, call.field0);
    if callee.kind != NodeKind.Ident { return 2; }

    // Check argument count
    if call.field2 != 2 { return 3; }  // args_count

    // Check arguments
    let args_start: i64 = call.field1;
    let arg0: i64 = node_child(pool, args_start, 0);
    let arg1: i64 = node_child(pool, args_start, 1);

    let a0: *Node = node_get(pool, arg0);
    let a1: *Node = node_get(pool, arg1);
    if a0.field0 != 1 { return 4; }  // First arg = 1
    if a1.field0 != 2 { return 5; }  // Second arg = 2

    return 0;
}

// Test 6: Parse return statement
fn test_parse_return() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = Parser_init("return 42;", pool, &g_type_registry);

    let stmt: i64 = Parser_parseStmt(&p);

    let ret: *Node = node_get(pool, stmt);
    if ret.kind != NodeKind.ReturnStmt { return 1; }

    // Check return value
    let val: *Node = node_get(pool, ret.field0);
    if val.kind != NodeKind.IntLit { return 2; }
    if val.field0 != 42 { return 3; }

    return 0;
}

// Test 7: Parse block
fn test_Parser_parseBlock() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = Parser_init("{ return 1; return 2; }", pool, &g_type_registry);

    let block: i64 = Parser_parseBlock(&p);

    let blk: *Node = node_get(pool, block);
    if blk.kind != NodeKind.BlockStmt { return 1; }
    if blk.field1 != 2 { return 2; }  // 2 statements

    return 0;
}

// Test 8: Parse function declaration
fn test_parse_fn_decl() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = Parser_init("fn main() i64 { return 42; }", pool, &g_type_registry);

    let decl: i64 = Parser_parseDecl(&p);

    let fn_node: *Node = node_get(pool, decl);
    if fn_node.kind != NodeKind.FnDecl { return 1; }

    // Check name (start=3, len=4 for "main")
    if fn_node.field0 != 3 { return 2; }   // name_start
    if fn_node.field1 != 4 { return 3; }   // name_len

    // Check no parameters
    if fn_node.field3 != 0 { return 4; }   // params_count

    return 0;
}

// Test 9: Parse function with parameters
fn test_parse_fn_params() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = Parser_init("fn add(a: i64, b: i64) i64 { return 42; }", pool);

    let decl: i64 = Parser_parseDecl(&p);

    let fn_node: *Node = node_get(pool, decl);
    if fn_node.kind != NodeKind.FnDecl { return 1; }

    // Check 2 parameters
    if fn_node.field3 != 2 { return 2; }   // params_count

    // Check first parameter
    let params_start: i64 = fn_node.field2;
    let p0_idx: i64 = node_child(pool, params_start, 0);
    let p0: *Node = node_get(pool, p0_idx);
    if p0.kind != NodeKind.ParamDecl { return 3; }

    return 0;
}

// Test 10: Parse expression in return
fn test_parse_return_expr() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = Parser_init("return 1 + 2;", pool, &g_type_registry);

    let stmt: i64 = Parser_parseStmt(&p);

    let ret: *Node = node_get(pool, stmt);
    if ret.kind != NodeKind.ReturnStmt { return 1; }

    // Return value should be binary expr
    let val: *Node = node_get(pool, ret.field0);
    if val.kind != NodeKind.BinaryExpr { return 2; }

    return 0;
}

// ============================================================================
// Sprint B: Struct/Enum Tests
// ============================================================================

// Test 11: Parse struct declaration
fn test_parse_struct() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = Parser_init("struct Point { x: i64, y: i64 }", pool);

    let decl: i64 = Parser_parseDecl(&p);

    let s: *Node = node_get(pool, decl);
    if s.kind != NodeKind.StructDecl { return 1; }

    // Check name offset and length
    // "struct Point" - Point starts at offset 7, length 5
    if s.field0 != 7 { return 2; }   // name_start
    if s.field1 != 5 { return 3; }   // name_len

    // Check 2 fields
    if s.field3 != 2 { return 4; }   // fields_count

    // Check first field
    let fields_start: i64 = s.field2;
    let f0_idx: i64 = node_child(pool, fields_start, 0);
    let f0: *Node = node_get(pool, f0_idx);
    if f0.kind != NodeKind.FieldDecl { return 5; }

    return 0;
}

// Test 12: Parse enum declaration
fn test_parse_enum() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = Parser_init("enum Color { Red, Green, Blue }", pool);

    let decl: i64 = Parser_parseDecl(&p);

    let e: *Node = node_get(pool, decl);
    if e.kind != NodeKind.EnumDecl { return 1; }

    // Check name offset and length
    // "enum Color" - Color starts at offset 5, length 5
    if e.field0 != 5 { return 2; }   // name_start
    if e.field1 != 5 { return 3; }   // name_len

    // Check 3 variants
    if e.field3 != 3 { return 4; }   // variants_count

    // Check first variant is an Ident
    let variants_start: i64 = e.field2;
    let v0_idx: i64 = node_child(pool, variants_start, 0);
    let v0: *Node = node_get(pool, v0_idx);
    if v0.kind != NodeKind.Ident { return 5; }

    return 0;
}

// Test 13: Parse field access
fn test_parse_field_access() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = Parser_init("point.x", pool, &g_type_registry);

    let expr: i64 = Parser_parseExpr(&p);

    let fa: *Node = node_get(pool, expr);
    if fa.kind != NodeKind.FieldAccess { return 1; }

    // Base should be identifier "point"
    let base: *Node = node_get(pool, fa.field0);
    if base.kind != NodeKind.Ident { return 2; }

    // Field name "x" - starts after "point." at offset 6, length 1
    if fa.field1 != 6 { return 3; }   // field_start
    if fa.field2 != 1 { return 4; }   // field_len

    return 0;
}

// Test 14: Parse chained field access (Type.Variant style)
fn test_parse_chained_access() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = Parser_init("TokenType.Ident", pool, &g_type_registry);

    let expr: i64 = Parser_parseExpr(&p);

    let fa: *Node = node_get(pool, expr);
    if fa.kind != NodeKind.FieldAccess { return 1; }

    // Base should be identifier "TokenType"
    let base: *Node = node_get(pool, fa.field0);
    if base.kind != NodeKind.Ident { return 2; }

    return 0;
}

// ============================================================================
// Sprint C: Pointer and String Tests
// ============================================================================

// Test 15: Parse string literal
fn test_parse_string_lit() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = Parser_init("\"hello\"", pool, &g_type_registry);

    let expr: i64 = Parser_parseExpr(&p);

    let s: *Node = node_get(pool, expr);
    if s.kind != NodeKind.StringLit { return 1; }

    // String content starts at offset 1 (after quote), length 5
    if s.field0 != 1 { return 2; }   // str_start
    if s.field1 != 5 { return 3; }   // str_len

    return 0;
}

// Test 16: Parse address-of expression
fn test_parse_address_of() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = Parser_init("&x", pool, &g_type_registry);

    let expr: i64 = Parser_parseExpr(&p);

    let addr: *Node = node_get(pool, expr);
    if addr.kind != NodeKind.AddressOf { return 1; }

    // Operand should be identifier "x"
    let operand: *Node = node_get(pool, addr.field0);
    if operand.kind != NodeKind.Ident { return 2; }

    return 0;
}

// Test 17: Parse dereference expression
fn test_parse_deref() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = Parser_init("ptr.*", pool, &g_type_registry);

    let expr: i64 = Parser_parseExpr(&p);

    let deref: *Node = node_get(pool, expr);
    if deref.kind != NodeKind.DerefExpr { return 1; }

    // Operand should be identifier "ptr"
    let operand: *Node = node_get(pool, deref.field0);
    if operand.kind != NodeKind.Ident { return 2; }

    return 0;
}

// Test 18: Parse pointer type in function parameter
fn test_parse_ptr_type() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = Parser_init("fn foo(p: *i64) i64 { return 0; }", pool, &g_type_registry);

    let decl: i64 = Parser_parseDecl(&p);

    let fn_node: *Node = node_get(pool, decl);
    if fn_node.kind != NodeKind.FnDecl { return 1; }

    // Check 1 parameter
    if fn_node.field3 != 1 { return 2; }   // params_count

    // Check first parameter has pointer type
    let params_start: i64 = fn_node.field2;
    let p0_idx: i64 = node_child(pool, params_start, 0);
    let p0: *Node = node_get(pool, p0_idx);
    if p0.kind != NodeKind.ParamDecl { return 3; }

    // Type handle should be TYPE_PTR_BASE + TYPE_I64 = 10 + 0 = 10
    // Note: TYPE_I64 in parser.cot is 0, TYPE_PTR_BASE is 10
    if p0.field3 != 10 { return 4; }  // type_handle stored in field3

    return 0;
}

// ============================================================================
// Sprint D: Import and Const Tests
// ============================================================================

// Test 19: Parse import declaration
fn test_parse_import() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = Parser_init("import \"foo.cot\";", pool, &g_type_registry);

    let decl: i64 = Parser_parseDecl(&p);

    let imp: *Node = node_get(pool, decl);
    if imp.kind != NodeKind.ImportDecl { return 1; }

    // Path content starts at offset 8 (after 'import "'), length 7
    if imp.field0 != 8 { return 2; }   // path_start
    if imp.field1 != 7 { return 3; }   // path_len

    return 0;
}

// Test 20: Parse const declaration (no type)
fn test_parse_const() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = Parser_init("const MAX = 100;", pool, &g_type_registry);

    let decl: i64 = Parser_parseDecl(&p);

    let c: *Node = node_get(pool, decl);
    if c.kind != NodeKind.ConstDecl { return 1; }

    // Name "MAX" starts at offset 6, length 3
    if c.field0 != 6 { return 2; }   // name_start
    if c.field1 != 3 { return 3; }   // name_len

    // No type annotation
    if c.field2 != -1 { return 4; }   // type_handle should be -1

    // Init expr should be IntLit with value 100
    let init: *Node = node_get(pool, c.field3);
    if init.kind != NodeKind.IntLit { return 5; }
    if init.field0 != 100 { return 6; }

    return 0;
}

// Test 21: Parse const declaration with type
fn test_parse_const_typed() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    var p: Parser = Parser_init("const SIZE: i64 = 256;", pool, &g_type_registry);

    let decl: i64 = Parser_parseDecl(&p);

    let c: *Node = node_get(pool, decl);
    if c.kind != NodeKind.ConstDecl { return 1; }

    // Type annotation should be TYPE_I64 = 0
    if c.field2 != 0 { return 2; }   // type_handle

    return 0;
}

// Test 22: Parse file with const - verify Parser_parseFile works with const decl
fn test_Parser_parseFile_with_import() i64 {
    let pool: *NodePool = init_test_pool();
    reset_pool(pool);
    // Test Parser_parseFile with a const (simpler, no nested children issues)
    var p: Parser = Parser_init("const X = 42;", pool, &g_type_registry);

    let file: i64 = Parser_parseFile(&p);

    // File should be a block with 1 declaration
    let blk: *Node = node_get(pool, file);
    if blk.kind != NodeKind.BlockStmt { return 1; }
    if blk.field1 != 1 { return 2; }

    // First should be const
    let decls_start: i64 = blk.field0;
    let d0_idx: i64 = node_child(pool, decls_start, 0);
    let d0: *Node = node_get(pool, d0_idx);
    if d0.kind != NodeKind.ConstDecl { return 3; }

    return 0;
}

fn main() i64 {
    var failed: i64 = 0;

    if test_parse_int() != 0 {
        println("FAIL: test_parse_int");
        failed = failed + 1;
    }

    if test_parse_ident() != 0 {
        println("FAIL: test_parse_ident");
        failed = failed + 1;
    }

    if test_parse_add() != 0 {
        println("FAIL: test_parse_add");
        failed = failed + 1;
    }

    if test_parse_precedence() != 0 {
        println("FAIL: test_parse_precedence");
        failed = failed + 1;
    }

    if test_parse_call() != 0 {
        println("FAIL: test_parse_call");
        failed = failed + 1;
    }

    if test_parse_return() != 0 {
        println("FAIL: test_parse_return");
        failed = failed + 1;
    }

    if test_Parser_parseBlock() != 0 {
        println("FAIL: test_Parser_parseBlock");
        failed = failed + 1;
    }

    if test_parse_fn_decl() != 0 {
        println("FAIL: test_parse_fn_decl");
        failed = failed + 1;
    }

    if test_parse_fn_params() != 0 {
        println("FAIL: test_parse_fn_params");
        failed = failed + 1;
    }

    if test_parse_return_expr() != 0 {
        println("FAIL: test_parse_return_expr");
        failed = failed + 1;
    }

    // Sprint B: Struct/Enum tests
    if test_parse_struct() != 0 {
        println("FAIL: test_parse_struct");
        failed = failed + 1;
    }

    if test_parse_enum() != 0 {
        println("FAIL: test_parse_enum");
        failed = failed + 1;
    }

    if test_parse_field_access() != 0 {
        println("FAIL: test_parse_field_access");
        failed = failed + 1;
    }

    if test_parse_chained_access() != 0 {
        println("FAIL: test_parse_chained_access");
        failed = failed + 1;
    }

    // Sprint C: Pointer and String tests
    if test_parse_string_lit() != 0 {
        println("FAIL: test_parse_string_lit");
        failed = failed + 1;
    }

    if test_parse_address_of() != 0 {
        println("FAIL: test_parse_address_of");
        failed = failed + 1;
    }

    if test_parse_deref() != 0 {
        println("FAIL: test_parse_deref");
        failed = failed + 1;
    }

    if test_parse_ptr_type() != 0 {
        println("FAIL: test_parse_ptr_type");
        failed = failed + 1;
    }

    // Sprint D: Import and Const tests
    if test_parse_import() != 0 {
        println("FAIL: test_parse_import");
        failed = failed + 1;
    }

    if test_parse_const() != 0 {
        println("FAIL: test_parse_const");
        failed = failed + 1;
    }

    if test_parse_const_typed() != 0 {
        println("FAIL: test_parse_const_typed");
        failed = failed + 1;
    }

    if test_Parser_parseFile_with_import() != 0 {
        println("FAIL: test_Parser_parseFile_with_import");
        failed = failed + 1;
    }

    if failed == 0 {
        println("All 22 parser tests passed!");
    }

    return failed;
}

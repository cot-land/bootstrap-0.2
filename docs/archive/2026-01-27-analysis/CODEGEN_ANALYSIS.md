# Codegen Analysis - cot1/codegen/genssa.cot vs src/codegen/arm64.zig

## Summary

**Parity Status: ~85% functional, needs O(n²) fixes and missing ops**

| Metric | Zig | cot1 | Status |
|--------|-----|------|--------|
| Lines of Code | 3280 | 3147 | Similar |
| Functions | 35 | 61 | cot1 has more (finer-grained) |
| SSA Ops Handled | 80+ | 60+ | Gap: missing ops |
| Performance | <1 sec | 1.9 sec | FIXED (was 102 sec) |

## Critical Performance Fix Applied

**2026-01-26: Fixed O(n²) posToLine bottleneck**

### The Bug
`GenState_posToLine()` and `GenState_posToColumn()` were O(source_len) scans from byte 0.
Called for every SSA value (107K values) with ~34K source bytes = 3.6 billion character scans.

### The Fix
Precompute a line offset table during `GenState_setSource()`:
- `line_offsets[i]` = byte offset where line i+1 starts
- Binary search for O(log n) lookup instead of O(n)

**Result: 101 seconds → 29ms codegen (3500x speedup)**

---

## Function-by-Function Comparison

### 1. Initialization & State Management

| Zig Function | cot1 Function | Parity | Notes |
|--------------|---------------|--------|-------|
| `ARM64CodeGen.init()` | `GenState_init()` | Same | Both allocate buffers |
| `setRegAllocState()` | (inline) | Same | cot1 uses gs.func.values[].reg |
| `setFrameSize()` | (inline) | Same | Set in gs.frame_size |
| `setGlobals()` | `GenState_setGlobals()` | Same | |
| `setTypeRegistry()` | `GenState_setTypeRegistry()` | Same | |
| `setDebugInfo()` | `GenState_setSource()` | **Fixed** | Added line offset table |

### 2. Code Generation Core

| Zig Function | cot1 Function | Parity | Notes |
|--------------|---------------|--------|-------|
| `generateBinary()` | `GenState_generate()` | Same | Main entry point |
| `emitPrologue()` | (inline in generate) | Same | STP X29, X30 + frame alloc |
| `emitEpilogue()` | (inline in blockControl) | Same | LDP + RET |
| `generateBlockBinary()` | `GenState_blockValues()` + `GenState_blockControl()` | Same | Split for clarity |
| `generateValueBinary()` | `GenState_value()` | **Gap** | cot1 missing some ops |
| `applyBranchFixups()` | `GenState_resolveBranches()` | Same | |
| `finalize()` | `GenState_finalize()` | Same | Mach-O creation |

### 3. Value Emission (Op Handlers)

| SSA Op | Zig | cot1 | Status |
|--------|-----|------|--------|
| const_int/const_64 | ✓ | ✓ | Same |
| const_bool | ✓ | ✓ | Same |
| const_nil | ✓ | ✗ | **Gap** |
| const_string | ✓ | ✓ | Same |
| const_ptr | ✓ | ✓ | Same |
| add/sub/mul/div | ✓ | ✓ | Same |
| mod | ✓ | ✓ | Same (SDIV + MSUB) |
| and/or/xor | ✓ | ✓ | Same |
| shl/shr | ✓ | ✓ | Same |
| neg/not | ✓ | ✓ | Same |
| eq/ne/lt/le/gt/ge | ✓ | ✓ | Same (CMP + CSET) |
| load | ✓ | ✓ | Same (LDR/LDRB/LDRH) |
| store | ✓ | ✓ | Same (STR/STRB/STRH) |
| local_addr | ✓ | ✓ | Same (ADD SP, #offset) |
| global_addr | ✓ | ✓ | Same (ADRP + ADD) |
| global_load | ✓ | ✓ | Same |
| global_store | ✓ | ✓ | Same |
| off_ptr | ✓ | ✓ | Same (ADD) |
| call | ✓ | ✓ | Same (BL + arg setup) |
| call_indirect | ✓ | ✓ | Same (BLR) |
| phi | ✓ | ✓ | Same (handled by regalloc) |
| copy/move | ✓ | ✓ | Same (MOV) |
| arg | ✓ | ✓ | Same (x0-x7 or stack) |
| return | ✓ | ✓ | Same |
| select | ✓ | ✓ | Same (CSEL) |
| zero_ext_* | ✓ | ✗ | **Gap** - missing in cot1 |
| sign_ext_* | ✓ | ✗ | **Gap** - missing in cot1 |
| trunc_* | ✓ | ✗ | **Gap** - missing in cot1 |
| string_make | ✓ | ✓ | Same (pair of values) |
| slice_make | ✓ | ✓ | Same |
| slice_ptr | ✓ | ✓ | Same |
| slice_len | ✓ | ✓ | Same |
| string_concat | ✓ | ✓ | Same (runtime call) |
| func_addr | ✓ | ✓ | Same (ADRP + ADD) |

### 4. Branch/Control Flow

| Zig Function | cot1 Function | Parity | Notes |
|--------------|---------------|--------|-------|
| B (unconditional) | encode_b() | Same | |
| B.cond | encode_b_cond() | Same | |
| CBZ/CBNZ | encode_cbz_cbnz() | Same | |
| emitPhiMoves() | GenState_emitPhiMoves() | Same | Parallel copy |

### 5. Helper Functions

| Zig Function | cot1 Function | Parity | Notes |
|--------------|---------------|--------|-------|
| ensureInReg() | GenState_materializeArgToReg() | Same | Load to register |
| getRegForValue() | (inline via v.reg) | Same | |
| emitLoadImmediate() | encode_movz/movk | Same | |
| setupCallArgs() | (inline in GenState_call) | Same | Parallel arg copy |
| moveToReg() | (inline) | Same | |

---

## Gaps to Close for 99% Parity

### 1. Missing SSA Ops (Priority: High)

```
Missing in cot1/codegen/genssa.cot:
- const_nil: Emit MOV reg, #0
- zero_ext_8to64, zero_ext_16to64, zero_ext_32to64
- sign_ext_8to64, sign_ext_16to64, sign_ext_32to64
- trunc_64to8, trunc_64to16, trunc_64to32
```

These are generated by the decompose pass and are needed for proper byte/halfword handling.

### 2. Instruction Encoding Gaps (Priority: Medium)

```
Missing in cot1/arm64/asm.cot:
- UXTB (unsigned extend byte)
- UXTH (unsigned extend halfword)
- SXTB (signed extend byte)
- SXTH (signed extend halfword)
- SXTW (signed extend word to 64-bit)
```

### 3. Callee-Saved Register Handling (Priority: Low)

Zig saves/restores x19-x28 when used. cot1 avoids these registers entirely.
This works but limits register availability.

### 4. Float/SIMD Support (Priority: Future)

Neither Zig nor cot1 currently handles floating point.

---

## Architecture Comparison

### Zig (ARM64CodeGen)
```
ARM64CodeGen struct:
├── allocator: std.mem.Allocator
├── func: *const Func
├── type_reg: *const TypeRegistry
├── reg_state: [32]?*const Value
├── code: ArrayListUnmanaged(u8)
├── symbols: ArrayListUnmanaged(Symbol)
├── relocations: ArrayListUnmanaged(Relocation)
├── regalloc_state: *const RegAllocState
├── frame_size: u32
├── block_offsets: AutoHashMap(u32, u32)
├── branch_fixups: ArrayListUnmanaged(BranchFixup)
├── string_refs: ArrayListUnmanaged(StringRef)
├── func_refs: ArrayListUnmanaged(FuncRef)
└── line_entries: ArrayListUnmanaged(LineEntry)
```

### cot1 (GenState)
```
GenState struct:
├── func: *Func
├── code: *u8, code_count, code_cap
├── bstart: *i64, bstart_cap              // block_offsets equivalent
├── branches: *Branch, branches_count, branches_cap
├── call_sites: *CallSite, call_sites_count, call_sites_cap
├── line_entries: *u8, line_entries_count, line_entries_cap
├── line_offsets: *i64, line_count        // NEW: for O(1) posToLine
├── source: *u8, source_len
├── globals: *IRGlobal, globals_count
├── data: *u8, data_count, data_cap
├── global_reloc_offsets/indices: *i64    // parallel arrays
├── func_addr_reloc_*: *i64               // parallel arrays
├── string_reloc_*: *i64                  // parallel arrays
├── type_registry: *TypeRegistry
├── frame_size: i64
├── is_main: bool
├── crash_handler_offset: i64
├── crash_handler_emitted: bool
├── has_hidden_return: bool
└── hidden_ret_ptr_offset: i64
```

**Key Difference:** cot1 uses parallel arrays instead of struct arrays to avoid
complex pointer arithmetic. This is intentional for bootstrap simplicity.

---

## Testing

### Verified Working
- All 166 e2e tests pass
- Stage1 compiles stage2 (main.cot → cot1-stage2.o)
- Phase 4/5 completes in <100ms

### Known Issues
- RELOC ERR for `_Drive` functions (unrelated to codegen)
- Some debug info may be incomplete

---

## Performance Characteristics

### Before Fix (2026-01-26)
```
Phase 4/5: 101,410ms
  - codegen: 101,350ms
    - blockvals: 101,347ms
      - recordline: 101,381ms  ← O(n²) bottleneck
```

### After Fix
```
Phase 4/5: 88ms
  - codegen: 29ms
    - blockvals: 28ms
      - recordline: 9ms  ← O(log n) binary search
```

**Total compile time: 102s → 1.9s**

---

## Recommendations for 99% Parity

1. **Add missing extension/truncation ops** - Required for byte/halfword types
2. **Add const_nil handling** - Simple: MOV reg, #0
3. **Consider callee-saved registers** - Would improve register pressure
4. **Document all differences** - For future maintainers

Current estimate: **~85% parity**, can reach **95%** with extension ops.

// End-to-End Codegen Test
// Tests the full pipeline: SSA → genssa → Mach-O → executable
//
// This test:
// 1. Manually constructs an SSA function that returns 42
// 2. Runs genssa to generate machine code
// 3. Uses MachOWriter to create a Mach-O object file
// 4. Writes the object file to disk
// 5. Reports the result (linking/running done externally)
//
// Run with:
//   ./zig-out/bin/cot cot0/codegen/e2e_codegen_test.cot -o /tmp/e2e_codegen_test && /tmp/e2e_codegen_test
//   ld -o /tmp/return42 /tmp/return42.o -lSystem -syslibroot $(xcrun --show-sdk-path) -arch arm64
//   /tmp/return42; echo $?

import "genssa.cot"
import "../frontend/types.cot"
import "../obj/macho.cot"
import "../lib/stdlib.cot"

extern fn open(path: *u8, flags: i32, mode: i32) i32;
extern fn close(fd: i32) i32;

const O_WRONLY: i32 = 1;
const O_CREAT: i32 = 512;
const O_TRUNC: i32 = 1024;
const FILE_MODE: i32 = 438;  // 0o666 - BUG-032 fixed: variadic args now on stack

// Storage arrays for SSA construction
var g_ssa_blocks: [10]Block;
var g_ssa_values: [100]Value;
var g_ssa_locals: [10]Local;

// Storage arrays for genssa
var g_code: [4096]u8;
var g_bstart: [10]i64;
var g_branches: [10]Branch;

// Storage arrays for MachOWriter
var g_data: [1024]u8;
var g_symbols: [10]Symbol;
var g_strings: [1024]u8;
var g_relocs: [10]Reloc;
var g_output: [65536]u8;

fn main() i64 {
    print("End-to-End Codegen Test\n");
    print("=======================\n\n");

    // Phase 1: Build SSA function manually
    print("Phase 1: Build SSA function (return 42)\n");

    var f: Func = undefined;
    Func_init(&f, 0, 0, TYPE_I64,
              &g_ssa_blocks[0], 10,
              &g_ssa_values[0], 100,
              &g_ssa_locals[0], 10);

    // Create entry block
    let entry: i64 = Func_newEntryBlock(&f);

    // Create constant 42
    let const_val: *Value = Func_emitConstInt(&f, 42, TYPE_I64);
    const_val.reg = X0;  // Assign result to X0

    // Create return
    let ret_val: *Value = Func_emitReturn(&f, const_val);
    Func_emitReturnBlock(&f);

    print("  Created ");
    print(f.blocks_count);
    print(" block(s), ");
    print(f.values_count);
    print(" value(s)\n");

    // Phase 2: Generate machine code with genssa
    print("Phase 2: Generate machine code (genssa)\n");

    var gs: GenState = undefined;
    GenState_init(&gs, &f,
                  &g_code[0], 4096,
                  &g_bstart[0], 10,
                  &g_branches[0], 10);

    let genssa_result: i64 = GenState_generate(&gs);

    if genssa_result != 0 {
        print("  FAIL: genssa returned error\n");
        return 1;
    }

    print("  Generated ");
    print(gs.code_count);
    print(" bytes of machine code\n");

    // Phase 3: Create Mach-O object file
    print("Phase 3: Create Mach-O object file\n");

    var w: MachOWriter = undefined;
    macho_writer_init(&w,
                      &g_code[0], gs.code_count,  // Use genssa output as code
                      &g_data[0], 1024,
                      &g_symbols[0], 10,
                      &g_strings[0], 1024,
                      &g_relocs[0], 10,
                      &g_output[0], 65536);

    // Copy code from genssa to MachOWriter
    w.code_count = gs.code_count;

    // Add _main symbol at offset 0
    var main_name: [5]u8;
    main_name[0] = 95;   // '_'
    main_name[1] = 109;  // 'm'
    main_name[2] = 97;   // 'a'
    main_name[3] = 105;  // 'i'
    main_name[4] = 110;  // 'n'
    let main_idx: i64 = macho_add_symbol(&w, &main_name[0], 5, 0, SECT_TEXT, true);

    // Write Mach-O to output buffer
    let bytes: i64 = MachOWriter_write(&w);

    print("  Created ");
    print(bytes);
    print(" byte Mach-O object file\n");

    // Phase 4: Write object file to disk
    print("Phase 4: Write to /tmp/return42.o\n");

    var path: [18]u8;
    path[0] = 47;   // '/'
    path[1] = 116;  // 't'
    path[2] = 109;  // 'm'
    path[3] = 112;  // 'p'
    path[4] = 47;   // '/'
    path[5] = 114;  // 'r'
    path[6] = 101;  // 'e'
    path[7] = 116;  // 't'
    path[8] = 117;  // 'u'
    path[9] = 114;  // 'r'
    path[10] = 110; // 'n'
    path[11] = 52;  // '4'
    path[12] = 50;  // '2'
    path[13] = 46;  // '.'
    path[14] = 111; // 'o'
    path[15] = 0;   // null terminator

    let fd: i32 = open(&path[0], O_WRONLY | O_CREAT | O_TRUNC, FILE_MODE);
    if fd < 0 {
        print("  FAIL: Could not open output file\n");
        return 2;
    }

    let written: i64 = write(fd, &g_output[0], bytes);
    close(fd);

    if written != bytes {
        print("  FAIL: Write returned wrong byte count\n");
        return 3;
    }

    print("  Wrote ");
    print(written);
    print(" bytes to /tmp/return42.o\n");

    print("\nPhase 5: Link and run (do this manually):\n");
    print("  ld -o /tmp/return42 /tmp/return42.o -lSystem -syslibroot $(xcrun --show-sdk-path) -arch arm64\n");
    print("  /tmp/return42; echo $?\n");
    print("  Expected output: 42\n");

    print("\nAll phases completed successfully!\n");
    return 0;
}

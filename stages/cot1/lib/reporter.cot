// =============================================================================
// Error Reporter - Accumulate Multiple Errors
// =============================================================================
//
// Reference: src/frontend/errors.zig (Zig bootstrap)
// Reference: Go's cmd/compile/internal/base error handling
//
// Provides:
// - ErrorCode: categorized error codes
// - Error: error with position and message
// - ErrorReporter: accumulates and reports errors
//
// Unlike panic() which exits immediately, ErrorReporter:
// - Accumulates multiple errors
// - Continues compilation to find more errors
// - Reports all errors at the end
// - Follows Go's "report up to 10 errors then stop" pattern
//
// =============================================================================

import "stdlib.cot"
import "source.cot"

extern fn malloc(size: i64) *u8;
extern fn free(ptr: *u8);
extern fn exit(code: i32);

// =============================================================================
// Error Codes
// =============================================================================
//
// Error codes follow the convention:
// - 1xx: Scanner errors
// - 2xx: Parser errors
// - 3xx: Type errors
// - 4xx: Semantic errors

// Scanner errors (1xx)
const ERR_UNTERMINATED_STRING: i64 = 100;
const ERR_UNTERMINATED_CHAR: i64 = 101;
const ERR_INVALID_ESCAPE: i64 = 102;
const ERR_INVALID_NUMBER: i64 = 103;
const ERR_UNEXPECTED_CHAR: i64 = 104;

// Parser errors (2xx)
const ERR_UNEXPECTED_TOKEN: i64 = 200;
const ERR_EXPECTED_EXPR: i64 = 201;
const ERR_EXPECTED_TYPE: i64 = 202;
const ERR_EXPECTED_IDENT: i64 = 203;
const ERR_EXPECTED_LBRACE: i64 = 204;
const ERR_EXPECTED_RBRACE: i64 = 205;
const ERR_EXPECTED_LPAREN: i64 = 206;
const ERR_EXPECTED_RPAREN: i64 = 207;
const ERR_EXPECTED_SEMICOLON: i64 = 208;

// Type errors (3xx)
const ERR_TYPE_MISMATCH: i64 = 300;
const ERR_UNDEFINED_IDENT: i64 = 301;
const ERR_REDEFINED_IDENT: i64 = 302;
const ERR_INVALID_OP: i64 = 303;
const ERR_WRONG_ARG_COUNT: i64 = 304;
const ERR_NOT_CALLABLE: i64 = 305;
const ERR_FIELD_NOT_FOUND: i64 = 306;

// Semantic errors (4xx)
const ERR_BREAK_OUTSIDE_LOOP: i64 = 400;
const ERR_CONTINUE_OUTSIDE_LOOP: i64 = 401;
const ERR_RETURN_TYPE_MISMATCH: i64 = 402;
const ERR_MISSING_RETURN: i64 = 403;

// Get description for error code.
fn ErrorCode_description(code: i64) string {
    if code == ERR_UNTERMINATED_STRING { return "unterminated string literal"; }
    if code == ERR_UNTERMINATED_CHAR { return "unterminated character literal"; }
    if code == ERR_INVALID_ESCAPE { return "invalid escape sequence"; }
    if code == ERR_INVALID_NUMBER { return "invalid number literal"; }
    if code == ERR_UNEXPECTED_CHAR { return "unexpected character"; }
    if code == ERR_UNEXPECTED_TOKEN { return "unexpected token"; }
    if code == ERR_EXPECTED_EXPR { return "expected expression"; }
    if code == ERR_EXPECTED_TYPE { return "expected type"; }
    if code == ERR_EXPECTED_IDENT { return "expected identifier"; }
    if code == ERR_EXPECTED_LBRACE { return "expected '{'"; }
    if code == ERR_EXPECTED_RBRACE { return "expected '}'"; }
    if code == ERR_EXPECTED_LPAREN { return "expected '('"; }
    if code == ERR_EXPECTED_RPAREN { return "expected ')'"; }
    if code == ERR_EXPECTED_SEMICOLON { return "expected ';' or newline"; }
    if code == ERR_TYPE_MISMATCH { return "type mismatch"; }
    if code == ERR_UNDEFINED_IDENT { return "undefined identifier"; }
    if code == ERR_REDEFINED_IDENT { return "redefined identifier"; }
    if code == ERR_INVALID_OP { return "invalid operation"; }
    if code == ERR_WRONG_ARG_COUNT { return "wrong number of arguments"; }
    if code == ERR_NOT_CALLABLE { return "not callable"; }
    if code == ERR_FIELD_NOT_FOUND { return "field not found"; }
    if code == ERR_BREAK_OUTSIDE_LOOP { return "break outside loop"; }
    if code == ERR_CONTINUE_OUTSIDE_LOOP { return "continue outside loop"; }
    if code == ERR_RETURN_TYPE_MISMATCH { return "return type mismatch"; }
    if code == ERR_MISSING_RETURN { return "missing return"; }
    return "unknown error";
}

// =============================================================================
// Error Struct
// =============================================================================

// An error at a specific source location.
struct Error {
    offset: i64,      // Source position (byte offset)
    code: i64,        // Error code (0 = no code)
    msg: string,      // Error message
}

// Create error at position.
fn Error_at(offset: i64, msg: string) Error {
    return Error{
        .offset = offset,
        .code = 0,
        .msg = msg,
    };
}

// Create error with code.
fn Error_withCode(offset: i64, code: i64, msg: string) Error {
    return Error{
        .offset = offset,
        .code = code,
        .msg = msg,
    };
}

// =============================================================================
// Error Reporter
// =============================================================================

// Maximum number of errors to report before stopping.
// Following Go's pattern from cmd/compile/internal/base/print.go
const MAX_ERRORS: i64 = 10;

// Maximum number of errors to store.
const MAX_STORED_ERRORS: i64 = 64;

// Collects and reports errors during compilation.
struct ErrorReporter {
    src: *Source,           // Source for position lookup
    errors: *Error,         // Array of errors
    error_count: i64,       // Number of errors
    error_cap: i64,         // Capacity
    first_offset: i64,      // Offset of first error (-1 if none)
    suppressed: bool,       // True if we stopped reporting
}

impl ErrorReporter {
    // Initialize reporter.
    fn init(src: *Source) ErrorReporter {
        let errors: *Error = @ptrCast(*Error, malloc(MAX_STORED_ERRORS * 24));  // sizeof(Error) ~= 24
        return ErrorReporter{
            .src = src,
            .errors = errors,
            .error_count = 0,
            .error_cap = MAX_STORED_ERRORS,
            .first_offset = -1,
            .suppressed = false,
        };
    }

    // Free resources.
    fn deinit(self: *ErrorReporter) {
        if self.errors != null {
            free(@ptrCast(*u8, self.errors));
            self.errors = null;
        }
    }

    // Report an error at a position.
    fn errorAt(self: *ErrorReporter, offset: i64, msg: string) {
        self.report(Error_at(offset, msg));
    }

    // Report an error with code.
    fn errorWithCode(self: *ErrorReporter, offset: i64, code: i64, msg: string) {
        self.report(Error_withCode(offset, code, msg));
    }

    // Report an error.
    fn report(self: *ErrorReporter, err: Error) {
        // Track first error
        if self.first_offset < 0 {
            self.first_offset = err.offset;
        }

        // Store error if we have space
        if self.error_count < self.error_cap {
            (self.errors + self.error_count).* = err;
        }
        self.error_count = self.error_count + 1;

        // Stop reporting after MAX_ERRORS (Go pattern)
        if self.error_count > MAX_ERRORS {
            if not self.suppressed {
                self.suppressed = true;
                eprint("error: too many errors (");
                eprint(MAX_ERRORS);
                eprintln("), stopping");
            }
            return;
        }

        // Print error immediately
        self.printError(err);
    }

    // Print a single error.
    fn printError(self: *ErrorReporter, err: Error) {
        let pos: Position = self.src.position(err.offset);

        // Format: filename:line:column: error[Exxx]: message
        pos.print();
        eprint(": error");

        if err.code > 0 {
            eprint("[E");
            eprint(err.code);
            eprint("]");
        }

        eprint(": ");
        eprint(err.msg);
        eprintln("");

        // Show source context
        self.src.printErrorContext(err.offset);
    }

    // Check if any errors were reported.
    fn hasErrors(self: *ErrorReporter) bool {
        return self.error_count > 0;
    }

    // Get error count.
    fn errorCount(self: *ErrorReporter) i64 {
        return self.error_count;
    }

    // Print summary.
    fn printSummary(self: *ErrorReporter) {
        if self.error_count == 0 {
            return;
        }

        eprintln("");
        eprint(self.error_count);
        if self.error_count == 1 {
            eprintln(" error generated.");
        } else {
            eprintln(" errors generated.");
        }
    }
}

// =============================================================================
// Convenience Functions for Common Error Patterns
// =============================================================================

// Report "expected X" error.
fn ErrorReporter_unexpectedToken(reporter: *ErrorReporter, offset: i64, expected: string) {
    // Build message: "expected X"
    // For now, just use the expected string directly
    // In future, could build formatted message
    reporter.errorWithCode(offset, ERR_UNEXPECTED_TOKEN, expected);
}

// Report "undefined identifier 'X'" error.
fn ErrorReporter_undefinedIdent(reporter: *ErrorReporter, offset: i64, name: string) {
    reporter.errorWithCode(offset, ERR_UNDEFINED_IDENT, name);
}

// Report "type mismatch" error.
fn ErrorReporter_typeMismatch(reporter: *ErrorReporter, offset: i64, msg: string) {
    reporter.errorWithCode(offset, ERR_TYPE_MISMATCH, msg);
}

// Report "redefinition of 'X'" error.
fn ErrorReporter_redefinedIdent(reporter: *ErrorReporter, offset: i64, name: string) {
    reporter.errorWithCode(offset, ERR_REDEFINED_IDENT, name);
}

// Create an ErrorReporter (free function constructor).
fn ErrorReporter_new(src: *Source) ErrorReporter {
    let errors: *Error = @ptrCast(*Error, malloc(MAX_STORED_ERRORS * 24));  // sizeof(Error) ~= 24
    return ErrorReporter{
        .src = src,
        .errors = errors,
        .error_count = 0,
        .error_cap = MAX_STORED_ERRORS,
        .first_offset = -1,
        .suppressed = false,
    };
}

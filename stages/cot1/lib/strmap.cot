// StrMap - String to i64 hash map
// Reference: Go runtime/map.go
//
// This is a bootstrap implementation for cot1. In cot2 with generics,
// this becomes Map(K, V) where K: Hashable.
//
// Uses linear probing for collision resolution.
// Keys are copied on insert (map owns the memory).
// Returns -1 for not found.

extern fn memcpy(dest: *u8, src: *u8, n: i64) *u8;

// djb2 hash function (simpler, fits in i64)
// Reference: http://www.cse.yorku.ca/~oz/hash.html
fn djb2_hash(ptr: *u8, len: i64) i64 {
    debug.log_d(DebugPhase.check, "djb2_hash: len={d}", len);
    var hash: i64 = 5381;
    var i: i64 = 0;
    while i < len {
        let c: u8 = (ptr + i).*;
        // hash = hash * 33 + c
        hash = ((hash * 32) + hash) + @intCast(i64, c);
        i = i + 1;
    }
    // Ensure positive result for modulo operations
    if hash < 0 {
        hash = 0 - hash;
    }
    return hash;
}

// Map entry - stores copied key and value
struct StrMapEntry {
    key_ptr: *u8,      // Copied string data (owned by map)
    key_len: i64,
    value: i64,
    used: bool,
}

// String to i64 hash map
struct StrMap {
    entries: *StrMapEntry,
    count: i64,        // Number of entries used
    cap: i64,          // Total capacity (always power of 2)
}

impl StrMap {

    fn get(self: *StrMap, key_ptr: *u8, key_len: i64) i64 {
        debug.log_d(DebugPhase.check, "StrMap.get: key_len={d}", key_len);
        if self.cap == 0 { return -1; }
    
        let hash: i64 = djb2_hash(key_ptr, key_len);
        var idx: i64 = hash % self.cap;
    
        // Linear probe until we find key or empty slot
        var probes: i64 = 0;
        while probes < self.cap {
            let e: *StrMapEntry = self.entries + idx;
    
            if not e.used {
                // Empty slot - key not in map
                return -1;
            }
    
            if str_equal(e.key_ptr, e.key_len, key_ptr, key_len) {
                // Found it
                return e.value;
            }
    
            // Collision - try next slot
            idx = (idx + 1) % self.cap;
            probes = probes + 1;
        }
    
        // Table full (shouldn't happen with proper load factor)
        return -1;
    }

    fn grow(self: *StrMap) {
        let old_entries: *StrMapEntry = self.entries;
        let old_cap: i64 = self.cap;
    
        // Allocate new entries array (double size)
        let new_cap: i64 = old_cap * 2;
        self.entries = malloc_StrMapEntry(new_cap);
        self.cap = new_cap;
        self.count = 0;
    
        // Zero initialize new entries
        var i: i64 = 0;
        while i < new_cap {
            let e: *StrMapEntry = self.entries + i;
            e.key_ptr = null;
            e.key_len = 0;
            e.value = 0;
            e.used = false;
            i = i + 1;
        }
    
        // Reinsert all old entries
        i = 0;
        while i < old_cap {
            let old_e: *StrMapEntry = old_entries + i;
            if old_e.used {
                // Reuse the already-copied key
                let hash: i64 = djb2_hash(old_e.key_ptr, old_e.key_len);
                var idx: i64 = hash % new_cap;
    
                // Find empty slot
                while (self.entries + idx).used {
                    idx = (idx + 1) % new_cap;
                }
    
                let new_e: *StrMapEntry = self.entries + idx;
                new_e.key_ptr = old_e.key_ptr;
                new_e.key_len = old_e.key_len;
                new_e.value = old_e.value;
                new_e.used = true;
                self.count = self.count + 1;
            }
            i = i + 1;
        }
    
        // Note: old_entries is leaked (no free in bootstrap)
    }

    fn put(self: *StrMap, key_ptr: *u8, key_len: i64, value: i64) {
        debug.log_dd(DebugPhase.check, "StrMap.put: key_len={d} value={d}", key_len, value);
        // Check load factor - grow if > 70%
        let threshold: i64 = (self.cap * 70) / 100;
        if self.count >= threshold {
            self.grow();
        }
    
        let hash: i64 = djb2_hash(key_ptr, key_len);
        var idx: i64 = hash % self.cap;
    
        // Linear probe to find slot
        var probes: i64 = 0;
        while probes < self.cap {
            let e: *StrMapEntry = self.entries + idx;
    
            if not e.used {
                // Empty slot - insert here
                // Copy the key
                let key_copy: *u8 = malloc_u8(key_len);
                memcpy(key_copy, key_ptr, key_len);
    
                e.key_ptr = key_copy;
                e.key_len = key_len;
                e.value = value;
                e.used = true;
                self.count = self.count + 1;
                return;
            }
    
            if str_equal(e.key_ptr, e.key_len, key_ptr, key_len) {
                // Key exists - update value
                e.value = value;
                return;
            }
    
            // Collision - try next slot
            idx = (idx + 1) % self.cap;
            probes = probes + 1;
        }
    
        // Table full (shouldn't happen)
    }

    fn contains(self: *StrMap, key_ptr: *u8, key_len: i64) bool {
        return self.get(key_ptr, key_len) >= 0;
    }

}

// Typed malloc for StrMapEntry array
extern fn malloc_StrMapEntry(count: i64) *StrMapEntry;

// Initialize an empty map with given capacity
fn StrMap_init(initial_cap: i64) StrMap {
    debug.log_d(DebugPhase.check, "StrMap_init: cap={d}", initial_cap);
    var m: StrMap = undefined;

    // Round up to power of 2
    var cap: i64 = 16;
    while cap < initial_cap {
        cap = cap * 2;
    }

    // Allocate entries array
    m.entries = malloc_StrMapEntry(cap);

    // Zero initialize all entries
    var i: i64 = 0;
    while i < cap {
        let e: *StrMapEntry = m.entries + i;
        e.key_ptr = null;
        e.key_len = 0;
        e.value = 0;
        e.used = false;
        i = i + 1;
    }

    m.count = 0;
    m.cap = cap;
    return m;
}

// Compare two strings for equality
fn str_equal(a_ptr: *u8, a_len: i64, b_ptr: *u8, b_len: i64) bool {
    debug.log_dd(DebugPhase.check, "str_equal: a_len={d} b_len={d}", a_len, b_len);
    if a_len != b_len { return false; }
    var i: i64 = 0;
    while i < a_len {
        if (a_ptr + i).* != (b_ptr + i).* {
            return false;
        }
        i = i + 1;
    }
    return true;
}

// Get value for key, returns -1 if not found

// Internal: grow the map to double capacity

// Put key-value pair into map
// Key is copied - caller doesn't need to keep it alive

// Check if map contains key

// Typed malloc for u8 (for key copies)
extern fn malloc_u8(size: i64) *u8;

// ============================================================================
// Inline Tests
// ============================================================================

test "djb2 hash returns positive value" {
    let s: string = "hello"
    let h: i64 = djb2_hash(s.ptr, s.len)
    @assert(h > 0)
}

test "djb2 same input same hash" {
    let s1: string = "test"
    let s2: string = "test"
    @assert(djb2_hash(s1.ptr, s1.len) == djb2_hash(s2.ptr, s2.len))
}

test "djb2 different input different hash" {
    let s1: string = "foo"
    let s2: string = "bar"
    @assert(djb2_hash(s1.ptr, s1.len) != djb2_hash(s2.ptr, s2.len))
}

test "str_equal same strings" {
    let s1: string = "hello"
    let s2: string = "hello"
    @assert(str_equal(s1.ptr, s1.len, s2.ptr, s2.len))
}

test "str_equal different strings" {
    let s1: string = "hello"
    let s2: string = "world"
    @assert(!str_equal(s1.ptr, s1.len, s2.ptr, s2.len))
}

test "str_equal different lengths" {
    let s1: string = "hi"
    let s2: string = "hello"
    @assert(!str_equal(s1.ptr, s1.len, s2.ptr, s2.len))
}

test "strmap init creates empty map" {
    var m: StrMap = StrMap_init(16)
    @assert(m.count == 0)
    @assert(m.cap >= 16)
}

test "strmap put and get" {
    var m: StrMap = StrMap_init(16)
    let key: string = "mykey"
    m.put(key.ptr, key.len, 42)
    @assert(m.get(key.ptr, key.len) == 42)
}

test "strmap get missing returns -1" {
    var m: StrMap = StrMap_init(16)
    let key: string = "missing"
    @assert(m.get(key.ptr, key.len) == -1)
}

test "strmap contains" {
    var m: StrMap = StrMap_init(16)
    let key: string = "exists"
    @assert(!m.contains(key.ptr, key.len))
    m.put(key.ptr, key.len, 1)
    @assert(m.contains(key.ptr, key.len))
}

test "strmap update existing key" {
    var m: StrMap = StrMap_init(16)
    let key: string = "key"
    m.put(key.ptr, key.len, 100)
    @assert(m.get(key.ptr, key.len) == 100)
    m.put(key.ptr, key.len, 200)
    @assert(m.get(key.ptr, key.len) == 200)
    @assert(m.count == 1)  // Still only one entry
}

test "strmap multiple keys" {
    var m: StrMap = StrMap_init(16)
    let k1: string = "one"
    let k2: string = "two"
    let k3: string = "three"
    m.put(k1.ptr, k1.len, 1)
    m.put(k2.ptr, k2.len, 2)
    m.put(k3.ptr, k3.len, 3)
    @assert(m.count == 3)
    @assert(m.get(k1.ptr, k1.len) == 1)
    @assert(m.get(k2.ptr, k2.len) == 2)
    @assert(m.get(k3.ptr, k3.len) == 3)
}

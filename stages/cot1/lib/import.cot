// Import Processing Module
// Handles recursive file import parsing, path resolution, and cycle detection.
//
// Reference: src/driver.zig parseFileRecursive()
// Reference: Go's cmd/compile/internal/noder LoadPackage pattern
//
// This module manages:
// - Tracking which files have been imported (cycle detection)
// - Resolving relative import paths (including ".." handling)
// - Parsing imported files recursively
// - Adjusting node source positions after import

import "stdlib.cot"

// Import AST types (NodePool, Node, NodeKind)
import "../frontend/ast.cot"

// ============================================================================
// External Dependencies
// ============================================================================

extern fn malloc_u8(count: i64) *u8;
extern fn malloc_i64(count: i64) *i64;

// OS realpath - resolves symlinks and normalizes ".." and "." components
// Returns the length of the resolved path, or copies original path on failure
extern fn cot_realpath(path: *u8, path_len: i64, out_buf: *u8, out_buf_cap: i64) i64;

// ============================================================================
// Constants
// ============================================================================

const IMPORT_MAX_PATHS: i64 = 100;
const IMPORT_MAX_PATH_LEN: i64 = 1024;  // Increased to support realpath (requires 1024)

// O_RDONLY is provided by safe_io.cot which is imported before this module

// ============================================================================
// Module Storage (self-allocated)
// ============================================================================

var im_paths: *u8 = null;           // Flat buffer for all paths
var im_paths_cap: i64 = 0;
var im_path_lens: *i64 = null;      // Length of each path
var im_path_lens_cap: i64 = 0;
var im_count: i64 = 0;              // Number of imported paths

var im_base_dir: *u8 = null;        // Base directory for relative imports
var im_base_dir_cap: i64 = 0;
var im_base_dir_len: i64 = 0;

var im_path_buf: *u8 = null;        // Temp buffer for building paths
var im_path_buf_cap: i64 = 0;

var im_importing_dir: *u8 = null;   // Directory of currently importing file
var im_importing_dir_cap: i64 = 0;
var im_importing_dir_len: i64 = 0;

var im_realpath_buf: *u8 = null;    // Temp buffer for realpath canonicalization
var im_realpath_buf_cap: i64 = 0;

var im_storage_initialized: bool = false;

// ============================================================================
// Storage Allocation
// ============================================================================

fn Import_allocateStorage() {
    if im_storage_initialized {
        return;
    }

    im_paths_cap = IMPORT_MAX_PATHS * IMPORT_MAX_PATH_LEN;
    im_paths = malloc_u8(im_paths_cap);
    if im_paths == null {
        print("Import_allocateStorage: malloc failed for im_paths\n");
        return;
    }

    im_path_lens_cap = IMPORT_MAX_PATHS;
    im_path_lens = malloc_i64(im_path_lens_cap);
    if im_path_lens == null {
        print("Import_allocateStorage: malloc failed for im_path_lens\n");
        return;
    }

    im_base_dir_cap = IMPORT_MAX_PATH_LEN;
    im_base_dir = malloc_u8(im_base_dir_cap);
    if im_base_dir == null {
        print("Import_allocateStorage: malloc failed for im_base_dir\n");
        return;
    }

    im_path_buf_cap = IMPORT_MAX_PATH_LEN;
    im_path_buf = malloc_u8(im_path_buf_cap);
    if im_path_buf == null {
        print("Import_allocateStorage: malloc failed for im_path_buf\n");
        return;
    }

    im_importing_dir_cap = IMPORT_MAX_PATH_LEN;
    im_importing_dir = malloc_u8(im_importing_dir_cap);
    if im_importing_dir == null {
        print("Import_allocateStorage: malloc failed for im_importing_dir\n");
        return;
    }

    im_realpath_buf_cap = IMPORT_MAX_PATH_LEN;
    im_realpath_buf = malloc_u8(im_realpath_buf_cap);
    if im_realpath_buf == null {
        print("Import_allocateStorage: malloc failed for im_realpath_buf\n");
        return;
    }

    im_storage_initialized = true;
}

// Initialize import tracking for a new compilation
fn Import_init() {
    Import_allocateStorage();
    im_count = 0;
    im_base_dir_len = 0;
    im_importing_dir_len = 0;
}

// ============================================================================
// Path Tracking (Cycle Detection)
// ============================================================================

// Check if a path has already been imported
fn Import_isPathImported(path: *u8, path_len: i64) bool {
    // Null checks
    if im_paths == null or im_path_lens == null or path == null {
        return false;
    }

    var i: i64 = 0;
    while i < im_count {
        let stored_len_ptr: *i64 = im_path_lens + i;
        let stored_len: i64 = stored_len_ptr.*;
        if stored_len == path_len {
            // Compare paths
            let stored_path: *u8 = im_paths + (i * IMPORT_MAX_PATH_LEN);
            var match: bool = true;
            var j: i64 = 0;
            while j < path_len {
                let c1: *u8 = stored_path + j;
                let c2: *u8 = path + j;
                if c1.* != c2.* {
                    match = false;
                }
                j = j + 1;
            }
            if match {
                return true;
            }
        }
        i = i + 1;
    }
    return false;
}

// Add a path to the imported list
fn Import_addPath(path: *u8, path_len: i64) {
    // Null checks
    if im_paths == null or im_path_lens == null or path == null {
        return;
    }
    if im_count >= IMPORT_MAX_PATHS {
        return;
    }
    let dest: *u8 = im_paths + (im_count * IMPORT_MAX_PATH_LEN);
    var i: i64 = 0;
    while i < path_len and i < IMPORT_MAX_PATH_LEN {
        let src_c: *u8 = path + i;
        let dst_c: *u8 = dest + i;
        dst_c.* = src_c.*;
        i = i + 1;
    }
    let len_ptr: *i64 = im_path_lens + im_count;
    len_ptr.* = path_len;
    im_count = im_count + 1;
}

// ============================================================================
// Path Resolution
// ============================================================================

// Extract directory from a file path (everything before last '/')
fn Import_extractBaseDir(path: *u8, path_len: i64) {
    // Find last '/' in path
    var last_slash: i64 = -1;
    var i: i64 = 0;
    while i < path_len {
        let c: *u8 = path + i;
        if c.* == 47 {  // '/'
            last_slash = i;
        }
        i = i + 1;
    }

    if last_slash < 0 {
        // No directory component
        im_base_dir_len = 0;
        return;
    }

    // Copy directory part including the slash
    i = 0;
    while i <= last_slash and i < im_base_dir_cap {
        let src: *u8 = path + i;
        (im_base_dir + i).* = src.*;
        i = i + 1;
    }
    im_base_dir_len = last_slash + 1;
}

// Get the base directory pointer and length
fn Import_getBaseDir() *u8 {
    return im_base_dir;
}

fn Import_getBaseDirLen() i64 {
    return im_base_dir_len;
}

// Build full path: base_dir + import_path (simple concatenation)
// Result stored in im_path_buf
fn Import_buildPath(import_path: *u8, import_path_len: i64) i64 {
    var result_len: i64 = 0;

    // Copy base directory
    var i: i64 = 0;
    while i < im_base_dir_len and result_len < IMPORT_MAX_PATH_LEN {
        (im_path_buf + result_len).* = (im_base_dir + i).*;
        result_len = result_len + 1;
        i = i + 1;
    }

    // Copy import path
    i = 0;
    while i < import_path_len and result_len < IMPORT_MAX_PATH_LEN {
        let c: *u8 = import_path + i;
        (im_path_buf + result_len).* = c.*;
        result_len = result_len + 1;
        i = i + 1;
    }

    // Null terminate
    (im_path_buf + result_len).* = 0;
    return result_len;
}

// Resolve an import path relative to a base directory using OS realpath
// This properly handles symlinks, "..", ".", and produces canonical absolute paths
// Result stored in im_path_buf, returns length
fn Import_resolvePath(base_dir: *u8, base_len: i64, rel_path: *u8, rel_len: i64) i64 {
    // Null checks - critical for preventing crashes
    if im_path_buf == null {
        print("Import_resolvePath: im_path_buf is null\n");
        return 0;
    }
    if base_dir == null {
        print("Import_resolvePath: base_dir is null\n");
        return 0;
    }
    if rel_path == null {
        print("Import_resolvePath: rel_path is null\n");
        return 0;
    }

    // Step 1: Build joined path (base_dir + rel_path) in im_path_buf
    var joined_len: i64 = 0;
    var i: i64 = 0;

    // Copy base_dir
    while i < base_len and joined_len < IMPORT_MAX_PATH_LEN - 1 {
        let c: *u8 = base_dir + i;
        (im_path_buf + joined_len).* = c.*;
        joined_len = joined_len + 1;
        i = i + 1;
    }

    // Copy rel_path
    i = 0;
    while i < rel_len and joined_len < IMPORT_MAX_PATH_LEN - 1 {
        let c: *u8 = rel_path + i;
        (im_path_buf + joined_len).* = c.*;
        joined_len = joined_len + 1;
        i = i + 1;
    }

    // Null-terminate the joined path
    (im_path_buf + joined_len).* = 0;

    // Step 2: Use OS realpath to canonicalize (resolves symlinks, "..", ".", etc.)
    // We need a temporary buffer since realpath writes to output
    if im_realpath_buf == null {
        // Fallback: return joined path without canonicalization
        return joined_len;
    }

    // Call cot_realpath - it handles all edge cases via OS
    let canonical_len: i64 = cot_realpath(im_path_buf, joined_len, im_realpath_buf, IMPORT_MAX_PATH_LEN);

    if canonical_len <= 0 {
        // realpath failed, return the joined path as-is
        return joined_len;
    }

    // Copy canonical path back to im_path_buf
    i = 0;
    while i < canonical_len and i < IMPORT_MAX_PATH_LEN - 1 {
        (im_path_buf + i).* = (im_realpath_buf + i).*;
        i = i + 1;
    }
    (im_path_buf + canonical_len).* = 0;

    return canonical_len;
}

// Get the resolved path buffer
fn Import_getPathBuf() *u8 {
    return im_path_buf;
}

// Extract directory from a full path (everything up to and including last '/')
// Returns the length of the directory portion
fn Import_getDirFromPath(path: *u8, path_len: i64, out_dir: *u8, max_len: i64) i64 {
    var last_slash: i64 = -1;
    var i: i64 = 0;
    while i < path_len {
        let c: *u8 = path + i;
        if c.* == 47 {  // '/'
            last_slash = i;
        }
        i = i + 1;
    }

    if last_slash < 0 {
        return 0;
    }

    // Copy up to and including the slash
    i = 0;
    while i <= last_slash and i < max_len {
        let c: *u8 = path + i;
        let d: *u8 = out_dir + i;
        d.* = c.*;
        i = i + 1;
    }
    return last_slash + 1;
}

// ============================================================================
// Node Position Adjustment
// ============================================================================

// Adjust source positions in newly parsed nodes to be absolute in combined source
// This is needed because the parser reports positions relative to the string slice
// it was given, but we need absolute positions for the combined source buffer.
fn Import_adjustNodePositions(pool: *NodePool, start_idx: i64, end_idx: i64, offset: i64) {
    var i: i64 = start_idx;
    while i < end_idx {
        let node: *Node = pool.nodes + i;

        // Adjust source span (all nodes have these)
        node.start = node.start + offset;
        node.end = node.end + offset;

        // Adjust kind-specific position fields
        // These are fields that contain source positions (not indices or values)
        if node.kind == NodeKind.Ident {
            // field0 = name_start (source position)
            node.field0 = node.field0 + offset;
        } else if node.kind == NodeKind.FnDecl {
            // field0 = name_start
            node.field0 = node.field0 + offset;
        } else if node.kind == NodeKind.ExternFnDecl {
            // field0 = name_start
            node.field0 = node.field0 + offset;
        } else if node.kind == NodeKind.VarDecl {
            // field0 = is_let, field1 = name_start, field2 = name_len
            node.field1 = node.field1 + offset;
        } else if node.kind == NodeKind.ConstDecl {
            // field0 = name_start
            node.field0 = node.field0 + offset;
        } else if node.kind == NodeKind.ImportDecl {
            // field0 = path_start
            node.field0 = node.field0 + offset;
        } else if node.kind == NodeKind.StructDecl {
            // field0 = name_start
            node.field0 = node.field0 + offset;
        } else if node.kind == NodeKind.EnumDecl {
            // field0 = name_start
            node.field0 = node.field0 + offset;
        } else if node.kind == NodeKind.FieldDecl {
            // field0 = name_start
            // Note: field2 is type_handle (not a source position)
            node.field0 = node.field0 + offset;
        } else if node.kind == NodeKind.StringLit {
            // field0 = content_start (source position of string content)
            node.field0 = node.field0 + offset;
        } else if node.kind == NodeKind.ParamDecl {
            // field0 = name_start (source position)
            node.field0 = node.field0 + offset;
        } else if node.kind == NodeKind.GlobalVarDecl {
            // field0 = is_mutable, field1 = name_start, field2 = name_len
            node.field1 = node.field1 + offset;
        } else if node.kind == NodeKind.FieldInit {
            // field0 = field_name_start (source position)
            node.field0 = node.field0 + offset;
        } else if node.kind == NodeKind.StructLit {
            // field0 = type_name_start (source position)
            node.field0 = node.field0 + offset;
        } else if node.kind == NodeKind.FieldAccess {
            // field1 = field_name_start (source position)
            node.field1 = node.field1 + offset;
        } else if node.kind == NodeKind.TypeExprNamed {
            // field0 = name_start (source position), field1 = name_len (not adjusted)
            node.field0 = node.field0 + offset;
        } else if node.kind == NodeKind.BuiltinCall {
            // field0 = name_start (source position after @)
            node.field0 = node.field0 + offset;
        } else if node.kind == NodeKind.ImplBlock {
            // field0 = type_name_start (source position - needs adjustment!)
            // field1 = type_name_len (not a position)
            // field2 = methods_start (children index - not a position)
            // field3 = methods_count (not a position)
            node.field0 = node.field0 + offset;
        } else if node.kind == NodeKind.ForStmt {
            // field0 = binding_start (loop variable name - source position)
            node.field0 = node.field0 + offset;
        } else if node.kind == NodeKind.TypeAliasDecl {
            // field0 = name_start (alias name - source position)
            node.field0 = node.field0 + offset;
        }

        i = i + 1;
    }
}

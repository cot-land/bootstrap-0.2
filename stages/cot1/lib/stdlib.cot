// Cot0 Standard Library
// Basic functions: len, print, println, eprint, eprintln, write
// Import this file to get these utilities
//
// Note: print/println/eprint/eprintln work with both strings and integers.
// The compiler detects the argument type and generates appropriate code:
// - For strings: calls write() with the string ptr/len
// - For integers: calls __print_int/__eprint_int runtime functions

extern fn write(fd: i32, buf: *u8, count: i64) i64;
extern fn get_time_ns() i64;

// Generic sized allocation - use @sizeOf(T) to compute struct sizes at compile time
// This avoids hardcoded sizes in the runtime which can become mismatched
extern fn malloc_sized(count: i64, struct_size: i64) *u8;
extern fn realloc_sized(ptr: *u8, old_count: i64, new_count: i64, struct_size: i64) *u8;

// Length of a string
// Note: For string literals, this is computed at compile time by the Zig compiler
// For cot0-stage1, we need runtime support
fn len(s: string) i64 {
    return s.len;
}

// Print a string to stdout (no newline)
fn print(s: string) {
    write(1, s.ptr, s.len);
}

// Print a string to stdout with newline
fn println(s: string) {
    print(s);
    var nl: u8 = 10;
    write(1, &nl, 1);
}

// Print a string to stderr (no newline)
fn eprint(s: string) {
    write(2, s.ptr, s.len);
}

// Print a string to stderr with newline
fn eprintln(s: string) {
    eprint(s);
    var nl: u8 = 10;
    write(2, &nl, 1);
}

// ============================================================================
// Inline Tests
// ============================================================================

test "len returns string length" {
    @assert(len("hello") == 5)
    @assert(len("") == 0)
    @assert(len("x") == 1)
}

test "len of literal with escape" {
    @assert(len("a\nb") == 3)
    @assert(len("\t") == 1)
}

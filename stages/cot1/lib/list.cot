// Cot0 Dynamic List Implementation
// Follows Zig's ArrayListUnmanaged pattern:
// - List struct holds data, count, capacity
// - Functions take list pointer
// - Growth via realloc when needed

// Memory allocation functions that zero memory (prevents non-deterministic behavior)
extern fn malloc_i64(count: i64) *i64;
extern fn realloc_i64(ptr: *i64, old_count: i64, new_count: i64) *i64;
extern fn free_i64(ptr: *i64);

// ============================================================================
// i64 List (for node indices, children, etc.)
// ============================================================================

struct I64List {
    items: *i64,    // Pointer to i64 array
    count: i64,
    capacity: i64,
}

fn i64list_init(list: *I64List) {
    list.items = null;
    list.count = 0;
    list.capacity = 0;
}

fn i64list_deinit(list: *I64List) {
    if list.items != null {
        free_i64(list.items);
    }
    list.items = null;
    list.count = 0;
    list.capacity = 0;
}

fn i64list_ensure_capacity(list: *I64List, needed: i64) {
    if list.capacity >= needed {
        return;
    }

    // Calculate new capacity (at least double, or needed)
    var new_cap: i64 = 8;
    if list.capacity > 0 {
        new_cap = list.capacity * 2;
    }
    while new_cap < needed {
        new_cap = new_cap * 2;
    }

    // Allocate or reallocate (using zeroing allocators)
    if list.items == null {
        list.items = malloc_i64(new_cap);
    } else {
        list.items = realloc_i64(list.items, list.capacity, new_cap);
    }
    list.capacity = new_cap;
}

fn i64list_append(list: *I64List, value: i64) {
    i64list_ensure_capacity(list, list.count + 1);
    let ptr: *i64 = list.items + list.count;
    ptr.* = value;
    list.count = list.count + 1;
}

fn i64list_get(list: *I64List, index: i64) i64 {
    let ptr: *i64 = list.items + index;
    return ptr.*;
}

fn i64list_set(list: *I64List, index: i64, value: i64) {
    let ptr: *i64 = list.items + index;
    ptr.* = value;
}

fn i64list_pop(list: *I64List) i64 {
    list.count = list.count - 1;
    let ptr: *i64 = list.items + list.count;
    return ptr.*;
}

fn i64list_clear(list: *I64List) {
    list.count = 0;
}

// Get number of items in list
fn i64list_len(list: *I64List) i64 {
    return list.count;
}

// Check if list is empty
fn i64list_isEmpty(list: *I64List) bool {
    return list.count == 0;
}

// ============================================================================
// u8 List (for code buffers, source, output)
// ============================================================================

extern fn malloc_u8(size: i64) *u8;
extern fn realloc_u8(ptr: *u8, old_size: i64, new_size: i64) *u8;
extern fn free_u8(ptr: *u8);

extern fn malloc_i64(count: i64) *i64;
extern fn realloc_i64(ptr: *i64, old_count: i64, new_count: i64) *i64;
extern fn free_i64(ptr: *i64);

struct U8List {
    items: *u8,
    count: i64,
    capacity: i64,
}

fn u8list_init(list: *U8List) {
    list.items = null;
    list.count = 0;
    list.capacity = 0;
}

fn u8list_init_cap(list: *U8List, initial_cap: i64) {
    list.count = 0;
    list.capacity = initial_cap;
    list.items = malloc_u8(initial_cap);
}

fn u8list_deinit(list: *U8List) {
    if list.items != null {
        free_u8(list.items);
    }
    list.items = null;
    list.count = 0;
    list.capacity = 0;
}

fn u8list_ensure_capacity(list: *U8List, needed: i64) {
    if list.capacity >= needed {
        return;
    }
    var new_cap: i64 = 256;
    if list.capacity > 0 {
        new_cap = list.capacity * 2;
    }
    while new_cap < needed {
        new_cap = new_cap * 2;
    }
    if list.items == null {
        list.items = malloc_u8(new_cap);
    } else {
        list.items = realloc_u8(list.items, list.capacity, new_cap);
    }
    list.capacity = new_cap;
}

fn u8list_append(list: *U8List, value: u8) {
    u8list_ensure_capacity(list, list.count + 1);
    let ptr: *u8 = list.items + list.count;
    ptr.* = value;
    list.count = list.count + 1;
}

fn u8list_get(list: *U8List, index: i64) u8 {
    let ptr: *u8 = list.items + index;
    return ptr.*;
}

fn u8list_set(list: *U8List, index: i64, value: u8) {
    let ptr: *u8 = list.items + index;
    ptr.* = value;
}

// ============================================================================
// Inline Tests
// ============================================================================

test "i64list init sets empty state" {
    var list: I64List
    i64list_init(&list)
    @assert(list.count == 0)
    @assert(list.capacity == 0)
    @assert(list.items == null)
}

test "i64list isEmpty on empty list" {
    var list: I64List
    i64list_init(&list)
    @assert(i64list_isEmpty(&list))
    @assert(i64list_len(&list) == 0)
}

test "i64list append and get" {
    var list: I64List
    i64list_init(&list)
    i64list_append(&list, 42)
    i64list_append(&list, 7)
    i64list_append(&list, 99)
    @assert(list.count == 3)
    @assert(i64list_get(&list, 0) == 42)
    @assert(i64list_get(&list, 1) == 7)
    @assert(i64list_get(&list, 2) == 99)
}

test "i64list set modifies value" {
    var list: I64List
    i64list_init(&list)
    i64list_append(&list, 1)
    i64list_append(&list, 2)
    i64list_set(&list, 0, 100)
    i64list_set(&list, 1, 200)
    @assert(i64list_get(&list, 0) == 100)
    @assert(i64list_get(&list, 1) == 200)
}

test "i64list pop returns last element" {
    var list: I64List
    i64list_init(&list)
    i64list_append(&list, 10)
    i64list_append(&list, 20)
    i64list_append(&list, 30)
    @assert(i64list_pop(&list) == 30)
    @assert(list.count == 2)
    @assert(i64list_pop(&list) == 20)
    @assert(list.count == 1)
}

test "i64list clear resets count" {
    var list: I64List
    i64list_init(&list)
    i64list_append(&list, 1)
    i64list_append(&list, 2)
    i64list_append(&list, 3)
    @assert(list.count == 3)
    i64list_clear(&list)
    @assert(list.count == 0)
    @assert(i64list_isEmpty(&list))
}

test "i64list capacity growth" {
    var list: I64List
    i64list_init(&list)
    // Append more than initial capacity to trigger growth
    var i: i64 = 0
    while i < 20 {
        i64list_append(&list, i)
        i = i + 1
    }
    @assert(list.count == 20)
    @assert(list.capacity >= 20)
    @assert(i64list_get(&list, 0) == 0)
    @assert(i64list_get(&list, 19) == 19)
}

test "u8list init sets empty state" {
    var list: U8List
    u8list_init(&list)
    @assert(list.count == 0)
    @assert(list.capacity == 0)
    @assert(list.items == null)
}

test "u8list append and get" {
    var list: U8List
    u8list_init(&list)
    u8list_append(&list, 65)  // 'A'
    u8list_append(&list, 66)  // 'B'
    u8list_append(&list, 67)  // 'C'
    @assert(list.count == 3)
    @assert(u8list_get(&list, 0) == 65)
    @assert(u8list_get(&list, 1) == 66)
    @assert(u8list_get(&list, 2) == 67)
}

test "u8list set modifies value" {
    var list: U8List
    u8list_init(&list)
    u8list_append(&list, 0)
    u8list_set(&list, 0, 255)
    @assert(u8list_get(&list, 0) == 255)
}

// Cot0 Dynamic List Implementation
// Follows Zig's ArrayListUnmanaged pattern:
// - List struct holds data, count, capacity
// - Functions take list pointer
// - Growth via realloc when needed

// Memory allocation functions that zero memory (prevents non-deterministic behavior)
extern fn malloc_i64(count: i64) *i64;
extern fn realloc_i64(ptr: *i64, old_count: i64, new_count: i64) *i64;
extern fn free_i64(ptr: *i64);

// ============================================================================
// i64 List (for node indices, children, etc.)
// ============================================================================

struct I64List {
    items: *i64,    // Pointer to i64 array
    count: i64,
    capacity: i64,
}

fn i64list_init(list: *I64List) {
    list.items = null;
    list.count = 0;
    list.capacity = 0;
}

fn i64list_deinit(list: *I64List) {
    if list.items != null {
        free_i64(list.items);
    }
    list.items = null;
    list.count = 0;
    list.capacity = 0;
}

fn i64list_ensure_capacity(list: *I64List, needed: i64) {
    if list.capacity >= needed {
        return;
    }

    // Calculate new capacity (at least double, or needed)
    var new_cap: i64 = 8;
    if list.capacity > 0 {
        new_cap = list.capacity * 2;
    }
    while new_cap < needed {
        new_cap = new_cap * 2;
    }

    // Allocate or reallocate (using zeroing allocators)
    if list.items == null {
        list.items = malloc_i64(new_cap);
    } else {
        list.items = realloc_i64(list.items, list.capacity, new_cap);
    }
    list.capacity = new_cap;
}

fn i64list_append(list: *I64List, value: i64) {
    i64list_ensure_capacity(list, list.count + 1);
    let ptr: *i64 = list.items + list.count;
    ptr.* = value;
    list.count = list.count + 1;
}

fn i64list_get(list: *I64List, index: i64) i64 {
    let ptr: *i64 = list.items + index;
    return ptr.*;
}

fn i64list_set(list: *I64List, index: i64, value: i64) {
    let ptr: *i64 = list.items + index;
    ptr.* = value;
}

fn i64list_pop(list: *I64List) i64 {
    list.count = list.count - 1;
    let ptr: *i64 = list.items + list.count;
    return ptr.*;
}

fn i64list_clear(list: *I64List) {
    list.count = 0;
}

// Get number of items in list
fn i64list_len(list: *I64List) i64 {
    return list.count;
}

// Check if list is empty
fn i64list_isEmpty(list: *I64List) bool {
    return list.count == 0;
}

// ============================================================================
// u8 List (for code buffers, source, output)
// ============================================================================

extern fn malloc_u8(size: i64) *u8;
extern fn realloc_u8(ptr: *u8, old_size: i64, new_size: i64) *u8;
extern fn free_u8(ptr: *u8);

extern fn malloc_i64(count: i64) *i64;
extern fn realloc_i64(ptr: *i64, old_count: i64, new_count: i64) *i64;
extern fn free_i64(ptr: *i64);

struct U8List {
    items: *u8,
    count: i64,
    capacity: i64,
}

fn u8list_init(list: *U8List) {
    list.items = null;
    list.count = 0;
    list.capacity = 0;
}

fn u8list_init_cap(list: *U8List, initial_cap: i64) {
    list.count = 0;
    list.capacity = initial_cap;
    list.items = malloc_u8(initial_cap);
}

fn u8list_deinit(list: *U8List) {
    if list.items != null {
        free_u8(list.items);
    }
    list.items = null;
    list.count = 0;
    list.capacity = 0;
}

fn u8list_ensure_capacity(list: *U8List, needed: i64) {
    if list.capacity >= needed {
        return;
    }
    var new_cap: i64 = 256;
    if list.capacity > 0 {
        new_cap = list.capacity * 2;
    }
    while new_cap < needed {
        new_cap = new_cap * 2;
    }
    if list.items == null {
        list.items = malloc_u8(new_cap);
    } else {
        list.items = realloc_u8(list.items, list.capacity, new_cap);
    }
    list.capacity = new_cap;
}

fn u8list_append(list: *U8List, value: u8) {
    u8list_ensure_capacity(list, list.count + 1);
    let ptr: *u8 = list.items + list.count;
    ptr.* = value;
    list.count = list.count + 1;
}

fn u8list_get(list: *U8List, index: i64) u8 {
    let ptr: *u8 = list.items + index;
    return ptr.*;
}

fn u8list_set(list: *U8List, index: i64, value: u8) {
    let ptr: *u8 = list.items + index;
    ptr.* = value;
}

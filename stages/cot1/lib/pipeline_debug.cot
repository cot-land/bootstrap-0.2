// =============================================================================
// Pipeline Debug Infrastructure
// =============================================================================
//
// Matches the Zig compiler's src/pipeline_debug.zig EXACTLY.
//
// Usage:
//   COT_DEBUG=parse,lower,ssa,regalloc  - Enable specific phases
//   COT_DEBUG=all                        - Enable all debug output
//   COT_TRACE=funcname                   - Trace a specific function
//
// API (matches Zig):
//   debug.log(.lower, "message")
//   debug.log(.lower, "value = {d}", value)
//   debug.log(.lower, "name = '{s}'", name_ptr, name_len)
//
// =============================================================================

import "stdlib.cot"

// Write syscall
extern fn write(fd: i32, buf: *u8, count: i64) i64;
extern fn getenv(name: *u8) *u8;

// =============================================================================
// Phase Enum (matches Zig's Phase enum)
// =============================================================================

enum DebugPhase {
    parse,
    check,
    lower,
    ssa,
    schedule,
    regalloc,
    codegen,
    strings,
    abi,
}

// =============================================================================
// Debug Struct with log method (matches Zig's debug.log API)
// =============================================================================

struct Debug {
    parse: bool,
    check: bool,
    lower: bool,
    ssa: bool,
    schedule: bool,
    regalloc: bool,
    codegen: bool,
    strings: bool,
    abi: bool,
    all: bool,
    initialized: bool,
    trace_func: *u8,
    trace_func_len: i64,
}

// Global debug instance - call debug.log(.phase, "msg", args)
var debug: Debug = undefined;

// =============================================================================
// Debug Implementation
// =============================================================================

impl Debug {
    fn init(self: *Debug) {
        self.parse = false;
        self.check = false;
        self.lower = false;
        self.ssa = false;
        self.schedule = false;
        self.regalloc = false;
        self.codegen = false;
        self.strings = false;
        self.abi = false;
        self.all = false;
        self.initialized = false;
        self.trace_func = null;
        self.trace_func_len = 0;
    }

    fn isEnabled(self: *Debug, phase: DebugPhase) bool {
        if self.all { return true; }
        if phase == DebugPhase.parse { return self.parse; }
        if phase == DebugPhase.check { return self.check; }
        if phase == DebugPhase.lower { return self.lower; }
        if phase == DebugPhase.ssa { return self.ssa; }
        if phase == DebugPhase.schedule { return self.schedule; }
        if phase == DebugPhase.regalloc { return self.regalloc; }
        if phase == DebugPhase.codegen { return self.codegen; }
        if phase == DebugPhase.strings { return self.strings; }
        if phase == DebugPhase.abi { return self.abi; }
        return false;
    }

    fn phaseName(self: *Debug, phase: DebugPhase) *u8 {
        if phase == DebugPhase.parse { return "parse".ptr; }
        if phase == DebugPhase.check { return "check".ptr; }
        if phase == DebugPhase.lower { return "lower".ptr; }
        if phase == DebugPhase.ssa { return "ssa".ptr; }
        if phase == DebugPhase.schedule { return "schedule".ptr; }
        if phase == DebugPhase.regalloc { return "regalloc".ptr; }
        if phase == DebugPhase.codegen { return "codegen".ptr; }
        if phase == DebugPhase.strings { return "strings".ptr; }
        if phase == DebugPhase.abi { return "abi".ptr; }
        return "unknown".ptr;
    }

    fn phaseNameLen(self: *Debug, phase: DebugPhase) i64 {
        if phase == DebugPhase.parse { return 5; }
        if phase == DebugPhase.check { return 5; }
        if phase == DebugPhase.lower { return 5; }
        if phase == DebugPhase.ssa { return 3; }
        if phase == DebugPhase.schedule { return 8; }
        if phase == DebugPhase.regalloc { return 8; }
        if phase == DebugPhase.codegen { return 7; }
        if phase == DebugPhase.strings { return 7; }
        if phase == DebugPhase.abi { return 3; }
        return 7;
    }

    // Log with no arguments: debug.log(.lower, "message")
    fn log(self: *Debug, phase: DebugPhase, msg: *u8) {
        if not self.isEnabled(phase) { return; }
        write(1, "[".ptr, 1);
        write(1, self.phaseName(phase), self.phaseNameLen(phase));
        write(1, "] ".ptr, 2);
        write(1, msg, str_len(msg));
        write(1, "\n".ptr, 1);
    }

    // Log with one i64: debug.log_d(.lower, "value = {d}", value)
    fn log_d(self: *Debug, phase: DebugPhase, fmt: *u8, d: i64) {
        if not self.isEnabled(phase) { return; }
        write(1, "[".ptr, 1);
        write(1, self.phaseName(phase), self.phaseNameLen(phase));
        write(1, "] ".ptr, 2);
        self.print_fmt_d(fmt, d);
        write(1, "\n".ptr, 1);
    }

    // Log with one string: debug.log_s(.lower, "name = '{s}'", ptr, len)
    fn log_s(self: *Debug, phase: DebugPhase, fmt: *u8, s: *u8, s_len: i64) {
        if not self.isEnabled(phase) { return; }
        write(1, "[".ptr, 1);
        write(1, self.phaseName(phase), self.phaseNameLen(phase));
        write(1, "] ".ptr, 2);
        self.print_fmt_s(fmt, s, s_len);
        write(1, "\n".ptr, 1);
    }

    // Log with string and i64: debug.log_sd(.lower, "'{s}' = {d}", ptr, len, d)
    fn log_sd(self: *Debug, phase: DebugPhase, fmt: *u8, s: *u8, s_len: i64, d: i64) {
        if not self.isEnabled(phase) { return; }
        write(1, "[".ptr, 1);
        write(1, self.phaseName(phase), self.phaseNameLen(phase));
        write(1, "] ".ptr, 2);
        self.print_fmt_sd(fmt, s, s_len, d);
        write(1, "\n".ptr, 1);
    }

    // Log with two i64s: debug.log_dd(.lower, "{d} and {d}", d1, d2)
    fn log_dd(self: *Debug, phase: DebugPhase, fmt: *u8, d1: i64, d2: i64) {
        if not self.isEnabled(phase) { return; }
        write(1, "[".ptr, 1);
        write(1, self.phaseName(phase), self.phaseNameLen(phase));
        write(1, "] ".ptr, 2);
        self.print_fmt_dd(fmt, d1, d2);
        write(1, "\n".ptr, 1);
    }

    // Log with string and two i64s: debug.log_sdd(.lower, "'{s}' type={d} size={d}", ptr, len, d1, d2)
    fn log_sdd(self: *Debug, phase: DebugPhase, fmt: *u8, s: *u8, s_len: i64, d1: i64, d2: i64) {
        if not self.isEnabled(phase) { return; }
        write(1, "[".ptr, 1);
        write(1, self.phaseName(phase), self.phaseNameLen(phase));
        write(1, "] ".ptr, 2);
        self.print_fmt_sdd(fmt, s, s_len, d1, d2);
        write(1, "\n".ptr, 1);
    }

    // ==========================================================================
    // Format string parsing helpers
    // ==========================================================================

    fn print_fmt_d(self: *Debug, fmt: *u8, d: i64) {
        let len: i64 = str_len(fmt);
        var i: i64 = 0;
        while i < len {
            let c: u8 = (fmt + i).*;
            if c == 123 and i + 2 < len {  // '{'
                let c2: u8 = (fmt + i + 1).*;
                let c3: u8 = (fmt + i + 2).*;
                if c2 == 100 and c3 == 125 {  // 'd' '}'
                    print(d);
                    i = i + 3;
                    continue;
                }
            }
            write(1, fmt + i, 1);
            i = i + 1;
        }
    }

    fn print_fmt_s(self: *Debug, fmt: *u8, s: *u8, s_len: i64) {
        let len: i64 = str_len(fmt);
        var i: i64 = 0;
        while i < len {
            let c: u8 = (fmt + i).*;
            if c == 123 and i + 2 < len {  // '{'
                let c2: u8 = (fmt + i + 1).*;
                let c3: u8 = (fmt + i + 2).*;
                if c2 == 115 and c3 == 125 {  // 's' '}'
                    if s != null and s_len > 0 {
                        write(1, s, s_len);
                    }
                    i = i + 3;
                    continue;
                }
            }
            write(1, fmt + i, 1);
            i = i + 1;
        }
    }

    fn print_fmt_sd(self: *Debug, fmt: *u8, s: *u8, s_len: i64, d: i64) {
        let len: i64 = str_len(fmt);
        var i: i64 = 0;
        var used_s: bool = false;
        var used_d: bool = false;
        while i < len {
            let c: u8 = (fmt + i).*;
            if c == 123 and i + 2 < len {  // '{'
                let c2: u8 = (fmt + i + 1).*;
                let c3: u8 = (fmt + i + 2).*;
                if c2 == 115 and c3 == 125 and not used_s {  // 's' '}'
                    if s != null and s_len > 0 {
                        write(1, s, s_len);
                    }
                    used_s = true;
                    i = i + 3;
                    continue;
                }
                if c2 == 100 and c3 == 125 and not used_d {  // 'd' '}'
                    print(d);
                    used_d = true;
                    i = i + 3;
                    continue;
                }
            }
            write(1, fmt + i, 1);
            i = i + 1;
        }
    }

    fn print_fmt_dd(self: *Debug, fmt: *u8, d1: i64, d2: i64) {
        let len: i64 = str_len(fmt);
        var i: i64 = 0;
        var which_d: i64 = 0;
        while i < len {
            let c: u8 = (fmt + i).*;
            if c == 123 and i + 2 < len {  // '{'
                let c2: u8 = (fmt + i + 1).*;
                let c3: u8 = (fmt + i + 2).*;
                if c2 == 100 and c3 == 125 {  // 'd' '}'
                    if which_d == 0 {
                        print(d1);
                    } else {
                        print(d2);
                    }
                    which_d = which_d + 1;
                    i = i + 3;
                    continue;
                }
            }
            write(1, fmt + i, 1);
            i = i + 1;
        }
    }

    fn print_fmt_sdd(self: *Debug, fmt: *u8, s: *u8, s_len: i64, d1: i64, d2: i64) {
        let len: i64 = str_len(fmt);
        var i: i64 = 0;
        var used_s: bool = false;
        var which_d: i64 = 0;
        while i < len {
            let c: u8 = (fmt + i).*;
            if c == 123 and i + 2 < len {  // '{'
                let c2: u8 = (fmt + i + 1).*;
                let c3: u8 = (fmt + i + 2).*;
                if c2 == 115 and c3 == 125 and not used_s {  // 's' '}'
                    if s != null and s_len > 0 {
                        write(1, s, s_len);
                    }
                    used_s = true;
                    i = i + 3;
                    continue;
                }
                if c2 == 100 and c3 == 125 {  // 'd' '}'
                    if which_d == 0 {
                        print(d1);
                    } else {
                        print(d2);
                    }
                    which_d = which_d + 1;
                    i = i + 3;
                    continue;
                }
            }
            write(1, fmt + i, 1);
            i = i + 1;
        }
    }
}

// =============================================================================
// Helper: string length
// =============================================================================

fn str_len(s: *u8) i64 {
    if s == null { return 0; }
    var len: i64 = 0;
    while (s + len).* != 0 {
        len = len + 1;
    }
    return len;
}

// =============================================================================
// Parse COT_DEBUG environment variable
// =============================================================================

fn debug_parse_env(env: *u8) {
    if env == null { return; }

    let env_len: i64 = str_len(env);
    var start: i64 = 0;
    var i: i64 = 0;

    while i <= env_len {
        var c: u8 = 0;
        if i < env_len {
            c = (env + i).*;
        }

        if c == 44 or c == 0 {  // ',' or end
            let token_len: i64 = i - start;
            if token_len > 0 {
                let token: *u8 = env + start;
                if dbg_streq(token, token_len, "all".ptr, 3) { debug.all = true; }
                if dbg_streq(token, token_len, "parse".ptr, 5) { debug.parse = true; }
                if dbg_streq(token, token_len, "check".ptr, 5) { debug.check = true; }
                if dbg_streq(token, token_len, "lower".ptr, 5) { debug.lower = true; }
                if dbg_streq(token, token_len, "ssa".ptr, 3) { debug.ssa = true; }
                if dbg_streq(token, token_len, "schedule".ptr, 8) { debug.schedule = true; }
                if dbg_streq(token, token_len, "regalloc".ptr, 8) { debug.regalloc = true; }
                if dbg_streq(token, token_len, "codegen".ptr, 7) { debug.codegen = true; }
                if dbg_streq(token, token_len, "strings".ptr, 7) { debug.strings = true; }
                if dbg_streq(token, token_len, "abi".ptr, 3) { debug.abi = true; }
            }
            start = i + 1;
        }
        i = i + 1;
    }
}

fn dbg_streq(a: *u8, a_len: i64, b: *u8, b_len: i64) bool {
    if a_len != b_len { return false; }
    var i: i64 = 0;
    while i < a_len {
        if (a + i).* != (b + i).* { return false; }
        i = i + 1;
    }
    return true;
}

// =============================================================================
// Initialize debug system (call once at startup)
// =============================================================================

fn pipeline_debug_init() {
    if debug.initialized { return; }

    debug.init();
    debug.initialized = true;

    // Parse COT_DEBUG
    let debug_env: *u8 = getenv("COT_DEBUG".ptr);
    if debug_env != null {
        debug_parse_env(debug_env);
    }

    // Parse COT_TRACE
    let trace_env: *u8 = getenv("COT_TRACE".ptr);
    if trace_env != null {
        debug.trace_func = trace_env;
        debug.trace_func_len = str_len(trace_env);

        print("\n");
        print("======================================================================\n");
        print("  COT_TRACE enabled for function: ");
        write(1, trace_env, debug.trace_func_len);
        print("\n");
        print("  Tracing through ALL pipeline phases\n");
        print("======================================================================\n");
        print("\n");
    }
}

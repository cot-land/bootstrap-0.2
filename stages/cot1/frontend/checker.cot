// Cot0 Type Checker
// Minimal type checking for: i64, bool, void, functions
//
// Design follows Go's go/types package patterns:
// - Multi-phase: collect declarations, then check bodies
// - Scope hierarchy with parent chain for name lookup
// - Symbol table for tracking declared names
//
// Reference: ~/learning/go/src/cmd/compile/internal/types2/
// Reference: bootstrap-0.2/src/frontend/checker.zig

// Note: Dependencies (token.cot, types.cot, ast.cot) are imported by main.cot

// ============================================================================
// Type Aliases (cot1 feature: dogfooding our own language features)
// ============================================================================

// SymbolIndex: Index into symbol table arrays
type SymbolIndex = i64

// ============================================================================
// Symbol Kinds
// ============================================================================

enum CheckerSymbolKind {
    Variable,
    Constant,
    Function,
    TypeName,
    Parameter,
}

// ============================================================================
// Symbol (Go's Object)
// ============================================================================

struct CheckerSymbol {
    name_start: i64,     // Name offset in source
    name_len: i64,       // Name length
    kind: CheckerSymbolKind,    // What kind of symbol
    type_idx: i64,       // Type index from TypeRegistry
    node_idx: i64,       // AST node where defined
    mutable: bool,       // var vs let/const
    is_extern: bool,     // extern fn?
    const_value: i64,    // Value for constants (-1 if not const)
}

fn CheckerSymbol_new(name_start: i64, name_len: i64, kind: CheckerSymbolKind, type_idx: i64, node_idx: i64, mutable: bool) CheckerSymbol {
    return CheckerSymbol{
        .name_start = name_start,
        .name_len = name_len,
        .kind = kind,
        .type_idx = type_idx,
        .node_idx = node_idx,
        .mutable = mutable,
        .is_extern = false,
        .const_value = -1,
    };
}

fn CheckerSymbol_newConst(name_start: i64, name_len: i64, type_idx: i64, node_idx: i64, value: i64) CheckerSymbol {
    return CheckerSymbol{
        .name_start = name_start,
        .name_len = name_len,
        .kind = CheckerSymbolKind.Constant,
        .type_idx = type_idx,
        .node_idx = node_idx,
        .mutable = false,
        .is_extern = false,
        .const_value = value,
    };
}

fn CheckerSymbol_newExtern(name_start: i64, name_len: i64, kind: CheckerSymbolKind, type_idx: i64, node_idx: i64) CheckerSymbol {
    return CheckerSymbol{
        .name_start = name_start,
        .name_len = name_len,
        .kind = kind,
        .type_idx = type_idx,
        .node_idx = node_idx,
        .mutable = false,
        .is_extern = true,
        .const_value = -1,
    };
}

// ============================================================================
// Scope (Go's Scope)
// ============================================================================

// MAX_SYMBOLS removed - not used (ScopePool uses external arrays)

struct Scope {
    symbols: *CheckerSymbol,       // Array of symbols
    count: i64,             // Number of symbols in this scope
    parent_idx: i64,        // Parent scope index (-1 for none)
}

// ============================================================================
// Scope Pool
// ============================================================================

// MAX_SCOPES removed - not used (ScopePool uses external arrays)

struct ScopePool {
    scopes: *Scope,         // Array of scopes
    count: i64,             // Number of scopes
    symbols: *CheckerSymbol,       // Global symbol storage
    symbols_count: i64,     // Total symbols allocated
}

impl ScopePool {

    fn init(self: *ScopePool) {
        self.count = 0;
        self.symbols_count = 0;
    }

    fn createScope(self: *ScopePool, parent_idx: i64) i64 {
        let idx: i64 = self.count;
        self.count = self.count + 1;
    
        let s: *Scope = self.scopes + idx;
        s.symbols = self.symbols + self.symbols_count;
        s.count = 0;
        s.parent_idx = parent_idx;
    
        return idx;
    }

    fn define(self: *ScopePool, scope_idx: i64, sym: CheckerSymbol) {
        let s: *Scope = self.scopes + scope_idx;
        let sym_ptr: *CheckerSymbol = s.symbols + s.count;
        sym_ptr.* = sym;
        s.count = s.count + 1;
        self.symbols_count = self.symbols_count + 1;
    }

    fn lookupType(self: *ScopePool, scope_idx: i64, source: *u8, name_start: i64, name_len: i64) i64 {
        var current_idx: i64 = scope_idx;
    
        while current_idx >= 0 {
            let s: *Scope = self.scopes + current_idx;
    
            // Search symbols in this scope
            var i: i64 = 0;
            while i < s.count {
                let sym: *CheckerSymbol = s.symbols + i;
                if Checker_names_equal(source, sym.name_start, sym.name_len, source, name_start, name_len) {
                    return sym.type_idx;
                }
                i = i + 1;
            }
    
            current_idx = s.parent_idx;
        }
    
        return -1;  // Not found
    }

    fn isDefined(self: *ScopePool, scope_idx: i64, source: *u8, name_start: i64, name_len: i64) bool {
        let s: *Scope = self.scopes + scope_idx;
        var i: i64 = 0;
        while i < s.count {
            let sym: *CheckerSymbol = s.symbols + i;
            if Checker_names_equal(source, sym.name_start, sym.name_len, source, name_start, name_len) {
                return true;
            }
            i = i + 1;
        }
        return false;
    }

}




// Look up symbol in scope and parents
// Returns the symbol's type index, or -1 if not found

// Check if a symbol is already defined in this scope (not parents)
// Zig ref: Scope.isDefined

// Check if two names are equal
fn Checker_names_equal(src1: *u8, start1: i64, len1: i64, src2: *u8, start2: i64, len2: i64) bool {
    if len1 != len2 { return false; }

    var i: i64 = 0;
    while i < len1 {
        let c1: u8 = (src1 + start1 + i).*;
        let c2: u8 = (src2 + start2 + i).*;
        if c1 != c2 { return false; }
        i = i + 1;
    }

    return true;
}

// ============================================================================
// Checker State
// ============================================================================

struct Checker {
    type_pool: *TypeRegistry,   // Type registry
    scope_pool: *ScopePool, // Scope pool
    ast_pool: *NodePool,    // AST nodes
    source: *u8,            // Source text
    current_scope: i64,     // Current scope index
    return_type: i64,       // Expected return type for current function
    in_loop: bool,          // Inside a loop?
    error_count: i64,       // Number of errors found
}

impl Checker {

    fn init(self: *Checker, type_pool: *TypeRegistry, scope_pool: *ScopePool,
                    ast_pool: *NodePool, source: *u8) {
        self.type_pool = type_pool;
        self.scope_pool = scope_pool;
        self.ast_pool = ast_pool;
        self.source = source;
        self.current_scope = scope_pool.createScope( -1);  // Global scope
        self.return_type = TYPE_VOID;
        self.in_loop = false;
        self.error_count = 0;
    }

    fn checkExpr(self: *Checker, node_idx: i64) i64 {
        if node_idx < 0 { return TYPE_INVALID; }
    
        let node: *Node = Node_get(self.ast_pool, node_idx);
    
        // IntLit -> i64
        if node.kind == NodeKind.IntLit {
            return TYPE_I64;
        }
    
        // StringLit -> string
        if node.kind == NodeKind.StringLit {
            return TYPE_STRING;
        }
    
        // Ident -> lookup in scope
        if node.kind == NodeKind.Ident {
            let name_start: i64 = node.field0;
            let name_len: i64 = node.field1;
    
            let type_idx: i64 = self.scope_pool.lookupType( self.current_scope,
                                                   self.source, name_start, name_len);
    
            // Check if symbol was found (-1 means not found)
            if type_idx < 0 {
                self.error_count = self.error_count + 1;
                return TYPE_INVALID;
            }
    
            return type_idx;
        }
    
        // BinaryExpr -> check both operands
        if node.kind == NodeKind.BinaryExpr {
            let left: i64 = node.field0;
            let right: i64 = node.field1;
            let op: i64 = node.field2;
    
            let left_type: i64 = self.checkExpr(left);
            let right_type: i64 = self.checkExpr(right);
    
            // For arithmetic ops, both must be numeric
            // ops: 0=Add, 1=Sub, 2=Mul, 3=Div, 4=Mod
            if op == 0 or op == 1 or op == 2 or op == 3 or op == 4 {
                if not TypeInfo_isNumeric(self.type_pool, left_type) {
                    self.error_count = self.error_count + 1;
                    return TYPE_INVALID;
                }
                if not TypeInfo_isNumeric(self.type_pool, right_type) {
                    self.error_count = self.error_count + 1;
                    return TYPE_INVALID;
                }
                // Result is the same type (simplified - assume i64)
                return left_type;
            }
    
            // Comparison ops return bool
            // ops: 5=Equal, 6=NotEqual, 7=Less, 8=LessEq, 9=Greater, 10=GreaterEq
            if op == 5 or op == 6 or op == 7 or op == 8 or op == 9 or op == 10 {
                // Both operands should be comparable (same type or numeric)
                if TypeInfo_isNumeric(self.type_pool, left_type) and TypeInfo_isNumeric(self.type_pool, right_type) {
                    return TYPE_BOOL;
                }
                // String comparison
                if TypeInfo_isString(self.type_pool, left_type) and TypeInfo_isString(self.type_pool, right_type) {
                    return TYPE_BOOL;
                }
                // Same type comparison (bool == bool, etc.)
                if TypeInfo_equal(self.type_pool, left_type, right_type) {
                    return TYPE_BOOL;
                }
                self.error_count = self.error_count + 1;
                return TYPE_INVALID;
            }
    
            // Logical ops (and, or) require bool operands, return bool
            // ops: 11=And, 12=Or
            if op == 11 or op == 12 {
                if not TypeInfo_isBool(self.type_pool, left_type) {
                    self.error_count = self.error_count + 1;
                    return TYPE_INVALID;
                }
                if not TypeInfo_isBool(self.type_pool, right_type) {
                    self.error_count = self.error_count + 1;
                    return TYPE_INVALID;
                }
                return TYPE_BOOL;
            }
    
            return TYPE_INVALID;
        }
    
        // CallExpr -> check callee is function, check args
        if node.kind == NodeKind.CallExpr {
            let callee: i64 = node.field0;
            let args_start: i64 = node.field1;
            let args_count: i64 = node.field2;
    
            let callee_type: i64 = self.checkExpr(callee);
            if not TypeInfo_isFunc(self.type_pool, callee_type) {
                self.error_count = self.error_count + 1;
                return TYPE_INVALID;
            }
    
            // Get return type of function
            return TypeInfo_ret(self.type_pool, callee_type);
        }
    
        // UnaryExpr -> check operand, return appropriate type
        if node.kind == NodeKind.UnaryExpr {
            let operand: i64 = node.field0;
            let op: i64 = node.field1;  // 0=Neg, 1=Not, 2=BitNot
    
            let operand_type: i64 = self.checkExpr(operand);
    
            // Negation requires numeric, returns same type
            if op == 0 {
                if not TypeInfo_isNumeric(self.type_pool, operand_type) {
                    self.error_count = self.error_count + 1;
                    return TYPE_INVALID;
                }
                return operand_type;
            }
    
            // Logical not requires bool, returns bool
            if op == 1 {
                if not TypeInfo_isBool(self.type_pool, operand_type) {
                    self.error_count = self.error_count + 1;
                    return TYPE_INVALID;
                }
                return TYPE_BOOL;
            }
    
            // Bitwise not requires integer, returns same type
            if op == 2 {
                if not TypeInfo_isInteger(self.type_pool, operand_type) {
                    self.error_count = self.error_count + 1;
                    return TYPE_INVALID;
                }
                return operand_type;
            }
    
            return TYPE_INVALID;
        }
    
        // AddressOf -> returns pointer to operand type
        if node.kind == NodeKind.AddressOf {
            let operand: i64 = node.field0;
            let operand_type: i64 = self.checkExpr(operand);
    
            // Create pointer type
            return self.type_pool.makePointer( operand_type);
        }
    
        // DerefExpr -> operand must be pointer, returns element type
        if node.kind == NodeKind.DerefExpr {
            let operand: i64 = node.field0;
            let operand_type: i64 = self.checkExpr(operand);
    
            if not TypeInfo_isPointer(self.type_pool, operand_type) {
                self.error_count = self.error_count + 1;
                return TYPE_INVALID;
            }
    
            // Return element type
            return TypeInfo_elem(self.type_pool, operand_type);
        }
    
        // FieldAccess -> check base is struct/enum, return field/variant type
        if node.kind == NodeKind.FieldAccess {
            let base: i64 = node.field0;
            let field_start: i64 = node.field1;
            let field_len: i64 = node.field2;
    
            let base_type: i64 = self.checkExpr(base);
    
            // Struct field access: returns field type
            // Note: Full field name lookup requires field registry (not implemented)
            // For now, just verify base is struct and return i64 as placeholder
            if TypeInfo_isStruct(self.type_pool, base_type) {
                // TODO: Look up actual field type by name
                // For now return i64 as placeholder
                return TYPE_I64;
            }
    
            // Enum variant access: returns the enum type itself
            if TypeInfo_isEnum(self.type_pool, base_type) {
                return base_type;
            }
    
            // String .len and .ptr access
            if TypeInfo_isString(self.type_pool, base_type) {
                // .len returns i64
                // .ptr returns *u8
                // For simplicity, return i64 for both (ptr is address which is i64)
                return TYPE_I64;
            }
    
            self.error_count = self.error_count + 1;
            return TYPE_INVALID;
        }
    
        return TYPE_INVALID;
    }

    fn checkStmt(self: *Checker, node_idx: i64) bool {
        if node_idx < 0 { return false; }
    
        let node: *Node = Node_get(self.ast_pool, node_idx);
    
        // ReturnStmt -> check value matches return type
        if node.kind == NodeKind.ReturnStmt {
            let value: i64 = node.field0;
    
            if value >= 0 {
                let value_type: i64 = self.checkExpr(value);
                if not TypeInfo_isAssignable(self.type_pool, value_type, self.return_type) {
                    self.error_count = self.error_count + 1;
                }
            } else {
                // No value - must be void return
                if self.return_type != 12 {
                    self.error_count = self.error_count + 1;
                }
            }
    
            return true;  // Always returns
        }
    
        // ExprStmt -> just check the expression
        if node.kind == NodeKind.ExprStmt {
            let expr: i64 = node.field0;
            self.checkExpr(expr);
            return false;
        }
    
        // BlockStmt -> check each statement
        if node.kind == NodeKind.BlockStmt {
            let stmts_start: i64 = node.field0;
            let stmts_count: i64 = node.field1;
    
            var i: i64 = 0;
            var has_return: bool = false;
            while i < stmts_count {
                let stmt_idx: i64 = Node_child(self.ast_pool, stmts_start, i);
                if self.checkStmt(stmt_idx) {
                    has_return = true;
                }
                i = i + 1;
            }
    
            return has_return;
        }
    
        // IfStmt -> check condition is bool, check both branches
        if node.kind == NodeKind.IfStmt {
            let cond: i64 = node.field0;
            let then_body: i64 = node.field1;
            let else_body: i64 = node.field2;
    
            // Check condition is boolean
            let cond_type: i64 = self.checkExpr(cond);
            if not TypeInfo_isBool(self.type_pool, cond_type) {
                self.error_count = self.error_count + 1;
            }
    
            // Check then branch
            let then_returns: bool = self.checkStmt(then_body);
    
            // Check else branch if present
            var else_returns: bool = false;
            if else_body >= 0 {
                else_returns = self.checkStmt(else_body);
            }
    
            // Returns only if both branches return
            return then_returns and else_returns;
        }
    
        // WhileStmt -> check condition is bool, check body
        if node.kind == NodeKind.WhileStmt {
            let cond: i64 = node.field0;
            let body: i64 = node.field1;
    
            // Check condition is boolean
            let cond_type: i64 = self.checkExpr(cond);
            if not TypeInfo_isBool(self.type_pool, cond_type) {
                self.error_count = self.error_count + 1;
            }
    
            // Track that we're in a loop
            let old_in_loop: bool = self.in_loop;
            self.in_loop = true;
    
            // Check body
            self.checkStmt(body);
    
            // Restore loop state
            self.in_loop = old_in_loop;
    
            // While loops don't guarantee return
            return false;
        }
    
        return false;
    }

    fn checkVarDecl(self: *Checker, node_idx: i64) {
        if node_idx < 0 { return; }
    
        let node: *Node = Node_get(self.ast_pool, node_idx);
        if node.kind != NodeKind.VarDecl { return; }
    
        let is_let: i64 = node.field0;      // 1 = let (immutable), 0 = var (mutable)
        let name_start: i64 = node.field1;
        let name_len: i64 = node.field2;
        let init_expr: i64 = node.field3;
    
        // Determine type from initializer expression
        var var_type: i64 = TYPE_INVALID;
        if init_expr >= 0 {
            var_type = self.checkExpr(init_expr);
        }
    
        // Create symbol and add to current scope
        let mutable: bool = is_let == 0;
        let sym: CheckerSymbol = CheckerSymbol_new(name_start, name_len, CheckerSymbolKind.Variable,
                                      var_type, node_idx, mutable);
        self.scope_pool.define( self.current_scope, sym);
    }

    fn resolveTypeHandle(self: *Checker, type_handle: i64) i64 {
        // Basic types: direct mapping
        if type_handle == PTYPE_I64 { return TYPE_I64; }
        if type_handle == PTYPE_I32 { return TYPE_I32; }
        if type_handle == PTYPE_U8 { return TYPE_U8; }
        if type_handle == PTYPE_BOOL { return TYPE_BOOL; }
        if type_handle == PTYPE_VOID { return TYPE_VOID; }
        if type_handle == PTYPE_STRING { return TYPE_STRING; }
    
        // Pointer types: PTYPE_PTR_BASE + pointee_handle
        if type_handle >= PTYPE_PTR_BASE and type_handle < PTYPE_USER_BASE {
            let pointee_handle: i64 = type_handle - PTYPE_PTR_BASE;
            let pointee_type: i64 = self.resolveTypeHandle(pointee_handle);
            return self.type_pool.makePointer( pointee_type);
        }
    
        // User-defined types: PTYPE_USER_BASE + source_offset
        if type_handle >= PTYPE_USER_BASE {
            let name_start: i64 = type_handle - PTYPE_USER_BASE;
            // Find end of name in source (scan for non-identifier char)
            var name_len: i64 = 0;
            var pos: i64 = name_start;
            while true {
                let c: u8 = (self.source + pos).*;
                // Check if still identifier char: a-z, A-Z, 0-9, _
                if (c >= 97 and c <= 122) or (c >= 65 and c <= 90) or
                   (c >= 48 and c <= 57) or c == 95 {
                    name_len = name_len + 1;
                    pos = pos + 1;
                } else {
                    break;
                }
            }
            // Look up type by name in scope
            return self.scope_pool.lookupType( self.current_scope,
                                     self.source, name_start, name_len);
        }
    
        return TYPE_INVALID;
    }

    fn resolveTypeNode(self: *Checker, type_node_idx: i64) i64 {
        if type_node_idx < 0 {
            return TYPE_INVALID;
        }
    
        let node: *Node = Node_get(self.ast_pool, type_node_idx);
    
        // TypeExprNamed: look up type by name (handles built-in types and user types)
        if node.kind == NodeKind.TypeExprNamed {
            let name_start: i64 = node.field0;
            let name_len: i64 = node.field1;
            // Check built-in types first
            if name_len == 3 {
                let c0: u8 = (self.source + name_start).*;
                if c0 == 105 {  // 'i'
                    let c1: u8 = (self.source + name_start + 1).*;
                    let c2: u8 = (self.source + name_start + 2).*;
                    if c1 == 54 and c2 == 52 { return TYPE_I64; }  // i64
                    if c1 == 51 and c2 == 50 { return TYPE_I32; }  // i32
                }
            }
            if name_len == 2 {
                let c0: u8 = (self.source + name_start).*;
                let c1: u8 = (self.source + name_start + 1).*;
                if c0 == 117 and c1 == 56 { return TYPE_U8; }  // u8
            }
            if name_len == 4 {
                let c0: u8 = (self.source + name_start).*;
                if c0 == 98 { return TYPE_BOOL; }   // bool
                if c0 == 118 { return TYPE_VOID; }  // void
            }
            if name_len == 6 {
                let c0: u8 = (self.source + name_start).*;
                if c0 == 115 { return TYPE_STRING; }  // string
            }
            // Look up user-defined type in scope
            return self.scope_pool.lookupType( self.current_scope,
                                        self.source, name_start, name_len);
        }
    
        // TypeExprPointer: *T
        if node.kind == NodeKind.TypeExprPointer {
            let inner_idx: i64 = node.field0;
            let inner_type: i64 = self.resolveTypeNode(inner_idx);
            return self.type_pool.makePointer( inner_type);
        }
    
        // TypeExprOptional: ?T (for now, treat as inner type)
        if node.kind == NodeKind.TypeExprOptional {
            let inner_idx: i64 = node.field0;
            return self.resolveTypeNode(inner_idx);
        }
    
        // TypeExprErrorUnion: !T (for now, treat as inner type)
        // Reference: Zig's checker.zig:1677-1679
        if node.kind == NodeKind.TypeExprErrorUnion {
            let payload_idx: i64 = node.field0;
            return self.resolveTypeNode(payload_idx);
        }
    
        // TypeExprArray: [N]T
        if node.kind == NodeKind.TypeExprArray {
            let size_node_idx: i64 = node.field0;
            let elem_node_idx: i64 = node.field1;
            var array_size: i64 = 0;
            if size_node_idx >= 0 {
                let size_node: *Node = Node_get(self.ast_pool, size_node_idx);
                if size_node.kind == NodeKind.IntLit {
                    array_size = size_node.field0;
                }
            }
            let elem_type: i64 = self.resolveTypeNode(elem_node_idx);
            return self.type_pool.makeArray( elem_type, array_size);
        }
    
        // TypeExprSlice: []T
        if node.kind == NodeKind.TypeExprSlice {
            let elem_node_idx: i64 = node.field0;
            let elem_type: i64 = self.resolveTypeNode(elem_node_idx);
            return self.type_pool.makeSlice( elem_type);
        }
    
        // TypeExprFunc: fn(params) -> ret (pre-resolved by parser)
        if node.kind == NodeKind.TypeExprFunc {
            return node.field1;  // Pre-resolved TypeRegistry index
        }
    
        return TYPE_INVALID;
    }

    fn checkStructDecl(self: *Checker, node_idx: i64) {
        if node_idx < 0 { return; }
    
        let node: *Node = Node_get(self.ast_pool, node_idx);
        if node.kind != NodeKind.StructDecl { return; }
    
        let name_start: i64 = node.field0;
        let name_len: i64 = node.field1;
        let ast_fields_start: i64 = node.field2;  // Index into AST children array
        let fields_count: i64 = node.field3;
    
        // Record start of fields in TypeRegistry's fields array
        let type_fields_start: i64 = self.type_pool.fields_count;
    
        // Process each field and compute offsets
        // Mirrors Zig checker.zig:1744-1759
        var offset: i64 = 0;
        var max_align: i64 = 1;
        var i: i64 = 0;
        while i < fields_count {
            // Get FieldDecl node from AST children
            let field_node_idx: i64 = Node_child(self.ast_pool, ast_fields_start, i);
            let field_node: *Node = Node_get(self.ast_pool, field_node_idx);
    
            // FieldDecl: field0=name_start, field1=name_len, field2=type_start, field3=type_handle
            let fname_start: i64 = field_node.field0;
            let fname_len: i64 = field_node.field1;
            let type_handle: i64 = field_node.field3;
    
            // Resolve field type to get size/alignment
            let field_type: i64 = self.resolveTypeHandle(type_handle);
            let field_size: i64 = TypeInfo_size(self.type_pool, field_type);
            let field_align: i64 = TypeInfo_alignment(self.type_pool, field_type);
    
            // Align offset to field alignment
            if field_align > 0 {
                offset = (offset + field_align - 1) / field_align * field_align;
            }
    
            // Track max alignment for struct alignment
            if field_align > max_align {
                max_align = field_align;
            }
    
            // Add field to TypeRegistry with computed offset
            self.type_pool.addField( fname_start, fname_len, field_type, offset);
    
            // Advance offset by field size
            offset = offset + field_size;
    
            i = i + 1;
        }
    
        // Align final size to struct alignment (round up to max_align)
        let struct_size: i64 = (offset + max_align - 1) / max_align * max_align;
    
        // Create struct type with TypeRegistry fields_start (not AST children start)
        let struct_type: i64 = self.type_pool.makeStruct( name_start, name_len,
                                                 type_fields_start, fields_count,
                                                 struct_size, max_align);
    
        // Register as type name in scope
        let sym: CheckerSymbol = CheckerSymbol_new(name_start, name_len, CheckerSymbolKind.TypeName,
                                      struct_type, node_idx, false);
        self.scope_pool.define( self.current_scope, sym);
    }

    fn checkEnumDecl(self: *Checker, node_idx: i64) {
        if node_idx < 0 { return; }
    
        let node: *Node = Node_get(self.ast_pool, node_idx);
        if node.kind != NodeKind.EnumDecl { return; }
    
        let name_start: i64 = node.field0;
        let name_len: i64 = node.field1;
        let variants_start: i64 = node.field2;
        let variants_count: i64 = node.field3;
    
        // Create enum type
        let enum_type: i64 = self.type_pool.makeEnum( name_start, name_len, variants_count);
    
        // Register as type name in scope
        let sym: CheckerSymbol = CheckerSymbol_new(name_start, name_len, CheckerSymbolKind.TypeName,
                                      enum_type, node_idx, false);
        self.scope_pool.define( self.current_scope, sym);
    }

    fn checkFnDecl(self: *Checker, node_idx: i64) {
        let node: *Node = Node_get(self.ast_pool, node_idx);
        if node.kind != NodeKind.FnDecl { return; }
    
        let name_start: i64 = node.field0;
        let name_len: i64 = node.field1;
        let params_start: i64 = node.field2;
        let params_count: i64 = node.field3;
    
        // Create new scope for function body
        let fn_scope: i64 = self.scope_pool.createScope( self.current_scope);
        let old_scope: i64 = self.current_scope;
        self.current_scope = fn_scope;
    
        // TODO: Add parameters to function scope
        // TODO: Get return type from function declaration
        // For now, assume i64 return type
        let old_return: i64 = self.return_type;
        self.return_type = 5;
    
        // TODO: Check function body
    
        // Restore scope
        self.current_scope = old_scope;
        self.return_type = old_return;
    }

    fn ok(self: *Checker) bool {
        return self.error_count == 0;
    }

    fn errors(self: *Checker) i64 {
        return self.error_count;
    }

    fn checkTypeAliasDecl(self: *Checker, node_idx: i64) {
        if node_idx < 0 { return; }
    
        let node: *Node = Node_get(self.ast_pool, node_idx);
        if node.kind != NodeKind.TypeAliasDecl { return; }
    
        let name_start: i64 = node.field0;
        let name_len: i64 = node.field1;
        let type_node_idx: i64 = node.field2;  // AST node index (NOT PTYPE_*)
    
        // Resolve the target type from AST node
        let target_type: i64 = self.resolveTypeNode(type_node_idx);
    
        // Register alias name as a TypeName symbol pointing to the target type
        let sym: CheckerSymbol = CheckerSymbol_new(name_start, name_len, CheckerSymbolKind.TypeName,
                                      target_type, node_idx, false);
        self.scope_pool.define( self.current_scope, sym);
    }

    fn checkFile(self: *Checker) {
        // Phase 1: Process all struct, enum, and type alias declarations first
        // This registers types with correct field offsets in the type pool
        var i: i64 = 0;
        while i < self.ast_pool.count {
            let node: *Node = Node_get(self.ast_pool, i);
            if node.kind == NodeKind.StructDecl {
                self.checkStructDecl(i);
            } else if node.kind == NodeKind.EnumDecl {
                self.checkEnumDecl(i);
            } else if node.kind == NodeKind.TypeAliasDecl {
                self.checkTypeAliasDecl(i);
            }
            i = i + 1;
        }
    }

}


// ============================================================================
// Type Checking - Expressions
// ============================================================================

// Check an expression and return its type

// ============================================================================
// Type Checking - Statements
// ============================================================================

// Check a statement, return true if control always returns

// ============================================================================
// Type Checking - Variable Declarations
// ============================================================================

// Check a variable declaration and add to scope

// ============================================================================
// Parser Type Handle Resolution
// ============================================================================
// PTYPE_* constants are defined in types.cot

// Resolve a parser type handle to a TypeRegistry type index
// Mirrors Zig bootstrap's resolveTypeRef

// Resolve a TypeExpr AST node to a TypeRegistry index
// Mirrors Zig bootstrap's resolveTypeExpr() and lowerer's resolve_type_expr()
// This is needed because the parser stores AST node indices, not PTYPE_* handles

// ============================================================================
// Type Checking - Struct/Enum Declarations
// ============================================================================

// Check a struct declaration and register type
// Mirrors Zig bootstrap's buildStructType - computes field offsets

// Check an enum declaration and register type

// ============================================================================
// Type Checking - Declarations
// ============================================================================

// Check a function declaration

// ============================================================================
// Helper Functions
// ============================================================================

// Check if result is valid (no errors)

// Get error count

// cot1: Check a type alias declaration and register it
// type Name = TargetType

// Check all declarations in the file
// Following Zig checker.zig:checkFile pattern

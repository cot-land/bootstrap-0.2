// Cot0 Type Representation
// Minimal type system for: i64, bool, void, functions
//
// Design follows Go's go/types package patterns:
// - TypeKind enum for type discrimination
// - TypeIndex (i64) for compact storage and interning
// - TypeRegistry for type creation and lookup
// - Predicate functions for type checking
//
// Reference: ~/learning/go/src/cmd/compile/internal/types/type.go
// Reference: bootstrap-0.2/src/frontend/types.zig

import "token.cot"
import "../lib/list.cot"  // For realloc_i64
import "../lib/strmap.cot"  // For type name lookup

// ============================================================================
// Type Aliases (cot1 feature: dogfooding our own language features)
// ============================================================================

// TypeId: Index into type pool
// Makes code more readable - clear that we're dealing with type indices
type TypeId = i64

// ============================================================================
// Type Index
// ============================================================================

// Index into type pool. -1 = invalid/error type.
const INVALID_TYPE: TypeId = -1;

// ============================================================================
// Type Kinds (Go's Kind enum)
// ============================================================================

// Kind of type.
enum TypeKind {
    Invalid,    // Error/unknown type

    // Basic types
    Bool,       // bool
    I8,         // i8
    I16,        // i16
    I32,        // i32
    I64,        // i64
    U8,         // u8
    U16,        // u16
    U32,        // u32
    U64,        // u64
    F32,        // f32
    F64,        // f64
    Void,       // void (no value)

    // Composite types
    Pointer,    // *T
    Slice,      // []T
    Array,      // [N]T
    Func,       // fn(args) ret
    Struct,     // struct { fields }
    Enum,       // enum { variants }
    String,     // string (slice of u8)
}

// ============================================================================
// Type Structure
// ============================================================================

// Type represents a Cot type.
// Uses a flat struct with kind-specific interpretation of fields.
struct Type {
    kind: TypeKind,

    // Kind-specific fields:
    // For Pointer: elem is the pointee type index
    // For Slice: elem is the element type index
    // For Array: elem is element type, len is array length
    // For Func: params_start, params_count, ret_type
    // For Struct: name_start, name_len, fields_start, fields_count

    elem: i64,          // Element type index (for Pointer, Slice, Array)
    len: i64,           // Array length (for Array)
    ret_type: i64,      // Return type index (for Func)
    params_start: i64,  // Start index in params array (for Func)
    params_count: i64,  // Number of parameters (for Func)
    name_start: i64,    // Name offset in source (for Struct, Enum)
    name_len: i64,      // Name length (for Struct, Enum)
    size: i64,          // Size in bytes
    align: i64,         // Alignment in bytes
}

// ============================================================================
// Field Information (for struct fields)
// ============================================================================

struct FieldInfo {
    name_start: i64,    // Field name offset in source
    name_len: i64,      // Field name length
    type_idx: i64,      // Field type index
    offset: i64,        // Byte offset within struct
}

// ============================================================================
// Type Pool (arena allocation for type interning)
// ============================================================================

// MAX_TYPES, MAX_PARAMS, MAX_FIELDS removed - using dynamic growth

// Realloc externs for dynamic growth
// Note: realloc_i64 is declared in lib/list.cot
extern fn realloc_Type(ptr: *Type, old_count: i64, new_count: i64) *Type;
extern fn realloc_FieldInfo(ptr: *FieldInfo, old_count: i64, new_count: i64) *FieldInfo;

// Malloc externs for self-allocation
extern fn malloc_Type(count: i64) *Type;
extern fn malloc_FieldInfo(count: i64) *FieldInfo;

// ============================================================================
// Module Storage (allocated once, reused across compilations)
// Following Zig pattern: modules self-allocate rather than requiring
// external storage passed in from main.
// ============================================================================

// Initial capacities
const TR_INIT_TYPES: i64 = 1024;
const TR_INIT_PARAMS: i64 = 5000;
const TR_INIT_FIELDS: i64 = 5000;

// Module-level storage
var tr_types: *Type = null;
var tr_types_cap: i64 = 0;
var tr_params: *i64 = null;
var tr_params_cap: i64 = 0;
var tr_fields: *FieldInfo = null;
var tr_fields_cap: i64 = 0;
var tr_storage_initialized: bool = false;

// Allocate module storage (called once on first use)
fn TypeRegistry_allocateStorage() {
    if tr_storage_initialized {
        return;
    }

    tr_types_cap = TR_INIT_TYPES;
    tr_types = malloc_Type(tr_types_cap);

    tr_params_cap = TR_INIT_PARAMS;
    tr_params = malloc_i64(tr_params_cap);

    tr_fields_cap = TR_INIT_FIELDS;
    tr_fields = malloc_FieldInfo(tr_fields_cap);

    tr_storage_initialized = true;
}

struct TypeRegistry {
    types: *Type,        // Pointer to array of types
    count: i64,          // Current type count
    types_cap: i64,      // Types array capacity

    // Parameter arrays (for function types)
    params: *i64,        // Pointer to array of type indices
    params_count: i64,
    params_cap: i64,     // Params array capacity

    // Field arrays (for struct types)
    fields: *FieldInfo,  // Pointer to array of field information
    fields_count: i64,   // Current field count
    fields_cap: i64,     // Fields array capacity

    // Source text for name comparison
    source: *u8,
    source_len: i64,

    // Name to type index map (for fast lookup)
    name_map: StrMap,
}

// ============================================================================
// Pre-defined Type Indices
// ============================================================================

// These match the order in which types are registered in TypeRegistry_init
const TYPE_INVALID: i64 = 0;
const TYPE_BOOL: i64 = 1;
const TYPE_I8: i64 = 2;
const TYPE_I16: i64 = 3;
const TYPE_I32: i64 = 4;
const TYPE_I64: i64 = 5;
const TYPE_U8: i64 = 6;
const TYPE_U16: i64 = 7;
const TYPE_U32: i64 = 8;
const TYPE_U64: i64 = 9;
const TYPE_F32: i64 = 10;
const TYPE_F64: i64 = 11;
const TYPE_VOID: i64 = 12;
const TYPE_STRING: i64 = 13;
const TYPE_SLICE: i64 = 14;   // Slice type marker for locals

// Aliases
const TYPE_INT: i64 = 5;   // i64 is the default int
const TYPE_FLOAT: i64 = 11; // f64 is the default float
const TYPE_BYTE: i64 = 6;  // u8 is byte

// First user-defined type index
const FIRST_USER_TYPE: i64 = 15;

// ============================================================================
// Parser Type Handles (PTYPE_*)
// ============================================================================
// These are used by the parser to represent types before TypeRegistry resolution.
// The resolve_type_handle() function converts PTYPE_* to TYPE_* indices.
//
// PTYPE_* ranges:
// - 0-9: Basic types
// - 10-99: Pointer types (PTYPE_PTR_BASE + pointee_handle)
// - 100+: User types (PTYPE_USER_BASE + source offset of type name)

const PTYPE_I64: i64 = 0;
const PTYPE_I32: i64 = 1;
const PTYPE_U8: i64 = 2;
const PTYPE_BOOL: i64 = 3;
const PTYPE_VOID: i64 = 4;
const PTYPE_STRING: i64 = 5;
const PTYPE_PTR_BASE: i64 = 10;    // Pointer types start here
const PTYPE_USER_BASE: i64 = 100;  // User types start here (up to 9999)
const PTYPE_ARRAY_BASE: i64 = 10000;  // Array types: PTYPE_ARRAY_BASE + index into array_info table
const PTYPE_SLICE_BASE: i64 = 100000; // Slice types: PTYPE_SLICE_BASE + elem_type

// Array type info storage - simple inline encoding
// Since we can't easily share global pointers between files,
// use a simpler encoding: PTYPE_ARRAY_BASE + (size * 100 + elem_type)
// This limits array sizes to < 100000 and element types to < 100

// Register an array type, returns PTYPE handle

impl TypeRegistry {

    fn ensureTypesCapacity(self: *TypeRegistry, additional: i64) {
        let needed: i64 = self.count + additional;
        if needed <= self.types_cap {
            return;
        }
        var new_cap: i64 = self.types_cap * 2;
        if new_cap < needed {
            new_cap = needed;
        }
        self.types = realloc_Type(self.types, self.types_cap, new_cap);
        self.types_cap = new_cap;
        // Update module storage if using self-allocation
        if tr_storage_initialized {
            tr_types = self.types;
            tr_types_cap = self.types_cap;
        }
    }

    fn ensureParamsCapacity(self: *TypeRegistry, additional: i64) {
        let needed: i64 = self.params_count + additional;
        if needed <= self.params_cap {
            return;
        }
        var new_cap: i64 = self.params_cap * 2;
        if new_cap < needed {
            new_cap = needed;
        }
        self.params = realloc_i64(self.params, self.params_cap, new_cap);
        self.params_cap = new_cap;
        // Update module storage if using self-allocation
        if tr_storage_initialized {
            tr_params = self.params;
            tr_params_cap = self.params_cap;
        }
    }

    fn ensureFieldsCapacity(self: *TypeRegistry, additional: i64) {
        let needed: i64 = self.fields_count + additional;
        if needed <= self.fields_cap {
            return;
        }
        var new_cap: i64 = self.fields_cap * 2;
        if new_cap < needed {
            new_cap = needed;
        }
        self.fields = realloc_FieldInfo(self.fields, self.fields_cap, new_cap);
        self.fields_cap = new_cap;
        // Update module storage if using self-allocation
        if tr_storage_initialized {
            tr_fields = self.fields;
            tr_fields_cap = self.fields_cap;
        }
    }

    fn initWithStorage(self: *TypeRegistry, types: *Type, types_cap: i64,
                                     params: *i64, params_cap: i64,
                                     fields: *FieldInfo, fields_cap: i64) {
        self.types = types;
        self.types_cap = types_cap;
        self.params = params;
        self.params_cap = params_cap;
        self.fields = fields;
        self.fields_cap = fields_cap;
        self.count = 0;
        self.params_count = 0;
        self.fields_count = 0;
        self.source = null;
        self.source_len = 0;
        self.name_map = StrMap_init(256);  // Initialize type name lookup map
    
        // Register basic types in order
        self.registerBasic(TypeKind.Invalid, 0, 0);   // 0: invalid
        self.registerBasic(TypeKind.Bool, 1, 1);      // 1: bool
        self.registerBasic(TypeKind.I8, 1, 1);        // 2: i8
        self.registerBasic(TypeKind.I16, 2, 2);       // 3: i16
        self.registerBasic(TypeKind.I32, 4, 4);       // 4: i32
        self.registerBasic(TypeKind.I64, 8, 8);       // 5: i64
        self.registerBasic(TypeKind.U8, 1, 1);        // 6: u8
        self.registerBasic(TypeKind.U16, 2, 2);       // 7: u16
        self.registerBasic(TypeKind.U32, 4, 4);       // 8: u32
        self.registerBasic(TypeKind.U64, 8, 8);       // 9: u64
        self.registerBasic(TypeKind.F32, 4, 4);       // 10: f32
        self.registerBasic(TypeKind.F64, 8, 8);       // 11: f64
        self.registerBasic(TypeKind.Void, 0, 0);      // 12: void
        self.registerBasic(TypeKind.String, 16, 8);   // 13: string (ptr + len)
        self.registerBasic(TypeKind.Slice, 16, 8);    // 14: TYPE_SLICE placeholder (ptr + len)
        // User types start at index 15 (FIRST_USER_TYPE)
    }

    fn init(self: *TypeRegistry) {
        // Allocate module storage if not already done
        TypeRegistry_allocateStorage();
    
        // Wire up pool to use module storage
        self.types = tr_types;
        self.types_cap = tr_types_cap;
        self.params = tr_params;
        self.params_cap = tr_params_cap;
        self.fields = tr_fields;
        self.fields_cap = tr_fields_cap;
        self.count = 0;
        self.params_count = 0;
        self.fields_count = 0;
        self.source = null;
        self.source_len = 0;
        self.name_map = StrMap_init(256);  // Initialize type name lookup map
    
        // Register basic types in order
        self.registerBasic(TypeKind.Invalid, 0, 0);   // 0: invalid
        self.registerBasic(TypeKind.Bool, 1, 1);      // 1: bool
        self.registerBasic(TypeKind.I8, 1, 1);        // 2: i8
        self.registerBasic(TypeKind.I16, 2, 2);       // 3: i16
        self.registerBasic(TypeKind.I32, 4, 4);       // 4: i32
        self.registerBasic(TypeKind.I64, 8, 8);       // 5: i64
        self.registerBasic(TypeKind.U8, 1, 1);        // 6: u8
        self.registerBasic(TypeKind.U16, 2, 2);       // 7: u16
        self.registerBasic(TypeKind.U32, 4, 4);       // 8: u32
        self.registerBasic(TypeKind.U64, 8, 8);       // 9: u64
        self.registerBasic(TypeKind.F32, 4, 4);       // 10: f32
        self.registerBasic(TypeKind.F64, 8, 8);       // 11: f64
        self.registerBasic(TypeKind.Void, 0, 0);      // 12: void
        self.registerBasic(TypeKind.String, 16, 8);   // 13: string (ptr + len)
        self.registerBasic(TypeKind.Slice, 16, 8);    // 14: TYPE_SLICE placeholder (ptr + len)
        // User types start at index 15 (FIRST_USER_TYPE)
    }

    fn registerBasic(self: *TypeRegistry, kind: TypeKind, size: i64, align: i64) i64 {
        self.ensureTypesCapacity(1);
        let idx: i64 = self.count;
        self.count = self.count + 1;
    
        let t: *Type = self.types + idx;
        t.kind = kind;
        t.elem = INVALID_TYPE;
        t.len = 0;
        t.ret_type = INVALID_TYPE;
        t.params_start = 0;
        t.params_count = 0;
        t.name_start = 0;
        t.name_len = 0;
        t.size = size;
        t.align = align;
    
        return idx;
    }

    fn get(self: *TypeRegistry, idx: i64) *Type {
        if idx < 0 or idx >= self.count {
            return self.types + 0;  // Return invalid type
        }
        return self.types + idx;
    }

    fn findByName(self: *TypeRegistry, name_ptr: *u8, name_len: i64) i64 {
        return self.name_map.get(name_ptr, name_len);
    }

    fn lookupByName(self: *TypeRegistry, source: *u8, name_start: i64, name_len: i64) i64 {
        return self.name_map.get(source + name_start, name_len);
    }

    fn makePointer(self: *TypeRegistry, elem: i64) i64 {
        self.ensureTypesCapacity(1);
        let idx: i64 = self.count;
        self.count = self.count + 1;
    
        let t: *Type = self.types + idx;
        t.kind = TypeKind.Pointer;
        t.elem = elem;
        t.len = 0;
        t.ret_type = INVALID_TYPE;
        t.params_start = 0;
        t.params_count = 0;
        t.name_start = 0;
        t.name_len = 0;
        t.size = 8;  // Pointers are 8 bytes on 64-bit
        t.align = 8;
    
        return idx;
    }

    fn makeSlice(self: *TypeRegistry, elem: i64) i64 {
        self.ensureTypesCapacity(1);
        let idx: i64 = self.count;
        self.count = self.count + 1;
    
        let t: *Type = self.types + idx;
        t.kind = TypeKind.Slice;
        t.elem = elem;
        t.len = 0;
        t.ret_type = INVALID_TYPE;
        t.params_start = 0;
        t.params_count = 0;
        t.name_start = 0;
        t.name_len = 0;
        t.size = 16;  // ptr + len
        t.align = 8;
    
        return idx;
    }

    fn makeArray(self: *TypeRegistry, elem: i64, array_len: i64) i64 {
        self.ensureTypesCapacity(1);
        let idx: i64 = self.count;
        self.count = self.count + 1;
    
        let elem_type: *Type = self.get(elem);
        let elem_size: i64 = elem_type.size;
    
        let t: *Type = self.types + idx;
        t.kind = TypeKind.Array;
        t.elem = elem;
        t.len = array_len;
        t.ret_type = INVALID_TYPE;
        t.params_start = 0;
        t.params_count = 0;
        t.name_start = 0;
        t.name_len = 0;
        t.size = elem_size * array_len;
        t.align = elem_type.align;
    
        return idx;
    }

    fn makeFunc(self: *TypeRegistry, params_start: i64, params_count: i64, ret_type: i64) i64 {
        self.ensureTypesCapacity(1);
        let idx: i64 = self.count;
        self.count = self.count + 1;
    
        let t: *Type = self.types + idx;
        t.kind = TypeKind.Func;
        t.elem = INVALID_TYPE;
        t.len = 0;
        t.ret_type = ret_type;
        t.params_start = params_start;
        t.params_count = params_count;
        t.name_start = 0;
        t.name_len = 0;
        t.size = 8;  // Function pointer
        t.align = 8;
    
        return idx;
    }

    fn addParam(self: *TypeRegistry, param_type: i64) i64 {
        self.ensureParamsCapacity(1);
        let idx: i64 = self.params_count;
        let ptr: *i64 = self.params + idx;
        ptr.* = param_type;
        self.params_count = self.params_count + 1;
        return idx;
    }

    fn makeStruct(self: *TypeRegistry, name_start: i64, name_len: i64,
                        fields_start: i64, fields_count: i64, size: i64, align: i64) i64 {
        self.ensureTypesCapacity(1);
        let idx: i64 = self.count;
        self.count = self.count + 1;
    
        let t: *Type = self.types + idx;
        t.kind = TypeKind.Struct;
        t.elem = INVALID_TYPE;
        t.len = 0;
        t.ret_type = INVALID_TYPE;
        t.params_start = fields_start;  // Reuse params for field types
        t.params_count = fields_count;
        t.name_start = name_start;
        t.name_len = name_len;
        t.size = size;
        t.align = align;
    
        // Register in name map for fast lookup
        if name_len > 0 and self.source != null {
            self.name_map.put(self.source + name_start, name_len, idx);
        }
    
        return idx;
    }

    fn makeEnum(self: *TypeRegistry, name_start: i64, name_len: i64,
                      variants_count: i64) i64 {
        self.ensureTypesCapacity(1);
        let idx: i64 = self.count;
        self.count = self.count + 1;
    
        let t: *Type = self.types + idx;
        t.kind = TypeKind.Enum;
        t.elem = INVALID_TYPE;
        t.len = variants_count;  // Store variant count in len field
        t.ret_type = INVALID_TYPE;
        t.params_start = 0;
        t.params_count = 0;
        t.name_start = name_start;
        t.name_len = name_len;
        t.size = 4;   // Enums are 4 bytes (i32)
        t.align = 4;
    
        // Register in name map for fast lookup
        if name_len > 0 and self.source != null {
            self.name_map.put(self.source + name_start, name_len, idx);
        }
    
        return idx;
    }

    fn getParam(self: *TypeRegistry, params_start: i64, offset: i64) i64 {
        let ptr: *i64 = self.params + params_start + offset;
        return ptr.*;
    }

    fn sizeof(self: *TypeRegistry, idx: i64) i64 {
        if idx < 0 { return 0; }
    
        let t: *Type = self.get(idx);
        if t == null { return 0; }
    
        // For types with explicit size field, use it
        if t.size > 0 { return t.size; }
    
        // Handle by kind
        if t.kind == TypeKind.Pointer { return 8; }  // 64-bit pointer
        if t.kind == TypeKind.Slice { return 16; }   // ptr + len
        if t.kind == TypeKind.Func { return 8; }     // function pointer
        if t.kind == TypeKind.String { return 16; }  // ptr + len
    
        // Array: element size * length
        if t.kind == TypeKind.Array {
            let elem_size: i64 = self.sizeof(t.elem);
            return elem_size * t.len;
        }
    
        // Struct: use stored size
        if t.kind == TypeKind.Struct { return t.size; }
    
        // Enum: use stored size (usually i64)
        if t.kind == TypeKind.Enum { return t.size; }
    
        // Default to 8 for unknown types
        return 8;
    }

    fn setSource(self: *TypeRegistry, source: *u8, source_len: i64) {
        self.source = source;
        self.source_len = source_len;
    }

    fn addField(self: *TypeRegistry, name_start: i64, name_len: i64,
                      type_idx: i64, offset: i64) i64 {
        self.ensureFieldsCapacity(1);
        let idx: i64 = self.fields_count;
        self.fields_count = self.fields_count + 1;
    
        let f: *FieldInfo = self.fields + idx;
        f.name_start = name_start;
        f.name_len = name_len;
        f.type_idx = type_idx;
        f.offset = offset;
    
        return idx;
    }

    fn getField(self: *TypeRegistry, idx: i64) *FieldInfo {
        return self.fields + idx;
    }

    fn lookupField(self: *TypeRegistry, type_idx: i64,
                         field_name_ptr: *u8, field_name_len: i64) *FieldInfo {
        let t: *Type = self.get(type_idx);
    
        if t.kind != TypeKind.Struct {
            return null;
        }
    
        // fields_start in params_start, fields_count in params_count
        let fields_start: i64 = t.params_start;
        let fields_count: i64 = t.params_count;
    
        var i: i64 = 0;
        while i < fields_count {
            let f: *FieldInfo = self.fields + fields_start + i;
    
            if names_equal_ptr(self.source, f.name_start, f.name_len,
                              field_name_ptr, field_name_len) {
                return f;
            }
            i = i + 1;
        }
    
        return null;
    }

}

fn PType_registerArray(elem_ptype: i64, size: i64) i64 {
    // Encode: size * 100 + elem_type (elem_type < 100)
    return PTYPE_ARRAY_BASE + size * 100 + elem_ptype;
}

fn PType_arrayElem(ptype: i64) i64 {
    if ptype < PTYPE_ARRAY_BASE {
        return PTYPE_I64;
    }
    let encoded: i64 = ptype - PTYPE_ARRAY_BASE;
    return encoded % 100;  // elem_type is the remainder
}

fn PType_arraySize(ptype: i64) i64 {
    if ptype < PTYPE_ARRAY_BASE {
        return 0;
    }
    let encoded: i64 = ptype - PTYPE_ARRAY_BASE;
    return encoded / 100;  // size is the quotient
}

fn PType_registerSlice(elem_ptype: i64) i64 {
    return PTYPE_SLICE_BASE + elem_ptype;
}

fn PType_sliceElem(ptype: i64) i64 {
    if ptype < PTYPE_SLICE_BASE {
        return PTYPE_I64;
    }
    return ptype - PTYPE_SLICE_BASE;
}

fn ptype_TypeInfo_isSlice(ptype: i64) bool {
    return ptype >= PTYPE_SLICE_BASE;
}

fn TypeInfo_valid(idx: i64) bool {
    return idx != INVALID_TYPE and idx >= 0;
}

fn TypeInfo_isInvalid(pool: *TypeRegistry, idx: i64) bool {
    if idx == INVALID_TYPE or idx < 0 {
        return true;
    }
    let t: *Type = pool.get(idx);
    return t.kind == TypeKind.Invalid;
}

fn TypeInfo_isInteger(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get(idx);
    return t.kind == TypeKind.I8 or t.kind == TypeKind.I16 or
           t.kind == TypeKind.I32 or t.kind == TypeKind.I64 or
           t.kind == TypeKind.U8 or t.kind == TypeKind.U16 or
           t.kind == TypeKind.U32 or t.kind == TypeKind.U64;
}

fn TypeInfo_isSigned(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get(idx);
    return t.kind == TypeKind.I8 or t.kind == TypeKind.I16 or
           t.kind == TypeKind.I32 or t.kind == TypeKind.I64;
}

fn TypeInfo_isUnsigned(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get(idx);
    return t.kind == TypeKind.U8 or t.kind == TypeKind.U16 or
           t.kind == TypeKind.U32 or t.kind == TypeKind.U64;
}

fn TypeInfo_isFloat(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get(idx);
    return t.kind == TypeKind.F32 or t.kind == TypeKind.F64;
}

fn TypeInfo_isNumeric(pool: *TypeRegistry, idx: i64) bool {
    return TypeInfo_isInteger(pool, idx) or TypeInfo_isFloat(pool, idx);
}

fn TypeInfo_isBool(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get(idx);
    return t.kind == TypeKind.Bool;
}

fn TypeInfo_isVoid(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get(idx);
    return t.kind == TypeKind.Void;
}

fn TypeInfo_isPointer(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get(idx);
    return t.kind == TypeKind.Pointer;
}

fn TypeInfo_isSlice(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get(idx);
    return t.kind == TypeKind.Slice;
}

fn TypeInfo_isArray(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get(idx);
    return t.kind == TypeKind.Array;
}

fn TypeInfo_isFunc(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get(idx);
    return t.kind == TypeKind.Func;
}

fn TypeInfo_isString(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get(idx);
    return t.kind == TypeKind.String;
}

fn TypeInfo_isStruct(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get(idx);
    return t.kind == TypeKind.Struct;
}

fn TypeInfo_isEnum(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get(idx);
    return t.kind == TypeKind.Enum;
}

fn TypeInfo_elem(pool: *TypeRegistry, idx: i64) i64 {
    let t: *Type = pool.get(idx);
    return t.elem;
}

fn TypeInfo_arrayLen(pool: *TypeRegistry, idx: i64) i64 {
    let t: *Type = pool.get(idx);
    return t.len;
}

fn TypeInfo_ret(pool: *TypeRegistry, idx: i64) i64 {
    let t: *Type = pool.get(idx);
    return t.ret_type;
}

fn TypeInfo_paramCount(pool: *TypeRegistry, idx: i64) i64 {
    let t: *Type = pool.get(idx);
    return t.params_count;
}

fn TypeInfo_size(pool: *TypeRegistry, idx: i64) i64 {
    let t: *Type = pool.get(idx);
    return t.size;
}

fn TypeInfo_alignment(pool: *TypeRegistry, idx: i64) i64 {
    let t: *Type = pool.get(idx);
    return t.align;
}

fn TypeInfo_equal(pool: *TypeRegistry, a: i64, b: i64) bool {
    if a == b { return true; }
    if a < 0 or b < 0 { return false; }

    let ta: *Type = pool.get(a);
    let tb: *Type = pool.get(b);

    // Different kinds are never equal
    if ta.kind != tb.kind { return false; }

    // For basic types, same kind means equal
    if ta.kind == TypeKind.Bool or
       ta.kind == TypeKind.I8 or ta.kind == TypeKind.I16 or
       ta.kind == TypeKind.I32 or ta.kind == TypeKind.I64 or
       ta.kind == TypeKind.U8 or ta.kind == TypeKind.U16 or
       ta.kind == TypeKind.U32 or ta.kind == TypeKind.U64 or
       ta.kind == TypeKind.F32 or ta.kind == TypeKind.F64 or
       ta.kind == TypeKind.Void or ta.kind == TypeKind.String {
        return true;
    }

    // For Pointer, Slice: compare element types
    if ta.kind == TypeKind.Pointer or ta.kind == TypeKind.Slice {
        return TypeInfo_equal(pool, ta.elem, tb.elem);
    }

    // For Array: compare element types and lengths
    if ta.kind == TypeKind.Array {
        return ta.len == tb.len and TypeInfo_equal(pool, ta.elem, tb.elem);
    }

    // For Func: compare params and return type
    if ta.kind == TypeKind.Func {
        if ta.params_count != tb.params_count { return false; }
        if not TypeInfo_equal(pool, ta.ret_type, tb.ret_type) { return false; }

        var i: i64 = 0;
        while i < ta.params_count {
            let pa: i64 = pool.getParam(ta.params_start, i);
            let pb: i64 = pool.getParam(tb.params_start, i);
            if not TypeInfo_equal(pool, pa, pb) { return false; }
            i = i + 1;
        }
        return true;
    }

    return false;
}

fn TypeInfo_lookupBasic(source: *u8, name_start: i64, name_len: i64) i64 {
    // Single character type names
    if name_len == 2 {
        let c0: u8 = (source + name_start).*;
        let c1: u8 = (source + name_start + 1).*;

        if c0 == 105 and c1 == 56 { return TYPE_I8; }  // "i8"
        if c0 == 117 and c1 == 56 { return TYPE_U8; }  // "u8"
    }

    if name_len == 3 {
        let c0: u8 = (source + name_start).*;
        let c1: u8 = (source + name_start + 1).*;
        let c2: u8 = (source + name_start + 2).*;

        if c0 == 105 and c1 == 49 and c2 == 54 { return TYPE_I16; }  // "i16"
        if c0 == 105 and c1 == 51 and c2 == 50 { return TYPE_I32; }  // "i32"
        if c0 == 105 and c1 == 54 and c2 == 52 { return TYPE_I64; }  // "i64"
        if c0 == 117 and c1 == 49 and c2 == 54 { return TYPE_U16; }  // "u16"
        if c0 == 117 and c1 == 51 and c2 == 50 { return TYPE_U32; }  // "u32"
        if c0 == 117 and c1 == 54 and c2 == 52 { return TYPE_U64; }  // "u64"
        if c0 == 102 and c1 == 51 and c2 == 50 { return TYPE_F32; }  // "f32"
        if c0 == 102 and c1 == 54 and c2 == 52 { return TYPE_F64; }  // "f64"
        if c0 == 105 and c1 == 110 and c2 == 116 { return TYPE_INT; }  // "int"
    }

    if name_len == 4 {
        let c0: u8 = (source + name_start).*;
        let c1: u8 = (source + name_start + 1).*;
        let c2: u8 = (source + name_start + 2).*;
        let c3: u8 = (source + name_start + 3).*;

        if c0 == 98 and c1 == 111 and c2 == 111 and c3 == 108 { return TYPE_BOOL; }  // "bool"
        if c0 == 118 and c1 == 111 and c2 == 105 and c3 == 100 { return TYPE_VOID; }  // "void"
        if c0 == 98 and c1 == 121 and c2 == 116 and c3 == 101 { return TYPE_BYTE; }  // "byte"
    }

    if name_len == 5 {
        let c0: u8 = (source + name_start).*;
        let c1: u8 = (source + name_start + 1).*;
        let c2: u8 = (source + name_start + 2).*;
        let c3: u8 = (source + name_start + 3).*;
        let c4: u8 = (source + name_start + 4).*;

        if c0 == 102 and c1 == 108 and c2 == 111 and c3 == 97 and c4 == 116 { return TYPE_FLOAT; }  // "float"
    }

    if name_len == 6 {
        let c0: u8 = (source + name_start).*;
        let c1: u8 = (source + name_start + 1).*;
        let c2: u8 = (source + name_start + 2).*;
        let c3: u8 = (source + name_start + 3).*;
        let c4: u8 = (source + name_start + 4).*;
        let c5: u8 = (source + name_start + 5).*;

        // "string"
        if c0 == 115 and c1 == 116 and c2 == 114 and c3 == 105 and c4 == 110 and c5 == 103 {
            return TYPE_STRING;
        }
    }

    return INVALID_TYPE;
}

fn TypeInfo_isAssignable(pool: *TypeRegistry, from: i64, to: i64) bool {
    // Same type is always assignable
    if from == to { return true; }

    // Error types are assignable (for error recovery)
    if from < 0 or to < 0 { return true; }

    let from_t: *Type = pool.get(from);
    let to_t: *Type = pool.get(to);

    // Same basic types are assignable
    if from_t.kind == to_t.kind {
        if from_t.kind == TypeKind.Bool or
           from_t.kind == TypeKind.I8 or from_t.kind == TypeKind.I16 or
           from_t.kind == TypeKind.I32 or from_t.kind == TypeKind.I64 or
           from_t.kind == TypeKind.U8 or from_t.kind == TypeKind.U16 or
           from_t.kind == TypeKind.U32 or from_t.kind == TypeKind.U64 or
           from_t.kind == TypeKind.F32 or from_t.kind == TypeKind.F64 or
           from_t.kind == TypeKind.Void or from_t.kind == TypeKind.String {
            return true;
        }
    }

    // Pointer types with same element
    if from_t.kind == TypeKind.Pointer and to_t.kind == TypeKind.Pointer {
        return TypeInfo_equal(pool, from_t.elem, to_t.elem);
    }

    // Slice types with same element
    if from_t.kind == TypeKind.Slice and to_t.kind == TypeKind.Slice {
        return TypeInfo_equal(pool, from_t.elem, to_t.elem);
    }

    // Array to slice with same element type
    if from_t.kind == TypeKind.Array and to_t.kind == TypeKind.Slice {
        return TypeInfo_equal(pool, from_t.elem, to_t.elem);
    }

    // Array types with same element and length
    if from_t.kind == TypeKind.Array and to_t.kind == TypeKind.Array {
        return from_t.len == to_t.len and TypeInfo_equal(pool, from_t.elem, to_t.elem);
    }

    return false;
}

fn names_equal_ptr(source: *u8, start: i64, len1: i64, ptr: *u8, len2: i64) bool {
    if len1 != len2 { return false; }
    var i: i64 = 0;
    while i < len1 {
        let c1: u8 = (source + start + i).*;
        let c2: u8 = (ptr + i).*;
        if c1 != c2 { return false; }
        i = i + 1;
    }
    return true;
}

fn TypeInfo_getPointee(pool: *TypeRegistry, ptr_type_idx: i64) i64 {
    let t: *Type = pool.get(ptr_type_idx);
    if t.kind == TypeKind.Pointer {
        return t.elem;
    }
    return TYPE_INVALID;
}

fn TypeInfo_isPrimitive(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get(idx);
    if t.kind == TypeKind.Bool { return true; }
    if t.kind == TypeKind.I8 { return true; }
    if t.kind == TypeKind.I16 { return true; }
    if t.kind == TypeKind.I32 { return true; }
    if t.kind == TypeKind.I64 { return true; }
    if t.kind == TypeKind.U8 { return true; }
    if t.kind == TypeKind.U16 { return true; }
    if t.kind == TypeKind.U32 { return true; }
    if t.kind == TypeKind.U64 { return true; }
    if t.kind == TypeKind.F32 { return true; }
    if t.kind == TypeKind.F64 { return true; }
    if t.kind == TypeKind.Void { return true; }
    return false;
}

fn TypeInfo_fitsInRegs(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get(idx);
    return t.size <= 16;
}

fn TypeInfo_needsReg(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get(idx);
    if t.kind == TypeKind.Void { return false; }
    if t.kind == TypeKind.Invalid { return false; }
    return true;
}

fn TypeInfo_registerCount(pool: *TypeRegistry, idx: i64) i64 {
    let t: *Type = pool.get(idx);
    if t.kind == TypeKind.Void { return 0; }
    if t.kind == TypeKind.Invalid { return 0; }
    // String/Slice need 2 registers (ptr + len)
    if t.kind == TypeKind.String { return 2; }
    if t.kind == TypeKind.Slice { return 2; }
    // Everything else fits in 1 register (for now)
    if t.size <= 8 { return 1; }
    // Larger types need 2 registers
    if t.size <= 16 { return 2; }
    // Even larger types would need memory
    return 0;
}

// ============================================================================
// TEST INFRASTRUCTURE - Types
// ============================================================================

struct TestPoint {
    x: i64,
    y: i64,
}

struct TestInner {
    a: i64,
    b: i64,
}

struct TestOuter {
    inner: TestInner,
    c: i64,
}

struct TestLargeStruct {
    a: i64,
    b: i64,
    c: i64,
    d: i64,
    e: i64,
    f: i64,
    g: i64,
    h: i64,
}

enum TestStatus {
    Pending,
    Active,
    Done,
}

struct TestBigReturn {
    a: i64,
    b: i64,
    c: i64,
}

struct TestNodeForPtr {
    value: i64,
}

struct TestBigArg {
    a: i64,
    b: i64,
    c: i64,
    d: i64,
    e: i64,
    f: i64,
    g: i64,
}

// BUG-003: Struct with enum field - tests correct enum sizing
enum TestTokenKind { Ident, Number, String }
struct TestTokenWithEnum {
    kind: TestTokenKind,
    x: i64,
    y: i64,
}

// BUG-012: Pointer dereference to struct field
struct TestNodeForDeref {
    kind: i64,
    value: i64,
}

// BUG-016: Const on right side of comparison
const TEST_BUG016_CONST: i64 = 42

// ============================================================================
// TEST INFRASTRUCTURE - Helper Functions
// ============================================================================

fn test_add_via_ptr(ptr: *i64, val: i64) void {
    ptr.* = ptr.* + val
}

fn test_set_point_x(p: *TestPoint, val: i64) void {
    p.x = val
}

fn test_check_status(s: TestStatus) i64 {
    if s == TestStatus.Done { return 42 }
    if s == TestStatus.Active { return 20 }
    return 10
}

fn test_get_node_value(p: *TestNodeForPtr) i64 {
    return p.value
}

fn test_sum_big_arg(s: TestBigArg) i64 {
    return s.a + s.b + s.c + s.d + s.e + s.f + s.g
}

fn test_make_big_return(x: i64, y: i64, z: i64) TestBigReturn {
    var r: TestBigReturn
    r.a = x
    r.b = y
    r.c = z
    return r
}

fn test_get_deref_value(p: *TestNodeForDeref) i64 {
    return p.value
}

// ============================================================================
// INLINE TESTS - Bug Regression Tests (consolidated)
// ============================================================================

test "bug regressions" {
    // BUG-003: Struct with enum field - verifies correct enum sizing
    // If enum size is wrong, subsequent fields get corrupted
    var t: TestTokenWithEnum
    t.kind = TestTokenKind.Ident
    t.x = 10
    t.y = 20
    @assert(t.x + t.y == 30)

    // BUG-012: Pointer dereference to struct field
    var node: TestNodeForDeref
    node.kind = 5
    node.value = 42
    @assert(test_get_deref_value(&node) == 42)

    // BUG-016: Const on right side of comparison
    let a: i64 = 42
    @assert(a == TEST_BUG016_CONST)
}

// ============================================================================
// INLINE TESTS - Struct Types (consolidated)
// ============================================================================

test "struct operations" {
    // Simple struct
    var p: TestPoint
    p.x = 20
    p.y = 22
    @assert(p.x + p.y == 42)

    // Reassign fields
    var p2: TestPoint
    p2.x = 10
    p2.y = 10
    p2.x = p2.x + 12
    p2.y = p2.y + 10
    @assert(p2.x + p2.y == 42)

    // Nested struct access
    var o: TestOuter
    o.inner.a = 10
    o.inner.b = 20
    o.c = 12
    @assert(o.inner.a + o.inner.b + o.c == 42)

    // Large struct (>16 bytes)
    var s: TestLargeStruct
    s.a = 1; s.b = 2; s.c = 3; s.d = 4
    s.e = 5; s.f = 6; s.g = 7; s.h = 14
    @assert(s.a + s.b + s.c + s.d + s.e + s.f + s.g + s.h == 42)
}

// ============================================================================
// INLINE TESTS - Enum Types (consolidated)
// ============================================================================

test "enum operations" {
    @assert(test_check_status(TestStatus.Pending) == 10)
    @assert(test_check_status(TestStatus.Active) == 20)
    @assert(test_check_status(TestStatus.Done) == 42)
}

// ============================================================================
// INLINE TESTS - Pointer Types (consolidated)
// ============================================================================

test "pointer operations" {
    // Read through pointer
    var x: i64 = 42
    var p: *i64 = &x
    @assert(p.* == 42)

    // Write through pointer
    var y: i64 = 0
    var q: *i64 = &y
    q.* = 42
    @assert(y == 42)

    // Modify via pointer parameter
    var z: i64 = 10
    test_add_via_ptr(&z, 32)
    @assert(z == 42)

    // Pointer to struct field
    var pt: TestPoint
    pt.x = 0
    pt.y = 22
    test_set_point_x(&pt, 20)
    @assert(pt.x + pt.y == 42)

    // Pointer to pointer (double dereference)
    var a: i64 = 42
    var pa: *i64 = &a
    var ppa: **i64 = &pa
    @assert(ppa.*.* == 42)

    // Modify through pointer-to-pointer
    ppa.*.* = 100
    @assert(a == 100)

    // Pointer comparison
    var b: i64 = 42
    var pb: *i64 = &b
    var pb2: *i64 = &b
    @assert(pb == pb2)  // Same address

    var c: i64 = 42
    var pc: *i64 = &c
    @assert(pb != pc)  // Different addresses
}

// ============================================================================
// INLINE TESTS - Array Types (consolidated)
// ============================================================================

test "array operations" {
    // Index with constant
    var arr: [4]i64 = [10, 20, 30, 40]
    @assert(arr[0] == 10)

    // Index with variable
    var i: i64 = 2
    @assert(arr[i] == 30)

    // Assignment
    var arr2: [4]i64 = [0, 0, 0, 0]
    arr2[0] = 10; arr2[1] = 20
    arr2[2] = 30; arr2[3] = 40
    @assert(arr2[0] + arr2[3] == 50)

    // Sum elements
    var arr3: [4]i64 = [10, 11, 12, 9]
    @assert(arr3[0] + arr3[1] + arr3[2] + arr3[3] == 42)

    // Copy semantics
    var a: [3]i64 = [10, 20, 30]
    var b: [3]i64 = a
    b[0] = 99
    @assert(a[0] == 10)
    @assert(b[0] == 99)

    // Loop over array
    var arr4: [5]i64 = [1, 2, 3, 4, 5]
    var sum: i64 = 0
    var j: i64 = 0
    while j < 5 {
        sum = sum + arr4[j]
        j = j + 1
    }
    @assert(sum == 15)
}

// ============================================================================
// INLINE TESTS - Slice Types (consolidated)
// ============================================================================

test "slice operations" {
    // Create slice
    var arr: [5]i64 = [10, 20, 30, 40, 50]
    let s1: []i64 = arr[0:3]
    @assert(len(s1) == 3)

    // Index slice
    let s2: []i64 = arr[1:4]
    @assert(s2[0] == 20)
    @assert(s2[1] == 30)
    @assert(s2[2] == 40)

    // Offset slice
    let s3: []i64 = arr[2:5]
    @assert(s3[0] == 30)

    // Write through slice (shared memory)
    let s4: []i64 = arr[0:3]
    s4[0] = 42
    @assert(arr[0] == 42)

    // Implicit end
    arr[0] = 10  // restore
    let s5: []i64 = arr[2:]
    @assert(s5[0] == 30)
    @assert(len(s5) == 3)

    // Implicit start
    let s6: []i64 = arr[:3]
    @assert(s6[2] == 30)
    @assert(len(s6) == 3)

    // Full slice
    let s7: []i64 = arr[:]
    @assert(len(s7) == 5)
}

// ============================================================================
// INLINE TESTS - String Types (consolidated)
// ============================================================================

test "string operations" {
    // Literal
    let s1: string = "hello"
    @assert(len(s1) == 5)

    // Empty
    let s2: string = ""
    @assert(len(s2) == 0)

    // Escape sequences
    let s3: string = "a\nb"
    @assert(len(s3) == 3)

    // Index
    let c: u8 = s1[0]
    @assert(c == 104)  // 'h'

    // Copy
    let s4: string = s1
    @assert(len(s4) == 5)

    // Slice
    let sub: string = s1[0:3]
    @assert(len(sub) == 3)

    // Concat
    let s5: string = "hello"
    let s6: string = " world"
    let s7: string = s5 + s6
    @assert(len(s7) == 11)

    // Concat with empty
    let s8: string = "foo"
    let s9: string = ""
    let s10: string = s8 + s9
    @assert(len(s10) == 3)
}

// ============================================================================
// INLINE TESTS - Null Pointers (consolidated)
// ============================================================================

test "null pointer operations" {
    let p1: *i64 = null
    @assert(p1 == null)
    @assert(null == p1)

    var x: i64 = 42
    let p2: *i64 = &x
    @assert(p2 != null)
}

// ============================================================================
// INLINE TESTS - Characters (consolidated)
// ============================================================================

test "character operations" {
    let c: u8 = 'A'
    @assert(c == 65)

    let a: u8 = 'a'
    let b: u8 = 'b'
    @assert(a < b)

    let newline: u8 = '\n'
    let tab: u8 = '\t'
    @assert(newline == 10)
    @assert(tab == 9)
}

// ============================================================================
// INLINE TESTS - Integer Types (consolidated)
// ============================================================================

test "integer type operations" {
    // u8 type
    let u8_val: u8 = 255
    @assert(u8_val == 255)

    // i32 type
    let small: i32 = 1000
    @assert(small == 1000)

    // Negative i32
    let neg: i32 = -500
    @assert(neg == -500)

    // u32 type
    let unsigned: u32 = 4000000000
    @assert(unsigned > 0)

    // Type casting with @intCast
    let a: u8 = 100
    let b: i64 = @intCast(i64, a)
    @assert(b == 100)

    // Truncating cast
    let c: i64 = 300
    let d: u8 = @intCast(u8, c)  // 300 mod 256 = 44
    @assert(d == 44)

    // i64 extremes
    let max: i64 = 9223372036854775807
    @assert(max > 0)
}

// ============================================================================
// INLINE TESTS - Nested Struct Types (consolidated)
// ============================================================================

struct TestInnerStruct {
    x: i64,
    y: i64,
}

struct TestOuterStruct {
    inner: TestInnerStruct,
    z: i64,
}

struct TestDeepNested {
    outer: TestOuterStruct,
    w: i64,
}

test "nested struct operations" {
    // Basic nested struct
    var outer: TestOuterStruct
    outer.inner.x = 10
    outer.inner.y = 20
    outer.z = 30
    @assert(outer.inner.x == 10)
    @assert(outer.inner.y == 20)
    @assert(outer.z == 30)

    // Nested struct literal
    let outer2: TestOuterStruct = TestOuterStruct{
        .inner = TestInnerStruct{ .x = 1, .y = 2 },
        .z = 3
    }
    @assert(outer2.inner.x + outer2.inner.y + outer2.z == 6)

    // Deep nested struct
    var deep: TestDeepNested
    deep.outer.inner.x = 5
    deep.outer.inner.y = 6
    deep.outer.z = 7
    deep.w = 8
    @assert(deep.outer.inner.x + deep.outer.inner.y + deep.outer.z + deep.w == 26)

    // Copy inner struct
    let inner_copy: TestInnerStruct = outer.inner
    @assert(inner_copy.x == 10)
    @assert(inner_copy.y == 20)
}

// ============================================================================
// INLINE TESTS - Struct with Array Members (consolidated)
// ============================================================================

struct TestArrayStruct {
    values: [5]i64,
    count: i64,
}

test "struct with array member" {
    var s: TestArrayStruct
    s.count = 0

    // Fill array
    var i: i64 = 0
    while i < 5 {
        s.values[i] = i * 10
        s.count = s.count + 1
        i = i + 1
    }
    @assert(s.count == 5)
    @assert(s.values[0] == 0)
    @assert(s.values[2] == 20)
    @assert(s.values[4] == 40)

    // Sum values
    var sum: i64 = 0
    var j: i64 = 0
    while j < s.count {
        sum = sum + s.values[j]
        j = j + 1
    }
    @assert(sum == 100)  // 0+10+20+30+40
}

// ============================================================================
// INLINE TESTS - Pointer to Struct Operations (consolidated)
// ============================================================================

fn test_modify_inner(inner: *TestInnerStruct) void {
    inner.x = 100
    inner.y = 200
}

fn test_sum_inner(inner: *TestInnerStruct) i64 {
    return inner.x + inner.y
}

test "pointer to struct operations" {
    // Modify struct through pointer
    var inner: TestInnerStruct = TestInnerStruct{ .x = 1, .y = 2 }
    test_modify_inner(&inner)
    @assert(inner.x == 100)
    @assert(inner.y == 200)

    // Read struct through pointer in function
    var inner2: TestInnerStruct = TestInnerStruct{ .x = 30, .y = 12 }
    @assert(test_sum_inner(&inner2) == 42)

    // Pointer to nested struct member
    var outer: TestOuterStruct
    outer.inner.x = 5
    outer.inner.y = 10
    outer.z = 15
    let p: *TestInnerStruct = &outer.inner
    @assert(p.x == 5)
    @assert(p.y == 10)

    // Modify nested through pointer
    p.x = 50
    @assert(outer.inner.x == 50)
}

// ============================================================================
// INLINE TESTS - Array of Structs (consolidated)
// ============================================================================

test "array of structs" {
    var arr: [3]TestInnerStruct = undefined
    arr[0] = TestInnerStruct{ .x = 1, .y = 2 }
    arr[1] = TestInnerStruct{ .x = 3, .y = 4 }
    arr[2] = TestInnerStruct{ .x = 5, .y = 6 }

    // Access elements
    @assert(arr[0].x == 1)
    @assert(arr[1].y == 4)
    @assert(arr[2].x + arr[2].y == 11)

    // Sum all values
    var sum: i64 = 0
    var i: i64 = 0
    while i < 3 {
        sum = sum + arr[i].x + arr[i].y
        i = i + 1
    }
    @assert(sum == 21)  // (1+2)+(3+4)+(5+6)

    // Modify element
    arr[1].x = 30
    arr[1].y = 40
    @assert(arr[1].x + arr[1].y == 70)
}

// ============================================================================
// INLINE TESTS - Slice of Structs (consolidated)
// ============================================================================

test "slice of structs" {
    var arr: [5]TestInnerStruct = undefined
    var i: i64 = 0
    while i < 5 {
        arr[i] = TestInnerStruct{ .x = i, .y = i * 2 }
        i = i + 1
    }

    // Create slice
    let s: []TestInnerStruct = arr[1:4]
    @assert(len(s) == 3)

    // Access slice elements
    @assert(s[0].x == 1)  // arr[1]
    @assert(s[1].x == 2)  // arr[2]
    @assert(s[2].x == 3)  // arr[3]

    // Sum x values in slice
    var sum: i64 = 0
    for item in s {
        sum = sum + item.x
    }
    @assert(sum == 6)  // 1+2+3
}

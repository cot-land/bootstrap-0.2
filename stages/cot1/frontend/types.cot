// Cot0 Type Representation
// Minimal type system for: i64, bool, void, functions
//
// Design follows Go's go/types package patterns:
// - TypeKind enum for type discrimination
// - TypeIndex (i64) for compact storage and interning
// - TypeRegistry for type creation and lookup
// - Predicate functions for type checking
//
// Reference: ~/learning/go/src/cmd/compile/internal/types/type.go
// Reference: bootstrap-0.2/src/frontend/types.zig

import "token.cot"
import "../lib/list.cot"  // For realloc_i64
import "../lib/strmap.cot"  // For type name lookup

// ============================================================================
// Type Aliases (cot1 feature: dogfooding our own language features)
// ============================================================================

// TypeId: Index into type pool
// Makes code more readable - clear that we're dealing with type indices
type TypeId = i64

// ============================================================================
// Type Index
// ============================================================================

// Index into type pool. -1 = invalid/error type.
const INVALID_TYPE: TypeId = -1;

// ============================================================================
// Type Kinds (Go's Kind enum)
// ============================================================================

// Kind of type.
enum TypeKind {
    Invalid,    // Error/unknown type

    // Basic types
    Bool,       // bool
    I8,         // i8
    I16,        // i16
    I32,        // i32
    I64,        // i64
    U8,         // u8
    U16,        // u16
    U32,        // u32
    U64,        // u64
    F32,        // f32
    F64,        // f64
    Void,       // void (no value)

    // Composite types
    Pointer,    // *T
    Slice,      // []T
    Array,      // [N]T
    Func,       // fn(args) ret
    Struct,     // struct { fields }
    Enum,       // enum { variants }
    String,     // string (slice of u8)
}

// ============================================================================
// Type Structure
// ============================================================================

// Type represents a Cot type.
// Uses a flat struct with kind-specific interpretation of fields.
struct Type {
    kind: TypeKind,

    // Kind-specific fields:
    // For Pointer: elem is the pointee type index
    // For Slice: elem is the element type index
    // For Array: elem is element type, len is array length
    // For Func: params_start, params_count, ret_type
    // For Struct: name_start, name_len, fields_start, fields_count

    elem: i64,          // Element type index (for Pointer, Slice, Array)
    len: i64,           // Array length (for Array)
    ret_type: i64,      // Return type index (for Func)
    params_start: i64,  // Start index in params array (for Func)
    params_count: i64,  // Number of parameters (for Func)
    name_start: i64,    // Name offset in source (for Struct, Enum)
    name_len: i64,      // Name length (for Struct, Enum)
    size: i64,          // Size in bytes
    align: i64,         // Alignment in bytes
}

// ============================================================================
// Field Information (for struct fields)
// ============================================================================

struct FieldInfo {
    name_start: i64,    // Field name offset in source
    name_len: i64,      // Field name length
    type_idx: i64,      // Field type index
    offset: i64,        // Byte offset within struct
}

// ============================================================================
// Type Pool (arena allocation for type interning)
// ============================================================================

// MAX_TYPES, MAX_PARAMS, MAX_FIELDS removed - using dynamic growth

// Realloc externs for dynamic growth
// Note: realloc_i64 is declared in lib/list.cot
extern fn realloc_Type(ptr: *Type, old_count: i64, new_count: i64) *Type;
extern fn realloc_FieldInfo(ptr: *FieldInfo, old_count: i64, new_count: i64) *FieldInfo;

// Malloc externs for self-allocation
extern fn malloc_Type(count: i64) *Type;
extern fn malloc_FieldInfo(count: i64) *FieldInfo;

// ============================================================================
// Module Storage (allocated once, reused across compilations)
// Following Zig pattern: modules self-allocate rather than requiring
// external storage passed in from main.
// ============================================================================

// Initial capacities
const TR_INIT_TYPES: i64 = 1024;
const TR_INIT_PARAMS: i64 = 5000;
const TR_INIT_FIELDS: i64 = 5000;

// Module-level storage
var tr_types: *Type = null;
var tr_types_cap: i64 = 0;
var tr_params: *i64 = null;
var tr_params_cap: i64 = 0;
var tr_fields: *FieldInfo = null;
var tr_fields_cap: i64 = 0;
var tr_storage_initialized: bool = false;

// Allocate module storage (called once on first use)
fn TypeRegistry_allocateStorage() {
    if tr_storage_initialized {
        return;
    }

    tr_types_cap = TR_INIT_TYPES;
    tr_types = malloc_Type(tr_types_cap);

    tr_params_cap = TR_INIT_PARAMS;
    tr_params = malloc_i64(tr_params_cap);

    tr_fields_cap = TR_INIT_FIELDS;
    tr_fields = malloc_FieldInfo(tr_fields_cap);

    tr_storage_initialized = true;
}

struct TypeRegistry {
    types: *Type,        // Pointer to array of types
    count: i64,          // Current type count
    types_cap: i64,      // Types array capacity

    // Parameter arrays (for function types)
    params: *i64,        // Pointer to array of type indices
    params_count: i64,
    params_cap: i64,     // Params array capacity

    // Field arrays (for struct types)
    fields: *FieldInfo,  // Pointer to array of field information
    fields_count: i64,   // Current field count
    fields_cap: i64,     // Fields array capacity

    // Source text for name comparison
    source: *u8,
    source_len: i64,

    // Name to type index map (for fast lookup)
    name_map: StrMap,
}

// ============================================================================
// Pre-defined Type Indices
// ============================================================================

// These match the order in which types are registered in TypeRegistry_init
const TYPE_INVALID: i64 = 0;
const TYPE_BOOL: i64 = 1;
const TYPE_I8: i64 = 2;
const TYPE_I16: i64 = 3;
const TYPE_I32: i64 = 4;
const TYPE_I64: i64 = 5;
const TYPE_U8: i64 = 6;
const TYPE_U16: i64 = 7;
const TYPE_U32: i64 = 8;
const TYPE_U64: i64 = 9;
const TYPE_F32: i64 = 10;
const TYPE_F64: i64 = 11;
const TYPE_VOID: i64 = 12;
const TYPE_STRING: i64 = 13;
const TYPE_SLICE: i64 = 14;   // Slice type marker for locals

// Aliases
const TYPE_INT: i64 = 5;   // i64 is the default int
const TYPE_FLOAT: i64 = 11; // f64 is the default float
const TYPE_BYTE: i64 = 6;  // u8 is byte

// First user-defined type index
const FIRST_USER_TYPE: i64 = 15;

// ============================================================================
// Parser Type Handles (PTYPE_*)
// ============================================================================
// These are used by the parser to represent types before TypeRegistry resolution.
// The resolve_type_handle() function converts PTYPE_* to TYPE_* indices.
//
// PTYPE_* ranges:
// - 0-9: Basic types
// - 10-99: Pointer types (PTYPE_PTR_BASE + pointee_handle)
// - 100+: User types (PTYPE_USER_BASE + source offset of type name)

const PTYPE_I64: i64 = 0;
const PTYPE_I32: i64 = 1;
const PTYPE_U8: i64 = 2;
const PTYPE_BOOL: i64 = 3;
const PTYPE_VOID: i64 = 4;
const PTYPE_STRING: i64 = 5;
const PTYPE_PTR_BASE: i64 = 10;    // Pointer types start here
const PTYPE_USER_BASE: i64 = 100;  // User types start here (up to 9999)
const PTYPE_ARRAY_BASE: i64 = 10000;  // Array types: PTYPE_ARRAY_BASE + index into array_info table
const PTYPE_SLICE_BASE: i64 = 100000; // Slice types: PTYPE_SLICE_BASE + elem_type

// Array type info storage - simple inline encoding
// Since we can't easily share global pointers between files,
// use a simpler encoding: PTYPE_ARRAY_BASE + (size * 100 + elem_type)
// This limits array sizes to < 100000 and element types to < 100

// Register an array type, returns PTYPE handle

impl TypeRegistry {

    fn ensureTypesCapacity(self: *TypeRegistry, additional: i64) {
        let needed: i64 = self.count + additional;
        if needed <= self.types_cap {
            return;
        }
        var new_cap: i64 = self.types_cap * 2;
        if new_cap < needed {
            new_cap = needed;
        }
        self.types = realloc_Type(self.types, self.types_cap, new_cap);
        self.types_cap = new_cap;
        // Update module storage if using self-allocation
        if tr_storage_initialized {
            tr_types = self.types;
            tr_types_cap = self.types_cap;
        }
    }

    fn ensureParamsCapacity(self: *TypeRegistry, additional: i64) {
        let needed: i64 = self.params_count + additional;
        if needed <= self.params_cap {
            return;
        }
        var new_cap: i64 = self.params_cap * 2;
        if new_cap < needed {
            new_cap = needed;
        }
        self.params = realloc_i64(self.params, self.params_cap, new_cap);
        self.params_cap = new_cap;
        // Update module storage if using self-allocation
        if tr_storage_initialized {
            tr_params = self.params;
            tr_params_cap = self.params_cap;
        }
    }

    fn ensureFieldsCapacity(self: *TypeRegistry, additional: i64) {
        let needed: i64 = self.fields_count + additional;
        if needed <= self.fields_cap {
            return;
        }
        var new_cap: i64 = self.fields_cap * 2;
        if new_cap < needed {
            new_cap = needed;
        }
        self.fields = realloc_FieldInfo(self.fields, self.fields_cap, new_cap);
        self.fields_cap = new_cap;
        // Update module storage if using self-allocation
        if tr_storage_initialized {
            tr_fields = self.fields;
            tr_fields_cap = self.fields_cap;
        }
    }

    fn initWithStorage(self: *TypeRegistry, types: *Type, types_cap: i64,
                                     params: *i64, params_cap: i64,
                                     fields: *FieldInfo, fields_cap: i64) {
        self.types = types;
        self.types_cap = types_cap;
        self.params = params;
        self.params_cap = params_cap;
        self.fields = fields;
        self.fields_cap = fields_cap;
        self.count = 0;
        self.params_count = 0;
        self.fields_count = 0;
        self.source = null;
        self.source_len = 0;
        self.name_map = StrMap_init(256);  // Initialize type name lookup map
    
        // Register basic types in order
        self.registerBasic(TypeKind.Invalid, 0, 0);   // 0: invalid
        self.registerBasic(TypeKind.Bool, 1, 1);      // 1: bool
        self.registerBasic(TypeKind.I8, 1, 1);        // 2: i8
        self.registerBasic(TypeKind.I16, 2, 2);       // 3: i16
        self.registerBasic(TypeKind.I32, 4, 4);       // 4: i32
        self.registerBasic(TypeKind.I64, 8, 8);       // 5: i64
        self.registerBasic(TypeKind.U8, 1, 1);        // 6: u8
        self.registerBasic(TypeKind.U16, 2, 2);       // 7: u16
        self.registerBasic(TypeKind.U32, 4, 4);       // 8: u32
        self.registerBasic(TypeKind.U64, 8, 8);       // 9: u64
        self.registerBasic(TypeKind.F32, 4, 4);       // 10: f32
        self.registerBasic(TypeKind.F64, 8, 8);       // 11: f64
        self.registerBasic(TypeKind.Void, 0, 0);      // 12: void
        self.registerBasic(TypeKind.String, 16, 8);   // 13: string (ptr + len)
        self.registerBasic(TypeKind.Slice, 16, 8);    // 14: TYPE_SLICE placeholder (ptr + len)
        // User types start at index 15 (FIRST_USER_TYPE)
    }

    fn init(self: *TypeRegistry) {
        // Allocate module storage if not already done
        TypeRegistry_allocateStorage();
    
        // Wire up pool to use module storage
        self.types = tr_types;
        self.types_cap = tr_types_cap;
        self.params = tr_params;
        self.params_cap = tr_params_cap;
        self.fields = tr_fields;
        self.fields_cap = tr_fields_cap;
        self.count = 0;
        self.params_count = 0;
        self.fields_count = 0;
        self.source = null;
        self.source_len = 0;
        self.name_map = StrMap_init(256);  // Initialize type name lookup map
    
        // Register basic types in order
        self.registerBasic(TypeKind.Invalid, 0, 0);   // 0: invalid
        self.registerBasic(TypeKind.Bool, 1, 1);      // 1: bool
        self.registerBasic(TypeKind.I8, 1, 1);        // 2: i8
        self.registerBasic(TypeKind.I16, 2, 2);       // 3: i16
        self.registerBasic(TypeKind.I32, 4, 4);       // 4: i32
        self.registerBasic(TypeKind.I64, 8, 8);       // 5: i64
        self.registerBasic(TypeKind.U8, 1, 1);        // 6: u8
        self.registerBasic(TypeKind.U16, 2, 2);       // 7: u16
        self.registerBasic(TypeKind.U32, 4, 4);       // 8: u32
        self.registerBasic(TypeKind.U64, 8, 8);       // 9: u64
        self.registerBasic(TypeKind.F32, 4, 4);       // 10: f32
        self.registerBasic(TypeKind.F64, 8, 8);       // 11: f64
        self.registerBasic(TypeKind.Void, 0, 0);      // 12: void
        self.registerBasic(TypeKind.String, 16, 8);   // 13: string (ptr + len)
        self.registerBasic(TypeKind.Slice, 16, 8);    // 14: TYPE_SLICE placeholder (ptr + len)
        // User types start at index 15 (FIRST_USER_TYPE)
    }

    fn registerBasic(self: *TypeRegistry, kind: TypeKind, size: i64, align: i64) i64 {
        self.ensureTypesCapacity(1);
        let idx: i64 = self.count;
        self.count = self.count + 1;
    
        let t: *Type = self.types + idx;
        t.kind = kind;
        t.elem = INVALID_TYPE;
        t.len = 0;
        t.ret_type = INVALID_TYPE;
        t.params_start = 0;
        t.params_count = 0;
        t.name_start = 0;
        t.name_len = 0;
        t.size = size;
        t.align = align;
    
        return idx;
    }

    fn get(self: *TypeRegistry, idx: i64) *Type {
        if idx < 0 or idx >= self.count {
            return self.types + 0;  // Return invalid type
        }
        return self.types + idx;
    }

    fn findByName(self: *TypeRegistry, name_ptr: *u8, name_len: i64) i64 {
        return StrMap_get(&self.name_map, name_ptr, name_len);
    }

    fn lookupByName(self: *TypeRegistry, source: *u8, name_start: i64, name_len: i64) i64 {
        return StrMap_get(&self.name_map, source + name_start, name_len);
    }

    fn makePointer(self: *TypeRegistry, elem: i64) i64 {
        self.ensureTypesCapacity(1);
        let idx: i64 = self.count;
        self.count = self.count + 1;
    
        let t: *Type = self.types + idx;
        t.kind = TypeKind.Pointer;
        t.elem = elem;
        t.len = 0;
        t.ret_type = INVALID_TYPE;
        t.params_start = 0;
        t.params_count = 0;
        t.name_start = 0;
        t.name_len = 0;
        t.size = 8;  // Pointers are 8 bytes on 64-bit
        t.align = 8;
    
        return idx;
    }

    fn makeSlice(self: *TypeRegistry, elem: i64) i64 {
        self.ensureTypesCapacity(1);
        let idx: i64 = self.count;
        self.count = self.count + 1;
    
        let t: *Type = self.types + idx;
        t.kind = TypeKind.Slice;
        t.elem = elem;
        t.len = 0;
        t.ret_type = INVALID_TYPE;
        t.params_start = 0;
        t.params_count = 0;
        t.name_start = 0;
        t.name_len = 0;
        t.size = 16;  // ptr + len
        t.align = 8;
    
        return idx;
    }

    fn makeArray(self: *TypeRegistry, elem: i64, array_len: i64) i64 {
        self.ensureTypesCapacity(1);
        let idx: i64 = self.count;
        self.count = self.count + 1;
    
        let elem_type: *Type = self.get(elem);
        let elem_size: i64 = elem_type.size;
    
        let t: *Type = self.types + idx;
        t.kind = TypeKind.Array;
        t.elem = elem;
        t.len = array_len;
        t.ret_type = INVALID_TYPE;
        t.params_start = 0;
        t.params_count = 0;
        t.name_start = 0;
        t.name_len = 0;
        t.size = elem_size * array_len;
        t.align = elem_type.align;
    
        return idx;
    }

    fn makeFunc(self: *TypeRegistry, params_start: i64, params_count: i64, ret_type: i64) i64 {
        self.ensureTypesCapacity(1);
        let idx: i64 = self.count;
        self.count = self.count + 1;
    
        let t: *Type = self.types + idx;
        t.kind = TypeKind.Func;
        t.elem = INVALID_TYPE;
        t.len = 0;
        t.ret_type = ret_type;
        t.params_start = params_start;
        t.params_count = params_count;
        t.name_start = 0;
        t.name_len = 0;
        t.size = 8;  // Function pointer
        t.align = 8;
    
        return idx;
    }

    fn addParam(self: *TypeRegistry, param_type: i64) i64 {
        self.ensureParamsCapacity(1);
        let idx: i64 = self.params_count;
        let ptr: *i64 = self.params + idx;
        ptr.* = param_type;
        self.params_count = self.params_count + 1;
        return idx;
    }

    fn makeStruct(self: *TypeRegistry, name_start: i64, name_len: i64,
                        fields_start: i64, fields_count: i64, size: i64, align: i64) i64 {
        self.ensureTypesCapacity(1);
        let idx: i64 = self.count;
        self.count = self.count + 1;
    
        let t: *Type = self.types + idx;
        t.kind = TypeKind.Struct;
        t.elem = INVALID_TYPE;
        t.len = 0;
        t.ret_type = INVALID_TYPE;
        t.params_start = fields_start;  // Reuse params for field types
        t.params_count = fields_count;
        t.name_start = name_start;
        t.name_len = name_len;
        t.size = size;
        t.align = align;
    
        // Register in name map for fast lookup
        if name_len > 0 and self.source != null {
            StrMap_put(&self.name_map, self.source + name_start, name_len, idx);
        }
    
        return idx;
    }

    fn makeEnum(self: *TypeRegistry, name_start: i64, name_len: i64,
                      variants_count: i64) i64 {
        self.ensureTypesCapacity(1);
        let idx: i64 = self.count;
        self.count = self.count + 1;
    
        let t: *Type = self.types + idx;
        t.kind = TypeKind.Enum;
        t.elem = INVALID_TYPE;
        t.len = variants_count;  // Store variant count in len field
        t.ret_type = INVALID_TYPE;
        t.params_start = 0;
        t.params_count = 0;
        t.name_start = name_start;
        t.name_len = name_len;
        t.size = 4;   // Enums are 4 bytes (i32)
        t.align = 4;
    
        // Register in name map for fast lookup
        if name_len > 0 and self.source != null {
            StrMap_put(&self.name_map, self.source + name_start, name_len, idx);
        }
    
        return idx;
    }

    fn getParam(self: *TypeRegistry, params_start: i64, offset: i64) i64 {
        let ptr: *i64 = self.params + params_start + offset;
        return ptr.*;
    }

    fn sizeof(self: *TypeRegistry, idx: i64) i64 {
        if idx < 0 { return 0; }
    
        let t: *Type = self.get(idx);
        if t == null { return 0; }
    
        // For types with explicit size field, use it
        if t.size > 0 { return t.size; }
    
        // Handle by kind
        if t.kind == TypeKind.Pointer { return 8; }  // 64-bit pointer
        if t.kind == TypeKind.Slice { return 16; }   // ptr + len
        if t.kind == TypeKind.Func { return 8; }     // function pointer
        if t.kind == TypeKind.String { return 16; }  // ptr + len
    
        // Array: element size * length
        if t.kind == TypeKind.Array {
            let elem_size: i64 = self.sizeof(t.elem);
            return elem_size * t.len;
        }
    
        // Struct: use stored size
        if t.kind == TypeKind.Struct { return t.size; }
    
        // Enum: use stored size (usually i64)
        if t.kind == TypeKind.Enum { return t.size; }
    
        // Default to 8 for unknown types
        return 8;
    }

    fn setSource(self: *TypeRegistry, source: *u8, source_len: i64) {
        self.source = source;
        self.source_len = source_len;
    }

    fn addField(self: *TypeRegistry, name_start: i64, name_len: i64,
                      type_idx: i64, offset: i64) i64 {
        self.ensureFieldsCapacity(1);
        let idx: i64 = self.fields_count;
        self.fields_count = self.fields_count + 1;
    
        let f: *FieldInfo = self.fields + idx;
        f.name_start = name_start;
        f.name_len = name_len;
        f.type_idx = type_idx;
        f.offset = offset;
    
        return idx;
    }

    fn getField(self: *TypeRegistry, idx: i64) *FieldInfo {
        return self.fields + idx;
    }

    fn lookupField(self: *TypeRegistry, type_idx: i64,
                         field_name_ptr: *u8, field_name_len: i64) *FieldInfo {
        let t: *Type = self.get(type_idx);
    
        if t.kind != TypeKind.Struct {
            return null;
        }
    
        // fields_start in params_start, fields_count in params_count
        let fields_start: i64 = t.params_start;
        let fields_count: i64 = t.params_count;
    
        var i: i64 = 0;
        while i < fields_count {
            let f: *FieldInfo = self.fields + fields_start + i;
    
            if names_equal_ptr(self.source, f.name_start, f.name_len,
                              field_name_ptr, field_name_len) {
                return f;
            }
            i = i + 1;
        }
    
        return null;
    }

}

fn PType_registerArray(elem_ptype: i64, size: i64) i64 {
    // Encode: size * 100 + elem_type (elem_type < 100)
    return PTYPE_ARRAY_BASE + size * 100 + elem_ptype;
}

fn PType_arrayElem(ptype: i64) i64 {
    if ptype < PTYPE_ARRAY_BASE {
        return PTYPE_I64;
    }
    let encoded: i64 = ptype - PTYPE_ARRAY_BASE;
    return encoded % 100;  // elem_type is the remainder
}

fn PType_arraySize(ptype: i64) i64 {
    if ptype < PTYPE_ARRAY_BASE {
        return 0;
    }
    let encoded: i64 = ptype - PTYPE_ARRAY_BASE;
    return encoded / 100;  // size is the quotient
}

fn PType_registerSlice(elem_ptype: i64) i64 {
    return PTYPE_SLICE_BASE + elem_ptype;
}

fn PType_sliceElem(ptype: i64) i64 {
    if ptype < PTYPE_SLICE_BASE {
        return PTYPE_I64;
    }
    return ptype - PTYPE_SLICE_BASE;
}

fn ptype_TypeInfo_isSlice(ptype: i64) bool {
    return ptype >= PTYPE_SLICE_BASE;
}

fn TypeInfo_valid(idx: i64) bool {
    return idx != INVALID_TYPE and idx >= 0;
}

fn TypeInfo_isInvalid(pool: *TypeRegistry, idx: i64) bool {
    if idx == INVALID_TYPE or idx < 0 {
        return true;
    }
    let t: *Type = pool.get( idx);
    return t.kind == TypeKind.Invalid;
}

fn TypeInfo_isInteger(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get( idx);
    return t.kind == TypeKind.I8 or t.kind == TypeKind.I16 or
           t.kind == TypeKind.I32 or t.kind == TypeKind.I64 or
           t.kind == TypeKind.U8 or t.kind == TypeKind.U16 or
           t.kind == TypeKind.U32 or t.kind == TypeKind.U64;
}

fn TypeInfo_isSigned(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get( idx);
    return t.kind == TypeKind.I8 or t.kind == TypeKind.I16 or
           t.kind == TypeKind.I32 or t.kind == TypeKind.I64;
}

fn TypeInfo_isUnsigned(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get( idx);
    return t.kind == TypeKind.U8 or t.kind == TypeKind.U16 or
           t.kind == TypeKind.U32 or t.kind == TypeKind.U64;
}

fn TypeInfo_isFloat(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get( idx);
    return t.kind == TypeKind.F32 or t.kind == TypeKind.F64;
}

fn TypeInfo_isNumeric(pool: *TypeRegistry, idx: i64) bool {
    return TypeInfo_isInteger(pool, idx) or TypeInfo_isFloat(pool, idx);
}

fn TypeInfo_isBool(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get( idx);
    return t.kind == TypeKind.Bool;
}

fn TypeInfo_isVoid(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get( idx);
    return t.kind == TypeKind.Void;
}

fn TypeInfo_isPointer(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get( idx);
    return t.kind == TypeKind.Pointer;
}

fn TypeInfo_isSlice(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get( idx);
    return t.kind == TypeKind.Slice;
}

fn TypeInfo_isArray(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get( idx);
    return t.kind == TypeKind.Array;
}

fn TypeInfo_isFunc(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get( idx);
    return t.kind == TypeKind.Func;
}

fn TypeInfo_isString(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get( idx);
    return t.kind == TypeKind.String;
}

fn TypeInfo_isStruct(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get( idx);
    return t.kind == TypeKind.Struct;
}

fn TypeInfo_isEnum(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get( idx);
    return t.kind == TypeKind.Enum;
}

fn TypeInfo_elem(pool: *TypeRegistry, idx: i64) i64 {
    let t: *Type = pool.get( idx);
    return t.elem;
}

fn TypeInfo_arrayLen(pool: *TypeRegistry, idx: i64) i64 {
    let t: *Type = pool.get( idx);
    return t.len;
}

fn TypeInfo_ret(pool: *TypeRegistry, idx: i64) i64 {
    let t: *Type = pool.get( idx);
    return t.ret_type;
}

fn TypeInfo_paramCount(pool: *TypeRegistry, idx: i64) i64 {
    let t: *Type = pool.get( idx);
    return t.params_count;
}

fn TypeInfo_size(pool: *TypeRegistry, idx: i64) i64 {
    let t: *Type = pool.get( idx);
    return t.size;
}

fn TypeInfo_alignment(pool: *TypeRegistry, idx: i64) i64 {
    let t: *Type = pool.get( idx);
    return t.align;
}

fn TypeInfo_equal(pool: *TypeRegistry, a: i64, b: i64) bool {
    if a == b { return true; }
    if a < 0 or b < 0 { return false; }

    let ta: *Type = pool.get( a);
    let tb: *Type = pool.get( b);

    // Different kinds are never equal
    if ta.kind != tb.kind { return false; }

    // For basic types, same kind means equal
    if ta.kind == TypeKind.Bool or
       ta.kind == TypeKind.I8 or ta.kind == TypeKind.I16 or
       ta.kind == TypeKind.I32 or ta.kind == TypeKind.I64 or
       ta.kind == TypeKind.U8 or ta.kind == TypeKind.U16 or
       ta.kind == TypeKind.U32 or ta.kind == TypeKind.U64 or
       ta.kind == TypeKind.F32 or ta.kind == TypeKind.F64 or
       ta.kind == TypeKind.Void or ta.kind == TypeKind.String {
        return true;
    }

    // For Pointer, Slice: compare element types
    if ta.kind == TypeKind.Pointer or ta.kind == TypeKind.Slice {
        return TypeInfo_equal(pool, ta.elem, tb.elem);
    }

    // For Array: compare element types and lengths
    if ta.kind == TypeKind.Array {
        return ta.len == tb.len and TypeInfo_equal(pool, ta.elem, tb.elem);
    }

    // For Func: compare params and return type
    if ta.kind == TypeKind.Func {
        if ta.params_count != tb.params_count { return false; }
        if not TypeInfo_equal(pool, ta.ret_type, tb.ret_type) { return false; }

        var i: i64 = 0;
        while i < ta.params_count {
            let pa: i64 = TypeRegistry_getParam(pool, ta.params_start, i);
            let pb: i64 = TypeRegistry_getParam(pool, tb.params_start, i);
            if not TypeInfo_equal(pool, pa, pb) { return false; }
            i = i + 1;
        }
        return true;
    }

    return false;
}

fn TypeInfo_lookupBasic(source: *u8, name_start: i64, name_len: i64) i64 {
    // Single character type names
    if name_len == 2 {
        let c0: u8 = (source + name_start).*;
        let c1: u8 = (source + name_start + 1).*;

        if c0 == 105 and c1 == 56 { return TYPE_I8; }  // "i8"
        if c0 == 117 and c1 == 56 { return TYPE_U8; }  // "u8"
    }

    if name_len == 3 {
        let c0: u8 = (source + name_start).*;
        let c1: u8 = (source + name_start + 1).*;
        let c2: u8 = (source + name_start + 2).*;

        if c0 == 105 and c1 == 49 and c2 == 54 { return TYPE_I16; }  // "i16"
        if c0 == 105 and c1 == 51 and c2 == 50 { return TYPE_I32; }  // "i32"
        if c0 == 105 and c1 == 54 and c2 == 52 { return TYPE_I64; }  // "i64"
        if c0 == 117 and c1 == 49 and c2 == 54 { return TYPE_U16; }  // "u16"
        if c0 == 117 and c1 == 51 and c2 == 50 { return TYPE_U32; }  // "u32"
        if c0 == 117 and c1 == 54 and c2 == 52 { return TYPE_U64; }  // "u64"
        if c0 == 102 and c1 == 51 and c2 == 50 { return TYPE_F32; }  // "f32"
        if c0 == 102 and c1 == 54 and c2 == 52 { return TYPE_F64; }  // "f64"
        if c0 == 105 and c1 == 110 and c2 == 116 { return TYPE_INT; }  // "int"
    }

    if name_len == 4 {
        let c0: u8 = (source + name_start).*;
        let c1: u8 = (source + name_start + 1).*;
        let c2: u8 = (source + name_start + 2).*;
        let c3: u8 = (source + name_start + 3).*;

        if c0 == 98 and c1 == 111 and c2 == 111 and c3 == 108 { return TYPE_BOOL; }  // "bool"
        if c0 == 118 and c1 == 111 and c2 == 105 and c3 == 100 { return TYPE_VOID; }  // "void"
        if c0 == 98 and c1 == 121 and c2 == 116 and c3 == 101 { return TYPE_BYTE; }  // "byte"
    }

    if name_len == 5 {
        let c0: u8 = (source + name_start).*;
        let c1: u8 = (source + name_start + 1).*;
        let c2: u8 = (source + name_start + 2).*;
        let c3: u8 = (source + name_start + 3).*;
        let c4: u8 = (source + name_start + 4).*;

        if c0 == 102 and c1 == 108 and c2 == 111 and c3 == 97 and c4 == 116 { return TYPE_FLOAT; }  // "float"
    }

    if name_len == 6 {
        let c0: u8 = (source + name_start).*;
        let c1: u8 = (source + name_start + 1).*;
        let c2: u8 = (source + name_start + 2).*;
        let c3: u8 = (source + name_start + 3).*;
        let c4: u8 = (source + name_start + 4).*;
        let c5: u8 = (source + name_start + 5).*;

        // "string"
        if c0 == 115 and c1 == 116 and c2 == 114 and c3 == 105 and c4 == 110 and c5 == 103 {
            return TYPE_STRING;
        }
    }

    return INVALID_TYPE;
}

fn TypeInfo_isAssignable(pool: *TypeRegistry, from: i64, to: i64) bool {
    // Same type is always assignable
    if from == to { return true; }

    // Error types are assignable (for error recovery)
    if from < 0 or to < 0 { return true; }

    let from_t: *Type = pool.get( from);
    let to_t: *Type = pool.get( to);

    // Same basic types are assignable
    if from_t.kind == to_t.kind {
        if from_t.kind == TypeKind.Bool or
           from_t.kind == TypeKind.I8 or from_t.kind == TypeKind.I16 or
           from_t.kind == TypeKind.I32 or from_t.kind == TypeKind.I64 or
           from_t.kind == TypeKind.U8 or from_t.kind == TypeKind.U16 or
           from_t.kind == TypeKind.U32 or from_t.kind == TypeKind.U64 or
           from_t.kind == TypeKind.F32 or from_t.kind == TypeKind.F64 or
           from_t.kind == TypeKind.Void or from_t.kind == TypeKind.String {
            return true;
        }
    }

    // Pointer types with same element
    if from_t.kind == TypeKind.Pointer and to_t.kind == TypeKind.Pointer {
        return TypeInfo_equal(pool, from_t.elem, to_t.elem);
    }

    // Slice types with same element
    if from_t.kind == TypeKind.Slice and to_t.kind == TypeKind.Slice {
        return TypeInfo_equal(pool, from_t.elem, to_t.elem);
    }

    // Array to slice with same element type
    if from_t.kind == TypeKind.Array and to_t.kind == TypeKind.Slice {
        return TypeInfo_equal(pool, from_t.elem, to_t.elem);
    }

    // Array types with same element and length
    if from_t.kind == TypeKind.Array and to_t.kind == TypeKind.Array {
        return from_t.len == to_t.len and TypeInfo_equal(pool, from_t.elem, to_t.elem);
    }

    return false;
}

fn names_equal_ptr(source: *u8, start: i64, len1: i64, ptr: *u8, len2: i64) bool {
    if len1 != len2 { return false; }
    var i: i64 = 0;
    while i < len1 {
        let c1: u8 = (source + start + i).*;
        let c2: u8 = (ptr + i).*;
        if c1 != c2 { return false; }
        i = i + 1;
    }
    return true;
}

fn TypeInfo_getPointee(pool: *TypeRegistry, ptr_type_idx: i64) i64 {
    let t: *Type = pool.get( ptr_type_idx);
    if t.kind == TypeKind.Pointer {
        return t.elem;
    }
    return TYPE_INVALID;
}

fn TypeInfo_isPrimitive(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get( idx);
    if t.kind == TypeKind.Bool { return true; }
    if t.kind == TypeKind.I8 { return true; }
    if t.kind == TypeKind.I16 { return true; }
    if t.kind == TypeKind.I32 { return true; }
    if t.kind == TypeKind.I64 { return true; }
    if t.kind == TypeKind.U8 { return true; }
    if t.kind == TypeKind.U16 { return true; }
    if t.kind == TypeKind.U32 { return true; }
    if t.kind == TypeKind.U64 { return true; }
    if t.kind == TypeKind.F32 { return true; }
    if t.kind == TypeKind.F64 { return true; }
    if t.kind == TypeKind.Void { return true; }
    return false;
}

fn TypeInfo_fitsInRegs(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get( idx);
    return t.size <= 16;
}

fn TypeInfo_needsReg(pool: *TypeRegistry, idx: i64) bool {
    let t: *Type = pool.get( idx);
    if t.kind == TypeKind.Void { return false; }
    if t.kind == TypeKind.Invalid { return false; }
    return true;
}

fn TypeInfo_registerCount(pool: *TypeRegistry, idx: i64) i64 {
    let t: *Type = pool.get( idx);
    if t.kind == TypeKind.Void { return 0; }
    if t.kind == TypeKind.Invalid { return 0; }
    // String/Slice need 2 registers (ptr + len)
    if t.kind == TypeKind.String { return 2; }
    if t.kind == TypeKind.Slice { return 2; }
    // Everything else fits in 1 register (for now)
    if t.size <= 8 { return 1; }
    // Larger types need 2 registers
    if t.size <= 16 { return 2; }
    // Even larger types would need memory
    return 0;
}

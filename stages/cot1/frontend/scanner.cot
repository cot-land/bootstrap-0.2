// Cot0 Scanner
// Sprint A: Control flow, variables, comparison/logical operators
//
// Reference: ~/learning/go/src/cmd/compile/internal/syntax/scanner.go

import "token.cot"

struct Scanner {
    source: string,
    pos: i64,
}

impl Scanner {

    fn isAtEnd(self: *Scanner) bool {
        return self.pos >= len(self.source);
    }

    fn peek(self: *Scanner) u8 {
        if self.isAtEnd() {
            return 0;
        }
        return self.source[self.pos];
    }

    // Peek at next character (for two-char operators)
    // Following Go's scanner.go pattern
    fn peekNext(self: *Scanner) u8 {
        if self.pos + 1 >= len(self.source) {
            return 0;
        }
        return self.source[self.pos + 1];
    }

    fn advance(self: *Scanner) u8 {
        let c: u8 = self.peek();
        self.pos = self.pos + 1;
        return c;
    }

    // Get current position in source
    // Reference: Zig's Scanner.getPosition()
    fn getPosition(self: *Scanner) i64 {
        return self.pos;
    }

    fn skipWhitespace(self: *Scanner)  {
        while not self.isAtEnd() {
            let c: u8 = self.peek();
            if c == 32 or c == 9 or c == 10 or c == 13 {  // space, tab, newline, cr
                self.advance();
            } else if c == 47 {  // '/'
                // Check for comment
                if self.pos + 1 < len(self.source) and self.source[self.pos + 1] == 47 {
                    // Line comment - skip to end of line
                    while not self.isAtEnd() and self.peek() != 10 {
                        self.advance();
                    }
                } else {
                    return;
                }
            } else {
                return;
            }
        }
    }

    fn scanNumber(self: *Scanner) Token {
        let start: i64 = self.pos;

        // Handle hex, octal, binary prefixes
        // Following Zig: src/frontend/scanner.zig:190-208
        if self.peek() == 48 {  // '0'
            self.advance();
            let next: u8 = self.peek();
            if next == 120 or next == 88 {  // 'x' or 'X'
                self.advance();
                // Scan hex digits
                while isHexDigit(self.peek()) {
                    self.advance();
                }
                return Token_new(TokenType.Int, start, self.pos - start);
            } else if next == 111 or next == 79 {  // 'o' or 'O'
                self.advance();
                // Scan octal digits (0-7)
                while self.peek() >= 48 and self.peek() <= 55 {
                    self.advance();
                }
                return Token_new(TokenType.Int, start, self.pos - start);
            } else if next == 98 or next == 66 {  // 'b' or 'B'
                self.advance();
                // Scan binary digits (0-1)
                while self.peek() == 48 or self.peek() == 49 {
                    self.advance();
                }
                return Token_new(TokenType.Int, start, self.pos - start);
            }
            // Fall through for plain decimal starting with 0
        }

        // Scan decimal digits
        while isDigit(self.peek()) {
            self.advance();
        }
        return Token_new(TokenType.Int, start, self.pos - start);
    }

    fn scanIdentifier(self: *Scanner) Token {
        let start: i64 = self.pos;
        while isAlphaNumeric(self.peek()) {
            self.advance();
        }
        // Check if it's a keyword
        let text: string = @string(self.source.ptr + start, self.pos - start);
        let tt: TokenType = Token_lookup(text);
        return Token_new(tt, start, self.pos - start);
    }

    // Scan character literal: '...'
    fn scanChar(self: *Scanner) Token {
        let start: i64 = self.pos;
        self.advance();  // Skip opening '

        if not self.isAtEnd() {
            let c: u8 = self.peek();
            if c == 92 {  // \ (escape)
                self.advance();  // Skip backslash
                if not self.isAtEnd() {
                    self.advance();  // Skip escaped char
                }
            } else if c != 39 {  // not closing '
                self.advance();  // Skip the char
            }
        }

        // Skip closing quote
        if not self.isAtEnd() and self.peek() == 39 {
            self.advance();
        }

        return Token_new(TokenType.CharLit, start, self.pos - start);
    }

    // Scan string literal: "..."
    // Following Go's scanner.go stdString pattern
    fn scanString(self: *Scanner) Token {
        let start: i64 = self.pos;
        self.advance();  // Skip opening "

        while not self.isAtEnd() {
            let c: u8 = self.peek();
            if c == 34 {  // "
                self.advance();  // Skip closing "
                return Token_new(TokenType.StringLit, start, self.pos - start);
            }
            if c == 92 {  // \ (escape)
                self.advance();  // Skip backslash
                if not self.isAtEnd() {
                    self.advance();  // Skip escaped char
                }
            } else if c == 10 {  // newline - unterminated string
                return Token_new(TokenType.Error, start, self.pos - start);
            } else {
                self.advance();
            }
        }

        // Unterminated string
        return Token_new(TokenType.Error, start, self.pos - start);
    }

    fn next(self: *Scanner) Token {
        self.skipWhitespace();

        if self.isAtEnd() {
            return Token_new(TokenType.Eof, self.pos, 0);
        }

        let start: i64 = self.pos;
        let c: u8 = self.advance();

        // Delimiters - single character
        if c == 40 { return Token_new(TokenType.LParen, start, 1); }   // (
        if c == 41 { return Token_new(TokenType.RParen, start, 1); }   // )
        if c == 123 { return Token_new(TokenType.LBrace, start, 1); }  // {
        if c == 125 { return Token_new(TokenType.RBrace, start, 1); }  // }
        if c == 91 { return Token_new(TokenType.LBracket, start, 1); } // [
        if c == 93 { return Token_new(TokenType.RBracket, start, 1); } // ]
        if c == 44 { return Token_new(TokenType.Comma, start, 1); }    // ,
        if c == 58 { return Token_new(TokenType.Colon, start, 1); }    // :
        if c == 59 { return Token_new(TokenType.Semi, start, 1); }     // ;
        if c == 46 { return Token_new(TokenType.Dot, start, 1); }      // .
        if c == 64 { return Token_new(TokenType.At, start, 1); }       // @
        if c == 126 { return Token_new(TokenType.Tilde, start, 1); }   // ~
        if c == 63 { return Token_new(TokenType.Question, start, 1); } // ? (cot1: optional)

        // Two-character operators - following Go's scanner.go pattern
        // = or == or =>
        if c == 61 {  // =
            let next: u8 = self.peek();
            if next == 61 {  // ==
                self.advance();
                return Token_new(TokenType.EqEq, start, 2);
            }
            if next == 62 {  // => (FatArrow for switch cases)
                self.advance();
                return Token_new(TokenType.FatArrow, start, 2);
            }
            return Token_new(TokenType.Eq, start, 1);
        }

        // ! or !=
        if c == 33 {  // !
            if self.peek() == 61 {  // !=
                self.advance();
                return Token_new(TokenType.NotEq, start, 2);
            }
            return Token_new(TokenType.Bang, start, 1);
        }

        // < or <= or <<
        if c == 60 {  // <
            let next: u8 = self.peek();
            if next == 61 {  // <=
                self.advance();
                return Token_new(TokenType.LessEq, start, 2);
            }
            if next == 60 {  // <<
                self.advance();
                return Token_new(TokenType.LessLess, start, 2);
            }
            return Token_new(TokenType.Less, start, 1);
        }

        // > or >= or >>
        if c == 62 {  // >
            let next: u8 = self.peek();
            if next == 61 {  // >=
                self.advance();
                return Token_new(TokenType.GreaterEq, start, 2);
            }
            if next == 62 {  // >>
                self.advance();
                return Token_new(TokenType.GreaterGreater, start, 2);
            }
            return Token_new(TokenType.Greater, start, 1);
        }

        // & or && or &=
        if c == 38 {  // &
            let next: u8 = self.peek();
            if next == 38 {  // &&
                self.advance();
                return Token_new(TokenType.AmpAmp, start, 2);
            }
            if next == 61 {  // &=
                self.advance();
                return Token_new(TokenType.AmpEq, start, 2);
            }
            return Token_new(TokenType.Amp, start, 1);
        }

        // | or || or |=
        if c == 124 {  // |
            let next: u8 = self.peek();
            if next == 124 {  // ||
                self.advance();
                return Token_new(TokenType.PipePipe, start, 2);
            }
            if next == 61 {  // |=
                self.advance();
                return Token_new(TokenType.PipeEq, start, 2);
            }
            return Token_new(TokenType.Pipe, start, 1);
        }

        // + or +=
        if c == 43 {  // +
            if self.peek() == 61 {  // +=
                self.advance();
                return Token_new(TokenType.PlusEq, start, 2);
            }
            return Token_new(TokenType.Plus, start, 1);
        }

        // - or -= or ->
        if c == 45 {  // -
            let next: u8 = self.peek();
            if next == 61 {  // -=
                self.advance();
                return Token_new(TokenType.MinusEq, start, 2);
            }
            if next == 62 {  // -> (following Zig compiler pattern for function types)
                self.advance();
                return Token_new(TokenType.Arrow, start, 2);
            }
            return Token_new(TokenType.Minus, start, 1);
        }

        // * or *=
        if c == 42 {  // *
            if self.peek() == 61 {  // *=
                self.advance();
                return Token_new(TokenType.StarEq, start, 2);
            }
            return Token_new(TokenType.Star, start, 1);
        }

        // / or /=
        if c == 47 {  // /
            if self.peek() == 61 {  // /=
                self.advance();
                return Token_new(TokenType.SlashEq, start, 2);
            }
            return Token_new(TokenType.Slash, start, 1);
        }

        // % or %=
        if c == 37 {  // %
            if self.peek() == 61 {  // %=
                self.advance();
                return Token_new(TokenType.PercentEq, start, 2);
            }
            return Token_new(TokenType.Percent, start, 1);
        }

        // ^ or ^=
        if c == 94 {  // ^
            if self.peek() == 61 {  // ^=
                self.advance();
                return Token_new(TokenType.CaretEq, start, 2);
            }
            return Token_new(TokenType.Caret, start, 1);
        }

        // String literal
        if c == 34 {  // "
            self.pos = start;  // Back up to re-read
            return self.scanString();
        }

        // Character literal
        if c == 39 {  // '
            self.pos = start;  // Back up to re-read
            return self.scanChar();
        }

        // Numbers
        if isDigit(c) {
            self.pos = start;  // Back up to re-read
            return self.scanNumber();
        }

        // Identifiers and keywords
        if isAlpha(c) {
            self.pos = start;  // Back up to re-read
            return self.scanIdentifier();
        }

        return Token_new(TokenType.Error, start, 1);
    }

}

fn Scanner_init(source: string) Scanner {
    return Scanner{ .source = source, .pos = 0 };
}

fn isDigit(c: u8) bool {
    return c >= 48 and c <= 57;  // '0' to '9'
}

fn isAlpha(c: u8) bool {
    return (c >= 65 and c <= 90) or   // A-Z
           (c >= 97 and c <= 122) or  // a-z
           c == 95;                    // _
}

fn isAlphaNumeric(c: u8) bool {
    return isAlpha(c) or isDigit(c);
}

// Check if character is a hex digit (0-9, a-f, A-F)
// Reference: Zig's isHexDigit()
fn isHexDigit(c: u8) bool {
    return isDigit(c) or (c >= 65 and c <= 70) or (c >= 97 and c <= 102);
}

// ============================================================================
// INLINE TESTS - Character Classification
// ============================================================================

test "character classification" {
    // isDigit
    @assert(isDigit('0'))
    @assert(isDigit('5'))
    @assert(isDigit('9'))
    @assert(!isDigit('a'))
    @assert(!isDigit(' '))

    // isAlpha
    @assert(isAlpha('a'))
    @assert(isAlpha('z'))
    @assert(isAlpha('A'))
    @assert(isAlpha('Z'))
    @assert(isAlpha('_'))
    @assert(!isAlpha('0'))
    @assert(!isAlpha(' '))

    // isAlphaNumeric
    @assert(isAlphaNumeric('a'))
    @assert(isAlphaNumeric('5'))
    @assert(isAlphaNumeric('_'))
    @assert(!isAlphaNumeric(' '))
    @assert(!isAlphaNumeric('+'))

    // isHexDigit
    @assert(isHexDigit('0'))
    @assert(isHexDigit('9'))
    @assert(isHexDigit('a'))
    @assert(isHexDigit('f'))
    @assert(isHexDigit('A'))
    @assert(isHexDigit('F'))
    @assert(!isHexDigit('g'))
    @assert(!isHexDigit('G'))
}

test "scanner init and basic ops" {
    var s: Scanner = Scanner_init("abc")
    @assert(!s.isAtEnd())
    @assert(s.peek() == 'a')
    @assert(s.peekNext() == 'b')
    @assert(s.getPosition() == 0)

    // Advance through characters
    @assert(s.advance() == 'a')
    @assert(s.peek() == 'b')
    @assert(s.getPosition() == 1)

    s.advance()  // 'b'
    s.advance()  // 'c'
    @assert(s.isAtEnd())
    @assert(s.peek() == 0)  // End of string returns 0
}

test "scan decimal numbers" {
    var s: Scanner = Scanner_init("42 123 0")
    var t: Token = s.next()
    @assert(t.kind == TokenType.Int)
    @assert(t.end == 2)  // "42"

    t = s.next()
    @assert(t.kind == TokenType.Int)
    @assert(t.end == 3)  // "123"

    t = s.next()
    @assert(t.kind == TokenType.Int)
    @assert(t.end == 1)  // "0"
}

test "scan hex numbers" {
    var s: Scanner = Scanner_init("0xff 0x1A")
    var t: Token = s.next()
    @assert(t.kind == TokenType.Int)
    @assert(t.end == 4)  // "0xff"

    t = s.next()
    @assert(t.kind == TokenType.Int)
    @assert(t.end == 4)  // "0x1A"
}

test "scan binary and octal" {
    var s: Scanner = Scanner_init("0b1010 0o77")
    var t: Token = s.next()
    @assert(t.kind == TokenType.Int)
    @assert(t.end == 6)  // "0b1010"

    t = s.next()
    @assert(t.kind == TokenType.Int)
    @assert(t.end == 4)  // "0o77"
}

test "scan identifiers" {
    var s: Scanner = Scanner_init("foo bar_baz _x x123")
    var t: Token = s.next()
    @assert(t.kind == TokenType.Ident)
    @assert(t.end == 3)  // "foo"

    t = s.next()
    @assert(t.kind == TokenType.Ident)
    @assert(t.end == 7)  // "bar_baz"

    t = s.next()
    @assert(t.kind == TokenType.Ident)
    @assert(t.end == 2)  // "_x"

    t = s.next()
    @assert(t.kind == TokenType.Ident)
    @assert(t.end == 4)  // "x123"
}

test "scan keywords" {
    var s: Scanner = Scanner_init("fn let var if else while return")
    @assert(s.next().kind == TokenType.Fn)
    @assert(s.next().kind == TokenType.Let)
    @assert(s.next().kind == TokenType.Var)
    @assert(s.next().kind == TokenType.If)
    @assert(s.next().kind == TokenType.Else)
    @assert(s.next().kind == TokenType.While)
    @assert(s.next().kind == TokenType.Return)
}

test "scan more keywords" {
    var s: Scanner = Scanner_init("struct enum true false null and or not")
    @assert(s.next().kind == TokenType.Struct)
    @assert(s.next().kind == TokenType.Enum)
    @assert(s.next().kind == TokenType.True)
    @assert(s.next().kind == TokenType.False)
    @assert(s.next().kind == TokenType.Null)
    @assert(s.next().kind == TokenType.And)
    @assert(s.next().kind == TokenType.Or)
    @assert(s.next().kind == TokenType.Not)
}

test "scan type keywords" {
    var s: Scanner = Scanner_init("i64 u8 bool string void")
    @assert(s.next().kind == TokenType.I64)
    @assert(s.next().kind == TokenType.U8)
    @assert(s.next().kind == TokenType.Bool)
    @assert(s.next().kind == TokenType.String)
    @assert(s.next().kind == TokenType.Void)
}

test "scan single char operators" {
    var s: Scanner = Scanner_init("+ - * / % = < > ! & | ^")
    @assert(s.next().kind == TokenType.Plus)
    @assert(s.next().kind == TokenType.Minus)
    @assert(s.next().kind == TokenType.Star)
    @assert(s.next().kind == TokenType.Slash)
    @assert(s.next().kind == TokenType.Percent)
    @assert(s.next().kind == TokenType.Eq)
    @assert(s.next().kind == TokenType.Less)
    @assert(s.next().kind == TokenType.Greater)
    @assert(s.next().kind == TokenType.Bang)
    @assert(s.next().kind == TokenType.Amp)
    @assert(s.next().kind == TokenType.Pipe)
    @assert(s.next().kind == TokenType.Caret)
}

test "scan two char operators" {
    var s: Scanner = Scanner_init("== != <= >= += -= *= /= << >>")
    @assert(s.next().kind == TokenType.EqEq)
    @assert(s.next().kind == TokenType.NotEq)
    @assert(s.next().kind == TokenType.LessEq)
    @assert(s.next().kind == TokenType.GreaterEq)
    @assert(s.next().kind == TokenType.PlusEq)
    @assert(s.next().kind == TokenType.MinusEq)
    @assert(s.next().kind == TokenType.StarEq)
    @assert(s.next().kind == TokenType.SlashEq)
    @assert(s.next().kind == TokenType.LessLess)
    @assert(s.next().kind == TokenType.GreaterGreater)
}

test "scan punctuation" {
    var s: Scanner = Scanner_init("( ) { } [ ] , ; : . ->")
    @assert(s.next().kind == TokenType.LParen)
    @assert(s.next().kind == TokenType.RParen)
    @assert(s.next().kind == TokenType.LBrace)
    @assert(s.next().kind == TokenType.RBrace)
    @assert(s.next().kind == TokenType.LBracket)
    @assert(s.next().kind == TokenType.RBracket)
    @assert(s.next().kind == TokenType.Comma)
    @assert(s.next().kind == TokenType.Semi)
    @assert(s.next().kind == TokenType.Colon)
    @assert(s.next().kind == TokenType.Dot)
    @assert(s.next().kind == TokenType.Arrow)
}

test "scan string literal" {
    var s: Scanner = Scanner_init("\"hello\"")
    var t: Token = s.next()
    @assert(t.kind == TokenType.StringLit)
    @assert(t.end == 7)  // includes quotes
}

test "scan char literal" {
    var s: Scanner = Scanner_init("'a' '\\n' '\\''")
    var t: Token = s.next()
    @assert(t.kind == TokenType.CharLit)
    @assert(t.end == 3)  // 'a'

    t = s.next()
    @assert(t.kind == TokenType.CharLit)
    @assert(t.end == 4)  // '\n'

    t = s.next()
    @assert(t.kind == TokenType.CharLit)
    @assert(t.end == 4)  // '\''
}

test "skip whitespace and comments" {
    var s: Scanner = Scanner_init("  \t\n  42 // comment\n 7")
    var t: Token = s.next()
    @assert(t.kind == TokenType.Int)
    @assert(t.end == 2)  // "42"

    t = s.next()
    @assert(t.kind == TokenType.Int)
    @assert(t.end == 1)  // "7"
}

test "scan eof" {
    var s: Scanner = Scanner_init("")
    @assert(s.next().kind == TokenType.Eof)

    var s2: Scanner = Scanner_init("   ")
    @assert(s2.next().kind == TokenType.Eof)
}


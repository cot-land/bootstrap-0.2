// Cot0 SSA Value Representation
// Minimal SSA value for self-hosting.
//
// Reference: ~/learning/go/src/cmd/compile/internal/ssa/value.go
// Reference: bootstrap-0.2/src/ssa/value.zig

import "op.cot"
// Note: I64List and i64list_* functions are available via earlier imports in main.cot

// ============================================================================
// Constants
// ============================================================================

const INVALID_ID: i64 = -1;

// ============================================================================
// SSA Value
// ============================================================================

// Value represents the result of an SSA operation.
// Each Value has:
// - An operation (Op) that defines what it computes
// - A result type
// - Zero or more argument Values (by index)
// - A use count tracking how many other Values reference it
struct Value {
    id: i64,              // Unique identifier within function
    op: Op,               // Operation this value performs
    type_idx: i64,        // Result type index

    // Arguments (indices into function's value array) - dynamic list
    args: I64List,        // Dynamic args list (no limit)

    // Use tracking (critical for DCE and regalloc)
    uses: i64,            // How many values reference this one

    // Auxiliary data (interpretation depends on op)
    aux_int: i64,         // Integer aux: const value, offset, etc.
    aux_ptr: i64,         // Pointer aux: symbol index, etc.

    // Block and position
    block_id: i64,        // Block this value belongs to
    pos: i64,             // Source position

    // Register allocation
    reg: i64,             // Assigned register (-1 if none)
    spill_slot: i64,      // Stack slot if spilled (-1 if none)
}

// ============================================================================
// Value Constructors (static functions - outside impl block)
// ============================================================================

fn Value_create(id: i64, op: Op, type_idx: i64, block_id: i64) Value {
    var v: Value = undefined;
    v.id = id;
    v.op = op;
    v.type_idx = type_idx;
    // Initialize dynamic args list
    i64list_init(&v.args);
    v.uses = 0;
    v.aux_int = 0;
    v.aux_ptr = 0;
    v.block_id = block_id;
    v.pos = 0;
    v.reg = -1;
    v.spill_slot = -1;
    return v;
}

fn Value_newConstInt(id: i64, value: i64, type_idx: i64, block_id: i64) Value {
    var v: Value = Value_create(id, Op.ConstInt, type_idx, block_id);
    v.aux_int = value;
    return v;
}

fn Value_newConstBool(id: i64, value: bool, block_id: i64) Value {
    var v: Value = Value_create(id, Op.ConstBool, 1, block_id);  // TYPE_BOOL = 1
    if value {
        v.aux_int = 1;
    } else {
        v.aux_int = 0;
    }
    return v;
}

impl Value {

    // Get number of arguments (accessor for args.count)
    fn getArgsCount(self: *Value) i64 {
        return self.args.count;
    }

    // ============================================================================
    // Value Argument Management
    // ============================================================================

    // Add a single argument to a value
    // IMPORTANT: Always use this instead of modifying args directly!
    // This maintains use count invariants.
    fn addArg(self: *Value, arg: *Value)  {
        i64list_append(&self.args, arg.id);
        arg.uses = arg.uses + 1;
    }

    // Add two arguments (common case for binary ops)
    fn addArg2(self: *Value, arg0: *Value, arg1: *Value)  {
        self.addArg(arg0);
        self.addArg(arg1);
    }

    // Add three arguments (e.g., store: ptr, val, mem)
    fn addArg3(self: *Value, arg0: *Value, arg1: *Value, arg2: *Value)  {
        self.addArg(arg0);
        self.addArg(arg1);
        self.addArg(arg2);
    }

    // Set argument at specific index (for phi nodes and similar)
    fn setArg(self: *Value, idx: i64, arg: *Value)  {
        if idx < 0 { return; }

        // Ensure capacity for this index
        i64list_ensure_capacity(&self.args, idx + 1);

        // Extend count if necessary (filling gaps with INVALID_ID)
        while self.args.count <= idx {
            i64list_append(&self.args, INVALID_ID);
        }

        // Decrement old arg's use count if present
        if i64list_get(&self.args, idx) != INVALID_ID {
            // Would need function context to decrement old arg's uses
        }

        i64list_set(&self.args, idx, arg.id);
        arg.uses = arg.uses + 1;
    }

    // Reset all arguments (for value replacement)
    fn resetArgs(self: *Value)  {
        i64list_clear(&self.args);
    }

    // Truncate args to specified count (for SSA passes)
    fn truncateArgs(self: *Value, count: i64)  {
        if count >= 0 and count < self.args.count {
            self.args.count = count;
        }
    }

    // Clear args and set a single arg by id (common SSA pass pattern)
    fn setSingleArg(self: *Value, arg_id: i64)  {
        i64list_clear(&self.args);
        i64list_append(&self.args, arg_id);
    }

    // ============================================================================
    // Value Queries
    // ============================================================================

    // Check if value is a constant (rematerializable)
    fn isConstant(self: *Value) bool {
        return Op_isConstant(self.op);
    }

    // Check if value is rematerializable (can be recomputed cheaply)
    // Reference: Zig's Value.isRematerializable()
    fn isRematerializable(self: *Value) bool {
        return Op_isConstant(self.op);
    }

    // Check if value has side effects
    fn hasSideEffects(self: *Value) bool {
        return Op_hasSideEffects(self.op);
    }

    // Check if value reads memory
    // Reference: Zig's Value.readsMemory()
    fn readsMemory(self: *Value) bool {
        return Op_readsMemory(self.op);
    }

    // Check if value writes memory
    // Reference: Zig's Value.writesMemory()
    fn writesMemory(self: *Value) bool {
        return Op_writesMemory(self.op);
    }

    // Check if value is dead (no uses and no side effects)
    fn isDead(self: *Value) bool {
        return self.uses == 0 and not self.hasSideEffects();
    }

    // Check if value produces a boolean result
    fn isBool(self: *Value) bool {
        return Op_isComparison(self.op) or self.op == Op.ConstBool;
    }

    // Get argument at index (or INVALID_ID if out of bounds)
    fn getArg(self: *Value, idx: i64) i64 {
        if idx < 0 or idx >= self.args.count { return INVALID_ID; }
        return i64list_get(&self.args, idx);
    }

    // Set argument at index by value id directly (for SSA passes)
    fn setArgById(self: *Value, idx: i64, arg_id: i64)  {
        if idx < 0 { return; }
        i64list_ensure_capacity(&self.args, idx + 1);
        while self.args.count <= idx {
            i64list_append(&self.args, INVALID_ID);
        }
        i64list_set(&self.args, idx, arg_id);
    }

    // Get first argument (or INVALID_ID if none)
    fn arg0(self: *Value) i64 {
        return self.getArg(0);
    }

    // Get second argument (or INVALID_ID if none)
    fn arg1(self: *Value) i64 {
        return self.getArg(1);
    }

    // Get third argument (or INVALID_ID if none)
    fn arg2(self: *Value) i64 {
        return self.getArg(2);
    }

    // Get number of arguments
    // Reference: Zig's Value.numArgs()
    fn numArgs(self: *Value) i64 {
        return self.args.count;
    }

    // Alias for argsLen to match Zig naming
    // Reference: Zig's Value.argsLen()
    fn argsLen(self: *Value) i64 {
        return self.args.count;
    }

    // Alias for isConst to match Zig naming
    // Reference: Zig's Value.isConst()
    fn isConst(self: *Value) bool {
        return Op_isConstant(self.op);
    }

    // Get assigned register (or -1 if none)
    // Reference: Zig's Value.getReg()
    fn getReg(self: *Value) i64 {
        return self.reg;
    }

    // Check if value has an assigned register
    // Reference: Zig's Value.hasReg()
    fn hasReg(self: *Value) bool {
        return self.reg >= 0;
    }

    // Get spill slot (or -1 if none)
    fn getSpillSlot(self: *Value) i64 {
        return self.spill_slot;
    }

    // Check if value is spilled
    fn isSpilled(self: *Value) bool {
        return self.spill_slot >= 0;
    }

    // ============================================================================
    // Use Count Management
    // ============================================================================

    // Increment use count (call when value becomes an argument)
    fn incUses(self: *Value) void {
        self.uses = self.uses + 1;
    }

    // Decrement use count (call when value is no longer referenced)
    fn decUses(self: *Value) void {
        if self.uses > 0 {
            self.uses = self.uses - 1;
        }
    }
}


// ============================================================================
// Value Pool (arena allocation)
// ============================================================================

const MAX_VALUES: i64 = 50000;

struct ValuePool {
    values: *Value,       // Externally allocated array
    count: i64,
    cap: i64,
}

impl ValuePool {

    fn init(self: *ValuePool, values: *Value, cap: i64)  {
        self.values = values;
        self.count = 0;
        self.cap = cap;
    }

    fn alloc(self: *ValuePool, op: Op, type_idx: i64, block_id: i64) *Value {
        if self.count >= self.cap {
            return self.values;  // Return first value as error placeholder
        }

        let id: i64 = self.count;
        let v: *Value = self.values + id;
        v.* = Value_create(id, op, type_idx, block_id);
        self.count = self.count + 1;

        return v;
    }

    fn get(self: *ValuePool, id: i64) *Value {
        if id < 0 or id >= self.count {
            return self.values;  // Return first value as error placeholder
        }
        return self.values + id;
    }
}

// ============================================================================
// Inline Tests
// ============================================================================

test "Value_create initializes fields" {
    var v: Value = Value_create(42, Op.Add64, 0, 1)
    @assert(v.id == 42)
    @assert(v.op == Op.Add64)
    @assert(v.type_idx == 0)
    @assert(v.block_id == 1)
    @assert(v.uses == 0)
    @assert(v.reg == -1)
    @assert(v.spill_slot == -1)
}

test "Value_newConstInt sets aux_int" {
    var v: Value = Value_newConstInt(1, 999, 2, 0)
    @assert(v.id == 1)
    @assert(v.op == Op.ConstInt)
    @assert(v.aux_int == 999)
    @assert(v.type_idx == 2)
}

test "Value_newConstBool true" {
    var v: Value = Value_newConstBool(5, true, 0)
    @assert(v.op == Op.ConstBool)
    @assert(v.aux_int == 1)
}

test "Value_newConstBool false" {
    var v: Value = Value_newConstBool(6, false, 0)
    @assert(v.op == Op.ConstBool)
    @assert(v.aux_int == 0)
}

test "Value getArgsCount starts at zero" {
    var v: Value = Value_create(0, Op.Add64, 0, 0)
    @assert(v.getArgsCount() == 0)
}

test "Value use count tracking" {
    var v: Value = Value_create(0, Op.Add64, 0, 0)
    @assert(v.uses == 0)
    v.incUses()
    @assert(v.uses == 1)
    v.incUses()
    @assert(v.uses == 2)
    v.decUses()
    @assert(v.uses == 1)
}

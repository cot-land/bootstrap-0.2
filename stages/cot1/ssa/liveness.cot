// Cot0 SSA Liveness Analysis
// Computes use distances for spill selection.
//
// Key insight: When we need to spill a value, spill the one with
// the FARTHEST next use (Belady's algorithm).
//
// Reference: ~/learning/go/src/cmd/compile/internal/ssa/regalloc.go
// Reference: bootstrap-0.2/src/ssa/liveness.zig

// Imports removed - func.cot already imported via genssa.cot

// ============================================================================
// Distance Constants (Go ref: regalloc.go:141-143)
// ============================================================================

const LIKELY_DISTANCE: i64 = 1;    // Likely branch (expected path)
const NORMAL_DISTANCE: i64 = 10;   // Normal branch or sequential code
const UNLIKELY_DISTANCE: i64 = 100; // Unlikely branch, or after call
const UNKNOWN_DISTANCE: i64 = -1;  // Sentinel for loop propagation

// ============================================================================
// Live Value Entry
// ============================================================================

// Information about a live value at a program point
struct LiveInfo {
    id: i64,           // Value ID
    dist: i64,         // Distance to next use (lower = sooner = less desirable to spill)
    pos: i64,          // Source position of next use
}

fn LiveInfo_new(id: i64, dist: i64, pos: i64) LiveInfo {
    return LiveInfo{
        .id = id,
        .dist = dist,
        .pos = pos,
    };
}

// ============================================================================
// Live Map (sparse set for tracking live values)
// Matches Zig: std.ArrayListUnmanaged(LiveInfo) with dynamic growth
// ============================================================================

// External allocation functions
extern fn malloc_LiveInfo(count: i64) *LiveInfo;
extern fn realloc_LiveInfo(ptr: *LiveInfo, old_count: i64, new_count: i64) *LiveInfo;
extern fn malloc_BlockLiveness(count: i64) *BlockLiveness;
extern fn realloc_BlockLiveness(ptr: *BlockLiveness, old_count: i64, new_count: i64) *BlockLiveness;

struct LiveMap {
    entries: *LiveInfo,    // Dense storage (owned, dynamically grown)
    count: i64,
    cap: i64,
    // Sparse index for O(1) lookup: index[value_id] = position in entries, or -1 if not present
    index: *i64,           // Direct-indexed by value_id
    index_cap: i64,
}

impl LiveMap {

    fn init(self: *LiveMap) {
        self.entries = null;
        self.count = 0;
        self.cap = 0;
        self.index = null;
        self.index_cap = 0;
    }

    fn ensureIndexCapacity(self: *LiveMap, value_id: i64) {
        let needed: i64 = value_id + 1;
        if self.index_cap >= needed { return; }
    
        // Calculate new capacity
        var new_cap: i64 = 256;
        if self.index_cap > 0 { new_cap = self.index_cap * 2; }
        while new_cap < needed { new_cap = new_cap * 2; }
    
        // Allocate new index
        let new_index: *i64 = malloc_i64(new_cap);
    
        // Initialize new slots to -1
        var i: i64 = 0;
        while i < new_cap {
            (new_index + i).* = -1;
            i = i + 1;
        }
    
        // Copy old values if any
        if self.index != null {
            i = 0;
            while i < self.index_cap {
                (new_index + i).* = (self.index + i).*;
                i = i + 1;
            }
        }
    
        self.index = new_index;
        self.index_cap = new_cap;
    }

    fn ensureCapacity(self: *LiveMap, needed: i64) {
        if self.cap >= needed { return; }
    
        // Calculate new capacity (at least double, or needed)
        var new_cap: i64 = 16;
        if self.cap > 0 { new_cap = self.cap * 2; }
        while new_cap < needed { new_cap = new_cap * 2; }
    
        // Allocate or reallocate
        if self.entries == null {
            self.entries = malloc_LiveInfo(new_cap);
        } else {
            self.entries = realloc_LiveInfo(self.entries, self.cap, new_cap);
        }
        self.cap = new_cap;
    }

    fn clear(self: *LiveMap) {
        // Reset index entries for items being removed
        if self.index != null {
            var i: i64 = 0;
            while i < self.count {
                let entry: *LiveInfo = self.entries + i;
                let id: i64 = entry.id;
                if id >= 0 and id < self.index_cap {
                    (self.index + id).* = -1;
                }
                i = i + 1;
            }
        }
        self.count = 0;
    }

    fn find(self: *LiveMap, id: i64) i64 {
        if id < 0 or id >= self.index_cap or self.index == null {
            return -1;
        }
        return (self.index + id).*;
    }

    fn set(self: *LiveMap, id: i64, dist: i64, pos: i64) {
        let idx: i64 = self.find(id);
        if idx >= 0 {
            // Already present - update if closer use
            let entry: *LiveInfo = self.entries + idx;
            if dist < entry.dist {
                entry.dist = dist;
                entry.pos = pos;
            }
            return;
        }
    
        // Add new entry - grow if needed
        self.ensureCapacity(self.count + 1);
        self.ensureIndexCapacity(id);  // Ensure index can hold this id
        let entry: *LiveInfo = self.entries + self.count;
        entry.id = id;
        entry.dist = dist;
        entry.pos = pos;
        // Update index to point to this entry
        (self.index + id).* = self.count;
        self.count = self.count + 1;
    }

    fn setForce(self: *LiveMap, id: i64, dist: i64, pos: i64) {
        let idx: i64 = self.find(id);
        if idx >= 0 {
            let entry: *LiveInfo = self.entries + idx;
            entry.dist = dist;
            entry.pos = pos;
            return;
        }
    
        // Add new entry - grow if needed
        self.ensureCapacity(self.count + 1);
        self.ensureIndexCapacity(id);  // Ensure index can hold this id
        let entry: *LiveInfo = self.entries + self.count;
        entry.id = id;
        entry.dist = dist;
        entry.pos = pos;
        // Update index
        (self.index + id).* = self.count;
        self.count = self.count + 1;
    }

    fn get(self: *LiveMap, id: i64) i64 {
        let idx: i64 = self.find(id);
        if idx >= 0 {
            let entry: *LiveInfo = self.entries + idx;
            return entry.dist;
        }
        return INVALID_ID;
    }

    fn contains(self: *LiveMap, id: i64) bool {
        return self.find(id) >= 0;
    }

    fn remove(self: *LiveMap, id: i64) {
        let idx: i64 = self.find(id);
        if idx < 0 { return; }
    
        // Clear index for removed element
        if id >= 0 and id < self.index_cap and self.index != null {
            (self.index + id).* = -1;
        }
    
        // Swap with last element
        if self.count > 1 and idx < self.count - 1 {
            let last: *LiveInfo = self.entries + (self.count - 1);
            let entry: *LiveInfo = self.entries + idx;
            let last_id: i64 = last.id;
            entry.id = last_id;
            entry.dist = last.dist;
            entry.pos = last.pos;
            // Update index for swapped element
            if last_id >= 0 and last_id < self.index_cap and self.index != null {
                (self.index + last_id).* = idx;
            }
        }
        self.count = self.count - 1;
    }

    fn size(self: *LiveMap) i64 {
        return self.count;
    }

    fn getInfo(self: *LiveMap, id: i64) *LiveInfo {
        let idx: i64 = self.find(id);
        if idx >= 0 {
            return self.entries + idx;
        }
        // Return pointer to first entry as fallback (caller should check with find first)
        return self.entries;
    }

    fn addDistanceAll(self: *LiveMap, delta: i64) {
        var i: i64 = 0;
        while i < self.count {
            let entry: *LiveInfo = self.entries + i;
            if entry.dist != UNKNOWN_DISTANCE {
                entry.dist = entry.dist + delta;
            }
            i = i + 1;
        }
    }

    fn items(self: *LiveMap) *LiveInfo {
        return self.entries;
    }

}

struct BlockLiveness {
    block_id: i64,
    live_out: *LiveInfo,     // Values live at END of block (owned)
    live_out_count: i64,
    live_out_cap: i64,
    live_out_index: *i64,    // Sparse index for O(1) lookup: index[value_id] = position, or -1
    live_out_index_cap: i64,
    next_call: *i64,         // For each instruction, index of next call (owned)
    next_call_count: i64,
    next_call_cap: i64,
}

impl BlockLiveness {

    fn init(self: *BlockLiveness, block_id: i64) {
        self.block_id = block_id;
        self.live_out = null;
        self.live_out_count = 0;
        self.live_out_cap = 0;
        self.live_out_index = null;
        self.live_out_index_cap = 0;
        self.next_call = null;
        self.next_call_count = 0;
        self.next_call_cap = 0;
    }

    fn ensureIndexCapacity(self: *BlockLiveness, value_id: i64) {
        let needed: i64 = value_id + 1;
        if self.live_out_index_cap >= needed { return; }
    
        var new_cap: i64 = 256;
        if self.live_out_index_cap > 0 { new_cap = self.live_out_index_cap * 2; }
        while new_cap < needed { new_cap = new_cap * 2; }
    
        let new_index: *i64 = malloc_i64(new_cap);
        var i: i64 = 0;
        while i < new_cap {
            (new_index + i).* = -1;
            i = i + 1;
        }
        if self.live_out_index != null {
            i = 0;
            while i < self.live_out_index_cap {
                (new_index + i).* = (self.live_out_index + i).*;
                i = i + 1;
            }
        }
        self.live_out_index = new_index;
        self.live_out_index_cap = new_cap;
    }

    fn findLiveOut(self: *BlockLiveness, id: i64) i64 {
        if id < 0 or id >= self.live_out_index_cap or self.live_out_index == null {
            return -1;
        }
        return (self.live_out_index + id).*;
    }

    fn ensureLiveOutCapacity(self: *BlockLiveness, needed: i64) {
        if self.live_out_cap >= needed { return; }
        var new_cap: i64 = 16;
        if self.live_out_cap > 0 { new_cap = self.live_out_cap * 2; }
        while new_cap < needed { new_cap = new_cap * 2; }
        if self.live_out == null {
            self.live_out = malloc_LiveInfo(new_cap);
        } else {
            self.live_out = realloc_LiveInfo(self.live_out, self.live_out_cap, new_cap);
        }
        self.live_out_cap = new_cap;
    }

    fn ensureNextCallCapacity(self: *BlockLiveness, needed: i64) {
        if self.next_call_cap >= needed { return; }
        var new_cap: i64 = 16;
        if self.next_call_cap > 0 { new_cap = self.next_call_cap * 2; }
        while new_cap < needed { new_cap = new_cap * 2; }
        if self.next_call == null {
            self.next_call = malloc_i64(new_cap);
        } else {
            self.next_call = realloc_i64(self.next_call, self.next_call_cap, new_cap);
        }
        self.next_call_cap = new_cap;
    }

    fn update(self: *BlockLiveness, lm: *LiveMap) {
        // Ensure we have enough space
        self.ensureLiveOutCapacity(lm.count);
        // Copy entries
        var i: i64 = 0;
        while i < lm.count {
            let src: *LiveInfo = lm.entries + i;
            let dst: *LiveInfo = self.live_out + i;
            dst.id = src.id;
            dst.dist = src.dist;
            dst.pos = src.pos;
            i = i + 1;
        }
        self.live_out_count = lm.count;
    }

    fn contains(self: *BlockLiveness, id: i64) bool {
        var i: i64 = 0;
        while i < self.live_out_count {
            let entry: *LiveInfo = self.live_out + i;
            if entry.id == id {
                return true;
            }
            i = i + 1;
        }
        return false;
    }

    fn get(self: *BlockLiveness, id: i64) i64 {
        var i: i64 = 0;
        while i < self.live_out_count {
            let entry: *LiveInfo = self.live_out + i;
            if entry.id == id {
                return entry.dist;
            }
            i = i + 1;
        }
        return INVALID_ID;
    }

    fn computeNextCall(self: *BlockLiveness, f: *Func, block: *Block) {
        let start: i64 = block.values_start;
        let count: i64 = block.values_count;
    
        if count == 0 { return; }
    
        // Ensure we have enough space for next_call array
        self.ensureNextCallCapacity(count);
        self.next_call_count = count;
    
        // Process backwards: track the next call we've seen
        var current_next_call: i64 = -1;  // -1 means no call follows
        var i: i64 = count;
        while i > 0 {
            i = i - 1;
            let v: *Value = f.getValue( start + i);
    
            // Check if this is a call
            if Op_isCallOp(v.op) {
                current_next_call = i;
            }
    
            let nc: *i64 = self.next_call + i;
            nc.* = current_next_call;
        }
    }

}

struct LivenessResult {
    blocks: *BlockLiveness,    // Per-block liveness info (owned)
    blocks_count: i64,
    blocks_cap: i64,
}

impl LivenessResult {

    fn init(self: *LivenessResult) {
        self.blocks = null;
        self.blocks_count = 0;
        self.blocks_cap = 0;
    }

    fn ensureCapacity(self: *LivenessResult, needed: i64) {
        if self.blocks_cap >= needed { return; }
        var new_cap: i64 = 16;
        if self.blocks_cap > 0 { new_cap = self.blocks_cap * 2; }
        while new_cap < needed { new_cap = new_cap * 2; }
        if self.blocks == null {
            self.blocks = malloc_BlockLiveness(new_cap);
        } else {
            self.blocks = realloc_BlockLiveness(self.blocks, self.blocks_cap, new_cap);
        }
        self.blocks_cap = new_cap;
    }

    fn addBlock(self: *LivenessResult, block_id: i64) *BlockLiveness {
        self.ensureCapacity(self.blocks_count + 1);
        let bl: *BlockLiveness = self.blocks + self.blocks_count;
        bl.init( block_id);
        self.blocks_count = self.blocks_count + 1;
        return bl;
    }

    fn getBlock(self: *LivenessResult, block_id: i64) *BlockLiveness {
        var i: i64 = 0;
        while i < self.blocks_count {
            let bl: *BlockLiveness = self.blocks + i;
            if bl.block_id == block_id {
                return bl;
            }
            i = i + 1;
        }
        // Return first as error placeholder
        return self.blocks;
    }

    fn getLiveOut(self: *LivenessResult, block_id: i64) *BlockLiveness {
        return self.getBlock(block_id);
    }

    fn getDistance(self: *LivenessResult, block_id: i64, value_id: i64) i64 {
        let bl: *BlockLiveness = self.getBlock(block_id);
        return bl.get( value_id);
    }

    fn isLiveOut(self: *LivenessResult, block_id: i64, value_id: i64) bool {
        let bl: *BlockLiveness = self.getBlock(block_id);
        return bl.contains( value_id);
    }

    fn getNextCall(self: *LivenessResult, block_id: i64, inst_idx: i64) i64 {
        let bl: *BlockLiveness = self.getBlock(block_id);
        if inst_idx < 0 or inst_idx >= bl.next_call_count {
            return -1;
        }
        let nc: *i64 = bl.next_call + inst_idx;
        return nc.*;
    }

    fn hasCallAfter(self: *LivenessResult, block_id: i64, inst_idx: i64) bool {
        return self.getNextCall(block_id, inst_idx) >= 0;
    }

}

fn Value_needsRegister(v: *Value) bool {
    // Memory, control flow, and void operations don't need registers
    if v.op == Op.Store { return false; }
    if v.op == Op.Return { return false; }
    if v.op == Op.Move { return false; }
    if v.op == Op.Zero { return false; }
    if v.op == Op.InitMem { return false; }
    if v.op == Op.Nop { return false; }
    // Most other ops need registers
    return true;
}

fn Op_isCallOp(op: Op) bool {
    if op == Op.Call { return true; }
    if op == Op.TailCall { return true; }
    if op == Op.ClosureCall { return true; }
    return false;
}

fn Block_branchDistance(from: *Block, to_id: i64) i64 {
    // Two-way branch
    if from.succs_count == 2 {
        // First successor (then branch) - usually likely
        if from.succs[0] == to_id {
            return LIKELY_DISTANCE;
        }
        // Second successor (else branch) - usually less likely
        if from.succs[1] == to_id {
            return NORMAL_DISTANCE;
        }
    }
    return NORMAL_DISTANCE;
}

fn Liveness_processSuccessorPhis(lm: *LiveMap, f: *Func, block: *Block) {
    // For each successor
    var s: i64 = 0;
    while s < block.succs_count {
        let succ_id: i64 = block.succs[s];
        if succ_id == INVALID_BLOCK { s = s + 1; continue; }

        let succ: *Block = f.getBlock( succ_id);
        let delta: i64 = Block_branchDistance(block, succ_id);

        // Find phi nodes in successor
        var vi: i64 = 0;
        while vi < succ.values_count {
            let v: *Value = f.getValue( succ.values_start + vi);
            if v.op != Op.Phi { vi = vi + 1; continue; }

            // Phi input from this edge
            // For simplicity, assume edge_idx matches predecessor order
            // In full impl, we'd track edge indices
            if s < v.args.count {
                let arg_id: i64 = v.getArg( s);
                if arg_id != INVALID_ID {
                    let arg: *Value = f.getValue( arg_id);
                    if Value_needsRegister(arg) {
                        lm.set( arg_id, delta, 0);
                    }
                }
            }
            vi = vi + 1;
        }
        s = s + 1;
    }
}

fn Liveness_processBlockLiveness(lr: *LivenessResult, f: *Func, block: *Block,
                           lm: *LiveMap) i64 {
    let bl: *BlockLiveness = lr.getBlock( block.id);

    // Initialize live set from known live_out
    lm.clear();
    var i: i64 = 0;
    while i < bl.live_out_count {
        let entry: *LiveInfo = bl.live_out + i;
        lm.setForce( entry.id, entry.dist, entry.pos);
        i = i + 1;
    }

    let old_count: i64 = lm.count;

    // Process successor phis
    Liveness_processSuccessorPhis(lm, f, block);

    // If phi args were added, update live_out
    var changed: i64 = 0;
    if lm.count > old_count {
        bl.update( lm);
        changed = 1;
    }

    // Adjust distances for block length
    let block_len: i64 = block.values_count;
    lm.addDistanceAll( block_len);

    // Add control value to live set
    if block.control != INVALID_ID {
        let ctrl: *Value = f.getValue( block.control);
        if Value_needsRegister(ctrl) {
            lm.set( block.control, block_len, 0);
        }
    }

    // Process values in reverse order (bottom to top)
    i = block_len - 1;
    while i >= 0 {
        let v: *Value = f.getValue( block.values_start + i);

        // Value is defined here - remove from live set
        lm.remove( v.id);

        // Skip phi nodes (handled separately)
        if v.op == Op.Phi { i = i - 1; continue; }

        // Handle calls: add unlikely_distance penalty
        if Op_isCallOp(v.op) {
            lm.addDistanceAll( UNLIKELY_DISTANCE);
        }

        // Add arguments to live set
        var a: i64 = 0;
        while a < v.args.count {
            let arg_id: i64 = v.getArg( a);
            if arg_id != INVALID_ID {
                let arg: *Value = f.getValue( arg_id);
                if Value_needsRegister(arg) {
                    lm.set( arg_id, i, 0);
                }
            }
            a = a + 1;
        }
        i = i - 1;
    }

    // Propagate to predecessors
    var p: i64 = 0;
    while p < block.preds.count {
        let pred_id: i64 = block.getPred( p);
        if pred_id == INVALID_BLOCK { p = p + 1; continue; }

        let pred: *Block = f.getBlock( pred_id);
        let pred_bl: *BlockLiveness = lr.getBlock( pred_id);
        let delta: i64 = Block_branchDistance(pred, block.id);

        // Add values from current block's live (with delta)
        var update: i64 = 0;
        var j: i64 = 0;
        while j < lm.count {
            let entry: *LiveInfo = lm.entries + j;
            var new_dist: i64 = entry.dist;
            if new_dist != UNKNOWN_DISTANCE {
                new_dist = new_dist + delta;
            }

            // Check if already in predecessor's live_out using O(1) index lookup
            let k: i64 = pred_bl.findLiveOut( entry.id);
            if k >= 0 {
                // Already present - update if better distance
                let pe: *LiveInfo = pred_bl.live_out + k;
                if new_dist < pe.dist {
                    pe.dist = new_dist;
                    update = 1;
                }
            } else {
                // Add new entry - grow array and index if needed
                pred_bl.ensureLiveOutCapacity( pred_bl.live_out_count + 1);
                pred_bl.ensureIndexCapacity( entry.id);
                let dst: *LiveInfo = pred_bl.live_out + pred_bl.live_out_count;
                dst.id = entry.id;
                dst.dist = new_dist;
                dst.pos = entry.pos;
                // Update index
                (pred_bl.live_out_index + entry.id).* = pred_bl.live_out_count;
                pred_bl.live_out_count = pred_bl.live_out_count + 1;
                update = 1;
            }
            j = j + 1;
        }

        if update != 0 {
            changed = 1;
        }
        p = p + 1;
    }

    return changed;
}

fn Liveness_compute(lr: *LivenessResult, f: *Func, lm: *LiveMap) i64 {
    // Initialize block liveness structures - each block gets its own dynamic arrays
    var b: i64 = 0;
    while b < f.blocks_count {
        // Add block with dynamic allocation
        let bl: *BlockLiveness = lr.addBlock( b);

        // Compute nextCall array (allocates dynamically)
        let block: *Block = f.getBlock( b);
        bl.computeNextCall( f, block);

        b = b + 1;
    }

    // Fixed-point iteration
    // Process in reverse order (postorder approximation)
    var changed: i64 = 1;
    var iterations: i64 = 0;
    let max_iterations: i64 = 100;

    while changed != 0 and iterations < max_iterations {
        changed = 0;
        iterations = iterations + 1;

        // Process blocks in reverse order (postorder-ish)
        b = f.blocks_count - 1;
        while b >= 0 {
            let block: *Block = f.getBlock( b);
            let result: i64 = Liveness_processBlockLiveness(lr, f, block, lm);
            if result != 0 {
                changed = 1;
            }
            b = b - 1;
        }
    }

    return 0;
}

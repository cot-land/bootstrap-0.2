// Cot0 SSA Liveness Analysis
// Computes use distances for spill selection.
//
// Key insight: When we need to spill a value, spill the one with
// the FARTHEST next use (Belady's algorithm).
//
// Reference: ~/learning/go/src/cmd/compile/internal/ssa/regalloc.go
// Reference: bootstrap-0.2/src/ssa/liveness.zig

// Imports removed - func.cot already imported via genssa.cot

// ============================================================================
// Distance Constants (Go ref: regalloc.go:141-143)
// ============================================================================

const LIKELY_DISTANCE: i64 = 1;    // Likely branch (expected path)
const NORMAL_DISTANCE: i64 = 10;   // Normal branch or sequential code
const UNLIKELY_DISTANCE: i64 = 100; // Unlikely branch, or after call
const UNKNOWN_DISTANCE: i64 = -1;  // Sentinel for loop propagation

// ============================================================================
// Live Value Entry
// ============================================================================

// Information about a live value at a program point
struct LiveInfo {
    id: i64,           // Value ID
    dist: i64,         // Distance to next use (lower = sooner = less desirable to spill)
    pos: i64,          // Source position of next use
}

fn LiveInfo_new(id: i64, dist: i64, pos: i64) LiveInfo {
    return LiveInfo{
        .id = id,
        .dist = dist,
        .pos = pos,
    };
}

// ============================================================================
// Live Map (sparse set for tracking live values)
// Matches Zig: std.ArrayListUnmanaged(LiveInfo) with dynamic growth
// ============================================================================

// External allocation functions
extern fn malloc_LiveInfo(count: i64) *LiveInfo;
extern fn realloc_LiveInfo(ptr: *LiveInfo, old_count: i64, new_count: i64) *LiveInfo;

struct LiveMap {
    entries: *LiveInfo,    // Dense storage (owned, dynamically grown)
    count: i64,
    cap: i64,
    // Sparse index for O(1) lookup: index[value_id] = position in entries, or -1 if not present
    index: *i64,           // Direct-indexed by value_id
    index_cap: i64,
}

fn LiveMap_init(lm: *LiveMap) {
    lm.entries = null;
    lm.count = 0;
    lm.cap = 0;
    lm.index = null;
    lm.index_cap = 0;
}

// Ensure index has capacity for value_id
fn LiveMap_ensureIndexCapacity(lm: *LiveMap, value_id: i64) {
    let needed: i64 = value_id + 1;
    if lm.index_cap >= needed { return; }

    // Calculate new capacity
    var new_cap: i64 = 256;
    if lm.index_cap > 0 { new_cap = lm.index_cap * 2; }
    while new_cap < needed { new_cap = new_cap * 2; }

    // Allocate new index
    let new_index: *i64 = malloc_i64(new_cap);

    // Initialize new slots to -1
    var i: i64 = 0;
    while i < new_cap {
        (new_index + i).* = -1;
        i = i + 1;
    }

    // Copy old values if any
    if lm.index != null {
        i = 0;
        while i < lm.index_cap {
            (new_index + i).* = (lm.index + i).*;
            i = i + 1;
        }
    }

    lm.index = new_index;
    lm.index_cap = new_cap;
}

fn LiveMap_ensureCapacity(lm: *LiveMap, needed: i64) {
    if lm.cap >= needed { return; }

    // Calculate new capacity (at least double, or needed)
    var new_cap: i64 = 16;
    if lm.cap > 0 { new_cap = lm.cap * 2; }
    while new_cap < needed { new_cap = new_cap * 2; }

    // Allocate or reallocate
    if lm.entries == null {
        lm.entries = malloc_LiveInfo(new_cap);
    } else {
        lm.entries = realloc_LiveInfo(lm.entries, lm.cap, new_cap);
    }
    lm.cap = new_cap;
}

fn LiveMap_clear(lm: *LiveMap) {
    // Reset index entries for items being removed
    if lm.index != null {
        var i: i64 = 0;
        while i < lm.count {
            let entry: *LiveInfo = lm.entries + i;
            let id: i64 = entry.id;
            if id >= 0 and id < lm.index_cap {
                (lm.index + id).* = -1;
            }
            i = i + 1;
        }
    }
    lm.count = 0;
}

// Find entry by ID (returns index or -1) - O(1) using sparse index
fn LiveMap_find(lm: *LiveMap, id: i64) i64 {
    if id < 0 or id >= lm.index_cap or lm.index == null {
        return -1;
    }
    return (lm.index + id).*;
}

// Set value with distance. Updates if new distance is SMALLER (closer use).
fn LiveMap_set(lm: *LiveMap, id: i64, dist: i64, pos: i64) {
    let idx: i64 = LiveMap_find(lm, id);
    if idx >= 0 {
        // Already present - update if closer use
        let entry: *LiveInfo = lm.entries + idx;
        if dist < entry.dist {
            entry.dist = dist;
            entry.pos = pos;
        }
        return;
    }

    // Add new entry - grow if needed
    LiveMap_ensureCapacity(lm, lm.count + 1);
    LiveMap_ensureIndexCapacity(lm, id);  // Ensure index can hold this id
    let entry: *LiveInfo = lm.entries + lm.count;
    entry.id = id;
    entry.dist = dist;
    entry.pos = pos;
    // Update index to point to this entry
    (lm.index + id).* = lm.count;
    lm.count = lm.count + 1;
}

// Set value unconditionally (always overwrites)
fn LiveMap_setForce(lm: *LiveMap, id: i64, dist: i64, pos: i64) {
    let idx: i64 = LiveMap_find(lm, id);
    if idx >= 0 {
        let entry: *LiveInfo = lm.entries + idx;
        entry.dist = dist;
        entry.pos = pos;
        return;
    }

    // Add new entry - grow if needed
    LiveMap_ensureCapacity(lm, lm.count + 1);
    LiveMap_ensureIndexCapacity(lm, id);  // Ensure index can hold this id
    let entry: *LiveInfo = lm.entries + lm.count;
    entry.id = id;
    entry.dist = dist;
    entry.pos = pos;
    // Update index
    (lm.index + id).* = lm.count;
    lm.count = lm.count + 1;
}

// Get distance for a value (returns INVALID_ID if not present)
fn LiveMap_get(lm: *LiveMap, id: i64) i64 {
    let idx: i64 = LiveMap_find(lm, id);
    if idx >= 0 {
        let entry: *LiveInfo = lm.entries + idx;
        return entry.dist;
    }
    return INVALID_ID;
}

// Check if value is in the live set
fn LiveMap_contains(lm: *LiveMap, id: i64) bool {
    return LiveMap_find(lm, id) >= 0;
}

// Remove a value from the live set (swap-remove)
fn LiveMap_remove(lm: *LiveMap, id: i64) {
    let idx: i64 = LiveMap_find(lm, id);
    if idx < 0 { return; }

    // Clear index for removed element
    if id >= 0 and id < lm.index_cap and lm.index != null {
        (lm.index + id).* = -1;
    }

    // Swap with last element
    if lm.count > 1 and idx < lm.count - 1 {
        let last: *LiveInfo = lm.entries + (lm.count - 1);
        let entry: *LiveInfo = lm.entries + idx;
        let last_id: i64 = last.id;
        entry.id = last_id;
        entry.dist = last.dist;
        entry.pos = last.pos;
        // Update index for swapped element
        if last_id >= 0 and last_id < lm.index_cap and lm.index != null {
            (lm.index + last_id).* = idx;
        }
    }
    lm.count = lm.count - 1;
}

// Get number of live values (Zig ref: LiveMap.size)
fn LiveMap_size(lm: *LiveMap) i64 {
    return lm.count;
}

// Get full LiveInfo for a value (Zig ref: LiveMap.getInfo)
// Returns pointer to entry or null if not present
fn LiveMap_getInfo(lm: *LiveMap, id: i64) *LiveInfo {
    let idx: i64 = LiveMap_find(lm, id);
    if idx >= 0 {
        return lm.entries + idx;
    }
    // Return pointer to first entry as fallback (caller should check with find first)
    return lm.entries;
}

// Add distance delta to all entries
fn LiveMap_addDistanceAll(lm: *LiveMap, delta: i64) {
    var i: i64 = 0;
    while i < lm.count {
        let entry: *LiveInfo = lm.entries + i;
        if entry.dist != UNKNOWN_DISTANCE {
            entry.dist = entry.dist + delta;
        }
        i = i + 1;
    }
}

// Get all live entries (Zig ref: LiveMap.items)
// Returns pointer to entries array; use with LiveMap_size()
fn LiveMap_items(lm: *LiveMap) *LiveInfo {
    return lm.entries;
}

// ============================================================================
// Block Liveness
// Matches Zig: dynamically allocated per-block arrays
// ============================================================================

extern fn malloc_i64(count: i64) *i64;
extern fn realloc_i64(ptr: *i64, old_count: i64, new_count: i64) *i64;

struct BlockLiveness {
    block_id: i64,
    live_out: *LiveInfo,     // Values live at END of block (owned)
    live_out_count: i64,
    live_out_cap: i64,
    live_out_index: *i64,    // Sparse index for O(1) lookup: index[value_id] = position, or -1
    live_out_index_cap: i64,
    next_call: *i64,         // For each instruction, index of next call (owned)
    next_call_count: i64,
    next_call_cap: i64,
}

fn BlockLiveness_init(bl: *BlockLiveness, block_id: i64) {
    bl.block_id = block_id;
    bl.live_out = null;
    bl.live_out_count = 0;
    bl.live_out_cap = 0;
    bl.live_out_index = null;
    bl.live_out_index_cap = 0;
    bl.next_call = null;
    bl.next_call_count = 0;
    bl.next_call_cap = 0;
}

// Ensure live_out_index has capacity for value_id
fn BlockLiveness_ensureIndexCapacity(bl: *BlockLiveness, value_id: i64) {
    let needed: i64 = value_id + 1;
    if bl.live_out_index_cap >= needed { return; }

    var new_cap: i64 = 256;
    if bl.live_out_index_cap > 0 { new_cap = bl.live_out_index_cap * 2; }
    while new_cap < needed { new_cap = new_cap * 2; }

    let new_index: *i64 = malloc_i64(new_cap);
    var i: i64 = 0;
    while i < new_cap {
        (new_index + i).* = -1;
        i = i + 1;
    }
    if bl.live_out_index != null {
        i = 0;
        while i < bl.live_out_index_cap {
            (new_index + i).* = (bl.live_out_index + i).*;
            i = i + 1;
        }
    }
    bl.live_out_index = new_index;
    bl.live_out_index_cap = new_cap;
}

// O(1) lookup in live_out
fn BlockLiveness_findLiveOut(bl: *BlockLiveness, id: i64) i64 {
    if id < 0 or id >= bl.live_out_index_cap or bl.live_out_index == null {
        return -1;
    }
    return (bl.live_out_index + id).*;
}

fn BlockLiveness_ensureLiveOutCapacity(bl: *BlockLiveness, needed: i64) {
    if bl.live_out_cap >= needed { return; }
    var new_cap: i64 = 16;
    if bl.live_out_cap > 0 { new_cap = bl.live_out_cap * 2; }
    while new_cap < needed { new_cap = new_cap * 2; }
    if bl.live_out == null {
        bl.live_out = malloc_LiveInfo(new_cap);
    } else {
        bl.live_out = realloc_LiveInfo(bl.live_out, bl.live_out_cap, new_cap);
    }
    bl.live_out_cap = new_cap;
}

fn BlockLiveness_ensureNextCallCapacity(bl: *BlockLiveness, needed: i64) {
    if bl.next_call_cap >= needed { return; }
    var new_cap: i64 = 16;
    if bl.next_call_cap > 0 { new_cap = bl.next_call_cap * 2; }
    while new_cap < needed { new_cap = new_cap * 2; }
    if bl.next_call == null {
        bl.next_call = malloc_i64(new_cap);
    } else {
        bl.next_call = realloc_i64(bl.next_call, bl.next_call_cap, new_cap);
    }
    bl.next_call_cap = new_cap;
}

// Update live_out from a LiveMap
fn BlockLiveness_update(bl: *BlockLiveness, lm: *LiveMap) {
    // Ensure we have enough space
    BlockLiveness_ensureLiveOutCapacity(bl, lm.count);
    // Copy entries
    var i: i64 = 0;
    while i < lm.count {
        let src: *LiveInfo = lm.entries + i;
        let dst: *LiveInfo = bl.live_out + i;
        dst.id = src.id;
        dst.dist = src.dist;
        dst.pos = src.pos;
        i = i + 1;
    }
    bl.live_out_count = lm.count;
}

// Check if a value is in live_out
fn BlockLiveness_contains(bl: *BlockLiveness, id: i64) bool {
    var i: i64 = 0;
    while i < bl.live_out_count {
        let entry: *LiveInfo = bl.live_out + i;
        if entry.id == id {
            return true;
        }
        i = i + 1;
    }
    return false;
}

// Get distance for a value in live_out (or INVALID_ID)
fn BlockLiveness_get(bl: *BlockLiveness, id: i64) i64 {
    var i: i64 = 0;
    while i < bl.live_out_count {
        let entry: *LiveInfo = bl.live_out + i;
        if entry.id == id {
            return entry.dist;
        }
        i = i + 1;
    }
    return INVALID_ID;
}

// ============================================================================
// Liveness Result
// Matches Zig: dynamically allocated blocks array
// ============================================================================

extern fn malloc_BlockLiveness(count: i64) *BlockLiveness;
extern fn realloc_BlockLiveness(ptr: *BlockLiveness, old_count: i64, new_count: i64) *BlockLiveness;

struct LivenessResult {
    blocks: *BlockLiveness,    // Per-block liveness info (owned)
    blocks_count: i64,
    blocks_cap: i64,
}

fn LivenessResult_init(lr: *LivenessResult) {
    lr.blocks = null;
    lr.blocks_count = 0;
    lr.blocks_cap = 0;
}

fn LivenessResult_ensureCapacity(lr: *LivenessResult, needed: i64) {
    if lr.blocks_cap >= needed { return; }
    var new_cap: i64 = 16;
    if lr.blocks_cap > 0 { new_cap = lr.blocks_cap * 2; }
    while new_cap < needed { new_cap = new_cap * 2; }
    if lr.blocks == null {
        lr.blocks = malloc_BlockLiveness(new_cap);
    } else {
        lr.blocks = realloc_BlockLiveness(lr.blocks, lr.blocks_cap, new_cap);
    }
    lr.blocks_cap = new_cap;
}

fn LivenessResult_addBlock(lr: *LivenessResult, block_id: i64) *BlockLiveness {
    LivenessResult_ensureCapacity(lr, lr.blocks_count + 1);
    let bl: *BlockLiveness = lr.blocks + lr.blocks_count;
    BlockLiveness_init(bl, block_id);
    lr.blocks_count = lr.blocks_count + 1;
    return bl;
}

// Get BlockLiveness for a block ID
fn LivenessResult_getBlock(lr: *LivenessResult, block_id: i64) *BlockLiveness {
    var i: i64 = 0;
    while i < lr.blocks_count {
        let bl: *BlockLiveness = lr.blocks + i;
        if bl.block_id == block_id {
            return bl;
        }
        i = i + 1;
    }
    // Return first as error placeholder
    return lr.blocks;
}

// Get live_out for a block
fn LivenessResult_getLiveOut(lr: *LivenessResult, block_id: i64) *BlockLiveness {
    return LivenessResult_getBlock(lr, block_id);
}

// ============================================================================
// Liveness Computation
// ============================================================================

// Check if a value needs a register
fn Value_needsRegister(v: *Value) bool {
    // Memory, control flow, and void operations don't need registers
    if v.op == Op.Store { return false; }
    if v.op == Op.Return { return false; }
    if v.op == Op.Move { return false; }
    if v.op == Op.Zero { return false; }
    if v.op == Op.InitMem { return false; }
    if v.op == Op.Nop { return false; }
    // Most other ops need registers
    return true;
}

// Check if an operation is a call
fn Op_isCallOp(op: Op) bool {
    if op == Op.Call { return true; }
    if op == Op.TailCall { return true; }
    if op == Op.ClosureCall { return true; }
    return false;
}

// Calculate branch distance between blocks
fn Block_branchDistance(from: *Block, to_id: i64) i64 {
    // Two-way branch
    if from.succs_count == 2 {
        // First successor (then branch) - usually likely
        if from.succs[0] == to_id {
            return LIKELY_DISTANCE;
        }
        // Second successor (else branch) - usually less likely
        if from.succs[1] == to_id {
            return NORMAL_DISTANCE;
        }
    }
    return NORMAL_DISTANCE;
}

// Compute nextCall array for a block
fn BlockLiveness_computeNextCall(bl: *BlockLiveness, f: *Func, block: *Block) {
    let start: i64 = block.values_start;
    let count: i64 = block.values_count;

    if count == 0 { return; }

    // Ensure we have enough space for next_call array
    BlockLiveness_ensureNextCallCapacity(bl, count);
    bl.next_call_count = count;

    // Process backwards: track the next call we've seen
    var current_next_call: i64 = -1;  // -1 means no call follows
    var i: i64 = count;
    while i > 0 {
        i = i - 1;
        let v: *Value = f.getValue( start + i);

        // Check if this is a call
        if Op_isCallOp(v.op) {
            current_next_call = i;
        }

        let nc: *i64 = bl.next_call + i;
        nc.* = current_next_call;
    }
}

// Process phi arguments from successor blocks
fn Liveness_processSuccessorPhis(lm: *LiveMap, f: *Func, block: *Block) {
    // For each successor
    var s: i64 = 0;
    while s < block.succs_count {
        let succ_id: i64 = block.succs[s];
        if succ_id == INVALID_BLOCK { s = s + 1; continue; }

        let succ: *Block = f.getBlock( succ_id);
        let delta: i64 = Block_branchDistance(block, succ_id);

        // Find phi nodes in successor
        var vi: i64 = 0;
        while vi < succ.values_count {
            let v: *Value = f.getValue( succ.values_start + vi);
            if v.op != Op.Phi { vi = vi + 1; continue; }

            // Phi input from this edge
            // For simplicity, assume edge_idx matches predecessor order
            // In full impl, we'd track edge indices
            if s < v.args.count {
                let arg_id: i64 = Value_getArg(v, s);
                if arg_id != INVALID_ID {
                    let arg: *Value = f.getValue( arg_id);
                    if Value_needsRegister(arg) {
                        LiveMap_set(lm, arg_id, delta, 0);
                    }
                }
            }
            vi = vi + 1;
        }
        s = s + 1;
    }
}

// Process a single block in the liveness algorithm
// Uses dynamic allocation - no external work buffer needed
fn Liveness_processBlockLiveness(lr: *LivenessResult, f: *Func, block: *Block,
                           lm: *LiveMap) i64 {
    let bl: *BlockLiveness = LivenessResult_getBlock(lr, block.id);

    // Initialize live set from known live_out
    LiveMap_clear(lm);
    var i: i64 = 0;
    while i < bl.live_out_count {
        let entry: *LiveInfo = bl.live_out + i;
        LiveMap_setForce(lm, entry.id, entry.dist, entry.pos);
        i = i + 1;
    }

    let old_count: i64 = lm.count;

    // Process successor phis
    Liveness_processSuccessorPhis(lm, f, block);

    // If phi args were added, update live_out
    var changed: i64 = 0;
    if lm.count > old_count {
        BlockLiveness_update(bl, lm);
        changed = 1;
    }

    // Adjust distances for block length
    let block_len: i64 = block.values_count;
    LiveMap_addDistanceAll(lm, block_len);

    // Add control value to live set
    if block.control != INVALID_ID {
        let ctrl: *Value = f.getValue( block.control);
        if Value_needsRegister(ctrl) {
            LiveMap_set(lm, block.control, block_len, 0);
        }
    }

    // Process values in reverse order (bottom to top)
    i = block_len - 1;
    while i >= 0 {
        let v: *Value = f.getValue( block.values_start + i);

        // Value is defined here - remove from live set
        LiveMap_remove(lm, v.id);

        // Skip phi nodes (handled separately)
        if v.op == Op.Phi { i = i - 1; continue; }

        // Handle calls: add unlikely_distance penalty
        if Op_isCallOp(v.op) {
            LiveMap_addDistanceAll(lm, UNLIKELY_DISTANCE);
        }

        // Add arguments to live set
        var a: i64 = 0;
        while a < v.args.count {
            let arg_id: i64 = Value_getArg(v, a);
            if arg_id != INVALID_ID {
                let arg: *Value = f.getValue( arg_id);
                if Value_needsRegister(arg) {
                    LiveMap_set(lm, arg_id, i, 0);
                }
            }
            a = a + 1;
        }
        i = i - 1;
    }

    // Propagate to predecessors
    var p: i64 = 0;
    while p < block.preds.count {
        let pred_id: i64 = Block_getPred(block, p);
        if pred_id == INVALID_BLOCK { p = p + 1; continue; }

        let pred: *Block = f.getBlock( pred_id);
        let pred_bl: *BlockLiveness = LivenessResult_getBlock(lr, pred_id);
        let delta: i64 = Block_branchDistance(pred, block.id);

        // Add values from current block's live (with delta)
        var update: i64 = 0;
        var j: i64 = 0;
        while j < lm.count {
            let entry: *LiveInfo = lm.entries + j;
            var new_dist: i64 = entry.dist;
            if new_dist != UNKNOWN_DISTANCE {
                new_dist = new_dist + delta;
            }

            // Check if already in predecessor's live_out using O(1) index lookup
            let k: i64 = BlockLiveness_findLiveOut(pred_bl, entry.id);
            if k >= 0 {
                // Already present - update if better distance
                let pe: *LiveInfo = pred_bl.live_out + k;
                if new_dist < pe.dist {
                    pe.dist = new_dist;
                    update = 1;
                }
            } else {
                // Add new entry - grow array and index if needed
                BlockLiveness_ensureLiveOutCapacity(pred_bl, pred_bl.live_out_count + 1);
                BlockLiveness_ensureIndexCapacity(pred_bl, entry.id);
                let dst: *LiveInfo = pred_bl.live_out + pred_bl.live_out_count;
                dst.id = entry.id;
                dst.dist = new_dist;
                dst.pos = entry.pos;
                // Update index
                (pred_bl.live_out_index + entry.id).* = pred_bl.live_out_count;
                pred_bl.live_out_count = pred_bl.live_out_count + 1;
                update = 1;
            }
            j = j + 1;
        }

        if update != 0 {
            changed = 1;
        }
        p = p + 1;
    }

    return changed;
}

// Main entry point: Compute liveness for a function
// All storage is dynamically allocated - no external buffers needed
// Returns 0 on success
fn Liveness_compute(lr: *LivenessResult, f: *Func, lm: *LiveMap) i64 {
    // Initialize block liveness structures - each block gets its own dynamic arrays
    var b: i64 = 0;
    while b < f.blocks_count {
        // Add block with dynamic allocation
        let bl: *BlockLiveness = LivenessResult_addBlock(lr, b);

        // Compute nextCall array (allocates dynamically)
        let block: *Block = f.getBlock( b);
        BlockLiveness_computeNextCall(bl, f, block);

        b = b + 1;
    }

    // Fixed-point iteration
    // Process in reverse order (postorder approximation)
    var changed: i64 = 1;
    var iterations: i64 = 0;
    let max_iterations: i64 = 100;

    while changed != 0 and iterations < max_iterations {
        changed = 0;
        iterations = iterations + 1;

        // Process blocks in reverse order (postorder-ish)
        b = f.blocks_count - 1;
        while b >= 0 {
            let block: *Block = f.getBlock( b);
            let result: i64 = Liveness_processBlockLiveness(lr, f, block, lm);
            if result != 0 {
                changed = 1;
            }
            b = b - 1;
        }
    }

    return 0;
}

// ============================================================================
// Query Functions
// ============================================================================

// Get distance to next use for a value in a block's live_out
fn LivenessResult_getDistance(lr: *LivenessResult, block_id: i64, value_id: i64) i64 {
    let bl: *BlockLiveness = LivenessResult_getBlock(lr, block_id);
    return BlockLiveness_get(bl, value_id);
}

// Check if a value is live at the end of a block
fn LivenessResult_isLiveOut(lr: *LivenessResult, block_id: i64, value_id: i64) bool {
    let bl: *BlockLiveness = LivenessResult_getBlock(lr, block_id);
    return BlockLiveness_contains(bl, value_id);
}

// Get next call index for an instruction (or -1 if no call follows)
fn LivenessResult_getNextCall(lr: *LivenessResult, block_id: i64, inst_idx: i64) i64 {
    let bl: *BlockLiveness = LivenessResult_getBlock(lr, block_id);
    if inst_idx < 0 or inst_idx >= bl.next_call_count {
        return -1;
    }
    let nc: *i64 = bl.next_call + inst_idx;
    return nc.*;
}

// Check if instruction has a call at or after it
fn LivenessResult_hasCallAfter(lr: *LivenessResult, block_id: i64, inst_idx: i64) bool {
    return LivenessResult_getNextCall(lr, block_id, inst_idx) >= 0;
}

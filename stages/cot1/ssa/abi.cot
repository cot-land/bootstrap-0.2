// Cot0 ABI (Application Binary Interface) for ARM64
// Defines how function parameters and results are passed.
//
// Reference: ~/learning/go/src/cmd/compile/internal/abi/abiutils.go
// Reference: bootstrap-0.2/src/ssa/abi.zig
// Reference: ARM64 Procedure Call Standard (AAPCS64)

// Note: list.cot is imported via frontend/ast.cot before this file

// ============================================================================
// ARM64 Calling Convention Constants
// ============================================================================

const ARM64_INT_PARAM_REGS: i64 = 8;      // x0-x7
const ARM64_INT_RESULT_REGS: i64 = 2;     // x0-x1
const ARM64_MAX_REG_AGGREGATE: i64 = 16;  // Max 16 bytes in registers
const ARM64_STACK_ALIGN: i64 = 16;
const ARM64_REG_SIZE: i64 = 8;
const ARM64_HIDDEN_RET_REG: i64 = 8;      // x8

// ============================================================================
// Parameter Location
// ============================================================================

enum ParamLocation {
    Register,
    Stack,
    HiddenPtr,
}

// Helper: convert ParamLocation to i64 for storage
fn ParamLocation_toI64(loc: ParamLocation) i64 {
    if loc == ParamLocation.Register { return 0; }
    if loc == ParamLocation.Stack { return 1; }
    if loc == ParamLocation.HiddenPtr { return 2; }
    return 0;
}

// Helper: convert i64 to ParamLocation
fn ParamLocation_fromI64(val: i64) ParamLocation {
    if val == 0 { return ParamLocation.Register; }
    if val == 1 { return ParamLocation.Stack; }
    if val == 2 { return ParamLocation.HiddenPtr; }
    return ParamLocation.Register;
}

// ============================================================================
// ABIParamAssignment
// ============================================================================

struct ABIParamAssignment {
    type_idx: i64,
    location: ParamLocation,
    reg0: i64,          // First register (-1 if none)
    reg1: i64,          // Second register (-1 if none)
    regs_count: i64,
    offset: i64,        // Stack offset
    size: i64,
}

fn ABIParamAssignment_init() ABIParamAssignment {
    var a: ABIParamAssignment = undefined;
    a.type_idx = 0;
    a.location = ParamLocation.Register;
    a.reg0 = -1;
    a.reg1 = -1;
    a.regs_count = 0;
    a.offset = 0;
    a.size = 0;
    return a;
}

fn ABIParamAssignment_inRegs(type_idx: i64, r0: i64, r1: i64, count: i64) ABIParamAssignment {
    var a: ABIParamAssignment = ABIParamAssignment_init();
    a.type_idx = type_idx;
    a.location = ParamLocation.Register;
    a.reg0 = r0;
    a.reg1 = r1;
    a.regs_count = count;
    a.size = count * ARM64_REG_SIZE;
    return a;
}

fn ABIParamAssignment_onStack(type_idx: i64, offset: i64, size: i64) ABIParamAssignment {
    var a: ABIParamAssignment = ABIParamAssignment_init();
    a.type_idx = type_idx;
    a.location = ParamLocation.Stack;
    a.offset = offset;
    a.size = size;
    return a;
}

fn ABIParamAssignment_isRegister(a: *ABIParamAssignment) bool {
    return a.location == ParamLocation.Register;
}

fn ABIParamAssignment_isStack(a: *ABIParamAssignment) bool {
    return a.location == ParamLocation.Stack;
}

// ============================================================================
// ABIParamResultInfo
// ============================================================================

// Stores ABI info using dynamic lists instead of fixed arrays
struct ABIParamResultInfo {
    // Input parameters - stored as flat data: each param uses 6 i64s
    // [type_idx, location, reg0, reg1, offset, size]
    in_params: I64List,
    in_params_count: i64,

    // Output parameters
    out_params: I64List,
    out_params_count: i64,

    in_registers_used: i64,
    out_registers_used: i64,
    uses_hidden_return: bool,
    hidden_return_size: i64,
    arg_stack_size: i64,
}

const PARAM_FIELDS: i64 = 6;  // Fields per param in list

impl ABIParamResultInfo {

    fn init(self: *ABIParamResultInfo) {
        i64list_init(&self.in_params);
        i64list_init(&self.out_params);
        self.in_params_count = 0;
        self.out_params_count = 0;
        self.in_registers_used = 0;
        self.out_registers_used = 0;
        self.uses_hidden_return = false;
        self.hidden_return_size = 0;
        self.arg_stack_size = 0;
    }

    fn deinit(self: *ABIParamResultInfo) {
        i64list_deinit(&self.in_params);
        i64list_deinit(&self.out_params);
    }

    fn addInParam(self: *ABIParamResultInfo, a: *ABIParamAssignment) {
        i64list_append(&self.in_params, a.type_idx);
        i64list_append(&self.in_params, ParamLocation_toI64(a.location));
        i64list_append(&self.in_params, a.reg0);
        i64list_append(&self.in_params, a.reg1);
        i64list_append(&self.in_params, a.offset);
        i64list_append(&self.in_params, a.size);
        self.in_params_count = self.in_params_count + 1;
    }

    fn addOutParam(self: *ABIParamResultInfo, a: *ABIParamAssignment) {
        i64list_append(&self.out_params, a.type_idx);
        i64list_append(&self.out_params, ParamLocation_toI64(a.location));
        i64list_append(&self.out_params, a.reg0);
        i64list_append(&self.out_params, a.reg1);
        i64list_append(&self.out_params, a.offset);
        i64list_append(&self.out_params, a.size);
        self.out_params_count = self.out_params_count + 1;
    }

    fn getInParam(self: *ABIParamResultInfo, n: i64, out: *ABIParamAssignment) {
        if n < 0 or n >= self.in_params_count {
            out.* = ABIParamAssignment_init();
            return;
        }
        let base: i64 = n * PARAM_FIELDS;
        out.type_idx = i64list_get(&self.in_params, base);
        out.location = ParamLocation_fromI64(i64list_get(&self.in_params, base + 1));
        out.reg0 = i64list_get(&self.in_params, base + 2);
        out.reg1 = i64list_get(&self.in_params, base + 3);
        out.offset = i64list_get(&self.in_params, base + 4);
        out.size = i64list_get(&self.in_params, base + 5);
        if out.reg0 >= 0 {
            out.regs_count = 1;
            if out.reg1 >= 0 {
                out.regs_count = 2;
            }
        } else {
            out.regs_count = 0;
        }
    }

    fn getOutParam(self: *ABIParamResultInfo, n: i64, out: *ABIParamAssignment) {
        if n < 0 or n >= self.out_params_count {
            out.* = ABIParamAssignment_init();
            return;
        }
        let base: i64 = n * PARAM_FIELDS;
        out.type_idx = i64list_get(&self.out_params, base);
        out.location = ParamLocation_fromI64(i64list_get(&self.out_params, base + 1));
        out.reg0 = i64list_get(&self.out_params, base + 2);
        out.reg1 = i64list_get(&self.out_params, base + 3);
        out.offset = i64list_get(&self.out_params, base + 4);
        out.size = i64list_get(&self.out_params, base + 5);
        if out.reg0 >= 0 {
            out.regs_count = 1;
            if out.reg1 >= 0 {
                out.regs_count = 2;
            }
        } else {
            out.regs_count = 0;
        }
    }

    fn argReg(self: *ABIParamResultInfo, n: i64) i64 {
        if n < 0 or n >= self.in_params_count {
            return -1;
        }
        let base: i64 = n * PARAM_FIELDS;
        return i64list_get(&self.in_params, base + 2);  // reg0
    }

    fn resultReg(self: *ABIParamResultInfo, n: i64) i64 {
        if n < 0 or n >= self.out_params_count {
            return -1;
        }
        let base: i64 = n * PARAM_FIELDS;
        return i64list_get(&self.out_params, base + 2);  // reg0
    }

    fn numArgs(self: *ABIParamResultInfo) i64 {
        return self.in_params_count;
    }

    fn numResults(self: *ABIParamResultInfo) i64 {
        return self.out_params_count;
    }

}









// Get number of input parameters
// Reference: Zig's ABIParamResultInfo.numArgs()

// Get number of output results
// Reference: Zig's ABIParamResultInfo.numResults()

// ============================================================================
// ABI Analysis State
// ============================================================================

struct ABIAssignState {
    int_reg_idx: i64,
    stack_offset: i64,
}

impl ABIAssignState {

    fn resetRegs(self: *ABIAssignState) {
        self.int_reg_idx = 0;
    }

    fn tryAllocRegs(self: *ABIAssignState, type_size: i64, out_r0: *i64, out_r1: *i64) i64 {
        out_r0.* = -1;
        out_r1.* = -1;
    
        if type_size <= 8 and self.int_reg_idx < ARM64_INT_PARAM_REGS {
            out_r0.* = self.int_reg_idx;
            self.int_reg_idx = self.int_reg_idx + 1;
            return 1;
        }
    
        if type_size > 8 and type_size <= 16 {
            if self.int_reg_idx + 1 < ARM64_INT_PARAM_REGS {
                out_r0.* = self.int_reg_idx;
                out_r1.* = self.int_reg_idx + 1;
                self.int_reg_idx = self.int_reg_idx + 2;
                return 2;
            }
        }
    
        return 0;
    }

    fn allocStack(self: *ABIAssignState, type_size: i64, alignment: i64) i64 {
        if alignment > 0 {
            let mask: i64 = alignment - 1;
            self.stack_offset = (self.stack_offset + mask) & (0 - alignment);
        }
        let offset: i64 = self.stack_offset;
        self.stack_offset = self.stack_offset + type_size;
        return offset;
    }

}

fn ABIAssignState_init() ABIAssignState {
    return ABIAssignState{
        .int_reg_idx = 0,
        .stack_offset = 0,
    };
}




// ============================================================================
// Type Size Helpers
// ============================================================================

fn ABI_getTypeSize(type_idx: i64) i64 {
    if type_idx == 0 { return 0; }       // void
    if type_idx == 1 { return 1; }       // bool
    if type_idx == 2 { return 1; }       // i8
    if type_idx == 3 { return 2; }       // i16
    if type_idx == 4 { return 4; }       // i32
    if type_idx == 5 { return 8; }       // i64
    if type_idx == 6 { return 1; }       // u8
    if type_idx == 7 { return 2; }       // u16
    if type_idx == 8 { return 4; }       // u32
    if type_idx == 9 { return 8; }       // u64
    if type_idx == 10 { return 4; }      // f32
    if type_idx == 11 { return 8; }      // f64
    if type_idx == 12 { return 8; }      // pointer
    if type_idx == 13 { return 16; }     // string (ptr + len)
    return 8;
}

fn ABI_getTypeAlignment(type_idx: i64) i64 {
    let size: i64 = ABI_getTypeSize(type_idx);
    if size >= 8 { return 8; }
    if size >= 4 { return 4; }
    if size >= 2 { return 2; }
    return 1;
}

// ============================================================================
// ABI Analysis
// ============================================================================

fn ABI_analyzeFunc(info: *ABIParamResultInfo,
                   param_types: *i64, param_count: i64,
                   return_type: i64) {
    info.init();

    var state: ABIAssignState = ABIAssignState_init();

    // Analyze input parameters
    var i: i64 = 0;
    while i < param_count {
        let param_type: *i64 = param_types + i;
        let type_idx: i64 = param_type.*;
        let param_size: i64 = ABI_getTypeSize(type_idx);
        let param_align: i64 = ABI_getTypeAlignment(type_idx);

        var assignment: ABIParamAssignment = ABIParamAssignment_init();
        assignment.type_idx = type_idx;
        assignment.size = param_size;

        var r0: i64 = -1;
        var r1: i64 = -1;
        let num_regs: i64 = state.tryAllocRegs( param_size, &r0, &r1);

        if num_regs > 0 {
            assignment.location = ParamLocation.Register;
            assignment.reg0 = r0;
            assignment.reg1 = r1;
            assignment.regs_count = num_regs;
        } else {
            assignment.location = ParamLocation.Stack;
            assignment.offset = state.allocStack( param_size, param_align);
        }

        info.addInParam( &assignment);
        i = i + 1;
    }

    info.in_registers_used = state.int_reg_idx;
    // Round up to 16-byte alignment (ARM64 ABI requirement)
    // Following Zig: src/ssa/abi.zig:argWidth() uses alignUp(max_offset, ARM64.stack_align)
    info.arg_stack_size = ABI_alignUp(state.stack_offset, ARM64_STACK_ALIGN);

    // Reset for results
    state.resetRegs();

    // Analyze return type
    let ret_size: i64 = ABI_getTypeSize(return_type);

    if ret_size > 0 and return_type != 0 {
        if ret_size > ARM64_MAX_REG_AGGREGATE {
            info.uses_hidden_return = true;
            info.hidden_return_size = ret_size;

            var assignment: ABIParamAssignment = ABIParamAssignment_init();
            assignment.type_idx = return_type;
            assignment.location = ParamLocation.HiddenPtr;
            assignment.size = ret_size;
            info.addOutParam( &assignment);
        } else {
            var assignment: ABIParamAssignment = ABIParamAssignment_init();
            assignment.type_idx = return_type;
            assignment.size = ret_size;

            var r0: i64 = -1;
            var r1: i64 = -1;
            let num_regs: i64 = state.tryAllocRegs( ret_size, &r0, &r1);

            if num_regs > 0 {
                assignment.location = ParamLocation.Register;
                assignment.reg0 = r0;
                assignment.reg1 = r1;
                assignment.regs_count = num_regs;
            }

            info.addOutParam( &assignment);
        }
    }

    info.out_registers_used = state.int_reg_idx;
}

// ============================================================================
// Utility Functions
// ============================================================================

fn ABI_alignUp(value: i64, alignment: i64) i64 {
    if alignment == 0 { return value; }
    let mask: i64 = alignment - 1;
    return (value + mask) & (0 - alignment);
}

fn ABI_regMask(reg: i64) i64 {
    if reg < 0 or reg >= 64 { return 0; }
    var one: i64 = 1;
    var i: i64 = 0;
    while i < reg {
        one = one * 2;
        i = i + 1;
    }
    return one;
}

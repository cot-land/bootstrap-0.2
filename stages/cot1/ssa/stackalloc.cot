// Cot0 Stack Allocation Pass
// Assigns stack slots to spilled values and local variables.
//
// Reference: ~/learning/go/src/cmd/compile/internal/ssa/stackalloc.go
// Reference: bootstrap-0.2/src/ssa/stackalloc.zig

// Note: func.cot and list.cot are imported before this file via genssa.cot chain

// ============================================================================
// Constants
// ============================================================================

const FRAME_HEADER_SIZE: i64 = 16;  // FP + LR
const SPILL_SLOT_SIZE: i64 = 8;

// ============================================================================
// Stack Allocation Result
// ============================================================================

struct StackAllocResult {
    frame_size: i64,
    num_locals: i64,
    locals_size: i64,
    num_spill_slots: i64,
    num_reused: i64,
}

fn StackAllocResult_init() StackAllocResult {
    return StackAllocResult{
        .frame_size = FRAME_HEADER_SIZE,
        .num_locals = 0,
        .locals_size = 0,
        .num_spill_slots = 0,
        .num_reused = 0,
    };
}

// ============================================================================
// Stack Allocator State
// ============================================================================

struct StackAllocState {
    // Per-value state: [needs_slot (0/1), def_block, slot_idx]
    // Indexed by value_id * 3
    val_state: I64List,

    // Live-out tracking: list of (block_id, value_id) pairs
    live_out: I64List,

    // Interference: list of (val_a, val_b) pairs
    interferes: I64List,

    // Slots: list of (offset, type_idx) pairs
    slots: I64List,

    // Current stack offset
    current_offset: i64,
}

impl StackAllocState {

    fn markValues(self: *StackAllocState, f: *Func) {
        var b: i64 = 0;
        while b < f.blocks_count {
            let block: *Block = f.getBlock(b);

            var v: i64 = block.values_start;
            let end: i64 = block.values_start + block.values_count;
            while v < end {
                let val: *Value = f.getValue(v);

                self.setDefBlock(v, b);

                // A value needs a slot if it's a store_reg with uses
                if val.op == Op.StoreReg and val.uses > 0 {
                    self.setNeedsSlot(v, true);
                }

                v = v + 1;
            }

            b = b + 1;
        }
    }

    fn computeLiveness(self: *StackAllocState, f: *Func) {
        // For each value needing a slot, find uses and propagate liveness

        var vid: i64 = 0;
        while vid < f.values_count {
            if not self.needsSlot(vid) {
                vid = vid + 1;
                continue;
            }

            let def_block: i64 = self.getDefBlock(vid);

            // Find all uses
            var b: i64 = 0;
            while b < f.blocks_count {
                let block: *Block = f.getBlock(b);

                var v: i64 = block.values_start;
                let end: i64 = block.values_start + block.values_count;
                while v < end {
                    let use_val: *Value = f.getValue(v);

                    // Check if this value uses vid
                    var arg_idx: i64 = 0;
                    while arg_idx < use_val.args.count {
                        if use_val.getArg(arg_idx) == vid {
                            // Propagate liveness backward
                            self.propagateLiveness(f, vid, b, def_block);
                        }
                        arg_idx = arg_idx + 1;
                    }

                    v = v + 1;
                }

                b = b + 1;
            }

            vid = vid + 1;
        }
    }

    fn propagateLiveness(self: *StackAllocState, f: *Func, vid: i64, use_block: i64, def_block: i64) {
        // BFS backward through predecessors
        var worklist: I64List = undefined;
        var visited: I64List = undefined;
        i64list_init(&worklist);
        i64list_init(&visited);

        i64list_append(&worklist, use_block);

        while worklist.count > 0 {
            let bid: i64 = i64list_pop(&worklist);

            if bid < 0 or bid >= f.blocks_count {
                continue;
            }
            if bid == def_block {
                continue;
            }

            // Check if visited
            var is_visited: bool = false;
            var i: i64 = 0;
            while i < visited.count {
                if i64list_get(&visited, i) == bid {
                    is_visited = true;
                }
                i = i + 1;
            }
            if is_visited {
                continue;
            }
            i64list_append(&visited, bid);

            // Mark live at predecessors
            let block: *Block = f.getBlock(bid);
            var p: i64 = 0;
            while p < block.preds.count {
                let pred_id: i64 = block.getPred(p);
                if pred_id >= 0 {
                    self.addLiveOut(pred_id, vid);
                    i64list_append(&worklist, pred_id);
                }
                p = p + 1;
            }
        }

        i64list_deinit(&worklist);
        i64list_deinit(&visited);
    }

    fn buildInterference(self: *StackAllocState, f: *Func) {
        var b: i64 = 0;
        while b < f.blocks_count {
            let block: *Block = f.getBlock(b);

            // Collect live values at end of block
            var live: I64List = undefined;
            i64list_init(&live);

            // Add values that are live-out
            var i: i64 = 0;
            while i < self.live_out.count {
                let bid: i64 = i64list_get(&self.live_out, i);
                let vid: i64 = i64list_get(&self.live_out, i + 1);
                if bid == b {
                    i64list_append(&live, vid);
                }
                i = i + 2;
            }

            // Process values in reverse order
            var val_idx: i64 = block.values_start + block.values_count - 1;
            while val_idx >= block.values_start {
                let val: *Value = f.getValue(val_idx);
                let vid: i64 = val_idx;

                if self.needsSlot(vid) {
                    // Remove from live
                    var j: i64 = 0;
                    while j < live.count {
                        if i64list_get(&live, j) == vid {
                            // Swap with last and pop
                            let last: i64 = i64list_get(&live, live.count - 1);
                            i64list_set(&live, j, last);
                            live.count = live.count - 1;
                        } else {
                            j = j + 1;
                        }
                    }

                    // All currently live values interfere with vid
                    j = 0;
                    while j < live.count {
                        let other: i64 = i64list_get(&live, j);
                        if self.needsSlot(other) {
                            self.addInterference(vid, other);
                        }
                        j = j + 1;
                    }
                }

                // Add args to live
                var arg_idx: i64 = 0;
                while arg_idx < val.args.count {
                    let arg_id: i64 = val.getArg(arg_idx);
                    if arg_id >= 0 and self.needsSlot(arg_id) {
                        // Check if already in live
                        var found: bool = false;
                        var k: i64 = 0;
                        while k < live.count {
                            if i64list_get(&live, k) == arg_id {
                                found = true;
                            }
                            k = k + 1;
                        }
                        if not found {
                            i64list_append(&live, arg_id);
                        }
                    }
                    arg_idx = arg_idx + 1;
                }

                val_idx = val_idx - 1;
            }

            i64list_deinit(&live);
            b = b + 1;
        }
    }

    fn allocateLocals(self: *StackAllocState, f: *Func, result: *StackAllocResult) {
        var local_idx: i64 = 0;
        while local_idx < f.locals_count {
            let local: *Local = f.getLocal(local_idx);

            // Align to 8 bytes
            self.current_offset = (self.current_offset + 7) & (0 - 8);

            local.offset = self.current_offset;
            self.current_offset = self.current_offset + local.size;

            result.num_locals = result.num_locals + 1;
            local_idx = local_idx + 1;
        }

        result.locals_size = self.current_offset - FRAME_HEADER_SIZE;
    }

    fn allocateSpillSlots(self: *StackAllocState, f: *Func, result: *StackAllocResult) {
        var vid: i64 = 0;
        while vid < f.values_count {
            if not self.needsSlot(vid) {
                vid = vid + 1;
                continue;
            }

            let val: *Value = f.getValue(vid);
            let type_idx: i64 = val.type_idx;

            // Try to find an existing slot that doesn't interfere
            var found_slot: i64 = -1;

            // Conservative: don't reuse slots for store_reg
            if val.op != Op.StoreReg {
                var slot_idx: i64 = 0;
                while slot_idx < self.slots.count / 2 {
                    let slot_type: i64 = i64list_get(&self.slots, slot_idx * 2 + 1);

                    if slot_type == type_idx {
                        // Check interference with all values using this slot
                        var interferes: bool = false;

                        var other: i64 = 0;
                        while other < vid {
                            if self.getSlotIdx(other) == slot_idx {
                                if self.checkInterferes(vid, other) {
                                    interferes = true;
                                }
                            }
                            other = other + 1;
                        }

                        if not interferes {
                            found_slot = slot_idx;
                            result.num_reused = result.num_reused + 1;
                        }
                    }

                    if found_slot >= 0 {
                        break;
                    }
                    slot_idx = slot_idx + 1;
                }
            }

            // Allocate new slot if needed
            if found_slot < 0 {
                self.current_offset = (self.current_offset + 7) & (0 - 8);

                found_slot = self.slots.count / 2;
                i64list_append(&self.slots, self.current_offset);  // offset
                i64list_append(&self.slots, type_idx);              // type_idx

                self.current_offset = self.current_offset + SPILL_SLOT_SIZE;
                result.num_spill_slots = result.num_spill_slots + 1;
            }

            // Assign slot
            self.setSlotIdx(vid, found_slot);
            let slot_offset: i64 = i64list_get(&self.slots, found_slot * 2);
            val.spill_slot = slot_offset;

            vid = vid + 1;
        }
    }

    fn init(self: *StackAllocState) {
        i64list_init(&self.val_state);
        i64list_init(&self.live_out);
        i64list_init(&self.interferes);
        i64list_init(&self.slots);
        self.current_offset = FRAME_HEADER_SIZE;
    }

    fn deinit(self: *StackAllocState) {
        i64list_deinit(&self.val_state);
        i64list_deinit(&self.live_out);
        i64list_deinit(&self.interferes);
        i64list_deinit(&self.slots);
    }

    fn ensureValue(self: *StackAllocState, vid: i64) {
        let needed: i64 = (vid + 1) * 3;
        while self.val_state.count < needed {
            i64list_append(&self.val_state, 0);   // needs_slot = false
            i64list_append(&self.val_state, -1);  // def_block
            i64list_append(&self.val_state, -1);  // slot_idx
        }
    }

    fn setNeedsSlot(self: *StackAllocState, vid: i64, needs: bool) {
        self.ensureValue(vid);
        if needs {
            i64list_set(&self.val_state, vid * 3, 1);
        } else {
            i64list_set(&self.val_state, vid * 3, 0);
        }
    }

    fn needsSlot(self: *StackAllocState, vid: i64) bool {
        if vid * 3 >= self.val_state.count {
            return false;
        }
        return i64list_get(&self.val_state, vid * 3) != 0;
    }

    fn setDefBlock(self: *StackAllocState, vid: i64, bid: i64) {
        self.ensureValue(vid);
        i64list_set(&self.val_state, vid * 3 + 1, bid);
    }

    fn getDefBlock(self: *StackAllocState, vid: i64) i64 {
        if vid * 3 + 1 >= self.val_state.count {
            return -1;
        }
        return i64list_get(&self.val_state, vid * 3 + 1);
    }

    fn setSlotIdx(self: *StackAllocState, vid: i64, idx: i64) {
        self.ensureValue(vid);
        i64list_set(&self.val_state, vid * 3 + 2, idx);
    }

    fn getSlotIdx(self: *StackAllocState, vid: i64) i64 {
        if vid * 3 + 2 >= self.val_state.count {
            return -1;
        }
        return i64list_get(&self.val_state, vid * 3 + 2);
    }

    fn addLiveOut(self: *StackAllocState, bid: i64, vid: i64) {
        i64list_append(&self.live_out, bid);
        i64list_append(&self.live_out, vid);
    }

    fn isLiveOut(self: *StackAllocState, bid: i64, vid: i64) bool {
        var i: i64 = 0;
        while i < self.live_out.count {
            let b: i64 = i64list_get(&self.live_out, i);
            let v: i64 = i64list_get(&self.live_out, i + 1);
            if b == bid and v == vid {
                return true;
            }
            i = i + 2;
        }
        return false;
    }

    fn addInterference(self: *StackAllocState, a: i64, b: i64) {
        // Check if already present
        var i: i64 = 0;
        while i < self.interferes.count {
            let va: i64 = i64list_get(&self.interferes, i);
            let vb: i64 = i64list_get(&self.interferes, i + 1);
            if (va == a and vb == b) or (va == b and vb == a) {
                return;
            }
            i = i + 2;
        }
        i64list_append(&self.interferes, a);
        i64list_append(&self.interferes, b);
    }

    fn checkInterferes(self: *StackAllocState, a: i64, b: i64) bool {
        var i: i64 = 0;
        while i < self.interferes.count {
            let va: i64 = i64list_get(&self.interferes, i);
            let vb: i64 = i64list_get(&self.interferes, i + 1);
            if (va == a and vb == b) or (va == b and vb == a) {
                return true;
            }
            i = i + 2;
        }
        return false;
    }
}

fn StackAlloc_run(f: *Func) StackAllocResult {
    var state: StackAllocState = undefined;
    state.init();

    var result: StackAllocResult = StackAllocResult_init();

    // Save regalloc's spill count (it runs before stackalloc)
    let regalloc_spills: i64 = f.spill_slots;

    // Phase 1: Mark values needing slots
    state.markValues(f);

    // Phase 2: Compute liveness
    state.computeLiveness(f);

    // Phase 3: Build interference
    state.buildInterference(f);

    // Phase 4: Allocate locals
    state.allocateLocals(f, &result);

    // Phase 5: Allocate spill slots (for StoreReg values)
    state.allocateSpillSlots(f, &result);

    // Phase 6: Allocate space for regalloc spill slots
    // Regalloc sets spill_slot on values to slot numbers (0, 1, 2, ...)
    // We need to allocate actual stack space and convert to offsets
    let spill_base: i64 = state.current_offset;
    if regalloc_spills > 0 {
        // Align to 8 bytes
        state.current_offset = (state.current_offset + 7) & (0 - 8);
        // Record the base offset for spill slots
        let spill_start: i64 = state.current_offset;
        // Allocate space for all regalloc spills
        state.current_offset = state.current_offset + (regalloc_spills * SPILL_SLOT_SIZE);
        result.num_spill_slots = regalloc_spills;

        // Convert spill_slot numbers to actual offsets
        // Walk all values and convert slot number -> stack offset
        var vid: i64 = 0;
        while vid < f.values_count {
            let val: *Value = f.getValue(vid);
            // Check if this value has a spill slot NUMBER (set by regalloc)
            // Slot numbers are small non-negative integers (0, 1, 2, ...)
            // We need to convert these to actual stack offsets
            if val.spill_slot >= 0 and val.spill_slot < regalloc_spills {
                // Convert slot number to offset: spill_start + (slot_number * 8)
                val.spill_slot = spill_start + (val.spill_slot * SPILL_SLOT_SIZE);
            }
            vid = vid + 1;
        }
    }

    // Calculate total frame size (16-byte aligned)
    let total: i64 = state.current_offset;
    result.frame_size = (total + 15) & (0 - 16);

    f.frame_size = result.frame_size;
    f.spill_slots = result.num_spill_slots;

    state.deinit();

    return result;
}

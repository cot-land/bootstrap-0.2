// Copy Elimination Pass - Eliminate Trivial Copies
// Reference: src/ssa/compile.zig earlyCopyElim
// Reference: cmd/compile/internal/ssa/copyelim.go
//
// This pass eliminates trivial copy operations by replacing uses of
// copy(x) with x directly. This reduces register pressure and removes
// unnecessary move instructions.
//
// Algorithm:
// 1. Find all Copy operations
// 2. For each copy v = copy(w), replace all uses of v with w
// 3. Mark the copy as dead (uses = 0)
//
// Note: This works with cot1's flat array model because we only
// update arg references, not create/remove values.

// Note: func.cot and related imports come from genssa.cot/main.cot

// Run the copy elimination pass on a function
// Reference: compile.zig:334 earlyCopyElim
fn copyelim(f: *Func) {
    debug.log_d(DebugPhase.ssa, "copyelim: {d} blocks", f.blocks_count);
    // Process each block
    var b: i64 = 0;
    while b < f.blocks_count {
        let block: *Block = f.getBlock(b);
        copyelimBlock(f, block);
        b = b + 1;
    }
}

// Process a single block for copy elimination
fn copyelimBlock(f: *Func, block: *Block) {
    debug.log_d(DebugPhase.ssa, "copyelimBlock: {d} values", block.values_count);
    var vi: i64 = 0;
    while vi < block.values_count {
        let v: *Value = f.getValue(block.values_start + vi);

        // Look for copy operations with exactly one argument
        if v.op == Op.Copy and v.args.count == 1 {
            let src_id: i64 = v.getArg(0);
            if src_id >= 0 and src_id < f.values_count {
                // Replace all uses of v with src
                let replaced: i64 = replaceUses(f, v.id, src_id);

                if replaced > 0 {
                    // Update use counts
                    let src: *Value = f.getValue(src_id);
                    src.uses = src.uses + replaced;

                    // The copy itself no longer has uses (they were transferred)
                    // But keep the copy's use of src
                    v.uses = 0;
                }
            }
        }

        vi = vi + 1;
    }
}

// Replace all uses of old_id with new_id in the function
// Returns the number of replacements made
fn replaceUses(f: *Func, old_id: i64, new_id: i64) i64 {
    debug.log_dd(DebugPhase.ssa, "replaceUses: {d} -> {d}", old_id, new_id);
    var count: i64 = 0;

    // Scan all values in the function
    var vi: i64 = 0;
    while vi < f.values_count {
        let v: *Value = f.values + vi;

        // Don't modify the copy itself
        if v.id == old_id {
            vi = vi + 1;
            continue;
        }

        // Check each argument
        var ai: i64 = 0;
        while ai < v.args.count {
            if v.getArg(ai) == old_id {
                v.setArgById(ai, new_id);
                count = count + 1;
            }
            ai = ai + 1;
        }

        vi = vi + 1;
    }

    // Also check block control values
    var bi: i64 = 0;
    while bi < f.blocks_count {
        let block: *Block = f.getBlock(bi);
        if block.control == old_id {
            block.control = new_id;
            count = count + 1;
        }
        bi = bi + 1;
    }

    return count;
}

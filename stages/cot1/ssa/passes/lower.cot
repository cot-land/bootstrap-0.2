// Lower Pass - Lower High-Level SSA to Machine Operations
// Reference: src/ssa/passes/lower.zig
// Reference: cmd/compile/internal/ssa/lower.go
//
// This pass converts generic SSA operations to ARM64-optimized operations.
// Examples:
// - Mul by power of 2 → Shl (shift left)
// - Add/Sub with small constant → mark for immediate encoding
// - Div by power of 2 (unsigned) → Shr (shift right)

// Imports removed - func.cot, value.cot, block.cot, op.cot already imported via genssa.cot

// Check if value is a power of 2
fn isPowerOf2(n: i64) bool {
    if n <= 0 { return false; }
    return (n & (n - 1)) == 0;
}

// Get log2 of a power of 2
fn log2(n: i64) i64 {
    var result: i64 = 0;
    var val: i64 = n;
    while val > 1 {
        val = val >> 1;
        result = result + 1;
    }
    return result;
}

// Check if constant fits in 12-bit immediate (ARM64 ADD/SUB immediate)
fn fitsImm12(n: i64) bool {
    return n >= 0 and n <= 4095;
}

// Run the lower pass on a function
// Reference: lower.zig:238 lower
fn lower(f: *Func) {
    var b: i64 = 0;
    while b < f.blocks_count {
        let block: *Block = f.getBlock( b);
        lowerBlock(f, block);
        b = b + 1;
    }
}

// Lower values in a single block
fn lowerBlock(f: *Func, block: *Block) {
    var vi: i64 = 0;
    while vi < block.values_count {
        let v: *Value = f.getValue( block.values_start + vi);

        // Pattern 1: Mul by power of 2 → Shl
        // x * 2^n → x << n
        if v.op == Op.Mul64 and v.args.count == 2 {
            let right_id: i64 = v.getArg( 1);
            if right_id >= 0 {
                let right: *Value = f.getValue( right_id);
                if right.op == Op.ConstInt and isPowerOf2(right.aux_int) {
                    let shift_amount: i64 = log2(right.aux_int);

                    // Transform Mul to Shl
                    v.op = Op.Shl64;

                    // Create a shift amount constant in place of the multiplier
                    // We reuse the const value but change its aux_int
                    right.aux_int = shift_amount;

                    // Note: use counts stay the same
                }
            }
        }

        // Note: UDiv/UMod patterns not implemented - cot0 only has signed Div64/Mod64
        // Unsigned div/mod optimizations would need Op.UDiv and Op.UMod to be added

        // Pattern 2: Mul by 0 → ConstInt 0
        if v.op == Op.Mul64 and v.args.count == 2 {
            let right_id: i64 = v.getArg( 1);
            if right_id >= 0 {
                let right: *Value = f.getValue( right_id);
                if right.op == Op.ConstInt and right.aux_int == 0 {
                    // Decrement use counts on args
                    let left_id: i64 = v.getArg( 0);
                    if left_id >= 0 {
                        let left: *Value = f.getValue( left_id);
                        left.uses = left.uses - 1;
                    }
                    right.uses = right.uses - 1;

                    // Transform to constant 0
                    v.op = Op.ConstInt;
                    v.aux_int = 0;
                    i64list_clear(&v.args);
                }
            }
        }

        // Pattern 5: Mul by 1 → Copy
        if v.op == Op.Mul64 and v.args.count == 2 {
            let right_id: i64 = v.getArg( 1);
            if right_id >= 0 {
                let right: *Value = f.getValue( right_id);
                if right.op == Op.ConstInt and right.aux_int == 1 {
                    let left_id: i64 = v.getArg( 0);

                    // Decrement use on right (the constant 1)
                    right.uses = right.uses - 1;

                    // Transform to Copy of left
                    v.op = Op.Copy;
                    v.setArgById( 0, left_id);
                    v.truncateArgs( 1);
                }
            }
        }

        // Pattern 6: Add 0 → Copy
        if v.op == Op.Add64 and v.args.count == 2 {
            let right_id: i64 = v.getArg( 1);
            if right_id >= 0 {
                let right: *Value = f.getValue( right_id);
                if right.op == Op.ConstInt and right.aux_int == 0 {
                    let left_id: i64 = v.getArg( 0);

                    right.uses = right.uses - 1;

                    v.op = Op.Copy;
                    v.setArgById( 0, left_id);
                    v.truncateArgs( 1);
                }
            }
        }

        // Pattern 7: Sub 0 → Copy
        if v.op == Op.Sub64 and v.args.count == 2 {
            let right_id: i64 = v.getArg( 1);
            if right_id >= 0 {
                let right: *Value = f.getValue( right_id);
                if right.op == Op.ConstInt and right.aux_int == 0 {
                    let left_id: i64 = v.getArg( 0);

                    right.uses = right.uses - 1;

                    v.op = Op.Copy;
                    v.setArgById( 0, left_id);
                    v.truncateArgs( 1);
                }
            }
        }

        // Pattern 8: And with all 1s → Copy
        if v.op == Op.And64 and v.args.count == 2 {
            let right_id: i64 = v.getArg( 1);
            if right_id >= 0 {
                let right: *Value = f.getValue( right_id);
                if right.op == Op.ConstInt and right.aux_int == -1 {
                    let left_id: i64 = v.getArg( 0);

                    right.uses = right.uses - 1;

                    v.op = Op.Copy;
                    v.setArgById( 0, left_id);
                    v.truncateArgs( 1);
                }
            }
        }

        // Pattern 9: Or with 0 → Copy
        if v.op == Op.Or64 and v.args.count == 2 {
            let right_id: i64 = v.getArg( 1);
            if right_id >= 0 {
                let right: *Value = f.getValue( right_id);
                if right.op == Op.ConstInt and right.aux_int == 0 {
                    let left_id: i64 = v.getArg( 0);

                    right.uses = right.uses - 1;

                    v.op = Op.Copy;
                    v.setArgById( 0, left_id);
                    v.truncateArgs( 1);
                }
            }
        }

        // Pattern 10: Xor with 0 → Copy
        if v.op == Op.Xor64 and v.args.count == 2 {
            let right_id: i64 = v.getArg( 1);
            if right_id >= 0 {
                let right: *Value = f.getValue( right_id);
                if right.op == Op.ConstInt and right.aux_int == 0 {
                    let left_id: i64 = v.getArg( 0);

                    right.uses = right.uses - 1;

                    v.op = Op.Copy;
                    v.setArgById( 0, left_id);
                    v.truncateArgs( 1);
                }
            }
        }

        // Pattern 11: Shift by 0 → Copy
        if (v.op == Op.Shl64 or v.op == Op.Shr64 or v.op == Op.Sar64) and v.args.count == 2 {
            let right_id: i64 = v.getArg( 1);
            if right_id >= 0 {
                let right: *Value = f.getValue( right_id);
                if right.op == Op.ConstInt and right.aux_int == 0 {
                    let left_id: i64 = v.getArg( 0);

                    right.uses = right.uses - 1;

                    v.op = Op.Copy;
                    v.setArgById( 0, left_id);
                    v.truncateArgs( 1);
                }
            }
        }

        // Pattern 12: Constant folding - Add/Sub/Mul of two constants
        // Reference: compile.zig opt() - constant folding
        if (v.op == Op.Add64 or v.op == Op.Sub64 or v.op == Op.Mul64) and v.args.count == 2 {
            let left_id: i64 = v.getArg( 0);
            let right_id: i64 = v.getArg( 1);
            if left_id >= 0 and right_id >= 0 {
                let left: *Value = f.getValue( left_id);
                let right: *Value = f.getValue( right_id);
                if left.op == Op.ConstInt and right.op == Op.ConstInt {
                    // Both are constants - fold
                    var result: i64 = 0;
                    if v.op == Op.Add64 {
                        result = left.aux_int + right.aux_int;
                    } else if v.op == Op.Sub64 {
                        result = left.aux_int - right.aux_int;
                    } else if v.op == Op.Mul64 {
                        result = left.aux_int * right.aux_int;
                    }

                    // Decrement use counts
                    left.uses = left.uses - 1;
                    right.uses = right.uses - 1;

                    // Transform to constant
                    v.op = Op.ConstInt;
                    v.aux_int = result;
                    i64list_clear(&v.args);
                }
            }
        }

        // Pattern 13: Constant folding - bitwise operations on constants
        if (v.op == Op.And64 or v.op == Op.Or64 or v.op == Op.Xor64) and v.args.count == 2 {
            let left_id: i64 = v.getArg( 0);
            let right_id: i64 = v.getArg( 1);
            if left_id >= 0 and right_id >= 0 {
                let left: *Value = f.getValue( left_id);
                let right: *Value = f.getValue( right_id);
                if left.op == Op.ConstInt and right.op == Op.ConstInt {
                    var result: i64 = 0;
                    if v.op == Op.And64 {
                        result = left.aux_int & right.aux_int;
                    } else if v.op == Op.Or64 {
                        result = left.aux_int | right.aux_int;
                    } else if v.op == Op.Xor64 {
                        result = left.aux_int ^ right.aux_int;
                    }

                    left.uses = left.uses - 1;
                    right.uses = right.uses - 1;

                    v.op = Op.ConstInt;
                    v.aux_int = result;
                    i64list_clear(&v.args);
                }
            }
        }

        // Pattern 14: Constant folding - shift operations on constants
        if (v.op == Op.Shl64 or v.op == Op.Shr64) and v.args.count == 2 {
            let left_id: i64 = v.getArg( 0);
            let right_id: i64 = v.getArg( 1);
            if left_id >= 0 and right_id >= 0 {
                let left: *Value = f.getValue( left_id);
                let right: *Value = f.getValue( right_id);
                if left.op == Op.ConstInt and right.op == Op.ConstInt {
                    // Only fold if shift amount is reasonable
                    if right.aux_int >= 0 and right.aux_int < 64 {
                        var result: i64 = 0;
                        if v.op == Op.Shl64 {
                            result = left.aux_int << right.aux_int;
                        } else if v.op == Op.Shr64 {
                            // Logical shift right (unsigned)
                            result = left.aux_int >> right.aux_int;
                        }

                        left.uses = left.uses - 1;
                        right.uses = right.uses - 1;

                        v.op = Op.ConstInt;
                        v.aux_int = result;
                        i64list_clear(&v.args);
                    }
                }
            }
        }

        // Pattern 15: Constant comparison folding
        if (v.op == Op.Eq64 or v.op == Op.Ne64 or v.op == Op.Lt64 or
            v.op == Op.Le64 or v.op == Op.Gt64 or v.op == Op.Ge64) and v.args.count == 2 {
            let left_id: i64 = v.getArg( 0);
            let right_id: i64 = v.getArg( 1);
            if left_id >= 0 and right_id >= 0 {
                let left: *Value = f.getValue( left_id);
                let right: *Value = f.getValue( right_id);
                if left.op == Op.ConstInt and right.op == Op.ConstInt {
                    var result: i64 = 0;
                    if v.op == Op.Eq64 {
                        if left.aux_int == right.aux_int { result = 1; }
                    } else if v.op == Op.Ne64 {
                        if left.aux_int != right.aux_int { result = 1; }
                    } else if v.op == Op.Lt64 {
                        if left.aux_int < right.aux_int { result = 1; }
                    } else if v.op == Op.Le64 {
                        if left.aux_int <= right.aux_int { result = 1; }
                    } else if v.op == Op.Gt64 {
                        if left.aux_int > right.aux_int { result = 1; }
                    } else if v.op == Op.Ge64 {
                        if left.aux_int >= right.aux_int { result = 1; }
                    }

                    left.uses = left.uses - 1;
                    right.uses = right.uses - 1;

                    v.op = Op.ConstInt;
                    v.aux_int = result;
                    i64list_clear(&v.args);
                }
            }
        }

        // Pattern 16: Sub of same value → ConstInt 0
        // x - x → 0
        if v.op == Op.Sub64 and v.args.count == 2 {
            let left_id: i64 = v.getArg( 0);
            let right_id: i64 = v.getArg( 1);
            if left_id == right_id and left_id >= 0 {
                let arg: *Value = f.getValue( left_id);
                // Decrement uses by 2 (both args point to same value)
                arg.uses = arg.uses - 2;

                v.op = Op.ConstInt;
                v.aux_int = 0;
                i64list_clear(&v.args);
            }
        }

        // Pattern 17: Xor of same value → ConstInt 0
        // x ^ x → 0
        if v.op == Op.Xor64 and v.args.count == 2 {
            let left_id: i64 = v.getArg( 0);
            let right_id: i64 = v.getArg( 1);
            if left_id == right_id and left_id >= 0 {
                let arg: *Value = f.getValue( left_id);
                arg.uses = arg.uses - 2;

                v.op = Op.ConstInt;
                v.aux_int = 0;
                i64list_clear(&v.args);
            }
        }

        // Pattern 18: And of same value → Copy
        // x & x → x
        if v.op == Op.And64 and v.args.count == 2 {
            let left_id: i64 = v.getArg( 0);
            let right_id: i64 = v.getArg( 1);
            if left_id == right_id and left_id >= 0 {
                let arg: *Value = f.getValue( left_id);
                // One use remains (for Copy), one removed
                arg.uses = arg.uses - 1;

                v.op = Op.Copy;
                v.truncateArgs( 1);
            }
        }

        // Pattern 19: Or of same value → Copy
        // x | x → x
        if v.op == Op.Or64 and v.args.count == 2 {
            let left_id: i64 = v.getArg( 0);
            let right_id: i64 = v.getArg( 1);
            if left_id == right_id and left_id >= 0 {
                let arg: *Value = f.getValue( left_id);
                arg.uses = arg.uses - 1;

                v.op = Op.Copy;
                v.truncateArgs( 1);
            }
        }

        // Pattern 20: Neg64 of Neg64 → Copy
        // -(-x) → x
        if v.op == Op.Neg64 and v.args.count == 1 {
            let arg_id: i64 = v.getArg( 0);
            if arg_id >= 0 {
                let arg: *Value = f.getValue( arg_id);
                if arg.op == Op.Neg64 and arg.args.count == 1 {
                    let inner_id: i64 = arg.getArg( 0);
                    if inner_id >= 0 {
                        let inner: *Value = f.getValue( inner_id);
                        // v now directly uses inner instead of arg
                        arg.uses = arg.uses - 1;
                        inner.uses = inner.uses + 1;

                        v.op = Op.Copy;
                        v.setArgById( 0, inner_id);
                    }
                }
            }
        }

        vi = vi + 1;
    }
}

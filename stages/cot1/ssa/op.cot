// Cot0 SSA Operation Definitions
// Minimal SSA operations for self-hosting.
//
// Reference: ~/learning/go/src/cmd/compile/internal/ssa/op.go
// Reference: bootstrap-0.2/src/ssa/op.zig

// ============================================================================
// SSA Operations
// ============================================================================

enum Op {
    // Invalid/Placeholder
    Invalid,

    // Memory State
    InitMem,        // Initial memory at function entry

    // Constants (all rematerializable)
    ConstBool,      // Boolean: aux_int = 0 or 1
    ConstInt,       // Integer: aux_int = value
    ConstNil,       // Nil pointer
    ConstString,    // String: aux = string data
    ConstPtr,       // Pointer constant

    // Integer Arithmetic (64-bit)
    Add64,          // arg0 + arg1
    Sub64,          // arg0 - arg1
    Mul64,          // arg0 * arg1
    Div64,          // arg0 / arg1 (signed)
    Mod64,          // arg0 % arg1 (signed)
    Neg64,          // -arg0

    // Bitwise Operations (64-bit)
    And64,          // arg0 & arg1
    Or64,           // arg0 | arg1
    Xor64,          // arg0 ^ arg1
    Shl64,          // arg0 << arg1
    Shr64,          // arg0 >> arg1 (logical)
    Sar64,          // arg0 >> arg1 (arithmetic)
    Not64,          // ~arg0 (bitwise NOT)
    LogicalNot64,   // !arg0 (logical NOT: 0 -> 1, non-zero -> 0)

    // Comparisons (return bool)
    Eq64,           // arg0 == arg1
    Ne64,           // arg0 != arg1
    Lt64,           // arg0 < arg1 (signed)
    Le64,           // arg0 <= arg1 (signed)
    Gt64,           // arg0 > arg1 (signed)
    Ge64,           // arg0 >= arg1 (signed)
    Ltu64,          // arg0 < arg1 (unsigned)
    Leu64,          // arg0 <= arg1 (unsigned)

    // Type Conversions
    SignExt8to64,   // Sign-extend i8 to i64
    SignExt16to64,  // Sign-extend i16 to i64
    SignExt32to64,  // Sign-extend i32 to i64
    ZeroExt8to64,   // Zero-extend u8 to u64
    ZeroExt16to64,  // Zero-extend u16 to u64
    ZeroExt32to64,  // Zero-extend u32 to u64
    Trunc64to8,     // Truncate i64 to i8
    Trunc64to16,    // Truncate i64 to i16
    Trunc64to32,    // Truncate i64 to i32

    // Memory Operations
    Load,           // Load from memory: (ptr, mem) -> value
    Store,          // Store to memory: (ptr, value, mem) -> mem
    Move,           // Memory copy: (dst, src, size, mem) -> mem
    Zero,           // Zero memory: (ptr, size, mem) -> mem

    // Address Operations
    Addr,           // Address of symbol: aux = symbol
    LocalAddr,      // Address of local: aux_int = local index
    GlobalAddr,     // Address of global: aux_int = global index
    GlobalLoad,     // Load global: aux_int = global index
    GlobalStore,    // Store to global: aux_int = global index, arg0 = value
    OffPtr,         // Offset pointer: arg0 + aux_int
    AddPtr,         // Pointer arithmetic: arg0 + arg1 (for computed offsets)

    // Control Flow
    Phi,            // SSA phi node: merge values from predecessors
    Copy,           // Copy value (for register allocation)
    Arg,            // Function argument: aux_int = arg index
    FwdRef,         // Forward reference placeholder: aux_int = local index

    // Function Calls
    Call,           // Direct call: aux = function, args...
    TailCall,       // Tail call
    ClosureCall,    // Call via closure

    // Return
    Return,         // Return from function

    // Slice Operations
    SliceLen,       // Get slice length
    SlicePtr,       // Get slice pointer
    SliceMake,      // Make slice: (ptr, len) -> slice

    // String Operations
    StringLen,      // Get string length
    StringPtr,      // Get string pointer
    StringMake,     // Make string: (ptr, len) -> string
    StringConcat,   // String concatenation: (ptr1, len1, ptr2, len2) -> string

    // Struct Operations
    StructMake,     // Make struct from fields
    StructSelect,   // Select field from struct: aux_int = field index

    // ARM64-specific (lowered)
    ARM64_ADD,      // ARM64 ADD instruction
    ARM64_SUB,      // ARM64 SUB instruction
    ARM64_MUL,      // ARM64 MUL instruction
    ARM64_SDIV,     // ARM64 SDIV instruction
    ARM64_AND,      // ARM64 AND instruction
    ARM64_ORR,      // ARM64 ORR instruction
    ARM64_EOR,      // ARM64 EOR instruction
    ARM64_LSL,      // ARM64 LSL instruction
    ARM64_LSR,      // ARM64 LSR instruction
    ARM64_ASR,      // ARM64 ASR instruction
    ARM64_CMP,      // ARM64 CMP instruction
    ARM64_CSEL,     // ARM64 conditional select
    ARM64_LDR,      // ARM64 load register
    ARM64_STR,      // ARM64 store register
    ARM64_MOV,      // ARM64 move
    ARM64_MOVK,     // ARM64 move with keep
    ARM64_MOVZ,     // ARM64 move with zero
    ARM64_MOVN,     // ARM64 move with NOT
    ARM64_ADR,      // ARM64 address of label
    ARM64_ADRP,     // ARM64 address of page
    ARM64_BL,       // ARM64 branch with link (call)
    ARM64_RET,      // ARM64 return

    // Register Allocation
    SpillReg,       // Spill register to stack
    RestoreReg,     // Restore register from stack
    StoreReg,       // Store to stack slot
    LoadReg,        // Load from stack slot

    // Special
    Nop,            // No operation
    Select,         // Conditional select: (cond, true_val, false_val)
}

// ============================================================================
// Operation Properties
// ============================================================================

// Check if operation is a constant (rematerializable)
fn Op_isConstant(op: Op) bool {
    if op == Op.ConstBool { return true; }
    if op == Op.ConstInt { return true; }
    if op == Op.ConstNil { return true; }
    if op == Op.ConstString { return true; }
    if op == Op.ConstPtr { return true; }
    return false;
}

// Check if operation is a comparison (returns bool)
fn Op_isComparison(op: Op) bool {
    if op == Op.Eq64 { return true; }
    if op == Op.Ne64 { return true; }
    if op == Op.Lt64 { return true; }
    if op == Op.Le64 { return true; }
    if op == Op.Gt64 { return true; }
    if op == Op.Ge64 { return true; }
    if op == Op.Ltu64 { return true; }
    if op == Op.Leu64 { return true; }
    return false;
}

// Check if operation is commutative
fn Op_isCommutative(op: Op) bool {
    if op == Op.Add64 { return true; }
    if op == Op.Mul64 { return true; }
    if op == Op.And64 { return true; }
    if op == Op.Or64 { return true; }
    if op == Op.Xor64 { return true; }
    if op == Op.Eq64 { return true; }
    if op == Op.Ne64 { return true; }
    return false;
}

// Check if operation has side effects (can't be eliminated)
fn Op_hasSideEffects(op: Op) bool {
    if op == Op.Store { return true; }
    if op == Op.GlobalStore { return true; }
    if op == Op.Move { return true; }
    if op == Op.Zero { return true; }
    if op == Op.Call { return true; }
    if op == Op.TailCall { return true; }
    if op == Op.ClosureCall { return true; }
    if op == Op.StringConcat { return true; }  // Calls runtime, allocates
    if op == Op.Return { return true; }
    if op == Op.ARM64_STR { return true; }
    return false;
}

// Check if operation reads memory
// Reference: Zig's OpInfo.reads_memory
fn Op_readsMemory(op: Op) bool {
    if op == Op.Load { return true; }
    if op == Op.GlobalLoad { return true; }
    if op == Op.LoadReg { return true; }
    if op == Op.ARM64_LDR { return true; }
    if op == Op.Call { return true; }
    if op == Op.TailCall { return true; }
    if op == Op.ClosureCall { return true; }
    return false;
}

// Check if operation writes memory
// Reference: Zig's OpInfo.writes_memory
fn Op_writesMemory(op: Op) bool {
    if op == Op.Store { return true; }
    if op == Op.GlobalStore { return true; }
    if op == Op.Move { return true; }
    if op == Op.Zero { return true; }
    if op == Op.StoreReg { return true; }
    if op == Op.ARM64_STR { return true; }
    if op == Op.Call { return true; }
    if op == Op.TailCall { return true; }
    if op == Op.ClosureCall { return true; }
    return false;
}

// Check if operation is a control flow terminator
fn Op_isTerminator(op: Op) bool {
    if op == Op.Return { return true; }
    if op == Op.TailCall { return true; }
    return false;
}

// Check if operation is ARM64-specific
fn Op_isArm64(op: Op) bool {
    if op == Op.ARM64_ADD { return true; }
    if op == Op.ARM64_SUB { return true; }
    if op == Op.ARM64_MUL { return true; }
    if op == Op.ARM64_SDIV { return true; }
    if op == Op.ARM64_AND { return true; }
    if op == Op.ARM64_ORR { return true; }
    if op == Op.ARM64_EOR { return true; }
    if op == Op.ARM64_LSL { return true; }
    if op == Op.ARM64_LSR { return true; }
    if op == Op.ARM64_ASR { return true; }
    if op == Op.ARM64_CMP { return true; }
    if op == Op.ARM64_CSEL { return true; }
    if op == Op.ARM64_LDR { return true; }
    if op == Op.ARM64_STR { return true; }
    if op == Op.ARM64_MOV { return true; }
    if op == Op.ARM64_MOVK { return true; }
    if op == Op.ARM64_MOVZ { return true; }
    if op == Op.ARM64_MOVN { return true; }
    if op == Op.ARM64_ADR { return true; }
    if op == Op.ARM64_ADRP { return true; }
    if op == Op.ARM64_BL { return true; }
    if op == Op.ARM64_RET { return true; }
    return false;
}

// Get number of arguments for an operation
fn Op_numArgs(op: Op) i64 {
    // Constants take 0 args
    if Op_isConstant(op) { return 0; }
    if op == Op.InitMem { return 0; }
    if op == Op.Arg { return 0; }
    if op == Op.Addr { return 0; }
    if op == Op.LocalAddr { return 0; }
    if op == Op.Nop { return 0; }

    // Unary ops take 1 arg
    if op == Op.Neg64 { return 1; }
    if op == Op.Not64 { return 1; }
    if op == Op.LogicalNot64 { return 1; }
    if op == Op.Copy { return 1; }
    if op == Op.SliceLen { return 1; }
    if op == Op.SlicePtr { return 1; }
    if op == Op.StringLen { return 1; }
    if op == Op.StringPtr { return 1; }
    if op == Op.SignExt8to64 { return 1; }
    if op == Op.SignExt16to64 { return 1; }
    if op == Op.SignExt32to64 { return 1; }
    if op == Op.ZeroExt8to64 { return 1; }
    if op == Op.ZeroExt16to64 { return 1; }
    if op == Op.ZeroExt32to64 { return 1; }
    if op == Op.Trunc64to8 { return 1; }
    if op == Op.Trunc64to16 { return 1; }
    if op == Op.Trunc64to32 { return 1; }
    if op == Op.OffPtr { return 1; }
    if op == Op.Return { return 1; }

    // Binary ops take 2 args
    if op == Op.Add64 { return 2; }
    if op == Op.Sub64 { return 2; }
    if op == Op.Mul64 { return 2; }
    if op == Op.Div64 { return 2; }
    if op == Op.Mod64 { return 2; }
    if op == Op.And64 { return 2; }
    if op == Op.Or64 { return 2; }
    if op == Op.Xor64 { return 2; }
    if op == Op.Shl64 { return 2; }
    if op == Op.Shr64 { return 2; }
    if op == Op.Sar64 { return 2; }
    if op == Op.Eq64 { return 2; }
    if op == Op.Ne64 { return 2; }
    if op == Op.Lt64 { return 2; }
    if op == Op.Le64 { return 2; }
    if op == Op.Gt64 { return 2; }
    if op == Op.Ge64 { return 2; }
    if op == Op.Ltu64 { return 2; }
    if op == Op.Leu64 { return 2; }
    if op == Op.Load { return 2; }
    if op == Op.SliceMake { return 2; }
    if op == Op.StringMake { return 2; }
    if op == Op.AddPtr { return 2; }

    // 3-arg ops
    if op == Op.Store { return 3; }
    if op == Op.Select { return 3; }

    // Phi and Call have variable args
    return -1;
}

// Check if operation is a branch (affects control flow)
// Reference: Zig's Op.isBranch()
fn Op_isBranch(op: Op) bool {
    if op == Op.Return { return true; }
    if op == Op.TailCall { return true; }
    // Note: actual branch instructions are in block control, not values
    return false;
}

// Check if operation is a call
// Reference: Zig's Op.isCall()
fn Op_isCall(op: Op) bool {
    if op == Op.Call { return true; }
    if op == Op.TailCall { return true; }
    if op == Op.ClosureCall { return true; }
    return false;
}

// Check if operation is a load
// Reference: Zig's Op.isLoad()
fn Op_isLoad(op: Op) bool {
    if op == Op.Load { return true; }
    if op == Op.GlobalLoad { return true; }
    if op == Op.LoadReg { return true; }
    if op == Op.ARM64_LDR { return true; }
    return false;
}

// Check if operation is a store
// Reference: Zig's Op.isStore()
fn Op_isStore(op: Op) bool {
    if op == Op.Store { return true; }
    if op == Op.GlobalStore { return true; }
    if op == Op.StoreReg { return true; }
    if op == Op.ARM64_STR { return true; }
    return false;
}

// Get operation name as string
// Reference: Zig's @tagName(op)
// Note: Named Op_toString to avoid conflict with Op_name in validate.cot
fn Op_toString(op: Op) string {
    if op == Op.Invalid { return "Invalid"; }
    if op == Op.InitMem { return "InitMem"; }
    if op == Op.ConstBool { return "ConstBool"; }
    if op == Op.ConstInt { return "ConstInt"; }
    if op == Op.ConstNil { return "ConstNil"; }
    if op == Op.ConstString { return "ConstString"; }
    if op == Op.ConstPtr { return "ConstPtr"; }
    if op == Op.Add64 { return "Add64"; }
    if op == Op.Sub64 { return "Sub64"; }
    if op == Op.Mul64 { return "Mul64"; }
    if op == Op.Div64 { return "Div64"; }
    if op == Op.Mod64 { return "Mod64"; }
    if op == Op.Neg64 { return "Neg64"; }
    if op == Op.And64 { return "And64"; }
    if op == Op.Or64 { return "Or64"; }
    if op == Op.Xor64 { return "Xor64"; }
    if op == Op.Shl64 { return "Shl64"; }
    if op == Op.Shr64 { return "Shr64"; }
    if op == Op.Sar64 { return "Sar64"; }
    if op == Op.Not64 { return "Not64"; }
    if op == Op.LogicalNot64 { return "LogicalNot64"; }
    if op == Op.Eq64 { return "Eq64"; }
    if op == Op.Ne64 { return "Ne64"; }
    if op == Op.Lt64 { return "Lt64"; }
    if op == Op.Le64 { return "Le64"; }
    if op == Op.Gt64 { return "Gt64"; }
    if op == Op.Ge64 { return "Ge64"; }
    if op == Op.Ltu64 { return "Ltu64"; }
    if op == Op.Leu64 { return "Leu64"; }
    if op == Op.SignExt8to64 { return "SignExt8to64"; }
    if op == Op.SignExt16to64 { return "SignExt16to64"; }
    if op == Op.SignExt32to64 { return "SignExt32to64"; }
    if op == Op.ZeroExt8to64 { return "ZeroExt8to64"; }
    if op == Op.ZeroExt16to64 { return "ZeroExt16to64"; }
    if op == Op.ZeroExt32to64 { return "ZeroExt32to64"; }
    if op == Op.Trunc64to8 { return "Trunc64to8"; }
    if op == Op.Trunc64to16 { return "Trunc64to16"; }
    if op == Op.Trunc64to32 { return "Trunc64to32"; }
    if op == Op.Load { return "Load"; }
    if op == Op.Store { return "Store"; }
    if op == Op.Move { return "Move"; }
    if op == Op.Zero { return "Zero"; }
    if op == Op.Addr { return "Addr"; }
    if op == Op.LocalAddr { return "LocalAddr"; }
    if op == Op.GlobalAddr { return "GlobalAddr"; }
    if op == Op.GlobalLoad { return "GlobalLoad"; }
    if op == Op.GlobalStore { return "GlobalStore"; }
    if op == Op.OffPtr { return "OffPtr"; }
    if op == Op.AddPtr { return "AddPtr"; }
    if op == Op.Phi { return "Phi"; }
    if op == Op.Copy { return "Copy"; }
    if op == Op.Arg { return "Arg"; }
    if op == Op.FwdRef { return "FwdRef"; }
    if op == Op.Call { return "Call"; }
    if op == Op.TailCall { return "TailCall"; }
    if op == Op.ClosureCall { return "ClosureCall"; }
    if op == Op.Return { return "Return"; }
    if op == Op.SliceLen { return "SliceLen"; }
    if op == Op.SlicePtr { return "SlicePtr"; }
    if op == Op.SliceMake { return "SliceMake"; }
    if op == Op.StringLen { return "StringLen"; }
    if op == Op.StringPtr { return "StringPtr"; }
    if op == Op.StringMake { return "StringMake"; }
    if op == Op.StringConcat { return "StringConcat"; }
    if op == Op.StructMake { return "StructMake"; }
    if op == Op.StructSelect { return "StructSelect"; }
    if op == Op.ARM64_ADD { return "ARM64_ADD"; }
    if op == Op.ARM64_SUB { return "ARM64_SUB"; }
    if op == Op.ARM64_MUL { return "ARM64_MUL"; }
    if op == Op.ARM64_SDIV { return "ARM64_SDIV"; }
    if op == Op.ARM64_AND { return "ARM64_AND"; }
    if op == Op.ARM64_ORR { return "ARM64_ORR"; }
    if op == Op.ARM64_EOR { return "ARM64_EOR"; }
    if op == Op.ARM64_LSL { return "ARM64_LSL"; }
    if op == Op.ARM64_LSR { return "ARM64_LSR"; }
    if op == Op.ARM64_ASR { return "ARM64_ASR"; }
    if op == Op.ARM64_CMP { return "ARM64_CMP"; }
    if op == Op.ARM64_CSEL { return "ARM64_CSEL"; }
    if op == Op.ARM64_LDR { return "ARM64_LDR"; }
    if op == Op.ARM64_STR { return "ARM64_STR"; }
    if op == Op.ARM64_MOV { return "ARM64_MOV"; }
    if op == Op.ARM64_MOVK { return "ARM64_MOVK"; }
    if op == Op.ARM64_MOVZ { return "ARM64_MOVZ"; }
    if op == Op.ARM64_MOVN { return "ARM64_MOVN"; }
    if op == Op.ARM64_ADR { return "ARM64_ADR"; }
    if op == Op.ARM64_ADRP { return "ARM64_ADRP"; }
    if op == Op.ARM64_BL { return "ARM64_BL"; }
    if op == Op.ARM64_RET { return "ARM64_RET"; }
    if op == Op.SpillReg { return "SpillReg"; }
    if op == Op.RestoreReg { return "RestoreReg"; }
    if op == Op.StoreReg { return "StoreReg"; }
    if op == Op.LoadReg { return "LoadReg"; }
    if op == Op.Nop { return "Nop"; }
    if op == Op.Select { return "Select"; }
    return "Unknown";
}

// ============================================================================
// Inline Tests
// ============================================================================

test "Op_isConstant identifies constants" {
    @assert(Op_isConstant(Op.ConstInt))
    @assert(Op_isConstant(Op.ConstBool))
    @assert(Op_isConstant(Op.ConstNil))
    @assert(Op_isConstant(Op.ConstString))
    @assert(!Op_isConstant(Op.Add64))
    @assert(!Op_isConstant(Op.Load))
}

test "Op_isComparison identifies comparisons" {
    @assert(Op_isComparison(Op.Eq64))
    @assert(Op_isComparison(Op.Ne64))
    @assert(Op_isComparison(Op.Lt64))
    @assert(Op_isComparison(Op.Gt64))
    @assert(!Op_isComparison(Op.Add64))
    @assert(!Op_isComparison(Op.Mul64))
}

test "Op_isCommutative identifies commutative ops" {
    @assert(Op_isCommutative(Op.Add64))
    @assert(Op_isCommutative(Op.Mul64))
    @assert(Op_isCommutative(Op.And64))
    @assert(Op_isCommutative(Op.Or64))
    @assert(!Op_isCommutative(Op.Sub64))
    @assert(!Op_isCommutative(Op.Div64))
}

test "Op_hasSideEffects identifies side effects" {
    @assert(Op_hasSideEffects(Op.Store))
    @assert(Op_hasSideEffects(Op.Call))
    @assert(Op_hasSideEffects(Op.GlobalStore))
    @assert(!Op_hasSideEffects(Op.Add64))
    @assert(!Op_hasSideEffects(Op.ConstInt))
}

test "Op_readsMemory identifies memory reads" {
    @assert(Op_readsMemory(Op.Load))
    @assert(Op_readsMemory(Op.GlobalLoad))
    @assert(!Op_readsMemory(Op.Store))
    @assert(!Op_readsMemory(Op.Add64))
}

test "Op_writesMemory identifies memory writes" {
    @assert(Op_writesMemory(Op.Store))
    @assert(Op_writesMemory(Op.GlobalStore))
    @assert(!Op_writesMemory(Op.Load))
    @assert(!Op_writesMemory(Op.Add64))
}

test "Op_isTerminator identifies terminators" {
    @assert(Op_isTerminator(Op.Return))
    @assert(!Op_isTerminator(Op.Add64))
    @assert(!Op_isTerminator(Op.Call))
}

test "Op_isBranch identifies branches" {
    @assert(Op_isBranch(Op.Return))
    @assert(Op_isBranch(Op.TailCall))
    @assert(!Op_isBranch(Op.Add64))
    @assert(!Op_isBranch(Op.Call))
}

test "Op_isCall identifies calls" {
    @assert(Op_isCall(Op.Call))
    @assert(Op_isCall(Op.TailCall))
    @assert(!Op_isCall(Op.Add64))
    @assert(!Op_isCall(Op.Return))
}

test "Op_isLoad identifies loads" {
    @assert(Op_isLoad(Op.Load))
    @assert(Op_isLoad(Op.GlobalLoad))
    @assert(!Op_isLoad(Op.Store))
    @assert(!Op_isLoad(Op.Add64))
}

test "Op_isStore identifies stores" {
    @assert(Op_isStore(Op.Store))
    @assert(Op_isStore(Op.GlobalStore))
    @assert(!Op_isStore(Op.Load))
    @assert(!Op_isStore(Op.Add64))
}

test "Op_toString returns valid names" {
    @assert(Op_toString(Op.Add64).len > 0)
    @assert(Op_toString(Op.ConstInt).len > 0)
    @assert(Op_toString(Op.Load).len > 0)
}

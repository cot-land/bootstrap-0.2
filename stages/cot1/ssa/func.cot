// Cot0 SSA Function
// Minimal SSA function for self-hosting.
//
// Reference: ~/learning/go/src/cmd/compile/internal/ssa/func.go
// Reference: bootstrap-0.2/src/ssa/func.zig

// Only import block.cot - it transitively imports value.cot â†’ op.cot
import "block.cot"

// ============================================================================
// Constants
// ============================================================================

const FUNC_MAX_PARAMS: i64 = 32;
const FUNC_MAX_LOCALS: i64 = 1024;

// Initial capacities for Func-owned storage
// CRITICAL: These must be small because EACH function allocates its own storage.
// With 1106 functions, 50000 values each = 5.5 GB heap exhaustion!
// Start small and grow dynamically as needed.
// BUG FIX: Original values were too small. When Func_newValue returns *Value
// and the values array is later reallocated, those pointers become dangling.
// Increase initial capacities to avoid realloc during compilation of large functions.
// With 128 if statements creating ~1000 values and ~400 blocks, need higher limits.
// TODO: Proper fix is to use value IDs instead of pointers, or re-fetch after realloc.
const FN_INIT_BLOCKS: i64 = 1024;
const FN_INIT_VALUES: i64 = 10000;
const FN_INIT_LOCALS: i64 = 256;

// Generic sized allocation - use @sizeOf(T) to avoid hardcoded sizes in runtime
extern fn malloc_sized(count: i64, struct_size: i64) *u8;
extern fn realloc_sized(ptr: *u8, old_count: i64, new_count: i64, struct_size: i64) *u8;

// ============================================================================
// Local Variable
// ============================================================================

struct Local {
    name_start: i64,      // Name offset in source
    name_len: i64,        // Name length
    type_idx: i64,        // Type index
    is_mutable: bool,     // let vs var
    is_param: bool,       // Is function parameter
    param_idx: i64,       // Parameter index (if is_param)
    size: i64,            // Size in bytes
    align: i64,           // Alignment
    offset: i64,          // Stack frame offset (computed by stackalloc)
}

// Static constructors (outside impl block)
fn Local_create(name_start: i64, name_len: i64, type_idx: i64, is_mutable: bool) Local {
    debug.log_dd(DebugPhase.ssa, "Local_create: start={d} type={d}", name_start, type_idx);
    return Local{
        .name_start = name_start,
        .name_len = name_len,
        .type_idx = type_idx,
        .is_mutable = is_mutable,
        .is_param = false,
        .param_idx = 0,
        .size = 8,
        .align = 8,
        .offset = 0,
    };
}

fn Local_createParam(name_start: i64, name_len: i64, type_idx: i64, param_idx: i64) Local {
    debug.log_dd(DebugPhase.ssa, "Local_createParam: type={d} idx={d}", type_idx, param_idx);
    return Local{
        .name_start = name_start,
        .name_len = name_len,
        .type_idx = type_idx,
        .is_mutable = false,
        .is_param = true,
        .param_idx = param_idx,
        .size = 8,
        .align = 8,
        .offset = 0,
    };
}

impl Local {
    // Local accessor functions
    fn getType(self: *Local) i64 {
        return self.type_idx;
    }

    fn getSize(self: *Local) i64 {
        return self.size;
    }

    fn getOffset(self: *Local) i64 {
        return self.offset;
    }

    fn isParam(self: *Local) bool {
        return self.is_param;
    }

    fn isMutable(self: *Local) bool {
        return self.is_mutable;
    }
}

// ============================================================================
// SSA Function
// ============================================================================

// Func represents a function in SSA form.
// Contains:
// - Entry block
// - All basic blocks
// - All values (instructions)
// - Local variables
// - Stack frame layout
struct Func {
    // Function metadata
    name_start: i64,      // Name offset in source
    name_len: i64,        // Name length
    return_type: i64,     // Return type index
    return_type_size: i64, // Return type size in bytes (for hidden return detection)

    // Blocks
    blocks: *Block,       // Externally allocated block array
    blocks_count: i64,
    blocks_cap: i64,
    entry_block: i64,     // Entry block ID

    // Values
    values: *Value,       // Externally allocated value array
    values_count: i64,
    values_cap: i64,

    // Locals
    locals: *Local,       // Externally allocated local array
    locals_count: i64,
    locals_cap: i64,

    // Stack frame (computed by stackalloc)
    frame_size: i64,      // Total stack frame size
    spill_slots: i64,     // Number of spill slots used

    // Current building state
    current_block: i64,   // Block we're adding values to
}

impl Func {
    // ============================================================================
    // Function Initialization
    // ============================================================================

    // Func owns its storage (matches bootstrap Zig pattern)
    // Allocates blocks, values, locals arrays directly into struct fields
    fn init(self: *Func, name_start: i64, name_len: i64, return_type: i64) {
        debug.log_dd(DebugPhase.ssa, "Func.init: start={d} ret={d}", name_start, return_type);
        self.name_start = name_start;
        self.name_len = name_len;
        self.return_type = return_type;
        self.return_type_size = 8;  // Default to 8 bytes (i64), set larger for structs

        // Allocate blocks array - use @sizeOf(Block) for correct size
        self.blocks_cap = FN_INIT_BLOCKS;
        let block_size: i64 = @sizeOf(Block);
        let blocks_raw: *u8 = malloc_sized(self.blocks_cap, block_size);
        self.blocks = @ptrCast(*Block, blocks_raw);
        self.blocks_count = 0;
        self.entry_block = INVALID_BLOCK;

        // Allocate values array - use @sizeOf(Value) for correct size
        self.values_cap = FN_INIT_VALUES;
        let value_size: i64 = @sizeOf(Value);
        let values_raw: *u8 = malloc_sized(self.values_cap, value_size);
        self.values = @ptrCast(*Value, values_raw);
        self.values_count = 0;

        // Allocate locals array - use @sizeOf(Local) for correct size
        self.locals_cap = FN_INIT_LOCALS;
        let local_size: i64 = @sizeOf(Local);
        let locals_raw: *u8 = malloc_sized(self.locals_cap, local_size);
        self.locals = @ptrCast(*Local, locals_raw);
        self.locals_count = 0;

        self.frame_size = 0;
        self.spill_slots = 0;
        self.current_block = INVALID_BLOCK;
    }

    // ============================================================================
    // Block Management
    // ============================================================================

    // Create a new block and add it to the function
    fn newBlock(self: *Func, kind: BlockKind) i64 {
        debug.log_d(DebugPhase.ssa, "Func.newBlock: count={d}", self.blocks_count);
        // Grow blocks array if needed
        if self.blocks_count >= self.blocks_cap {
            let new_cap: i64 = self.blocks_cap * 2;
            let block_size: i64 = @sizeOf(Block);
            let old_ptr: *u8 = @ptrCast(*u8, self.blocks);
            let new_ptr: *u8 = realloc_sized(old_ptr, self.blocks_cap, new_cap, block_size);
            self.blocks = @ptrCast(*Block, new_ptr);
            self.blocks_cap = new_cap;
        }

        let id: i64 = self.blocks_count;
        let b: *Block = self.blocks + id;
        b.* = Block_new(id, kind);
        self.blocks_count = self.blocks_count + 1;

        return id;
    }

    // Create entry block (call once at start)
    fn newEntryBlock(self: *Func) i64 {
        debug.log(DebugPhase.ssa, "Func.newEntryBlock");
        let id: i64 = self.newBlock(BlockKind.Plain);
        self.entry_block = id;
        self.current_block = id;
        return id;
    }

    // Get block by ID
    fn getBlock(self: *Func, id: i64) *Block {
        debug.log_d(DebugPhase.ssa, "Func.getBlock: id={d}", id);
        if id < 0 or id >= self.blocks_count {
            return self.blocks;  // Return first as error placeholder
        }
        return self.blocks + id;
    }

    // Set current block (for value emission)
    fn setBlock(self: *Func, block_id: i64) {
        debug.log_d(DebugPhase.ssa, "Func.setBlock: id={d}", block_id);
        self.current_block = block_id;
    }

    // ============================================================================
    // Value Management
    // ============================================================================

    // Create a new value in the current block
    fn newValue(self: *Func, op: Op, type_idx: i64) *Value {
        debug.log_dd(DebugPhase.ssa, "Func.newValue: count={d} type={d}", self.values_count, type_idx);
        // Grow values array if needed
        if self.values_count >= self.values_cap {
            let new_cap: i64 = self.values_cap * 2;
            let value_size: i64 = @sizeOf(Value);
            let old_ptr: *u8 = @ptrCast(*u8, self.values);
            let new_ptr: *u8 = realloc_sized(old_ptr, self.values_cap, new_cap, value_size);
            self.values = @ptrCast(*Value, new_ptr);
            self.values_cap = new_cap;
        }
        if self.current_block == INVALID_BLOCK {
            return self.values;
        }

        let id: i64 = self.values_count;
        let v: *Value = self.values + id;
        v.* = Value_create(id, op, type_idx, self.current_block);
        self.values_count = self.values_count + 1;

        // Update block's value range
        let b: *Block = self.getBlock(self.current_block);
        if b.values_count == 0 {
            b.values_start = id;
        }
        b.values_count = b.values_count + 1;

        return v;
    }

    // Get value by ID
    fn getValue(self: *Func, id: i64) *Value {
        debug.log_d(DebugPhase.ssa, "Func.getValue: id={d}", id);
        if id < 0 or id >= self.values_count {
            return self.values;  // Return first as error placeholder
        }
        return self.values + id;
    }

    // ============================================================================
    // Local Management
    // ============================================================================

    // Add a local variable
    fn addLocal(self: *Func, name_start: i64, name_len: i64, type_idx: i64, is_mutable: bool) i64 {
        debug.log_dd(DebugPhase.ssa, "Func.addLocal: type={d} count={d}", type_idx, self.locals_count);
        // Grow locals array if needed
        if self.locals_count >= self.locals_cap {
            let new_cap: i64 = self.locals_cap * 2;
            let local_size: i64 = @sizeOf(Local);
            let old_ptr: *u8 = @ptrCast(*u8, self.locals);
            let new_ptr: *u8 = realloc_sized(old_ptr, self.locals_cap, new_cap, local_size);
            self.locals = @ptrCast(*Local, new_ptr);
            self.locals_cap = new_cap;
        }

        let idx: i64 = self.locals_count;
        let local: *Local = self.locals + idx;
        local.* = Local_create(name_start, name_len, type_idx, is_mutable);
        self.locals_count = self.locals_count + 1;

        return idx;
    }

    // Add a parameter (parameters come before other locals)
    fn addParam(self: *Func, name_start: i64, name_len: i64, type_idx: i64) i64 {
        debug.log_dd(DebugPhase.ssa, "Func.addParam: type={d} count={d}", type_idx, self.locals_count);
        // Grow locals array if needed
        if self.locals_count >= self.locals_cap {
            let new_cap: i64 = self.locals_cap * 2;
            let local_size: i64 = @sizeOf(Local);
            let old_ptr: *u8 = @ptrCast(*u8, self.locals);
            let new_ptr: *u8 = realloc_sized(old_ptr, self.locals_cap, new_cap, local_size);
            self.locals = @ptrCast(*Local, new_ptr);
            self.locals_cap = new_cap;
        }

        let param_idx: i64 = self.locals_count;
        let idx: i64 = self.locals_count;
        let local: *Local = self.locals + idx;
        local.* = Local_createParam(name_start, name_len, type_idx, param_idx);
        self.locals_count = self.locals_count + 1;

        return idx;
    }

    // Get local by index
    fn getLocal(self: *Func, idx: i64) *Local {
        debug.log_d(DebugPhase.ssa, "Func.getLocal: idx={d}", idx);
        if idx < 0 or idx >= self.locals_count {
            return self.locals;  // Return first as error placeholder
        }
        return self.locals + idx;
    }

    // Get count of blocks
    // Reference: Zig's Func.numBlocks()
    fn numBlocks(self: *Func) i64 {
        return self.blocks_count;
    }

    // Get count of values
    // Reference: Zig's Func.numValues()
    fn numValues(self: *Func) i64 {
        return self.values_count;
    }

    // Get count of locals
    // Reference: Zig's Func.numLocals()
    fn numLocals(self: *Func) i64 {
        return self.locals_count;
    }

    // Get frame size
    fn getFrameSize(self: *Func) i64 {
        return self.frame_size;
    }

    // Get entry block ID
    fn getEntryBlock(self: *Func) i64 {
        return self.entry_block;
    }

    // Get return type index
    fn getReturnType(self: *Func) i64 {
        return self.return_type;
    }

    // Get return type size in bytes
    fn getReturnTypeSize(self: *Func) i64 {
        return self.return_type_size;
    }

    // Set return type size (called after SSA building when type is known)
    fn setReturnTypeSize(self: *Func, size: i64) {
        self.return_type_size = size;
    }

    // Get current block ID
    fn getCurrentBlock(self: *Func) i64 {
        return self.current_block;
    }

    // ============================================================================
    // Value Emission Helpers
    // ============================================================================

    // Emit a constant integer
    fn emitConstInt(self: *Func, value: i64, type_idx: i64) *Value {
        debug.log_dd(DebugPhase.ssa, "Func.emitConstInt: val={d} type={d}", value, type_idx);
        let v: *Value = self.newValue(Op.ConstInt, type_idx);
        v.aux_int = value;
        return v;
    }

    // Emit a constant boolean
    fn emitConstBool(self: *Func, value: bool) *Value {
        debug.log(DebugPhase.ssa, "Func.emitConstBool");
        let v: *Value = self.newValue(Op.ConstBool, 1);  // TYPE_BOOL = 1
        if value {
            v.aux_int = 1;
        } else {
            v.aux_int = 0;
        }
        return v;
    }

    // Emit a constant string
    fn emitConstString(self: *Func, str_start: i64, str_len: i64) *Value {
        debug.log_dd(DebugPhase.ssa, "Func.emitConstString: start={d} len={d}", str_start, str_len);
        let v: *Value = self.newValue(Op.ConstString, 13);  // TYPE_STRING = 13
        v.aux_int = str_start;  // Offset in source text
        v.aux_ptr = str_len;    // Length of string
        return v;
    }

    // Emit a binary operation
    fn emitBinary(self: *Func, op: Op, left: *Value, right: *Value, type_idx: i64) *Value {
        debug.log_d(DebugPhase.ssa, "Func.emitBinary: type={d}", type_idx);
        let v: *Value = self.newValue(op, type_idx);
        v.addArg2(left, right);
        return v;
    }

    // Emit a unary operation
    fn emitUnary(self: *Func, op: Op, operand: *Value, type_idx: i64) *Value {
        debug.log_d(DebugPhase.ssa, "Func.emitUnary: type={d}", type_idx);
        let v: *Value = self.newValue(op, type_idx);
        v.addArg(operand);
        return v;
    }

    // Emit a select (conditional value): cond ? true_val : false_val
    fn emitSelect(self: *Func, cond: *Value, true_val: *Value, false_val: *Value, type_idx: i64) *Value {
        debug.log_d(DebugPhase.ssa, "Func.emitSelect: type={d}", type_idx);
        let v: *Value = self.newValue(Op.Select, type_idx);
        v.addArg3(cond, true_val, false_val);
        return v;
    }

    // Emit a load from local
    fn emitLoadLocal(self: *Func, local_idx: i64) *Value {
        debug.log_d(DebugPhase.ssa, "Func.emitLoadLocal: idx={d}", local_idx);
        let local: *Local = self.getLocal(local_idx);
        let v: *Value = self.newValue(Op.LocalAddr, local.type_idx);
        v.aux_int = local_idx;

        let load: *Value = self.newValue(Op.Load, local.type_idx);
        load.addArg(v);
        return load;
    }

    // Emit a store to local
    fn emitStoreLocal(self: *Func, local_idx: i64, val: *Value) *Value {
        debug.log_d(DebugPhase.ssa, "Func.emitStoreLocal: idx={d}", local_idx);
        let local: *Local = self.getLocal(local_idx);
        let addr: *Value = self.newValue(Op.LocalAddr, local.type_idx);
        addr.aux_int = local_idx;

        let store: *Value = self.newValue(Op.Store, 0);  // Store has no result type
        store.addArg2(addr, val);
        return store;
    }

    // Emit a return
    fn emitReturn(self: *Func, val: *Value) *Value {
        debug.log_d(DebugPhase.ssa, "Func.emitReturn: block={d}", self.current_block);
        let ret: *Value = self.newValue(Op.Return, 0);
        if val.id != INVALID_ID {
            ret.addArg(val);
        }
        // BUG-073: Set block kind to Return when emitting a Return value.
        // This ensures blockControl() won't emit additional control flow
        // after the Return value's epilogue + ret instruction.
        let b: *Block = self.getBlock(self.current_block);
        b.kind = BlockKind.Return;
        return ret;
    }

    // Emit a function call
    // name_start/name_len refer to positions in source
    fn emitCall(self: *Func, name_start: i64, name_len: i64, type_idx: i64) *Value {
        debug.log_dd(DebugPhase.ssa, "Func.emitCall: start={d} type={d}", name_start, type_idx);
        let v: *Value = self.newValue(Op.Call, type_idx);
        v.aux_int = name_start;
        v.aux_ptr = name_len;
        return v;
    }

    // Emit an indirect function call through function pointer (Go: ClosureCall)
    // Following Zig pattern: src/frontend/ir.zig:1168
    // The function pointer will be added as first arg by caller
    fn emitCallIndirect(self: *Func, type_idx: i64) *Value {
        debug.log_d(DebugPhase.ssa, "Func.emitCallIndirect: type={d}", type_idx);
        let v: *Value = self.newValue(Op.ClosureCall, type_idx);
        return v;
    }

    // ============================================================================
    // Control Flow
    // ============================================================================

    // Set up a conditional branch
    fn emitIf(self: *Func, cond: *Value, then_block: i64, else_block: i64) {
        debug.log_dd(DebugPhase.ssa, "Func.emitIf: then={d} else={d}", then_block, else_block);
        let b: *Block = self.getBlock(self.current_block);
        b.kind = BlockKind.If;
        b.control = cond.id;

        b.setSucc(0, then_block);
        b.setSucc(1, else_block);

        let then_b: *Block = self.getBlock(then_block);
        let else_b: *Block = self.getBlock(else_block);
        then_b.addPred(self.current_block);
        else_b.addPred(self.current_block);
    }

    // Set up an unconditional jump
    fn emitJump(self: *Func, target: i64) {
        debug.log_dd(DebugPhase.ssa, "Func.emitJump: from={d} to={d}", self.current_block, target);
        let b: *Block = self.getBlock(self.current_block);
        b.kind = BlockKind.Plain;
        b.addSucc(target);

        let target_b: *Block = self.getBlock(target);
        target_b.addPred(self.current_block);
    }

    // Mark current block as return block
    fn emitReturnBlock(self: *Func) {
        debug.log_d(DebugPhase.ssa, "Func.emitReturnBlock: block={d}", self.current_block);
        let b: *Block = self.getBlock(self.current_block);
        b.kind = BlockKind.Return;
    }
}

// ============================================================================
// Inline Tests
// ============================================================================

test "Local_create initializes fields" {
    var loc: Local = Local_create(0, 5, 2, true)
    @assert(loc.name_start == 0)
    @assert(loc.name_len == 5)
    @assert(loc.type_idx == 2)
    @assert(loc.is_mutable)
    @assert(!loc.is_param)
    @assert(loc.size == 8)
    @assert(loc.align == 8)
}

test "Local_createParam sets is_param" {
    var loc: Local = Local_createParam(10, 3, 1, 0)
    @assert(loc.name_start == 10)
    @assert(loc.name_len == 3)
    @assert(loc.type_idx == 1)
    @assert(loc.is_param)
    @assert(loc.param_idx == 0)
}

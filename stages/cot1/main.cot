// Cot1 Self-Hosting Compiler
// Full pipeline: Source → Scanner → Parser → Lowerer → SSA → genssa → Mach-O
//
// Usage: cot0 <source.cot> -o <output>

// ============================================================================
// Syscall Externs - MUST come before any imports that use them
// ============================================================================

// System calls
extern fn open(path: *u8, flags: i32, mode: i32) i32;
extern fn read(fd: i32, buf: *u8, count: i64) i64;
extern fn close(fd: i32) i32;
extern fn lseek(fd: i32, offset: i64, whence: i32) i64;

// Crash handler from cot_runtime
extern fn install_crash_handler();

// ============================================================================
// Library Imports
// ============================================================================

// Standard library - print, println, write
import "lib/stdlib.cot"

// Error infrastructure - panic, assert, bounds checks
import "lib/error.cot"

// Safe file I/O wrappers - validates parameters, tracks file descriptors
import "lib/safe_io.cot"

// Safe array access - bounds checking, null checks
import "lib/safe_array.cot"

// Type/Kind validation helpers - NodeKind_name, IRNodeKind_name, assert_* functions
import "lib/validate.cot"

// Debug tracing infrastructure - phase tracking, checkpoints, hexdump
import "lib/debug.cot"

// Debug initialization - command-line parsing and startup/shutdown
import "lib/debug_init.cot"

// Import processing - path tracking, resolution, cycle detection
import "lib/import.cot"

// Source position tracking - Pos, Span, Source, Position
import "lib/source.cot"

// Error reporter - accumulates multiple errors without immediate panic
import "lib/reporter.cot"

// ============================================================================
// Compiler Module Imports
// ============================================================================

// Frontend modules - import in specific order (required for compatibility)
import "frontend/token.cot"
import "frontend/scanner.cot"
import "frontend/types.cot"
import "frontend/ast.cot"
import "frontend/parser.cot"
import "frontend/checker.cot"
import "frontend/lower.cot"

// Codegen - genssa.cot imports ../ssa/func.cot transitively
import "codegen/genssa.cot"

// SSA Builder - IR to SSA conversion (matches Zig's ssa_builder.zig)
// Must be imported AFTER genssa.cot to avoid duplicate func.cot imports
import "ssa/builder.cot"
import "ssa/passes/expand_calls.cot"
import "ssa/passes/lower.cot"
import "ssa/passes/decompose.cot"
import "ssa/passes/schedule.cot"
import "ssa/passes/deadcode.cot"
import "ssa/passes/copyelim.cot"
import "ssa/passes/cse.cot"
import "ssa/liveness.cot"
import "ssa/regalloc.cot"

// SSA pass infrastructure and debugging
import "ssa/compile.cot"
import "ssa/debug.cot"

// Object file writer
import "obj/macho.cot"

// Typed malloc externs (MUST come after struct definitions in imports)
extern fn malloc_Node(count: i64) *Node;
extern fn malloc_Type(count: i64) *Type;
extern fn malloc_FieldInfo(count: i64) *FieldInfo;
extern fn malloc_IRNode(count: i64) *IRNode;
extern fn malloc_IRLocal(count: i64) *IRLocal;
extern fn malloc_IRFunc(count: i64) *IRFunc;
extern fn malloc_ConstEntry(count: i64) *ConstEntry;
extern fn malloc_IRGlobal(count: i64) *IRGlobal;
extern fn malloc_Block(count: i64) *Block;
extern fn malloc_Value(count: i64) *Value;
extern fn malloc_Local(count: i64) *Local;
extern fn malloc_Branch(count: i64) *Branch;
extern fn malloc_CallSite(count: i64) *CallSite;
// malloc_i64 is provided by lib/list.cot (imported via ast.cot, types.cot, etc.)
extern fn malloc_FuncAddrReloc(count: i64) *FuncAddrReloc;
extern fn malloc_StringReloc(count: i64) *StringReloc;
extern fn malloc_Symbol(count: i64) *Symbol;
extern fn malloc_Reloc(count: i64) *Reloc;
extern fn malloc_BlockDefs(count: i64) *BlockDefs;
extern fn malloc_BlockMapping(count: i64) *BlockMapping;
extern fn malloc_VarDef(count: i64) *VarDef;
extern fn malloc_TypeAliasEntry(count: i64) *TypeAliasEntry;
// Regalloc structs (liveness uses its own extern declarations)
extern fn malloc_ValState(count: i64) *ValState;
extern fn malloc_RegState(count: i64) *RegState;
// Type checker structs
extern fn malloc_Scope(count: i64) *Scope;
extern fn malloc_CheckerSymbol(count: i64) *CheckerSymbol;

// File flags now provided by lib/safe_io.cot
// O_RDONLY, O_WRONLY, O_CREAT, O_TRUNC defined there
const FILE_MODE: i32 = 420;  // 0o644

// ============================================================================
// Global Buffers - Use MAIN_ prefix to avoid conflicts with imported modules
// Note: MAX_NODES and MAX_CHILDREN are defined in ast.cot
// ============================================================================

// Source buffer - dynamically allocated
var g_source: *u8 = null;
var g_source_len: i64 = 0;
var g_source_cap: i64 = 0;

// Source file path (for debug info)
var g_source_path: *u8 = null;
var g_source_path_len: i64 = 0;

const INIT_OUTPUT_PATH: i64 = 256;
var g_output_path: *u8 = null;
var g_output_path_cap: i64 = 0;
var g_output_path_len: i64 = 0;

// Test mode flag - set by -test CLI argument
var g_test_mode: i64 = 0;

// AST storage - nodes are fixed array, children are dynamic
var g_nodes: *Node = null;
var g_nodes_cap: i64 = 0;
var g_pool: NodePool;       // children list is inside, initialized dynamically

// Type pool storage
// Type pool - storage now self-allocated inside types.cot module
var g_type_pool: TypeRegistry;

// IR storage - initial capacities (grow dynamically via realloc)
// Note: These need to be large enough to avoid realloc during lowering,
// since FuncBuilder stores direct pointers into these arrays
const INIT_IR_NODES: i64 = 100000;
const INIT_IR_LOCALS: i64 = 50000;
const INIT_IR_FUNCS: i64 = 1024;
const INIT_CONSTANTS: i64 = 2048;
// MAIN_MAX_CALL_ARGS removed - args stored in IRNode.call_args
var g_ir_nodes: *IRNode = null;
var g_ir_nodes_cap: i64 = 0;
var g_ir_locals: *IRLocal = null;
var g_ir_locals_cap: i64 = 0;
var g_ir_funcs: *IRFunc = null;
var g_ir_funcs_cap: i64 = 0;
var g_constants: *ConstEntry = null;
var g_constants_cap: i64 = 0;
// g_call_args removed - call args now stored directly in IRNode.call_args (matches Zig)

// Defer stack, type aliases, label stack now self-allocated by Lowerer (lower.cot)

// Global variable storage - dynamic growth
const INIT_IR_GLOBALS: i64 = 512;
var g_ir_globals: *IRGlobal = null;
var g_ir_globals_cap: i64 = 0;

// SSA storage (blocks, values, locals) now self-allocated by Func (func.cot)

// Liveness analysis - uses dynamic allocation internally (no globals needed)
// Reference: src/ssa/liveness.zig

// Register allocation storage now self-allocated by RegAlloc (regalloc.cot)

// Type checker storage - per compilation
// Reference: src/frontend/checker.zig
const INIT_SCOPES: i64 = 512;             // Max nested scopes
const INIT_CHECKER_SYMBOLS: i64 = 10000;  // Max symbols across all scopes
var g_scopes: *Scope = null;
var g_scopes_cap: i64 = 0;
var g_checker_symbols: *CheckerSymbol = null;
var g_checker_symbols_cap: i64 = 0;

// Mach-O storage - now allocated by macho.cot (MachOWriter_init)

// IR to SSA mapping (IR node index -> SSA value ID)
var g_ir_to_ssa_id: *i64 = null;
var g_ir_to_ssa_id_cap: i64 = 0;

// Local variable to SSA value mapping (local index -> SSA value ID)
var g_local_to_ssa_id: *i64 = null;
var g_local_to_ssa_id_cap: i64 = 0;

// SSABuilder storage - now self-allocated by builder.cot module

// Import tracking, base directory, path buffer - now handled by lib/import.cot
// Import_init() allocates storage and tracks state internally

// ============================================================================
// Driver Struct (matching src/driver.zig)
// ============================================================================

struct Driver {
    // In cot0, we use global state instead of allocator
    // These fields track compilation state
    source_ptr: *u8,
    source_len: i64,
    output_path: *u8,
    output_path_len: i64,
}

fn Driver_init() Driver {
    var d: Driver = undefined;
    d.source_ptr = g_source;
    d.source_len = 0;
    d.output_path = g_output_path;
    d.output_path_len = 0;
    return d;
}

// Compile source text directly (matches src/driver.zig compileSource)
// Note: In cot0, this is a thin wrapper since we use global state
fn Driver_compileSource(source: string, out_path: *u8, out_path_len: i64) i64 {
    return Driver_compileFile(source, out_path, out_path_len);
}

// Set debug phases for verbose output (matches src/driver.zig setDebugPhases)
// Note: In cot0, debug is controlled via print statements - stub for API parity
fn Driver_setDebugPhases(phases: *u8, phases_len: i64) {
    // TODO: Parse phases string and enable selective debug output
    // For now, this is a no-op - cot0 uses unconditional print statements
}

// ============================================================================
// Helper Functions
// ============================================================================

// NOTE: ir_op_to_ssa_op and ir_unary_op_to_ssa_op are now in ssa/builder.cot

// print(s) and println(s) are built-in functions that handle both strings and integers

// ============================================================================
// File I/O
// ============================================================================

fn read_file(path: *u8) i64 {
    // Use safe_io wrappers - validates parameters and provides clear errors
    let fd: i32 = safe_open_read(path, "read_file".ptr);
    g_source_len = safe_read_all(fd, g_source, g_source_cap - 1, "read_file".ptr);
    safe_close(fd, "read_file".ptr);

    let src_end: *u8 = g_source + g_source_len;
    src_end.* = 0;
    return g_source_len;
}

fn write_file(path: *u8, data: *u8, data_len: i64) i64 {
    // Use safe_io wrappers - validates parameters and provides clear errors
    let fd: i32 = safe_open_write(path, "write_file".ptr);
    safe_write_all(fd, data, data_len, "write_file".ptr);
    safe_close(fd, "write_file".ptr);
    return data_len;
}

// ============================================================================
// Pool Initialization
// ============================================================================

fn init_node_pool() *NodePool {
    g_pool.nodes = g_nodes;
    g_pool.count = 0;
    g_pool.capacity = g_nodes_cap;  // Set capacity from allocated size
    i64list_init(&g_pool.children);  // Dynamic list - grows as needed
    return &g_pool;
}

// ============================================================================
// Import Processing - Uses lib/import.cot for path tracking and resolution
// ============================================================================

// Read and parse an imported file, recursively processing its imports
// base_dir: directory of the file containing the import statement
// Returns number of new nodes (including from recursive imports)
fn parse_import_file_with_dir(import_path: *u8, import_path_len: i64, pool: *NodePool,
                               base_dir: *u8, base_dir_len: i64) i64 {
    // Resolve the import path relative to base_dir, handling ".."
    let full_path_len: i64 = Import_resolvePath(base_dir, base_dir_len, import_path, import_path_len);
    let path_buf: *u8 = Import_getPathBuf();

    // Check if already imported
    if Import_isPathImported(path_buf, full_path_len) {
        return 0;  // Already imported, skip
    }

    // Mark as imported
    Import_addPath(path_buf, full_path_len);

    // Get the directory of this imported file (for resolving its imports)
    var this_file_dir: U8List = undefined;
    u8list_init_cap(&this_file_dir, 256);
    // Null check - malloc_u8 could fail
    if this_file_dir.items == null {
        print("  Warning: Failed to allocate directory buffer for import\n");
        return 0;
    }
    let this_file_dir_len: i64 = Import_getDirFromPath(path_buf, full_path_len,
                                                        this_file_dir.items, this_file_dir.capacity);

    // Read the file - append to existing source
    let fd: i32 = open(path_buf, O_RDONLY, 0);
    if fd < 0 {
        print("  Warning: Cannot open import: ");
        write(1, path_buf, full_path_len);
        print("\n");
        return 0;  // Non-fatal, continue with other imports
    }

    let start_offset: i64 = g_source_len;
    let bytes_read: i64 = read(fd, g_source + g_source_len, g_source_cap - g_source_len - 1);
    close(fd);

    if bytes_read < 0 {
        print("  Warning: Cannot read import: ");
        write(1, path_buf, full_path_len);
        print(" (base_dir: ");
        write(1, base_dir, base_dir_len);
        print(")\n");
        return 0;
    }

    g_source_len = g_source_len + bytes_read;
    let src_end2: *u8 = g_source + g_source_len;
    src_end2.* = 0;

    // Parse the imported file
    let import_source: string = @string(g_source + start_offset, bytes_read);

    let nodes_before: i64 = pool.count;
    var parser: Parser = Parser_init(import_source, pool, &g_type_pool);
    parser.parseFile();

    if parser.hadError() {
        print("  Warning: Parse error in import\n");
    }

    // Adjust positions in new nodes to be absolute in g_source
    let direct_new_nodes: i64 = pool.count - nodes_before;
    if direct_new_nodes > 0 {
        Import_adjustNodePositions(pool, nodes_before, pool.count, start_offset);
    }

    // Recursively process imports in the newly parsed file
    var total_new_nodes: i64 = direct_new_nodes;
    var i: i64 = nodes_before;
    while i < nodes_before + direct_new_nodes {
        let node: *Node = pool.nodes + i;
        if node.kind == NodeKind.ImportDecl {
            // field0 = path_start (already adjusted), field1 = path_len
            let nested_path: *u8 = g_source + node.field0;
            let nested_path_len: i64 = node.field1;

            let nested_nodes: i64 = parse_import_file_with_dir(nested_path, nested_path_len, pool,
                                                                this_file_dir.items, this_file_dir_len);
            if nested_nodes > 0 {
                print("  Imported: ");
                write(1, nested_path, nested_path_len);
                print(" (");
                print(nested_nodes);
                print(" nodes)\n");
                total_new_nodes = total_new_nodes + nested_nodes;
            }
        }
        i = i + 1;
    }

    u8list_deinit(&this_file_dir);
    return total_new_nodes;
}

// Legacy wrapper for backward compatibility (uses Import module's base_dir)
fn parse_import_file(import_path: *u8, import_path_len: i64, pool: *NodePool) i64 {
    return parse_import_file_with_dir(import_path, import_path_len, pool,
                                       Import_getBaseDir(), Import_getBaseDirLen());
}

// Process all imports in the parsed AST (matches src/driver.zig parseFileRecursive)
fn Driver_parseFileRecursive(pool: *NodePool, main_file_nodes: i64) {
    var i: i64 = 0;
    while i < main_file_nodes {
        let node: *Node = pool.nodes + i;
        if node.kind == NodeKind.ImportDecl {
            let path_start: i64 = node.field0;
            let path_len: i64 = node.field1;
            let import_path: *u8 = g_source + path_start;

            let new_nodes: i64 = parse_import_file(import_path, path_len, pool);
            if new_nodes > 0 {
                print("  Imported: ");
                write(1, import_path, path_len);
                print(" (");
                print(new_nodes);
                print(" nodes)\n");
            }
        }
        i = i + 1;
    }
}

// ============================================================================
// Compilation Pipeline
// ============================================================================

fn Driver_compileFile(source: string, out_path: *u8, out_path_len: i64) i64 {
    let t_start: i64 = get_time_ns();
    var t_phase: i64 = t_start;
    var t_now: i64 = 0;

    print("Phase 1: Scanning...\n");

    // Phase 1: Scan and count tokens
    var scanner: Scanner = Scanner_init(source);
    var tok_count: i64 = 0;
    var tok: Token = scanner.next();
    while tok.kind != TokenType.Eof {
        tok_count = tok_count + 1;
        tok = scanner.next();
    }
    print("  Tokens: ");
    print(tok_count);
    print("\n");

    // Initialize type registry (needed for parser) - self-allocates storage
    g_type_pool.init();

    t_now = get_time_ns();
    print("  [Phase 1 time: "); print((t_now - t_phase) / 1000000); print("ms]\n");
    t_phase = t_now;

    // Phase 2: Parse
    print("Phase 2: Parsing...\n");
    let pool: *NodePool = init_node_pool();
    var parser: Parser = Parser_init(source, pool, &g_type_pool);
    let file_node: i64 = parser.parseFile();

    if parser.hadError() {
        print("  FAIL: Parser error at position ");
        print(parser.scanner.pos);
        print("\n");
        return 1;
    }

    print("  Nodes: ");
    print(pool.count);
    print(", Children: ");
    print(pool.children.count);
    print("\n");

    // Save main file node count before imports are added
    let main_file_nodes: i64 = pool.count;

    t_now = get_time_ns();
    print("  [Phase 2 time: "); print((t_now - t_phase) / 1000000); print("ms]\n");
    t_phase = t_now;

    // Phase 2.5: Process imports
    print("Phase 2.5: Processing imports...\n");
    Driver_parseFileRecursive(pool, main_file_nodes);
    print("  Total nodes after imports: ");
    print(pool.count);
    print(", Children: ");
    print(pool.children.count);
    print("\n");

    t_now = get_time_ns();
    print("  [Phase 2.5 time: "); print((t_now - t_phase) / 1000000); print("ms]\n");
    t_phase = t_now;

    // Phase 2.6: Type check
    // Following Zig: driver.zig creates Checker for each file, runs checkFile
    print("Phase 2.6: Type checking...\n");

    var scope_pool: ScopePool = undefined;
    scope_pool.scopes = g_scopes;
    scope_pool.symbols = g_checker_symbols;
    scope_pool.init();

    var checker: Checker = undefined;
    checker.init(&g_type_pool, &scope_pool, pool, g_source);
    checker.checkFile();

    if not checker.ok() {
        print("  FAIL: Type check errors: ");
        print(checker.errors());
        print("\n");
        return 1;
    }
    print("  Type check OK\n");

    t_now = get_time_ns();
    print("  [Phase 2.6 time: "); print((t_now - t_phase) / 1000000); print("ms]\n");
    t_phase = t_now;

    // Phase 3: Lower to IR
    print("Phase 3: Lowering to IR...\n");

    // Update type registry source to combined source buffer (after imports)
    g_type_pool.setSource(g_source, g_source_len);

    var lowerer: Lowerer = undefined;
    lowerer.init(
                 g_nodes, pool.count,
                 pool.children.items, pool.children.count,
                 g_source, g_source_len,
                 &g_type_pool,
                 g_ir_nodes, g_ir_nodes_cap,
                 g_ir_locals, g_ir_locals_cap,
                 g_ir_funcs, g_ir_funcs_cap,
                 g_constants, g_constants_cap);
    // Lowerer now self-allocates: defer_stack, type_aliases, label_stack
    lowerer.setGlobals(g_ir_globals, g_ir_globals_cap);

    // Enable test mode if -test flag was passed
    if g_test_mode != 0 {
        lowerer.setTestMode(1);
    }

    let ir_count: i64 = lowerer.lowerAll();

    // Sync globals from Lowerer after potential reallocations
    g_ir_nodes = lowerer.ir_nodes;
    g_ir_nodes_cap = lowerer.ir_nodes_cap;
    g_ir_locals = lowerer.ir_locals;
    g_ir_locals_cap = lowerer.ir_locals_cap;
    g_ir_funcs = lowerer.ir_funcs;
    g_ir_funcs_cap = lowerer.ir_funcs_cap;
    g_ir_globals = lowerer.ir_globals;
    g_ir_globals_cap = lowerer.ir_globals_cap;
    g_constants = lowerer.constants;
    g_constants_cap = lowerer.constants_cap;

    // Fix up synthesized function names (test functions have offset markers)
    if g_test_mode != 0 {
        lowerer.fixupSynthNames();
    }

    print("  IR nodes: ");
    print(ir_count);
    print(", Functions: ");
    print(lowerer.ir_funcs_count);
    print(", Globals: ");
    print(lowerer.ir_globals_count);
    print("\n");

    t_now = get_time_ns();
    print("  [Phase 3 time: "); print((t_now - t_phase) / 1000000); print("ms]\n");
    t_phase = t_now;

    // Phase 4 & 5: Build SSA and generate code for each function
    print("Phase 4/5: Building SSA and generating code...\n");

    // Initialize code generator state (shared across functions)
    // GenState now self-allocates its storage (following Zig pattern)
    var gs: GenState = undefined;
    gs.init();

    // Set source for DWARF debug info line tracking
    gs.setSource(g_source, g_source_len);

    // Set up globals for codegen (uses lowerer's registered globals)
    gs.setGlobals(g_ir_globals, lowerer.ir_globals_count);

    // BUG-054: Set type registry for hidden return detection at call sites
    gs.setTypeRegistry(&g_type_pool);

    var total_blocks: i64 = 0;
    var total_values: i64 = 0;

    // Timing accumulators for Phase 4/5 breakdown
    var t_build: i64 = 0;
    var t_passes: i64 = 0;
    var t_liveness: i64 = 0;
    var t_regalloc: i64 = 0;
    var t_codegen: i64 = 0;
    var t_tmp: i64 = 0;

    // Process each function
    // Defensive check: ensure g_ir_funcs is valid
    if g_ir_funcs == null {
        print("FATAL: g_ir_funcs is NULL! lowerer.ir_funcs=");
        print(@ptrToInt(lowerer.ir_funcs));
        print(" count=");
        print(lowerer.ir_funcs_count);
        print("\n");
        return 1;
    }

    var func_idx: i64 = 0;
    while func_idx < lowerer.ir_funcs_count {
        let ir_func: *IRFunc = g_ir_funcs + (func_idx);

        // Record code offset for this function
        ir_func.code_offset = gs.code_count;

        // Initialize SSA function (self-allocates storage)
        var ssa_func: Func = undefined;
        ssa_func.init(ir_func.name_start, ir_func.name_len, ir_func.return_type);

        // BUG-054: Compute return type size for hidden return detection
        // Following Zig: src/codegen/arm64.zig:493-522
        let ret_type_size: i64 = g_type_pool.sizeof(ir_func.return_type);
        ssa_func.setReturnTypeSize(ret_type_size);

        // ==================================================================
        // IR to SSA Conversion using SSABuilder
        // Matches Zig's ssa_builder.zig structure
        // ==================================================================

        // Initialize SSA builder (self-allocates storage)
        var builder: SSABuilder = undefined;
        builder.init(&ssa_func);

        // Set IR references for this function (split to avoid >8 args)
        builder.setIRNodes(
                         g_ir_nodes, ir_func.nodes_start, ir_func.nodes_count);
        builder.setIRLocals(
                         g_ir_locals, ir_func.locals_start, ir_func.locals_count);
        builder.setSource(g_source, g_source_len);
        builder.setTypeRegistry(&g_type_pool);

        // Build SSA from IR (handles blocks, locals, params, conversion)
        t_tmp = get_time_ns();
        let build_result: i64 = builder.build();
        t_build = t_build + (get_time_ns() - t_tmp);

        // Run expand_calls pass - handle >16B struct args and decompose aggregates
        // Reference: driver.zig Phase 4a.5: expand_calls
        t_tmp = get_time_ns();
        expandCalls(&ssa_func, &g_type_pool);
        decompose(&ssa_func, &g_type_pool);
        earlyDeadcode(&ssa_func);
        copyelim(&ssa_func);
        cse(&ssa_func);
        lower(&ssa_func);
        schedule(&ssa_func);
        t_passes = t_passes + (get_time_ns() - t_tmp);

        // Run liveness analysis - compute use distances for regalloc spill selection
        // Reference: src/ssa/liveness.zig, driver.zig Phase 4c
        t_tmp = get_time_ns();
        var live_map: LiveMap = undefined;
        live_map.init();
        var liveness_result: LivenessResult = undefined;
        liveness_result.init();
        Liveness_compute(&liveness_result, &ssa_func, &live_map);
        t_liveness = t_liveness + (get_time_ns() - t_tmp);

        // Run register allocation - assign physical registers to SSA values
        // Reference: src/ssa/regalloc.zig, driver.zig Phase 4c
        t_tmp = get_time_ns();
        var regalloc_state: RegAllocState = undefined;
        regalloc_state.init(&ssa_func, &liveness_result);
        regalloc_state.run(&ssa_func);
        t_regalloc = t_regalloc + (get_time_ns() - t_tmp);

        // Compute stack layout using StackAlloc pass
        // This assigns offsets to locals and computes frame_size with 16-byte alignment
        let stack_result: StackAllocResult = StackAlloc_run(&ssa_func);

        // Compute dominator tree for the function
        // This sets b.dom (immediate dominator) and b.dom_level (depth) for each block
        var dom_tree: DomTree = undefined;
        dom_tree.init();
        dom_tree.compute(&ssa_func);
        dom_tree.deinit();

        total_blocks = total_blocks + ssa_func.blocks_count;
        total_values = total_values + ssa_func.values_count;

        // Generate code for this function
        // Following Zig compiler pattern (src/codegen/arm64.zig:461-462):
        // Clear branch fixups at start of each function
        t_tmp = get_time_ns();
        gs.func = &ssa_func;
        gs.branches_count = 0;  // Reset branches for this function

        let genssa_result: i64 = gs.generate();
        t_codegen = t_codegen + (get_time_ns() - t_tmp);
        if genssa_result != 0 {
            print("  FAIL: genssa error\n");
            return 2;
        }


        func_idx = func_idx + 1;
    }

    // Print Phase 4/5 timing breakdown
    print("  [Timing: build="); print(t_build / 1000000);
    print("ms, passes="); print(t_passes / 1000000);
    print("ms, liveness="); print(t_liveness / 1000000);
    print("ms, regalloc="); print(t_regalloc / 1000000);
    print("ms, codegen="); print(t_codegen / 1000000);
    print("ms]\n");
    GenState_printTiming();

    print("  Total blocks: ");
    print(total_blocks);
    print(", Total values: ");
    print(total_values);
    print(", Code bytes: ");
    print(gs.code_count);
    print(", Call sites: ");
    print(gs.call_sites_count);
    print(", Global relocs: ");
    print(gs.global_relocs_count);
    print("\n");

    t_now = get_time_ns();
    print("  [Phase 4/5 time: "); print((t_now - t_phase) / 1000000); print("ms]\n");
    t_phase = t_now;

    // Phase 6: Finalize - Create Mach-O object
    // Following Zig: ARM64CodeGen.finalize() pattern
    print("Phase 6: Creating Mach-O object...\n");

    var writer: MachOWriter = undefined;
    writer.init(gs.code, gs.code_count, gs.data, gs.data_cap);

    // GenState_finalize handles:
    // - Resolving internal call sites (patching BL instructions)
    // - Adding function symbols
    // - Adding external call relocations
    // - Adding crash handler relocation
    // - Adding global variable symbols and data
    // - Adding global address relocations
    // - Adding function address relocations
    // - Adding string literal data and relocations
    // - Generating DWARF debug info
    let finalize_result: i64 = gs.finalize(
        g_source, g_source_len,
        g_ir_funcs, lowerer.ir_funcs_count,
        g_ir_globals, lowerer.ir_globals_count,
        g_source_path, g_source_path_len,
        &writer
    );

    if finalize_result != 0 {
        return finalize_result;
    }

    // Write Mach-O with debug info
    let macho_bytes: i64 = writer.writeWithDebug();
    print("  Mach-O bytes: ");
    print(macho_bytes);
    print("\n");

    t_now = get_time_ns();
    print("  [Phase 6 time: "); print((t_now - t_phase) / 1000000); print("ms]\n");
    t_phase = t_now;

    // Phase 7: Write to output file
    print("Phase 7: Writing output...\n");

    if out_path_len > 0 {
        let written: i64 = write_file(out_path, writer.output, macho_bytes);
        if written < 0 {
            return 3;
        }
        print("  Wrote ");
        print(written);
        print(" bytes\n");
    } else {
        print("  (No output path specified, skipping write)\n");
    }

    t_now = get_time_ns();
    print("  [Phase 7 time: "); print((t_now - t_phase) / 1000000); print("ms]\n");
    print("\n  [TOTAL time: "); print((t_now - t_start) / 1000000); print("ms]\n");

    return 0;
}

// ============================================================================
// Command Line Parsing
// ============================================================================

// Get string length (null-terminated) - uses safe_strlen with max limit
fn strlen(s: *u8) i64 {
    // Use safe_strlen with 64KB max to prevent infinite loops on bad strings
    return safe_strlen(s, 65536, "strlen".ptr);
}

// Compare two strings for equality
fn streq(a: *u8, b: *u8) bool {
    var pa: *u8 = a;
    var pb: *u8 = b;
    while pa.* != 0 and pb.* != 0 {
        if pa.* != pb.* {
            return false;
        }
        pa = pa + 1;
        pb = pb + 1;
    }
    return pa.* == pb.*;
}

// Copy string to buffer, return length
fn strcpy(dest: *u8, src: *u8, max_len: i64) i64 {
    var i: i64 = 0;
    var src_ptr: *u8 = src;
    var dst_ptr: *u8 = dest;
    while src_ptr.* != 0 and i < max_len - 1 {
        dst_ptr.* = src_ptr.*;
        src_ptr = src_ptr + 1;
        dst_ptr = dst_ptr + 1;
        i = i + 1;
    }
    dst_ptr.* = 0;  // Null terminate
    return i;
}

fn print_usage() {
    print("Usage: cot0 [-test] <source.cot> -o <output>\n");
    print("\n");
    print("  -test         Compile and run inline tests\n");
    print("  <source.cot>  Input Cot source file\n");
    print("  -o <output>   Output object file\n");
}

// ============================================================================
// Main Entry Point
// ============================================================================

fn main(argc: i64, argv: **u8) i64 {
    // Install crash handler FIRST - before anything else
    install_crash_handler();

    print("Cot1 Self-Hosting Compiler v0.2\n");
    print("================================\n\n");

    // Initialize debug infrastructure - parses -d, -v, -t, --debug-* flags
    debug_startup(argc, argv);

    // Allocate ALL dynamic buffers - NO STATIC ARRAYS

    // Byte buffers - 4MB for source (cot1 needs ~1.5MB total)
    g_source_cap = 4194304;
    g_source = malloc_u8(g_source_cap);
    // g_code, g_data, g_line_entries now allocated by genssa.cot
    // g_output, g_strings, g_debug_line/abbrev/info now allocated by macho.cot
    g_output_path_cap = 256;
    g_output_path = malloc_u8(g_output_path_cap);
    // Import tracking buffers now self-allocated by lib/import.cot (Import_init)

    // AST storage - needs ~107K for self-hosting
    g_nodes_cap = 200000;
    g_nodes = malloc_Node(g_nodes_cap);

    // Type storage - now self-allocated inside types.cot module via TypeRegistry_init()

    // IR storage - dynamic growth
    g_ir_nodes_cap = INIT_IR_NODES;
    g_ir_nodes = malloc_IRNode(g_ir_nodes_cap);
    g_ir_locals_cap = INIT_IR_LOCALS;
    g_ir_locals = malloc_IRLocal(g_ir_locals_cap);
    g_ir_funcs_cap = INIT_IR_FUNCS;
    g_ir_funcs = malloc_IRFunc(g_ir_funcs_cap);
    g_constants_cap = INIT_CONSTANTS;
    g_constants = malloc_ConstEntry(g_constants_cap);
    g_ir_globals_cap = INIT_IR_GLOBALS;
    g_ir_globals = malloc_IRGlobal(g_ir_globals_cap);

    // Type alias storage now self-allocated by Lowerer (lower.cot)
    // SSA storage (blocks, values, locals) now self-allocated by Func (func.cot)

    // Liveness analysis - uses dynamic allocation internally (no pre-allocation needed)
    // Register allocation storage now self-allocated by RegAlloc (regalloc.cot)

    // Type checker storage
    g_scopes_cap = INIT_SCOPES;
    g_scopes = malloc_Scope(g_scopes_cap);
    g_checker_symbols_cap = INIT_CHECKER_SYMBOLS;
    g_checker_symbols = malloc_CheckerSymbol(g_checker_symbols_cap);

    // Codegen storage - now allocated by genssa.cot (GenState_init)
    // Mach-O storage - now allocated by macho.cot (MachOWriter_init)
    // SSABuilder storage - now allocated by builder.cot (SSABuilder_init)

    // i64 arrays
    // g_type_params now allocated by types.cot module via TypeRegistry_init()
    // g_call_args removed - args stored in IRNode.call_args
    // defer_stack, label_stack now self-allocated by Lowerer (lower.cot)
    // g_bstart now allocated by genssa.cot
    g_ir_to_ssa_id_cap = 50000;
    g_ir_to_ssa_id = malloc_i64(g_ir_to_ssa_id_cap);
    g_local_to_ssa_id_cap = 5000;
    g_local_to_ssa_id = malloc_i64(g_local_to_ssa_id_cap);
    // g_import_path_lens now self-allocated by lib/import.cot

    // Parse command line arguments
    // Expected: cot0 [-test] <source.cot> -o <output>

    // Check for -test flag first
    var arg_offset: i64 = 0;

    if argc >= 2 {
        let argv_ptr1: **u8 = argv + 1;
        let first_arg: *u8 = argv_ptr1.*;
        // Check if first arg is "-test"
        if first_arg.* == 45 {   // '-'
            if (first_arg + 1).* == 116 {  // 't'
                if (first_arg + 2).* == 101 {  // 'e'
                    if (first_arg + 3).* == 115 {  // 's'
                        if (first_arg + 4).* == 116 {  // 't'
                            if (first_arg + 5).* == 0 {  // null terminator
                                g_test_mode = 1;
                                arg_offset = 1;
                                print("Test mode enabled\n");
                            }
                        }
                    }
                }
            }
        }
    }

    let required_args: i64 = 4 + arg_offset;
    if argc < required_args {
        print("Error: Not enough arguments\n\n");
        print_usage();
        return 1;
    }

    // Get source file path (argv[1] or argv[2] if -test)
    let argv_src: **u8 = argv + 1 + arg_offset;
    let source_path: *u8 = argv_src.*;

    // Check for -o flag (argv[2] or argv[3] if -test)
    let argv_flag: **u8 = argv + 2 + arg_offset;
    let flag: *u8 = argv_flag.*;

    // Build expected flag string
    var dash_o: [3]u8;
    dash_o[0] = 45;  // '-'
    dash_o[1] = 111; // 'o'
    dash_o[2] = 0;

    if !streq(flag, &dash_o[0]) {
        print("Error: Expected -o flag\n\n");
        print_usage();
        return 1;
    }

    // Get output path (argv[3] or argv[4] if -test)
    let argv_out: **u8 = argv + 3 + arg_offset;
    let output_path: *u8 = argv_out.*;
    let output_len: i64 = strlen(output_path);

    // Copy output path to global buffer (for null-termination)
    g_output_path_len = strcpy(g_output_path, output_path, INIT_OUTPUT_PATH);

    // Read source file
    print("Reading: ");
    var source_ptr: *u8 = source_path;
    while source_ptr.* != 0 {
        write(1, source_ptr, 1);
        source_ptr = source_ptr + 1;
    }
    print("\n");

    let bytes_read: i64 = read_file(source_path);
    if bytes_read < 0 {
        return 1;
    }

    print("  Read ");
    print(bytes_read);
    print(" bytes\n\n");

    // Initialize import tracking and extract base directory
    let source_path_len: i64 = strlen(source_path);
    Import_init();
    Import_extractBaseDir(source_path, source_path_len);

    // Store source path globally for debug info
    g_source_path = source_path;
    g_source_path_len = source_path_len;

    // Create string view of source
    let source: string = @string(g_source, g_source_len);

    let result: i64 = Driver_compileFile(source, g_output_path, g_output_path_len);

    if result == 0 {
        print("\nCompilation successful!\n");
    } else {
        print("\nCompilation failed with code ");
        print(result);
        print("\n");
    }

    // Print debug summary if verbose mode was enabled
    debug_shutdown();

    return result;
}

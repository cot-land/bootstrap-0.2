// macho_writer_test.cot - Tests for MachO writer
// Run with: ./zig-out/bin/cot cot0/obj/macho_writer_test.cot -o /tmp/macho_writer_test && /tmp/macho_writer_test

import "macho.cot"
import "../codegen/arm64.cot"
import "../lib/stdlib.cot"

// Storage buffers for MachOWriter
var g_code: [4096]u8;
var g_data: [4096]u8;
var g_symbols: [100]Symbol;
var g_strings: [4096]u8;
var g_relocs: [100]Reloc;
var g_output: [65536]u8;

fn main() i64 {
    print("MachO Writer Test\n");
    print("=================\n\n");

    let r1: i64 = test_writer_init();
    if r1 != 0 { return r1; }

    let r2: i64 = test_add_code();
    if r2 != 0 { return r2; }

    let r3: i64 = test_add_symbol();
    if r3 != 0 { return r3; }

    let r4: i64 = test_write_macho();
    if r4 != 0 { return r4; }

    print("\nAll MachO writer tests passed!\n");
    return 0;
}

fn test_writer_init() i64 {
    print("Test: writer_init - ");

    var w: MachOWriter = undefined;
    macho_writer_init(&w,
                      &g_code[0], 4096,
                      &g_data[0], 4096,
                      &g_symbols[0], 100,
                      &g_strings[0], 4096,
                      &g_relocs[0], 100,
                      &g_output[0], 65536);

    if w.code_count != 0 { print("FAIL (code_count)\n"); return 1; }
    if w.symbols_count != 0 { print("FAIL (symbols_count)\n"); return 2; }
    if w.strings_count != 1 { print("FAIL (strings_count should be 1)\n"); return 3; }
    if w.output_count != 0 { print("FAIL (output_count)\n"); return 4; }

    print("PASS\n");
    return 0;
}

fn test_add_code() i64 {
    print("Test: add_code - ");

    var w: MachOWriter = undefined;
    macho_writer_init(&w,
                      &g_code[0], 4096,
                      &g_data[0], 4096,
                      &g_symbols[0], 100,
                      &g_strings[0], 4096,
                      &g_relocs[0], 100,
                      &g_output[0], 65536);

    // Create a NOP instruction (0xd503201f)
    var nop: [4]u8;
    nop[0] = 31;   // 0x1f
    nop[1] = 32;   // 0x20
    nop[2] = 3;    // 0x03
    nop[3] = 213;  // 0xd5

    macho_add_code(&w, &nop[0], 4);

    if w.code_count != 4 { print("FAIL (code_count)\n"); return 10; }

    // Check first byte
    if g_code[0] != 31 { print("FAIL (byte 0)\n"); return 11; }
    if g_code[1] != 32 { print("FAIL (byte 1)\n"); return 12; }
    if g_code[2] != 3 { print("FAIL (byte 2)\n"); return 13; }
    if g_code[3] != 213 { print("FAIL (byte 3)\n"); return 14; }

    print("PASS\n");
    return 0;
}

fn test_add_symbol() i64 {
    print("Test: add_symbol - ");

    var w: MachOWriter = undefined;
    macho_writer_init(&w,
                      &g_code[0], 4096,
                      &g_data[0], 4096,
                      &g_symbols[0], 100,
                      &g_strings[0], 4096,
                      &g_relocs[0], 100,
                      &g_output[0], 65536);

    // Add a symbol "_main"
    var name: [5]u8;
    name[0] = 95;   // '_'
    name[1] = 109;  // 'm'
    name[2] = 97;   // 'a'
    name[3] = 105;  // 'i'
    name[4] = 110;  // 'n'

    let idx: i64 = macho_add_symbol(&w, &name[0], 5, 0, SECT_TEXT, true);

    if idx != 0 { print("FAIL (index should be 0)\n"); return 20; }
    if w.symbols_count != 1 { print("FAIL (symbols_count)\n"); return 21; }

    // String table should have: [0]=null, [1-5]="_main", [6]=null
    if w.strings_count != 7 { print("FAIL (strings_count)\n"); return 22; }

    print("PASS\n");
    return 0;
}

fn test_write_macho() i64 {
    print("Test: write_macho - ");

    var w: MachOWriter = undefined;
    macho_writer_init(&w,
                      &g_code[0], 4096,
                      &g_data[0], 4096,
                      &g_symbols[0], 100,
                      &g_strings[0], 4096,
                      &g_relocs[0], 100,
                      &g_output[0], 65536);

    // Add a simple return 42 function
    // MOV X0, #42
    var mov_inst: [4]u8;
    let mov: i64 = ARM64_encodeMovImm(X0, 42);
    mov_inst[0] = @intCast(u8, mov & 255);
    mov_inst[1] = @intCast(u8, (mov >> 8) & 255);
    mov_inst[2] = @intCast(u8, (mov >> 16) & 255);
    mov_inst[3] = @intCast(u8, (mov >> 24) & 255);
    macho_add_code(&w, &mov_inst[0], 4);

    // RET
    var ret_inst: [4]u8;
    let ret: i64 = ARM64_return();
    ret_inst[0] = @intCast(u8, ret & 255);
    ret_inst[1] = @intCast(u8, (ret >> 8) & 255);
    ret_inst[2] = @intCast(u8, (ret >> 16) & 255);
    ret_inst[3] = @intCast(u8, (ret >> 24) & 255);
    macho_add_code(&w, &ret_inst[0], 4);

    // Add _main symbol
    var name: [5]u8;
    name[0] = 95;   // '_'
    name[1] = 109;  // 'm'
    name[2] = 97;   // 'a'
    name[3] = 105;  // 'i'
    name[4] = 110;  // 'n'
    let main_idx: i64 = macho_add_symbol(&w, &name[0], 5, 0, SECT_TEXT, true);

    // Write the Mach-O file
    let bytes_written: i64 = MachOWriter_write(&w);

    if bytes_written <= 0 {
        print("FAIL (no output)\n");
        return 30;
    }

    // Check magic number (first 4 bytes)
    // MH_MAGIC_64 = 0xFEEDFACF (little-endian: CF FA ED FE)
    if g_output[0] != 207 { print("FAIL (magic[0])\n"); return 31; }  // 0xCF
    if g_output[1] != 250 { print("FAIL (magic[1])\n"); return 32; }  // 0xFA
    if g_output[2] != 237 { print("FAIL (magic[2])\n"); return 33; }  // 0xED
    if g_output[3] != 254 { print("FAIL (magic[3])\n"); return 34; }  // 0xFE

    print("PASS (");
    print(bytes_written);
    print(" bytes)\n");
    return 0;
}

// Mach-O Object File Format
// Defines constants and structures for generating Mach-O object files.
//
// Reference: src/obj/macho.zig (our Zig bootstrap)
// Reference: Apple Mach-O file format documentation
//
// Mach-O Structure:
// +------------------+
// | Mach-O Header    |  32 bytes (64-bit)
// +------------------+
// | Load Commands    |  Variable size
// +------------------+
// | __TEXT Segment   |
// |   __text section |  Code
// +------------------+
// | __DATA Segment   |
// |   __data section |  Initialized data
// +------------------+
// | __DWARF Segment  |
// |   __debug_line   |  Line number debug info
// +------------------+
// | Symbol Table     |
// +------------------+
// | String Table     |
// +------------------+

import "dwarf.cot"
// import "../lib/strmap.cot" // TEMPORARILY DISABLED

// ============================================================================
// Module-Level Storage (self-allocated by MachOWriter_init)
// Following Zig pattern: modules own their storage, allocated on first use
// ============================================================================

// Extern malloc declarations
extern fn malloc_u8(count: i64) *u8;
extern fn malloc_i64(count: i64) *i64;

// Storage capacity constants
const MW_SYMBOLS_CAP: i64 = 5000;  // Needs ~2000 functions + ~2000 strings for self-hosting
const MW_STRINGS_CAP: i64 = 131072;  // 128KB - enough for self-hosting (~35KB needed)
const MW_RELOCS_CAP: i64 = 10000;
const MW_DEBUG_LINE_CAP: i64 = 65536;
const MW_DEBUG_LINE_RELOCS_CAP: i64 = 16;
const MW_DEBUG_ABBREV_CAP: i64 = 64;
const MW_DEBUG_INFO_CAP: i64 = 512;
const MW_DEBUG_INFO_RELOCS_CAP: i64 = 4;
const MW_OUTPUT_CAP: i64 = 1048576;  // 1MB output buffer

// Module storage (allocated once, reused across compilations)
// Symbol arrays (parallel arrays)
var mw_sym_name_offsets: *i64 = null;
var mw_sym_values: *i64 = null;
var mw_sym_sections: *i64 = null;
var mw_sym_is_externals: *i64 = null;
var mw_symbols_cap: i64 = 0;

// Strings buffer
var mw_strings: *u8 = null;
var mw_strings_cap: i64 = 0;

// Relocation arrays (parallel arrays)
var mw_reloc_offsets: *i64 = null;
var mw_reloc_target_str_offs: *i64 = null;
var mw_reloc_target_lens: *i64 = null;
var mw_reloc_types: *i64 = null;
var mw_reloc_is_pcrels: *i64 = null;
var mw_reloc_lengths: *i64 = null;
var mw_relocs_cap: i64 = 0;

// Debug line buffer and relocations
var mw_debug_line: *u8 = null;
var mw_debug_line_cap: i64 = 0;
var mw_dbg_line_reloc_offsets: *i64 = null;
var mw_dbg_line_reloc_target_str_offs: *i64 = null;
var mw_dbg_line_reloc_target_lens: *i64 = null;
var mw_dbg_line_reloc_types: *i64 = null;
var mw_dbg_line_reloc_is_pcrels: *i64 = null;
var mw_dbg_line_reloc_lengths: *i64 = null;
var mw_debug_line_relocs_cap: i64 = 0;

// Debug abbrev and debug info
var mw_debug_abbrev: *u8 = null;
var mw_debug_abbrev_cap: i64 = 0;
var mw_debug_info: *u8 = null;
var mw_debug_info_cap: i64 = 0;
var mw_dbg_info_reloc_offsets: *i64 = null;
var mw_dbg_info_reloc_target_str_offs: *i64 = null;
var mw_dbg_info_reloc_target_lens: *i64 = null;
var mw_dbg_info_reloc_types: *i64 = null;
var mw_dbg_info_reloc_is_pcrels: *i64 = null;
var mw_dbg_info_reloc_lengths: *i64 = null;
var mw_debug_info_relocs_cap: i64 = 0;

// Output buffer
var mw_output: *u8 = null;
var mw_output_cap: i64 = 0;

// Flag to track if storage has been allocated
var mw_storage_initialized: bool = false;

// ============================================================================
// Magic Numbers
// ============================================================================

// Mach-O 64-bit magic (little-endian)
const MH_MAGIC_64: i64 = 0xFEEDFACF;
// Big-endian version (reversed)
const MH_CIGAM_64: i64 = 0xCFFAEDFE;

// ============================================================================
// CPU Types
// ============================================================================

// CPU type for ARM64
const CPU_TYPE_ARM64: i64 = 0x0100000C;
// CPU subtype for all ARM64 variants
const CPU_SUBTYPE_ARM64_ALL: i64 = 0x00000000;

// ============================================================================
// File Types
// ============================================================================

// Relocatable object file
const MH_OBJECT: i64 = 0x1;
// Executable file
const MH_EXECUTE: i64 = 0x2;
// Dynamic library
const MH_DYLIB: i64 = 0x6;

// ============================================================================
// Header Flags
// ============================================================================

// Object file may be safely divided into subsections
const MH_SUBSECTIONS_VIA_SYMBOLS: i64 = 0x2000;

// ============================================================================
// Load Command Types
// ============================================================================

// 64-bit segment load command
const LC_SEGMENT_64: i64 = 0x19;
// Symbol table load command
const LC_SYMTAB: i64 = 0x02;
// Dynamic symbol table load command
const LC_DYSYMTAB: i64 = 0x0B;
// Build version load command
const LC_BUILD_VERSION: i64 = 0x32;

// ============================================================================
// Section Types
// ============================================================================

// Regular section
const S_REGULAR: i64 = 0x0;
// Zero-filled section (BSS)
const S_ZEROFILL: i64 = 0x1;
// C string literals section
const S_CSTRING_LITERALS: i64 = 0x2;

// ============================================================================
// Section Attributes
// ============================================================================

// Section contains only executable machine instructions
const S_ATTR_PURE_INSTRUCTIONS: i64 = 0x80000000;
// Section contains some machine instructions
const S_ATTR_SOME_INSTRUCTIONS: i64 = 0x00000400;

// ============================================================================
// Symbol Types
// ============================================================================

// Undefined symbol
const N_UNDF: i64 = 0x0;
// External symbol
const N_EXT: i64 = 0x1;
// Symbol defined in section
const N_SECT: i64 = 0xE;

// ============================================================================
// ARM64 Relocation Types
// ============================================================================

// Absolute address relocation
const ARM64_RELOC_UNSIGNED: i64 = 0;
// Subtractor for computing differences
const ARM64_RELOC_SUBTRACTOR: i64 = 1;
// 26-bit branch instruction (B, BL)
const ARM64_RELOC_BRANCH26: i64 = 2;
// ADRP instruction (page address, bits 12-32)
const ARM64_RELOC_PAGE21: i64 = 3;
// ADD/LDR instruction (page offset, bits 0-11)
const ARM64_RELOC_PAGEOFF12: i64 = 4;
// GOT page address
const ARM64_RELOC_GOT_LOAD_PAGE21: i64 = 5;
// GOT page offset
const ARM64_RELOC_GOT_LOAD_PAGEOFF12: i64 = 6;

// ============================================================================
// Structure Sizes (in bytes)
// ============================================================================

// Mach-O 64-bit header size
const MACH_HEADER_64_SIZE: i64 = 32;
// Segment command 64 size (without sections)
const SEGMENT_COMMAND_64_SIZE: i64 = 72;
// Section 64 size
const SECTION_64_SIZE: i64 = 80;
// Symbol table command size
const SYMTAB_COMMAND_SIZE: i64 = 24;
// Nlist64 entry size (symbol table entry)
const NLIST64_SIZE: i64 = 16;
// Relocation entry size
const RELOCATION_SIZE: i64 = 8;

// ============================================================================
// Relocation Info Encoding
// ============================================================================

// Create relocation info word
// Format: symbolnum (24 bits) | pcrel (1) | length (2) | extern (1) | type (4)
fn RelocInfo_make(symbolnum: i64, pcrel: bool, length: i64, external: bool, reloc_type: i64) i64 {
    var result: i64 = symbolnum & 0xFFFFFF;
    if pcrel { result = result | (1 << 24); }
    result = result | ((length & 3) << 25);
    if external { result = result | (1 << 27); }
    result = result | ((reloc_type & 15) << 28);
    return result;
}

// ============================================================================
// Section Numbers (1-indexed for Mach-O)
// ============================================================================

const SECT_TEXT: i64 = 1;
const SECT_DATA: i64 = 2;
const SECT_BSS: i64 = 3;
const SECT_CSTRING: i64 = 4;

// ============================================================================
// Memory Protection Flags
// ============================================================================

const VM_PROT_READ: i64 = 0x1;
const VM_PROT_WRITE: i64 = 0x2;
const VM_PROT_EXECUTE: i64 = 0x4;
const VM_PROT_ALL: i64 = 0x7;  // rwx

// ============================================================================
// Alignment (log2)
// ============================================================================

// Text section typically aligned to 4 bytes (2^2) for ARM64
const TEXT_ALIGN: i64 = 2;
// Data section aligned to 8 bytes (2^3) for 64-bit values
const DATA_ALIGN: i64 = 3;
// Page alignment (2^14 = 16384 for ARM64 macOS)
const PAGE_ALIGN: i64 = 14;

// ============================================================================
// Helper Functions
// ============================================================================

// Compute length of null-terminated string
fn MachO_strlen(ptr: *u8) i64 {
    var len: i64 = 0;
    while (ptr + len).* != 0 {
        len = len + 1;
    }
    return len;
}

// Check if value is a valid Mach-O magic number
fn MachO_isMagic(magic: i64) bool {
    return magic == MH_MAGIC_64 or magic == MH_CIGAM_64;
}

// Check if file type is valid
fn MachO_isValidFileType(filetype: i64) bool {
    return filetype == MH_OBJECT or filetype == MH_EXECUTE or filetype == MH_DYLIB;
}

// Calculate padding needed for alignment
fn MachO_paddingForAlign(offset: i64, align_pow2: i64) i64 {
    let alignment: i64 = 1 << align_pow2;
    let remainder: i64 = offset & (alignment - 1);
    if remainder == 0 { return 0; }
    return alignment - remainder;
}

// Round up offset to alignment
fn MachO_alignUp(offset: i64, align_pow2: i64) i64 {
    return offset + MachO_paddingForAlign(offset, align_pow2);
}

// ============================================================================
// Symbol Entry (for symbol table)
// ============================================================================

struct Symbol {
    name_offset: i64,     // Offset in string table
    value: i64,           // Value/address
    section: i64,         // Section number (0=undef, 1=text, 2=data)
    is_external: bool,    // External symbol?
}

// ============================================================================
// Relocation Entry (for branch relocations)
// ============================================================================

// Following Zig: stores target as slice (ptr + len), looks up index at write time
struct Reloc {
    offset: i64,
    target_ptr: *u8,
    target_len: i64,
    reloc_type: i64,
    is_pcrel: i64,
    length: i64,
}

// ============================================================================
// Mach-O Writer State
// Uses external buffers (no dynamic allocation)
// ============================================================================

struct MachOWriter {
    // Code section (text)
    code: *u8,
    code_count: i64,
    code_cap: i64,

    // Data section
    data: *u8,
    data_count: i64,
    data_cap: i64,

    // Symbol table (parallel arrays to avoid struct pointer arithmetic)
    sym_name_offsets: *i64,
    sym_values: *i64,
    sym_sections: *i64,
    sym_is_externals: *i64,
    symbols_count: i64,
    symbols_cap: i64,

    // String table
    strings: *u8,
    strings_count: i64,
    strings_cap: i64,

    // Relocations (parallel arrays to avoid struct pointer arithmetic)
    // target is stored as string table offset + length (not pointer)
    reloc_offsets: *i64,
    reloc_target_str_offs: *i64,    // Offset into strings table
    reloc_target_lens: *i64,
    reloc_types: *i64,
    reloc_is_pcrels: *i64,
    reloc_lengths: *i64,
    relocs_count: i64,
    relocs_cap: i64,

    // Debug line section (__debug_line)
    debug_line: *u8,
    debug_line_count: i64,
    debug_line_cap: i64,

    // Debug line relocations (parallel arrays)
    dbg_line_reloc_offsets: *i64,
    dbg_line_reloc_target_str_offs: *i64,
    dbg_line_reloc_target_lens: *i64,
    dbg_line_reloc_types: *i64,
    dbg_line_reloc_is_pcrels: *i64,
    dbg_line_reloc_lengths: *i64,
    debug_line_relocs_count: i64,
    debug_line_relocs_cap: i64,

    // Debug abbrev section (__debug_abbrev)
    debug_abbrev: *u8,
    debug_abbrev_count: i64,
    debug_abbrev_cap: i64,

    // Debug info section (__debug_info)
    debug_info: *u8,
    debug_info_count: i64,
    debug_info_cap: i64,

    // Debug info relocations (parallel arrays)
    dbg_info_reloc_offsets: *i64,
    dbg_info_reloc_target_str_offs: *i64,
    dbg_info_reloc_target_lens: *i64,
    dbg_info_reloc_types: *i64,
    dbg_info_reloc_is_pcrels: *i64,
    dbg_info_reloc_lengths: *i64,
    debug_info_relocs_count: i64,
    debug_info_relocs_cap: i64,

    // Output buffer
    output: *u8,
    output_count: i64,
    output_cap: i64,
}

// ============================================================================
// Writer Initialization
// ============================================================================

// Allocate module storage if not already allocated

impl MachOWriter {

    fn init(self: *MachOWriter, code: *u8, code_count: i64, data: *u8, data_cap: i64) {
        // Allocate module storage on first use
        MachOWriter_allocateStorage();
    
        // Code from GenState (external)
        self.code = code;
        self.code_count = code_count;
        self.code_cap = code_count;  // Already populated
    
        // Data from GenState (external, but we may add to it)
        self.data = data;
        self.data_count = 0;
        self.data_cap = data_cap;
    
        // Symbol table - uses module storage
        self.sym_name_offsets = mw_sym_name_offsets;
        self.sym_values = mw_sym_values;
        self.sym_sections = mw_sym_sections;
        self.sym_is_externals = mw_sym_is_externals;
        self.symbols_count = 0;
        self.symbols_cap = mw_symbols_cap;
    
        // String table starts with null byte - uses module storage
        self.strings = mw_strings;
        self.strings_count = 1;  // Reserve byte 0 as null
        self.strings_cap = mw_strings_cap;
        mw_strings.* = 0;
    
        // Main relocations - uses module storage
        self.reloc_offsets = mw_reloc_offsets;
        self.reloc_target_str_offs = mw_reloc_target_str_offs;
        self.reloc_target_lens = mw_reloc_target_lens;
        self.reloc_types = mw_reloc_types;
        self.reloc_is_pcrels = mw_reloc_is_pcrels;
        self.reloc_lengths = mw_reloc_lengths;
        self.relocs_count = 0;
        self.relocs_cap = mw_relocs_cap;
    
        // Debug line section - uses module storage
        self.debug_line = mw_debug_line;
        self.debug_line_count = 0;
        self.debug_line_cap = mw_debug_line_cap;
    
        // Debug line relocations - uses module storage
        self.dbg_line_reloc_offsets = mw_dbg_line_reloc_offsets;
        self.dbg_line_reloc_target_str_offs = mw_dbg_line_reloc_target_str_offs;
        self.dbg_line_reloc_target_lens = mw_dbg_line_reloc_target_lens;
        self.dbg_line_reloc_types = mw_dbg_line_reloc_types;
        self.dbg_line_reloc_is_pcrels = mw_dbg_line_reloc_is_pcrels;
        self.dbg_line_reloc_lengths = mw_dbg_line_reloc_lengths;
        self.debug_line_relocs_count = 0;
        self.debug_line_relocs_cap = mw_debug_line_relocs_cap;
    
        // Debug abbrev section - uses module storage
        self.debug_abbrev = mw_debug_abbrev;
        self.debug_abbrev_count = 0;
        self.debug_abbrev_cap = mw_debug_abbrev_cap;
    
        // Debug info section - uses module storage
        self.debug_info = mw_debug_info;
        self.debug_info_count = 0;
        self.debug_info_cap = mw_debug_info_cap;
    
        // Debug info relocations - uses module storage
        self.dbg_info_reloc_offsets = mw_dbg_info_reloc_offsets;
        self.dbg_info_reloc_target_str_offs = mw_dbg_info_reloc_target_str_offs;
        self.dbg_info_reloc_target_lens = mw_dbg_info_reloc_target_lens;
        self.dbg_info_reloc_types = mw_dbg_info_reloc_types;
        self.dbg_info_reloc_is_pcrels = mw_dbg_info_reloc_is_pcrels;
        self.dbg_info_reloc_lengths = mw_dbg_info_reloc_lengths;
        self.debug_info_relocs_count = 0;
        self.debug_info_relocs_cap = mw_debug_info_relocs_cap;
    
        // Output buffer - uses module storage
        self.output = mw_output;
        self.output_count = 0;
        self.output_cap = mw_output_cap;
    }

    fn setDebugLine(self: *MachOWriter, debug_line: *u8, debug_line_cap: i64) {
        self.debug_line = debug_line;
        self.debug_line_count = 0;
        self.debug_line_cap = debug_line_cap;
    }

    fn setDebugLineRelocs(self: *MachOWriter,
                                       offsets: *i64, target_str_offs: *i64, target_lens: *i64,
                                       types: *i64, is_pcrels: *i64, lengths: *i64,
                                       cap: i64) {
        self.dbg_line_reloc_offsets = offsets;
        self.dbg_line_reloc_target_str_offs = target_str_offs;
        self.dbg_line_reloc_target_lens = target_lens;
        self.dbg_line_reloc_types = types;
        self.dbg_line_reloc_is_pcrels = is_pcrels;
        self.dbg_line_reloc_lengths = lengths;
        self.debug_line_relocs_count = 0;
        self.debug_line_relocs_cap = cap;
    }

    fn addDebugLineReloc(self: *MachOWriter, offset: i64, symbol_idx: i64) {
        if self.dbg_line_reloc_offsets == null or self.debug_line_relocs_count >= self.debug_line_relocs_cap {
            return;
        }
    
        // Get symbol name offset from parallel arrays
        let no_ptr: *i64 = self.sym_name_offsets + symbol_idx;
        let name_str_off: i64 = no_ptr.*;
        let name_ptr: *u8 = self.strings + name_str_off;
        var name_len: i64 = 0;
        while (name_ptr + name_len).* != 0 { name_len = name_len + 1; }
    
        // Store in parallel arrays
        let idx: i64 = self.debug_line_relocs_count;
        let off_ptr: *i64 = self.dbg_line_reloc_offsets + idx;
        let tgt_ptr: *i64 = self.dbg_line_reloc_target_str_offs + idx;
        let len_ptr: *i64 = self.dbg_line_reloc_target_lens + idx;
        let typ_ptr: *i64 = self.dbg_line_reloc_types + idx;
        let pcr_ptr: *i64 = self.dbg_line_reloc_is_pcrels + idx;
        let lng_ptr: *i64 = self.dbg_line_reloc_lengths + idx;
    
        off_ptr.* = offset;
        tgt_ptr.* = name_str_off;  // Store offset instead of pointer
        len_ptr.* = name_len;
        typ_ptr.* = ARM64_RELOC_UNSIGNED;
        pcr_ptr.* = 0;
        lng_ptr.* = 3;  // 8 bytes (2^3) for 64-bit address
    
        self.debug_line_relocs_count = self.debug_line_relocs_count + 1;
    }

    fn setDebugAbbrev(self: *MachOWriter, buf: *u8, cap: i64) {
        self.debug_abbrev = buf;
        self.debug_abbrev_count = 0;
        self.debug_abbrev_cap = cap;
    }

    fn setDebugInfo(self: *MachOWriter, buf: *u8, cap: i64) {
        self.debug_info = buf;
        self.debug_info_count = 0;
        self.debug_info_cap = cap;
    }

    fn setDebugInfoRelocs(self: *MachOWriter,
                                       offsets: *i64, target_str_offs: *i64, target_lens: *i64,
                                       types: *i64, is_pcrels: *i64, lengths: *i64,
                                       cap: i64) {
        self.dbg_info_reloc_offsets = offsets;
        self.dbg_info_reloc_target_str_offs = target_str_offs;
        self.dbg_info_reloc_target_lens = target_lens;
        self.dbg_info_reloc_types = types;
        self.dbg_info_reloc_is_pcrels = is_pcrels;
        self.dbg_info_reloc_lengths = lengths;
        self.debug_info_relocs_count = 0;
        self.debug_info_relocs_cap = cap;
    }

    fn addDebugInfoReloc(self: *MachOWriter, offset: i64, symbol_idx: i64) {
        if self.dbg_info_reloc_offsets == null or self.debug_info_relocs_count >= self.debug_info_relocs_cap {
            return;
        }
    
        // Get symbol name offset from parallel arrays
        let no_ptr: *i64 = self.sym_name_offsets + symbol_idx;
        let name_str_off: i64 = no_ptr.*;
        let name_ptr: *u8 = self.strings + name_str_off;
        var name_len: i64 = 0;
        while (name_ptr + name_len).* != 0 { name_len = name_len + 1; }
    
        // Store in parallel arrays
        let idx: i64 = self.debug_info_relocs_count;
        let off_ptr: *i64 = self.dbg_info_reloc_offsets + idx;
        let tgt_ptr: *i64 = self.dbg_info_reloc_target_str_offs + idx;
        let len_ptr: *i64 = self.dbg_info_reloc_target_lens + idx;
        let typ_ptr: *i64 = self.dbg_info_reloc_types + idx;
        let pcr_ptr: *i64 = self.dbg_info_reloc_is_pcrels + idx;
        let lng_ptr: *i64 = self.dbg_info_reloc_lengths + idx;
    
        off_ptr.* = offset;
        tgt_ptr.* = name_str_off;  // Store offset instead of pointer
        len_ptr.* = name_len;
        typ_ptr.* = ARM64_RELOC_UNSIGNED;
        pcr_ptr.* = 0;
        lng_ptr.* = 3;  // 8 bytes (2^3) for 64-bit address
    
        self.debug_info_relocs_count = self.debug_info_relocs_count + 1;
    }

    fn addCode(self: *MachOWriter, bytes: *u8, len: i64) {
        var i: i64 = 0;
        while i < len and self.code_count < self.code_cap {
            let src: *u8 = bytes + i;
            let dst: *u8 = self.code + self.code_count;
            dst.* = src.*;
            self.code_count = self.code_count + 1;
            i = i + 1;
        }
    }

    fn addData(self: *MachOWriter, bytes: *u8, len: i64) i64 {
        let offset: i64 = self.data_count;
        var i: i64 = 0;
        while i < len and self.data_count < self.data_cap {
            let src: *u8 = bytes + i;
            let dst: *u8 = self.data + self.data_count;
            dst.* = src.*;
            self.data_count = self.data_count + 1;
            i = i + 1;
        }
        return offset;
    }

    fn addDataByte(self: *MachOWriter, b: i64) {
        if self.data_count < self.data_cap {
            let dst: *u8 = self.data + self.data_count;
            dst.* = @intCast(u8, b);
            self.data_count = self.data_count + 1;
        }
    }

    fn addDataI64(self: *MachOWriter, value: i64) {
        // Write 8 bytes in little-endian order
        self.addDataByte(value & 0xFF);
        self.addDataByte((value >> 8) & 0xFF);
        self.addDataByte((value >> 16) & 0xFF);
        self.addDataByte((value >> 24) & 0xFF);
        self.addDataByte((value >> 32) & 0xFF);
        self.addDataByte((value >> 40) & 0xFF);
        self.addDataByte((value >> 48) & 0xFF);
        self.addDataByte((value >> 56) & 0xFF);
    }

    fn addDataZeros(self: *MachOWriter, len: i64) i64 {
        let offset: i64 = self.data_count;
        var i: i64 = 0;
        while i < len and self.data_count < self.data_cap {
            let dst: *u8 = self.data + self.data_count;
            dst.* = 0;
            self.data_count = self.data_count + 1;
            i = i + 1;
        }
        return offset;
    }

    fn addStringLiteral(self: *MachOWriter, s: *u8, len: i64) i64 {
        let offset: i64 = self.data_count;
        var i: i64 = 0;
        while i < len and self.data_count < self.data_cap {
            let src: *u8 = s + i;
            let dst: *u8 = self.data + self.data_count;
            dst.* = src.*;
            self.data_count = self.data_count + 1;
            i = i + 1;
        }
        // Add null terminator
        if self.data_count < self.data_cap {
            let null_ptr: *u8 = self.data + self.data_count;
            null_ptr.* = 0;
            self.data_count = self.data_count + 1;
        }
        return offset;
    }

    fn addString(self: *MachOWriter, s: *u8, len: i64) i64 {
        let offset: i64 = self.strings_count;
    
        var i: i64 = 0;
        while i < len and self.strings_count < self.strings_cap {
            let src: *u8 = s + i;
            let dst: *u8 = self.strings + self.strings_count;
            dst.* = src.*;
            self.strings_count = self.strings_count + 1;
            i = i + 1;
        }
    
        // Add null terminator
        if self.strings_count < self.strings_cap {
            let null_ptr: *u8 = self.strings + self.strings_count;
            null_ptr.* = 0;
            self.strings_count = self.strings_count + 1;
        }
    
        return offset;
    }

    fn addSymbol(self: *MachOWriter, name: *u8, name_len: i64,
                        value: i64, section: i64, is_external: bool) i64 {
        if self.symbols_count >= self.symbols_cap {
            return 0 - 1;  // Error
        }
    
        let name_offset: i64 = self.addString(name, name_len);
    
        let idx: i64 = self.symbols_count;
        let no_ptr: *i64 = self.sym_name_offsets + idx;
        let v_ptr: *i64 = self.sym_values + idx;
        let s_ptr: *i64 = self.sym_sections + idx;
        let e_ptr: *i64 = self.sym_is_externals + idx;
    
        no_ptr.* = name_offset;
        v_ptr.* = value;
        s_ptr.* = section;
        if is_external {
            e_ptr.* = 1;
        } else {
            e_ptr.* = 0;
        }
    
        self.symbols_count = self.symbols_count + 1;
        return idx;
    }

    fn findSymbol(self: *MachOWriter, name: *u8, name_len: i64) i64 {
        var i: i64 = 0;
        while i < self.symbols_count {
            // Get name_offset from parallel array
            let no_ptr: *i64 = self.sym_name_offsets + i;
            let sym_name_offset: i64 = no_ptr.*;
            let sym_name: *u8 = self.strings + sym_name_offset;
            var match: bool = true;
            var j: i64 = 0;
            while j < name_len {
                let c1: *u8 = name + j;
                let c2: *u8 = sym_name + j;
                if c1.* != c2.* {
                    match = false;
                }
                j = j + 1;
            }
            // Check null terminator
            let term: *u8 = sym_name + name_len;
            if match and term.* == 0 {
                return i;
            }
            i = i + 1;
        }
        return -1;
    }

    fn addReloc(self: *MachOWriter, offset: i64, target_ptr: *u8, target_len: i64,
                       reloc_type: i64, is_pcrel: i64) {
        if self.reloc_offsets == null or self.relocs_count >= self.relocs_cap {
            return;
        }
    
        // Store target name into strings table (NOT symbol index)
        // This is the Zig approach - resolve symbol index at write time
        let name_str_off: i64 = self.addString(target_ptr, target_len);
    
        // Store in parallel arrays
        let idx: i64 = self.relocs_count;
        let off_ptr: *i64 = self.reloc_offsets + idx;
        let tgt_ptr: *i64 = self.reloc_target_str_offs + idx;  // Stores string offset (not symbol index)
        let len_ptr: *i64 = self.reloc_target_lens + idx;
        let typ_ptr: *i64 = self.reloc_types + idx;
        let pcr_ptr: *i64 = self.reloc_is_pcrels + idx;
        let lng_ptr: *i64 = self.reloc_lengths + idx;
    
        off_ptr.* = offset;
        tgt_ptr.* = name_str_off;  // Store string offset - symbol index resolved at write time
        len_ptr.* = target_len;
        typ_ptr.* = reloc_type;
        pcr_ptr.* = is_pcrel;
        lng_ptr.* = 2;  // Default length
    
        self.relocs_count = self.relocs_count + 1;
    }

    fn addDataReloc(self: *MachOWriter, offset: i64, target_ptr: *u8, target_len: i64,
                            reloc_type: i64) {
        // Data relocations are not PC-relative
        self.addReloc(offset, target_ptr, target_len, reloc_type, 0);
    }

    fn outByte(self: *MachOWriter, b: i64) {
        if self.output_count < self.output_cap {
            let p: *u8 = self.output + self.output_count;
            p.* = @intCast(u8, b & 255);
            self.output_count = self.output_count + 1;
        }
    }

    fn outU32(self: *MachOWriter, val: i64) {
        self.outByte(val & 255);
        self.outByte((val >> 8) & 255);
        self.outByte((val >> 16) & 255);
        self.outByte((val >> 24) & 255);
    }

    fn outU64(self: *MachOWriter, val: i64) {
        self.outU32(val & 0xFFFFFFFF);
        self.outU32((val >> 32) & 0xFFFFFFFF);
    }

    fn outZeros(self: *MachOWriter, n: i64) {
        var i: i64 = 0;
        while i < n {
            self.outByte(0);
            i = i + 1;
        }
    }

    fn outBytes(self: *MachOWriter, src: *u8, len: i64) {
        var i: i64 = 0;
        while i < len {
            let p: *u8 = src + i;
            self.outByte(@intCast(i64, p.*));
            i = i + 1;
        }
    }

    fn writeMachHeader(self: *MachOWriter, ncmds: i64, sizeofcmds: i64) {
        self.outU32(MH_MAGIC_64);           // magic
        self.outU32(CPU_TYPE_ARM64);        // cputype
        self.outU32(CPU_SUBTYPE_ARM64_ALL); // cpusubtype
        self.outU32(MH_OBJECT);             // filetype
        self.outU32(ncmds);                 // ncmds
        self.outU32(sizeofcmds);            // sizeofcmds
        self.outU32(MH_SUBSECTIONS_VIA_SYMBOLS); // flags
        self.outU32(0);                     // reserved
    }

    fn writeSegmentCmd(self: *MachOWriter, vmsize: i64, fileoff: i64,
                         filesize: i64, nsects: i64) {
        let cmdsize: i64 = SEGMENT_COMMAND_64_SIZE + nsects * SECTION_64_SIZE;
    
        self.outU32(LC_SEGMENT_64);  // cmd
        self.outU32(cmdsize);        // cmdsize
        self.outZeros(16);           // segname (empty for relocatable object)
        self.outU64(0);              // vmaddr
        self.outU64(vmsize);         // vmsize
        self.outU64(fileoff);        // fileoff
        self.outU64(filesize);       // filesize
        self.outU32(VM_PROT_ALL);    // maxprot (rwx)
        self.outU32(VM_PROT_ALL);    // initprot
        self.outU32(nsects);         // nsects
        self.outU32(0);              // flags
    }

    fn writeSection(self: *MachOWriter,
                     sectname: *u8, segname: *u8,
                     size: i64, offset: i64,
                     sect_align: i64, flags: i64,
                     reloff: i64, nreloc: i64) {
        // Write 16-byte section name (pad with zeros)
        // Names are null-terminated, so copy until null or 16 bytes
        var i: i64 = 0;
        while i < 16 {
            let p: *u8 = sectname + i;
            if p.* != 0 {
                self.outByte(@intCast(i64, p.*));
            } else {
                self.outByte(0);
            }
            i = i + 1;
        }
    
        // Write 16-byte segment name (pad with zeros)
        i = 0;
        while i < 16 {
            let p: *u8 = segname + i;
            if p.* != 0 {
                self.outByte(@intCast(i64, p.*));
            } else {
                self.outByte(0);
            }
            i = i + 1;
        }
    
        self.outU64(0);          // addr (0 for object file)
        self.outU64(size);       // size
        self.outU32(offset);     // offset
        self.outU32(sect_align); // align (log2)
        self.outU32(reloff);     // reloff
        self.outU32(nreloc);     // nreloc
        self.outU32(flags);      // flags
        self.outU32(0);          // reserved1
        self.outU32(0);          // reserved2
        self.outU32(0);          // reserved3
    }

    fn writeSymtabCmd(self: *MachOWriter, symoff: i64, nsyms: i64,
                        stroff: i64, strsize: i64) {
        self.outU32(LC_SYMTAB);       // cmd
        self.outU32(SYMTAB_COMMAND_SIZE);  // cmdsize
        self.outU32(symoff);          // symoff
        self.outU32(nsyms);           // nsyms
        self.outU32(stroff);          // stroff
        self.outU32(strsize);         // strsize
    }

    fn writeTextReloc(self: *MachOWriter, idx: i64) {
        let offset_ptr: *i64 = self.reloc_offsets + idx;
        let target_str_off_ptr: *i64 = self.reloc_target_str_offs + idx;  // String offset in strings table
        let target_len_ptr: *i64 = self.reloc_target_lens + idx;
        let type_ptr: *i64 = self.reloc_types + idx;
        let is_pcrel_ptr: *i64 = self.reloc_is_pcrels + idx;
        let length_ptr: *i64 = self.reloc_lengths + idx;
    
        let offset: i64 = offset_ptr.*;
        let target_str_off: i64 = target_str_off_ptr.*;
        let target_len: i64 = target_len_ptr.*;
        let reloc_type: i64 = type_ptr.*;
        let is_pcrel: i64 = is_pcrel_ptr.*;
        let length: i64 = length_ptr.*;
    
        // Resolve symbol index at write time using linear search
        let target_ptr: *u8 = self.strings + target_str_off;
        var sym_idx: i64 = self.findSymbol(target_ptr, target_len);
        if sym_idx < 0 {
            // Should not happen - all symbols were added in write()
            sym_idx = 0;
        }
    
        self.outU32(offset);  // r_address
        let is_pcrel_bool: bool = is_pcrel != 0;
        let info: i64 = RelocInfo_make(sym_idx, is_pcrel_bool, length, true, reloc_type);
        self.outU32(info);
    }

    fn writeDbgLineReloc(self: *MachOWriter, idx: i64) {
        let offset_ptr: *i64 = self.dbg_line_reloc_offsets + idx;
        let target_str_off_ptr: *i64 = self.dbg_line_reloc_target_str_offs + idx;
        let target_len_ptr: *i64 = self.dbg_line_reloc_target_lens + idx;
        let type_ptr: *i64 = self.dbg_line_reloc_types + idx;
        let is_pcrel_ptr: *i64 = self.dbg_line_reloc_is_pcrels + idx;
        let length_ptr: *i64 = self.dbg_line_reloc_lengths + idx;
    
        let offset: i64 = offset_ptr.*;
        let target_str_off: i64 = target_str_off_ptr.*;
        let target_len: i64 = target_len_ptr.*;
        let reloc_type: i64 = type_ptr.*;
        let is_pcrel: i64 = is_pcrel_ptr.*;
        let length: i64 = length_ptr.*;
    
        let target_ptr: *u8 = self.strings + target_str_off;
    
        self.outU32(offset);
        var sym_idx: i64 = self.findSymbol(target_ptr, target_len);
        if sym_idx < 0 { sym_idx = 0; }
        let is_pcrel_bool: bool = is_pcrel != 0;
        let info: i64 = RelocInfo_make(sym_idx, is_pcrel_bool, length, true, reloc_type);
        self.outU32(info);
    }

    fn writeDbgInfoReloc(self: *MachOWriter, idx: i64) {
        let offset_ptr: *i64 = self.dbg_info_reloc_offsets + idx;
        let target_str_off_ptr: *i64 = self.dbg_info_reloc_target_str_offs + idx;
        let target_len_ptr: *i64 = self.dbg_info_reloc_target_lens + idx;
        let type_ptr: *i64 = self.dbg_info_reloc_types + idx;
        let is_pcrel_ptr: *i64 = self.dbg_info_reloc_is_pcrels + idx;
        let length_ptr: *i64 = self.dbg_info_reloc_lengths + idx;
    
        let offset: i64 = offset_ptr.*;
        let target_str_off: i64 = target_str_off_ptr.*;
        let target_len: i64 = target_len_ptr.*;
        let reloc_type: i64 = type_ptr.*;
        let is_pcrel: i64 = is_pcrel_ptr.*;
        let length: i64 = length_ptr.*;
    
        let target_ptr: *u8 = self.strings + target_str_off;
    
        self.outU32(offset);
        var sym_idx: i64 = self.findSymbol(target_ptr, target_len);
        if sym_idx < 0 { sym_idx = 0; }
        let is_pcrel_bool: bool = is_pcrel != 0;
        let info: i64 = RelocInfo_make(sym_idx, is_pcrel_bool, length, true, reloc_type);
        self.outU32(info);
    }

    fn writeNlist64(self: *MachOWriter, sym_idx: i64) {
        // Read from parallel arrays
        let no_ptr: *i64 = self.sym_name_offsets + sym_idx;
        let v_ptr: *i64 = self.sym_values + sym_idx;
        let s_ptr: *i64 = self.sym_sections + sym_idx;
        let e_ptr: *i64 = self.sym_is_externals + sym_idx;
    
        let sym_name_offset: i64 = no_ptr.*;
        let sym_value: i64 = v_ptr.*;
        let sym_section: i64 = s_ptr.*;
        let sym_is_external: i64 = e_ptr.*;
    
        self.outU32(sym_name_offset);  // n_strx
    
        // n_type: N_SECT | N_EXT for defined external, N_EXT for undefined
        var n_type: i64 = 0;
        if sym_section == 0 {
            // Undefined external symbol
            n_type = N_EXT;
        } else {
            // Defined in section
            n_type = N_SECT;
            if sym_is_external != 0 {
                n_type = n_type | N_EXT;
            }
        }
        self.outByte(n_type);  // n_type
    
        self.outByte(sym_section);  // n_sect
        self.outByte(0);  // n_desc low byte
        self.outByte(0);  // n_desc high byte
        self.outU64(sym_value);  // n_value
    }

    fn generateDebugLine(self: *MachOWriter,
                                      filename: *u8, filename_len: i64,
                                      line_entries: *u8, line_count: i64,
                                      code_size: i64, main_sym_idx: i64) i64 {
        if self.debug_line == null or self.debug_line_cap == 0 {
            return 0;
        }
    
        var dw: DebugLineWriter = undefined;
        dw.init( self.debug_line, self.debug_line_cap);
    
        // We need to calculate the header length before writing it
        // For DWARF v4, the structure is:
        // - unit_length (4 bytes, not including itself)
        // - version (2 bytes) = 4
        // - header_length (4 bytes)
        // - minimum_instruction_length (1 byte) = 4
        // - maximum_operations_per_instruction (1 byte) = 1
        // - default_is_stmt (1 byte) = 1
        // - line_base (1 byte) = -5
        // - line_range (1 byte) = 14
        // - opcode_base (1 byte) = 13
        // - standard_opcode_lengths (12 bytes for opcodes 1-12)
        // - include_directories (null-terminated list, we use one empty entry)
        // - file_names (null-terminated list)
        // - line number program
    
        // Header constants (fixed size portion after header_length)
        // min_inst_len(1) + max_ops(1) + default_is_stmt(1) + line_base(1) +
        // line_range(1) + opcode_base(1) + std_opcode_lengths(12) = 18 bytes
        let fixed_header_size: i64 = 18;
    
        // Include directories: empty list (just null byte)
        let include_dirs_size: i64 = 1;
    
        // File names: one file entry + terminating null
        // File entry: filename (null-terminated) + dir_idx (ULEB128) + mtime (ULEB128) + length (ULEB128)
        // Simplified: filename + 0 + 0 + 0 + 0 (4 null bytes for the 3 ULEB128 zeros and terminator)
        let file_entry_size: i64 = filename_len + 1 + 3 + 1;  // filename + null + 3 zeros + terminating null
    
        // Header length (from after header_length field to end of header)
        let header_length: i64 = fixed_header_size + include_dirs_size + file_entry_size;
    
        // Estimate line program size (will write at the end)
        // We'll calculate actual size after writing
    
        // Placeholder for unit_length (we'll patch this at the end)
        let unit_length_pos: i64 = dw.count;
        dw.writeU32( 0);  // Placeholder
    
        // Version
        dw.writeU16( DWARF_VERSION);
    
        // Header length
        dw.writeU32( header_length);
    
        // Minimum instruction length
        dw.writeByte( MIN_INST_LENGTH);
    
        // Maximum operations per instruction (DWARF v4+)
        dw.writeByte( MAX_OPS_PER_INST);
    
        // Default is_stmt
        dw.writeByte( DEFAULT_IS_STMT);
    
        // Line base
        dw.writeByte( LINE_BASE & 255);  // Signed, so -5 = 251
    
        // Line range
        dw.writeByte( LINE_RANGE);
    
        // Opcode base
        dw.writeByte( OPCODE_BASE);
    
        // Standard opcode lengths (for opcodes 1 through opcode_base-1)
        dw.writeByte( 0);  // DW_LNS_copy
        dw.writeByte( 1);  // DW_LNS_advance_pc
        dw.writeByte( 1);  // DW_LNS_advance_line
        dw.writeByte( 1);  // DW_LNS_set_file
        dw.writeByte( 1);  // DW_LNS_set_column
        dw.writeByte( 0);  // DW_LNS_negate_stmt
        dw.writeByte( 0);  // DW_LNS_set_basic_block
        dw.writeByte( 0);  // DW_LNS_const_add_pc
        dw.writeByte( 1);  // DW_LNS_fixed_advance_pc
        dw.writeByte( 0);  // DW_LNS_set_prologue_end
        dw.writeByte( 0);  // DW_LNS_set_epilogue_begin
        dw.writeByte( 1);  // DW_LNS_set_isa
    
        // Include directories (empty list - just null terminator)
        dw.writeByte( 0);
    
        // File names
        // Entry format: filename (null-term), directory index (ULEB128), mtime (ULEB128), length (ULEB128)
        dw.writeString( filename, filename_len);
        dw.writeULEB128( 0);  // Directory index 0
        dw.writeULEB128( 0);  // Modification time (unknown)
        dw.writeULEB128( 0);  // File length (unknown)
        // Terminate file name list
        dw.writeByte( 0);
    
        // Line number program
        // We need to emit the program that maps addresses to lines
    
        if line_count > 0 {
            // Each LineEntry is: code_offset(8) + source_pos(8) + line(8) + column(8) = 32 bytes
            let entry_size: i64 = 32;
    
            // Set initial address
            // Read first entry's code_offset (at byte offset 0)
            let first_addr: i64 = MachO_readI64(line_entries);
    
            // Record position where address will be written (after 3 bytes of opcode prefix)
            // DW_LNE_set_address format: 0 (1) + length ULEB (1) + opcode (1) + address (8)
            let addr_reloc_offset: i64 = dw.count + 3;
            dw.writeSetAddress( first_addr);
    
            // Add relocation for the address (symbol 0 is typically _main)
            self.addDebugLineReloc(addr_reloc_offset, main_sym_idx);
    
            // Set initial line (first entry, at byte offset 16)
            let first_line: i64 = MachO_readI64(line_entries + 16);
    
            // Advance line from 1 to first_line
            if first_line > 1 {
                dw.writeByte( DW_LNS_advance_line);
                dw.writeSLEB128( first_line - 1);
            }
    
            // Copy (emit row)
            dw.writeByte( DW_LNS_copy);
    
            // Process remaining entries
            var prev_addr: i64 = first_addr;
            var prev_line: i64 = first_line;
            var i: i64 = 1;
    
            while i < line_count {
                let entry_ptr: *u8 = line_entries + (i * entry_size);
                // code_offset is at byte offset 0 within entry
                let cur_addr: i64 = MachO_readI64(entry_ptr);
                // line is at byte offset 16 within entry
                let cur_line: i64 = MachO_readI64(entry_ptr + 16);
    
                let addr_delta: i64 = cur_addr - prev_addr;
                let line_delta: i64 = cur_line - prev_line;
    
                // Try special opcode if possible
                if DWARF_canUseSpecialOpcode(line_delta, addr_delta) {
                    let opcode: i64 = DWARF_specialOpcode(line_delta, addr_delta);
                    dw.writeByte( opcode);
                } else {
                    // Use standard opcodes
                    if addr_delta > 0 {
                        dw.writeByte( DW_LNS_advance_pc);
                        dw.writeULEB128( addr_delta / MIN_INST_LENGTH);
                    }
                    if line_delta != 0 {
                        dw.writeByte( DW_LNS_advance_line);
                        dw.writeSLEB128( line_delta);
                    }
                    dw.writeByte( DW_LNS_copy);
                }
    
                prev_addr = cur_addr;
                prev_line = cur_line;
                i = i + 1;
            }
    
            // Advance to end of code
            if code_size > prev_addr {
                let final_delta: i64 = code_size - prev_addr;
                dw.writeByte( DW_LNS_advance_pc);
                dw.writeULEB128( final_delta / MIN_INST_LENGTH);
            }
        }
    
        // End sequence
        dw.writeEndSequence();
    
        // Patch unit_length (total size minus the 4-byte length field itself)
        let total_size: i64 = dw.count;
        let unit_length: i64 = total_size - 4;
    
        // Write unit_length at the beginning
        let p0: *u8 = self.debug_line + unit_length_pos;
        p0.* = @intCast(u8, unit_length & 255);
        let p1: *u8 = self.debug_line + unit_length_pos + 1;
        p1.* = @intCast(u8, (unit_length >> 8) & 255);
        let p2: *u8 = self.debug_line + unit_length_pos + 2;
        p2.* = @intCast(u8, (unit_length >> 16) & 255);
        let p3: *u8 = self.debug_line + unit_length_pos + 3;
        p3.* = @intCast(u8, (unit_length >> 24) & 255);
    
        self.debug_line_count = dw.count;
        return dw.count;
    }

    fn write(self: *MachOWriter) i64 {
        // ========================================================================
        // Add missing external symbols from relocations (using linear search)
        // ========================================================================
        var i: i64 = 0;
        while i < self.relocs_count {
            let target_str_off: i64 = (self.reloc_target_str_offs + i).*;
            let target_len: i64 = (self.reloc_target_lens + i).*;
            let target_ptr: *u8 = self.strings + target_str_off;
    
            // Check if symbol exists using linear search
            let existing_idx: i64 = self.findSymbol(target_ptr, target_len);
            if existing_idx < 0 {
                // Add as undefined external symbol (section = 0)
                self.addSymbol(target_ptr, target_len, 0, 0, true);
            }
            i = i + 1;
        }
    
        // ========================================================================
        // Calculate layout (symbol count may have changed)
        // ========================================================================
        let num_sections: i64 = 2;  // __text and __data
        let load_cmds_size: i64 = SEGMENT_COMMAND_64_SIZE +
                                  num_sections * SECTION_64_SIZE +
                                  SYMTAB_COMMAND_SIZE;
    
        let text_offset: i64 = MACH_HEADER_64_SIZE + load_cmds_size;
        let text_size: i64 = self.code_count;
    
        let data_offset: i64 = MachO_alignUp(text_offset + text_size, 3);  // 8-byte align
        let data_size: i64 = self.data_count;
    
        let reloc_offset: i64 = MachO_alignUp(data_offset + data_size, 2);  // 4-byte align
        let reloc_size: i64 = self.relocs_count * RELOCATION_SIZE;
    
        let symtab_offset: i64 = MachO_alignUp(reloc_offset + reloc_size, 3);  // 8-byte align
        let symtab_size: i64 = self.symbols_count * NLIST64_SIZE;
    
        let strtab_offset: i64 = symtab_offset + symtab_size;
        let strtab_size: i64 = self.strings_count;
    
        let segment_filesize: i64 = data_offset + data_size - text_offset;
    
        // Write header
        self.writeMachHeader(2, load_cmds_size);
    
        // Write segment command
        self.writeSegmentCmd(segment_filesize, text_offset, segment_filesize, num_sections);
    
        // Write __text section
        let text_flags: i64 = S_ATTR_PURE_INSTRUCTIONS | S_ATTR_SOME_INSTRUCTIONS;
        var text_name: [16]u8;
        text_name[0] = 95;  // '_'
        text_name[1] = 95;  // '_'
        text_name[2] = 116; // 't'
        text_name[3] = 101; // 'e'
        text_name[4] = 120; // 'x'
        text_name[5] = 116; // 't'
    
        var text_seg: [16]u8;
        text_seg[0] = 95;   // '_'
        text_seg[1] = 95;   // '_'
        text_seg[2] = 84;   // 'T'
        text_seg[3] = 69;   // 'E'
        text_seg[4] = 88;   // 'X'
        text_seg[5] = 84;   // 'T'
    
        self.writeSection(&text_name[0], &text_seg[0],
                      text_size, text_offset,
                      TEXT_ALIGN, text_flags,
                      reloc_offset, self.relocs_count);
    
        // Write __data section
        var data_name: [16]u8;
        data_name[0] = 95;  // '_'
        data_name[1] = 95;  // '_'
        data_name[2] = 100; // 'd'
        data_name[3] = 97;  // 'a'
        data_name[4] = 116; // 't'
        data_name[5] = 97;  // 'a'
    
        var data_seg: [16]u8;
        data_seg[0] = 95;   // '_'
        data_seg[1] = 95;   // '_'
        data_seg[2] = 68;   // 'D'
        data_seg[3] = 65;   // 'A'
        data_seg[4] = 84;   // 'T'
        data_seg[5] = 65;   // 'A'
    
        self.writeSection(&data_name[0], &data_seg[0],
                      data_size, data_offset,
                      DATA_ALIGN, S_REGULAR,
                      0, 0);
    
        // Write symtab command
        self.writeSymtabCmd(symtab_offset, self.symbols_count,
                         strtab_offset, strtab_size);
    
        // Write text section content
        self.outBytes(self.code, self.code_count);
    
        // Pad to data section
        let pad1: i64 = data_offset - (text_offset + text_size);
        self.outZeros(pad1);
    
        // Write data section content
        self.outBytes(self.data, self.data_count);
    
        // Pad to relocation table
        let pad2: i64 = reloc_offset - (data_offset + data_size);
        self.outZeros(pad2);
    
        // Write relocations - resolve symbol indices at write time using linear search
        i = 0;
        while i < self.relocs_count {
            self.writeTextReloc(i);
            i = i + 1;
        }
    
        // Pad to symbol table
        let pad3: i64 = symtab_offset - (reloc_offset + reloc_size);
        self.outZeros(pad3);
    
        // Write symbol table (using parallel arrays)
        i = 0;
        while i < self.symbols_count {
            self.writeNlist64(i);
            i = i + 1;
        }
    
        // Write string table
        self.outBytes(self.strings, self.strings_count);
    
        return self.output_count;
    }

    fn writeWithDebug(self: *MachOWriter) i64 {
        // Check if we have debug info
        let has_debug: bool = self.debug_line != null and self.debug_line_count > 0;
    
        // If no debug info, use the regular write function
        if not has_debug {
            return self.write();
        }
    
        // ========================================================================
        // Add missing external symbols from relocations (using linear search)
        // ========================================================================
        var i: i64 = 0;
        while i < self.relocs_count {
            let target_str_off: i64 = (self.reloc_target_str_offs + i).*;
            let target_len: i64 = (self.reloc_target_lens + i).*;
            let target_ptr: *u8 = self.strings + target_str_off;
    
            // Check if symbol exists using linear search
            let existing_idx: i64 = self.findSymbol(target_ptr, target_len);
            if existing_idx < 0 {
                // Add as undefined external symbol (section = 0)
                self.addSymbol(target_ptr, target_len, 0, 0, true);
            }
            i = i + 1;
        }
    
        // Check if we have full debug info (abbrev + info)
        let has_full_debug: bool = self.debug_abbrev != null and self.debug_abbrev_count > 0 and
                                    self.debug_info != null and self.debug_info_count > 0;
    
        // ========================================================================
        // Step 3: Calculate layout (symbol count may have changed)
        // ========================================================================
        var num_sections: i64 = 3;   // __text, __data, __debug_line
        if has_full_debug {
            num_sections = 5;  // + __debug_abbrev, __debug_info
        }
    
        let load_cmds_size: i64 = SEGMENT_COMMAND_64_SIZE + num_sections * SECTION_64_SIZE +
                                  SYMTAB_COMMAND_SIZE;
    
        let text_offset: i64 = MACH_HEADER_64_SIZE + load_cmds_size;
        let text_size: i64 = self.code_count;
    
        let data_offset: i64 = MachO_alignUp(text_offset + text_size, 3);  // 8-byte align
        let data_size: i64 = self.data_count;
    
        // Debug sections layout
        let debug_line_offset: i64 = MachO_alignUp(data_offset + data_size, 2);  // 4-byte align
        let debug_line_size: i64 = self.debug_line_count;
    
        var debug_abbrev_offset: i64 = 0;
        var debug_abbrev_size: i64 = 0;
        var debug_info_offset: i64 = 0;
        var debug_info_size: i64 = 0;
    
        if has_full_debug {
            debug_abbrev_offset = MachO_alignUp(debug_line_offset + debug_line_size, 2);
            debug_abbrev_size = self.debug_abbrev_count;
    
            debug_info_offset = MachO_alignUp(debug_abbrev_offset + debug_abbrev_size, 2);
            debug_info_size = self.debug_info_count;
        }
    
        // Calculate end of debug sections for relocation offset
        var last_debug_end: i64 = debug_line_offset + debug_line_size;
        if has_full_debug {
            last_debug_end = debug_info_offset + debug_info_size;
        }
    
        // Text section relocations
        let text_reloc_offset: i64 = MachO_alignUp(last_debug_end, 2);  // 4-byte align
        let text_reloc_size: i64 = self.relocs_count * RELOCATION_SIZE;
    
        // Debug line section relocations
        let debug_line_reloc_offset: i64 = text_reloc_offset + text_reloc_size;
        let debug_line_reloc_size: i64 = self.debug_line_relocs_count * RELOCATION_SIZE;
    
        // Debug info section relocations
        var debug_info_reloc_offset: i64 = debug_line_reloc_offset + debug_line_reloc_size;
        var debug_info_reloc_size: i64 = 0;
        if has_full_debug {
            debug_info_reloc_size = self.debug_info_relocs_count * RELOCATION_SIZE;
        }
    
        let total_reloc_size: i64 = text_reloc_size + debug_line_reloc_size + debug_info_reloc_size;
    
        let symtab_offset: i64 = MachO_alignUp(text_reloc_offset + total_reloc_size, 3);  // 8-byte align
        let symtab_size: i64 = self.symbols_count * NLIST64_SIZE;
    
        let strtab_offset: i64 = symtab_offset + symtab_size;
        let strtab_size: i64 = self.strings_count;
    
        // Write header (2 load commands: 1 segment + symtab)
        self.writeMachHeader(2, load_cmds_size);
    
        // Write single segment command containing all sections
        var segment_filesize: i64 = debug_line_offset + debug_line_size - text_offset;
        if has_full_debug {
            segment_filesize = debug_info_offset + debug_info_size - text_offset;
        }
        self.writeSegmentCmd(segment_filesize, text_offset, segment_filesize, num_sections);
    
        // Write __text section
        let text_flags: i64 = S_ATTR_PURE_INSTRUCTIONS | S_ATTR_SOME_INSTRUCTIONS;
        var text_name: [16]u8;
        text_name[0] = 95; text_name[1] = 95; text_name[2] = 116;
        text_name[3] = 101; text_name[4] = 120; text_name[5] = 116;
        var text_seg: [16]u8;
        text_seg[0] = 95; text_seg[1] = 95; text_seg[2] = 84;
        text_seg[3] = 69; text_seg[4] = 88; text_seg[5] = 84;
        self.writeSection(&text_name[0], &text_seg[0],
                      text_size, text_offset,
                      TEXT_ALIGN, text_flags,
                      text_reloc_offset, self.relocs_count);
    
        // Write __data section
        var data_name: [16]u8;
        data_name[0] = 95; data_name[1] = 95; data_name[2] = 100;
        data_name[3] = 97; data_name[4] = 116; data_name[5] = 97;
        var data_seg: [16]u8;
        data_seg[0] = 95; data_seg[1] = 95; data_seg[2] = 68;
        data_seg[3] = 65; data_seg[4] = 84; data_seg[5] = 65;
        self.writeSection(&data_name[0], &data_seg[0],
                      data_size, data_offset,
                      DATA_ALIGN, S_REGULAR,
                      0, 0);
    
        // Write __debug_line section (__DWARF segment)
        var dbg_line_name: [16]u8;
        dbg_line_name[0] = 95; dbg_line_name[1] = 95;   // __
        dbg_line_name[2] = 100; dbg_line_name[3] = 101; // de
        dbg_line_name[4] = 98; dbg_line_name[5] = 117;  // bu
        dbg_line_name[6] = 103; dbg_line_name[7] = 95;  // g_
        dbg_line_name[8] = 108; dbg_line_name[9] = 105; // li
        dbg_line_name[10] = 110; dbg_line_name[11] = 101; // ne
        dbg_line_name[12] = 0;
        var dwarf_seg: [16]u8;
        dwarf_seg[0] = 95; dwarf_seg[1] = 95;   // __
        dwarf_seg[2] = 68; dwarf_seg[3] = 87;   // DW
        dwarf_seg[4] = 65; dwarf_seg[5] = 82;   // AR
        dwarf_seg[6] = 70; dwarf_seg[7] = 0;    // F
        self.writeSection(&dbg_line_name[0], &dwarf_seg[0],
                      debug_line_size, debug_line_offset,
                      0, S_REGULAR,
                      debug_line_reloc_offset, self.debug_line_relocs_count);
    
        if has_full_debug {
            // Write __debug_abbrev section
            var dbg_abbrev_name: [16]u8;
            dbg_abbrev_name[0] = 95; dbg_abbrev_name[1] = 95;   // __
            dbg_abbrev_name[2] = 100; dbg_abbrev_name[3] = 101; // de
            dbg_abbrev_name[4] = 98; dbg_abbrev_name[5] = 117;  // bu
            dbg_abbrev_name[6] = 103; dbg_abbrev_name[7] = 95;  // g_
            dbg_abbrev_name[8] = 97; dbg_abbrev_name[9] = 98;   // ab
            dbg_abbrev_name[10] = 98; dbg_abbrev_name[11] = 114; // br
            dbg_abbrev_name[12] = 101; dbg_abbrev_name[13] = 118; // ev
            dbg_abbrev_name[14] = 0;
            self.writeSection(&dbg_abbrev_name[0], &dwarf_seg[0],
                          debug_abbrev_size, debug_abbrev_offset,
                          0, S_REGULAR,
                          0, 0);  // No relocations for abbrev
    
            // Write __debug_info section
            var dbg_info_name: [16]u8;
            dbg_info_name[0] = 95; dbg_info_name[1] = 95;   // __
            dbg_info_name[2] = 100; dbg_info_name[3] = 101; // de
            dbg_info_name[4] = 98; dbg_info_name[5] = 117;  // bu
            dbg_info_name[6] = 103; dbg_info_name[7] = 95;  // g_
            dbg_info_name[8] = 105; dbg_info_name[9] = 110; // in
            dbg_info_name[10] = 102; dbg_info_name[11] = 111; // fo
            dbg_info_name[12] = 0;
            self.writeSection(&dbg_info_name[0], &dwarf_seg[0],
                          debug_info_size, debug_info_offset,
                          0, S_REGULAR,
                          debug_info_reloc_offset, self.debug_info_relocs_count);
        }
    
        // Write symtab command
        self.writeSymtabCmd(symtab_offset, self.symbols_count,
                         strtab_offset, strtab_size);
    
        // Write text section content
        self.outBytes(self.code, self.code_count);
    
        // Pad to data section
        let pad1: i64 = data_offset - (text_offset + text_size);
        self.outZeros(pad1);
    
        // Write data section content
        self.outBytes(self.data, self.data_count);
    
        // Pad to debug_line section
        let pad2: i64 = debug_line_offset - (data_offset + data_size);
        self.outZeros(pad2);
    
        // Write debug_line section content
        self.outBytes(self.debug_line, self.debug_line_count);
    
        if has_full_debug {
            // Pad to debug_abbrev section
            let pad_abbrev: i64 = debug_abbrev_offset - (debug_line_offset + debug_line_size);
            self.outZeros(pad_abbrev);
    
            // Write debug_abbrev section content
            self.outBytes(self.debug_abbrev, self.debug_abbrev_count);
    
            // Pad to debug_info section
            let pad_info: i64 = debug_info_offset - (debug_abbrev_offset + debug_abbrev_size);
            self.outZeros(pad_info);
    
            // Write debug_info section content
            self.outBytes(self.debug_info, self.debug_info_count);
        }
    
        // Pad to relocation table
        let pad3: i64 = text_reloc_offset - last_debug_end;
        self.outZeros(pad3);
    
        // Write text section relocations - resolve symbol indices at write time
        var j: i64 = 0;
        while j < self.relocs_count {
            self.writeTextReloc(j);
            j = j + 1;
        }
    
        // Write debug_line section relocations
        j = 0;
        while j < self.debug_line_relocs_count {
            self.writeDbgLineReloc(j);
            j = j + 1;
        }
    
        // Write debug_info section relocations
        if has_full_debug {
            j = 0;
            while j < self.debug_info_relocs_count {
                self.writeDbgInfoReloc(j);
                j = j + 1;
            }
        }
    
        // Pad to symbol table
        let pad4: i64 = symtab_offset - (text_reloc_offset + total_reloc_size);
        self.outZeros(pad4);
    
        // Write symbol table (using parallel arrays)
        i = 0;
        while i < self.symbols_count {
            self.writeNlist64(i);
            i = i + 1;
        }
    
        // Write string table
        self.outBytes(self.strings, self.strings_count);
    
        return self.output_count;
    }

}

fn MachOWriter_allocateStorage() {
    if mw_storage_initialized {
        return;
    }

    // Symbol arrays (parallel arrays)
    mw_symbols_cap = MW_SYMBOLS_CAP;
    mw_sym_name_offsets = malloc_i64(mw_symbols_cap);
    mw_sym_values = malloc_i64(mw_symbols_cap);
    mw_sym_sections = malloc_i64(mw_symbols_cap);
    mw_sym_is_externals = malloc_i64(mw_symbols_cap);

    // Strings buffer
    mw_strings_cap = MW_STRINGS_CAP;
    mw_strings = malloc_u8(mw_strings_cap);

    // Relocation arrays (parallel arrays)
    mw_relocs_cap = MW_RELOCS_CAP;
    mw_reloc_offsets = malloc_i64(mw_relocs_cap);
    mw_reloc_target_str_offs = malloc_i64(mw_relocs_cap);
    mw_reloc_target_lens = malloc_i64(mw_relocs_cap);
    mw_reloc_types = malloc_i64(mw_relocs_cap);
    mw_reloc_is_pcrels = malloc_i64(mw_relocs_cap);
    mw_reloc_lengths = malloc_i64(mw_relocs_cap);

    // Debug line buffer and relocations
    mw_debug_line_cap = MW_DEBUG_LINE_CAP;
    mw_debug_line = malloc_u8(mw_debug_line_cap);
    mw_debug_line_relocs_cap = MW_DEBUG_LINE_RELOCS_CAP;
    mw_dbg_line_reloc_offsets = malloc_i64(mw_debug_line_relocs_cap);
    mw_dbg_line_reloc_target_str_offs = malloc_i64(mw_debug_line_relocs_cap);
    mw_dbg_line_reloc_target_lens = malloc_i64(mw_debug_line_relocs_cap);
    mw_dbg_line_reloc_types = malloc_i64(mw_debug_line_relocs_cap);
    mw_dbg_line_reloc_is_pcrels = malloc_i64(mw_debug_line_relocs_cap);
    mw_dbg_line_reloc_lengths = malloc_i64(mw_debug_line_relocs_cap);

    // Debug abbrev and debug info
    mw_debug_abbrev_cap = MW_DEBUG_ABBREV_CAP;
    mw_debug_abbrev = malloc_u8(mw_debug_abbrev_cap);
    mw_debug_info_cap = MW_DEBUG_INFO_CAP;
    mw_debug_info = malloc_u8(mw_debug_info_cap);
    mw_debug_info_relocs_cap = MW_DEBUG_INFO_RELOCS_CAP;
    mw_dbg_info_reloc_offsets = malloc_i64(mw_debug_info_relocs_cap);
    mw_dbg_info_reloc_target_str_offs = malloc_i64(mw_debug_info_relocs_cap);
    mw_dbg_info_reloc_target_lens = malloc_i64(mw_debug_info_relocs_cap);
    mw_dbg_info_reloc_types = malloc_i64(mw_debug_info_relocs_cap);
    mw_dbg_info_reloc_is_pcrels = malloc_i64(mw_debug_info_relocs_cap);
    mw_dbg_info_reloc_lengths = malloc_i64(mw_debug_info_relocs_cap);

    // Output buffer
    mw_output_cap = MW_OUTPUT_CAP;
    mw_output = malloc_u8(mw_output_cap);

    mw_storage_initialized = true;
}

fn MachO_readI64(ptr: *u8) i64 {
    let p0: *u8 = ptr;
    let p1: *u8 = ptr + 1;
    let p2: *u8 = ptr + 2;
    let p3: *u8 = ptr + 3;
    let p4: *u8 = ptr + 4;
    let p5: *u8 = ptr + 5;
    let p6: *u8 = ptr + 6;
    let p7: *u8 = ptr + 7;
    var val: i64 = @intCast(i64, p0.*);
    val = val | (@intCast(i64, p1.*) << 8);
    val = val | (@intCast(i64, p2.*) << 16);
    val = val | (@intCast(i64, p3.*) << 24);
    val = val | (@intCast(i64, p4.*) << 32);
    val = val | (@intCast(i64, p5.*) << 40);
    val = val | (@intCast(i64, p6.*) << 48);
    val = val | (@intCast(i64, p7.*) << 56);
    return val;
}
